(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/apexcharts/dist/apexcharts.common.js
  var require_apexcharts_common = __commonJS({
    "node_modules/apexcharts/dist/apexcharts.common.js"(exports, module) {
      "use strict";
      function t3(t4, e4) {
        (null == e4 || e4 > t4.length) && (e4 = t4.length);
        for (var i4 = 0, a4 = Array(e4); i4 < e4; i4++) a4[i4] = t4[i4];
        return a4;
      }
      function e3(t4) {
        if (void 0 === t4) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      function i3(t4, e4) {
        if (!(t4 instanceof e4)) throw new TypeError("Cannot call a class as a function");
      }
      function a3(t4, e4) {
        for (var i4 = 0; i4 < e4.length; i4++) {
          var a4 = e4[i4];
          a4.enumerable = a4.enumerable || false, a4.configurable = true, "value" in a4 && (a4.writable = true), Object.defineProperty(t4, x4(a4.key), a4);
        }
      }
      function s3(t4, e4, i4) {
        return e4 && a3(t4.prototype, e4), i4 && a3(t4, i4), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function r3(t4, e4) {
        var i4 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!i4) {
          if (Array.isArray(t4) || (i4 = v3(t4)) || e4 && t4 && "number" == typeof t4.length) {
            i4 && (t4 = i4);
            var a4 = 0, s4 = function() {
            };
            return { s: s4, n: function() {
              return a4 >= t4.length ? { done: true } : { done: false, value: t4[a4++] };
            }, e: function(t5) {
              throw t5;
            }, f: s4 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var r4, o3 = true, n3 = false;
        return { s: function() {
          i4 = i4.call(t4);
        }, n: function() {
          var t5 = i4.next();
          return o3 = t5.done, t5;
        }, e: function(t5) {
          n3 = true, r4 = t5;
        }, f: function() {
          try {
            o3 || null == i4.return || i4.return();
          } finally {
            if (n3) throw r4;
          }
        } };
      }
      function o2(t4) {
        var i4 = c3();
        return function() {
          var a4, s4 = l3(t4);
          if (i4) {
            var r4 = l3(this).constructor;
            a4 = Reflect.construct(s4, arguments, r4);
          } else a4 = s4.apply(this, arguments);
          return (function(t5, i5) {
            if (i5 && ("object" == typeof i5 || "function" == typeof i5)) return i5;
            if (void 0 !== i5) throw new TypeError("Derived constructors may only return object or undefined");
            return e3(t5);
          })(this, a4);
        };
      }
      function n2(t4, e4, i4) {
        return (e4 = x4(e4)) in t4 ? Object.defineProperty(t4, e4, { value: i4, enumerable: true, configurable: true, writable: true }) : t4[e4] = i4, t4;
      }
      function l3(t4) {
        return l3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, l3(t4);
      }
      function h3(t4, e4) {
        if ("function" != typeof e4 && null !== e4) throw new TypeError("Super expression must either be null or a function");
        t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && u3(t4, e4);
      }
      function c3() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
          })));
        } catch (t5) {
        }
        return (c3 = function() {
          return !!t4;
        })();
      }
      function d2(t4, e4) {
        var i4 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var a4 = Object.getOwnPropertySymbols(t4);
          e4 && (a4 = a4.filter((function(e5) {
            return Object.getOwnPropertyDescriptor(t4, e5).enumerable;
          }))), i4.push.apply(i4, a4);
        }
        return i4;
      }
      function g4(t4) {
        for (var e4 = 1; e4 < arguments.length; e4++) {
          var i4 = null != arguments[e4] ? arguments[e4] : {};
          e4 % 2 ? d2(Object(i4), true).forEach((function(e5) {
            n2(t4, e5, i4[e5]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(i4)) : d2(Object(i4)).forEach((function(e5) {
            Object.defineProperty(t4, e5, Object.getOwnPropertyDescriptor(i4, e5));
          }));
        }
        return t4;
      }
      function u3(t4, e4) {
        return u3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e5) {
          return t5.__proto__ = e5, t5;
        }, u3(t4, e4);
      }
      function f3(t4, e4) {
        return (function(t5) {
          if (Array.isArray(t5)) return t5;
        })(t4) || (function(t5, e5) {
          var i4 = null == t5 ? null : "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (null != i4) {
            var a4, s4, r4, o3, n3 = [], l4 = true, h4 = false;
            try {
              if (r4 = (i4 = i4.call(t5)).next, 0 === e5) {
                if (Object(i4) !== i4) return;
                l4 = false;
              } else for (; !(l4 = (a4 = r4.call(i4)).done) && (n3.push(a4.value), n3.length !== e5); l4 = true) ;
            } catch (t6) {
              h4 = true, s4 = t6;
            } finally {
              try {
                if (!l4 && null != i4.return && (o3 = i4.return(), Object(o3) !== o3)) return;
              } finally {
                if (h4) throw s4;
              }
            }
            return n3;
          }
        })(t4, e4) || v3(t4, e4) || (function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        })();
      }
      function p3(e4) {
        return (function(e5) {
          if (Array.isArray(e5)) return t3(e5);
        })(e4) || (function(t4) {
          if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"]) return Array.from(t4);
        })(e4) || v3(e4) || (function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        })();
      }
      function x4(t4) {
        var e4 = (function(t5, e5) {
          if ("object" != typeof t5 || !t5) return t5;
          var i4 = t5[Symbol.toPrimitive];
          if (void 0 !== i4) {
            var a4 = i4.call(t5, e5 || "default");
            if ("object" != typeof a4) return a4;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === e5 ? String : Number)(t5);
        })(t4, "string");
        return "symbol" == typeof e4 ? e4 : e4 + "";
      }
      function b3(t4) {
        return b3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, b3(t4);
      }
      function v3(e4, i4) {
        if (e4) {
          if ("string" == typeof e4) return t3(e4, i4);
          var a4 = {}.toString.call(e4).slice(8, -1);
          return "Object" === a4 && e4.constructor && (a4 = e4.constructor.name), "Map" === a4 || "Set" === a4 ? Array.from(e4) : "Arguments" === a4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a4) ? t3(e4, i4) : void 0;
        }
      }
      var m3 = (function() {
        function t4() {
          i3(this, t4);
        }
        return s3(t4, [{ key: "shadeRGBColor", value: function(t5, e4) {
          var i4 = e4.split(","), a4 = t5 < 0 ? 0 : 255, s4 = t5 < 0 ? -1 * t5 : t5, r4 = parseInt(i4[0].slice(4), 10), o3 = parseInt(i4[1], 10), n3 = parseInt(i4[2], 10);
          return "rgb(" + (Math.round((a4 - r4) * s4) + r4) + "," + (Math.round((a4 - o3) * s4) + o3) + "," + (Math.round((a4 - n3) * s4) + n3) + ")";
        } }, { key: "shadeHexColor", value: function(t5, e4) {
          var i4 = parseInt(e4.slice(1), 16), a4 = t5 < 0 ? 0 : 255, s4 = t5 < 0 ? -1 * t5 : t5, r4 = i4 >> 16, o3 = i4 >> 8 & 255, n3 = 255 & i4;
          return "#" + (16777216 + 65536 * (Math.round((a4 - r4) * s4) + r4) + 256 * (Math.round((a4 - o3) * s4) + o3) + (Math.round((a4 - n3) * s4) + n3)).toString(16).slice(1);
        } }, { key: "shadeColor", value: function(e4, i4) {
          return t4.isColorHex(i4) ? this.shadeHexColor(e4, i4) : this.shadeRGBColor(e4, i4);
        } }], [{ key: "bind", value: function(t5, e4) {
          return function() {
            return t5.apply(e4, arguments);
          };
        } }, { key: "isObject", value: function(t5) {
          return t5 && "object" === b3(t5) && !Array.isArray(t5) && null != t5;
        } }, { key: "is", value: function(t5, e4) {
          return Object.prototype.toString.call(e4) === "[object " + t5 + "]";
        } }, { key: "listToArray", value: function(t5) {
          var e4, i4 = [];
          for (e4 = 0; e4 < t5.length; e4++) i4[e4] = t5[e4];
          return i4;
        } }, { key: "extend", value: function(t5, e4) {
          var i4 = this;
          "function" != typeof Object.assign && (Object.assign = function(t6) {
            if (null == t6) throw new TypeError("Cannot convert undefined or null to object");
            for (var e5 = Object(t6), i5 = 1; i5 < arguments.length; i5++) {
              var a5 = arguments[i5];
              if (null != a5) for (var s4 in a5) a5.hasOwnProperty(s4) && (e5[s4] = a5[s4]);
            }
            return e5;
          });
          var a4 = Object.assign({}, t5);
          return this.isObject(t5) && this.isObject(e4) && Object.keys(e4).forEach((function(s4) {
            i4.isObject(e4[s4]) && s4 in t5 ? a4[s4] = i4.extend(t5[s4], e4[s4]) : Object.assign(a4, n2({}, s4, e4[s4]));
          })), a4;
        } }, { key: "extendArray", value: function(e4, i4) {
          var a4 = [];
          return e4.map((function(e5) {
            a4.push(t4.extend(i4, e5));
          })), e4 = a4;
        } }, { key: "monthMod", value: function(t5) {
          return t5 % 12;
        } }, { key: "clone", value: function(e4) {
          if (t4.is("Array", e4)) {
            for (var i4 = [], a4 = 0; a4 < e4.length; a4++) i4[a4] = this.clone(e4[a4]);
            return i4;
          }
          if (t4.is("Null", e4)) return null;
          if (t4.is("Date", e4)) return e4;
          if ("object" === b3(e4)) {
            var s4 = {};
            for (var r4 in e4) e4.hasOwnProperty(r4) && (s4[r4] = this.clone(e4[r4]));
            return s4;
          }
          return e4;
        } }, { key: "log10", value: function(t5) {
          return Math.log(t5) / Math.LN10;
        } }, { key: "roundToBase10", value: function(t5) {
          return Math.pow(10, Math.floor(Math.log10(t5)));
        } }, { key: "roundToBase", value: function(t5, e4) {
          return Math.pow(e4, Math.floor(Math.log(t5) / Math.log(e4)));
        } }, { key: "parseNumber", value: function(t5) {
          return null === t5 ? t5 : parseFloat(t5);
        } }, { key: "stripNumber", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
          return Number.isInteger(t5) ? t5 : parseFloat(t5.toPrecision(e4));
        } }, { key: "randomId", value: function() {
          return (Math.random() + 1).toString(36).substring(4);
        } }, { key: "noExponents", value: function(t5) {
          var e4 = String(t5).split(/[eE]/);
          if (1 === e4.length) return e4[0];
          var i4 = "", a4 = t5 < 0 ? "-" : "", s4 = e4[0].replace(".", ""), r4 = Number(e4[1]) + 1;
          if (r4 < 0) {
            for (i4 = a4 + "0."; r4++; ) i4 += "0";
            return i4 + s4.replace(/^-/, "");
          }
          for (r4 -= s4.length; r4--; ) i4 += "0";
          return s4 + i4;
        } }, { key: "getDimensions", value: function(t5) {
          var e4 = getComputedStyle(t5, null), i4 = t5.clientHeight, a4 = t5.clientWidth;
          return i4 -= parseFloat(e4.paddingTop) + parseFloat(e4.paddingBottom), [a4 -= parseFloat(e4.paddingLeft) + parseFloat(e4.paddingRight), i4];
        } }, { key: "getBoundingClientRect", value: function(t5) {
          var e4 = t5.getBoundingClientRect();
          return { top: e4.top, right: e4.right, bottom: e4.bottom, left: e4.left, width: t5.clientWidth, height: t5.clientHeight, x: e4.left, y: e4.top };
        } }, { key: "getLargestStringFromArr", value: function(t5) {
          return t5.reduce((function(t6, e4) {
            return Array.isArray(e4) && (e4 = e4.reduce((function(t7, e5) {
              return t7.length > e5.length ? t7 : e5;
            }))), t6.length > e4.length ? t6 : e4;
          }), 0);
        } }, { key: "hexToRgba", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
          "#" !== t5.substring(0, 1) && (t5 = "#999999");
          var i4 = t5.replace("#", "");
          i4 = i4.match(new RegExp("(.{" + i4.length / 3 + "})", "g"));
          for (var a4 = 0; a4 < i4.length; a4++) i4[a4] = parseInt(1 === i4[a4].length ? i4[a4] + i4[a4] : i4[a4], 16);
          return void 0 !== e4 && i4.push(e4), "rgba(" + i4.join(",") + ")";
        } }, { key: "getOpacityFromRGBA", value: function(t5) {
          return parseFloat(t5.replace(/^.*,(.+)\)/, "$1"));
        } }, { key: "rgb2hex", value: function(t5) {
          return (t5 = t5.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t5.length ? "#" + ("0" + parseInt(t5[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t5[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t5[3], 10).toString(16)).slice(-2) : "";
        } }, { key: "isColorHex", value: function(t5) {
          return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t5);
        } }, { key: "getPolygonPos", value: function(t5, e4) {
          for (var i4 = [], a4 = 2 * Math.PI / e4, s4 = 0; s4 < e4; s4++) {
            var r4 = {};
            r4.x = t5 * Math.sin(s4 * a4), r4.y = -t5 * Math.cos(s4 * a4), i4.push(r4);
          }
          return i4;
        } }, { key: "polarToCartesian", value: function(t5, e4, i4, a4) {
          var s4 = (a4 - 90) * Math.PI / 180;
          return { x: t5 + i4 * Math.cos(s4), y: e4 + i4 * Math.sin(s4) };
        } }, { key: "escapeString", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i4 = t5.toString().slice();
          return i4 = i4.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e4);
        } }, { key: "negToZero", value: function(t5) {
          return t5 < 0 ? 0 : t5;
        } }, { key: "moveIndexInArray", value: function(t5, e4, i4) {
          if (i4 >= t5.length) for (var a4 = i4 - t5.length + 1; a4--; ) t5.push(void 0);
          return t5.splice(i4, 0, t5.splice(e4, 1)[0]), t5;
        } }, { key: "extractNumber", value: function(t5) {
          return parseFloat(t5.replace(/[^\d.]*/g, ""));
        } }, { key: "findAncestor", value: function(t5, e4) {
          for (; (t5 = t5.parentElement) && !t5.classList.contains(e4); ) ;
          return t5;
        } }, { key: "setELstyles", value: function(t5, e4) {
          for (var i4 in e4) e4.hasOwnProperty(i4) && (t5.style.key = e4[i4]);
        } }, { key: "preciseAddition", value: function(t5, e4) {
          var i4 = (String(t5).split(".")[1] || "").length, a4 = (String(e4).split(".")[1] || "").length, s4 = Math.pow(10, Math.max(i4, a4));
          return (Math.round(t5 * s4) + Math.round(e4 * s4)) / s4;
        } }, { key: "isNumber", value: function(t5) {
          return !isNaN(t5) && parseFloat(Number(t5)) === t5 && !isNaN(parseInt(t5, 10));
        } }, { key: "isFloat", value: function(t5) {
          return Number(t5) === t5 && t5 % 1 != 0;
        } }, { key: "isSafari", value: function() {
          return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        } }, { key: "isFirefox", value: function() {
          return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
        } }, { key: "isMsEdge", value: function() {
          var t5 = window.navigator.userAgent, e4 = t5.indexOf("Edge/");
          return e4 > 0 && parseInt(t5.substring(e4 + 5, t5.indexOf(".", e4)), 10);
        } }, { key: "getGCD", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a4 = Math.pow(10, i4 - Math.floor(Math.log10(Math.max(t5, e4))));
          for (t5 = Math.round(Math.abs(t5) * a4), e4 = Math.round(Math.abs(e4) * a4); e4; ) {
            var s4 = e4;
            e4 = t5 % e4, t5 = s4;
          }
          return t5 / a4;
        } }, { key: "getPrimeFactors", value: function(t5) {
          for (var e4 = [], i4 = 2; t5 >= 2; ) t5 % i4 == 0 ? (e4.push(i4), t5 /= i4) : i4++;
          return e4;
        } }, { key: "mod", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a4 = Math.pow(10, i4 - Math.floor(Math.log10(Math.max(t5, e4))));
          return (t5 = Math.round(Math.abs(t5) * a4)) % (e4 = Math.round(Math.abs(e4) * a4)) / a4;
        } }]), t4;
      })();
      var y3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.setEasingFunctions();
        }
        return s3(t4, [{ key: "setEasingFunctions", value: function() {
          var t5;
          if (!this.w.globals.easing) {
            switch (this.w.config.chart.animations.easing) {
              case "linear":
                t5 = "-";
                break;
              case "easein":
                t5 = "<";
                break;
              case "easeout":
                t5 = ">";
                break;
              case "easeinout":
              default:
                t5 = "<>";
                break;
              case "swing":
                t5 = function(t6) {
                  var e4 = 1.70158;
                  return (t6 -= 1) * t6 * ((e4 + 1) * t6 + e4) + 1;
                };
                break;
              case "bounce":
                t5 = function(t6) {
                  return t6 < 1 / 2.75 ? 7.5625 * t6 * t6 : t6 < 2 / 2.75 ? 7.5625 * (t6 -= 1.5 / 2.75) * t6 + 0.75 : t6 < 2.5 / 2.75 ? 7.5625 * (t6 -= 2.25 / 2.75) * t6 + 0.9375 : 7.5625 * (t6 -= 2.625 / 2.75) * t6 + 0.984375;
                };
                break;
              case "elastic":
                t5 = function(t6) {
                  return t6 === !!t6 ? t6 : Math.pow(2, -10 * t6) * Math.sin((t6 - 0.075) * (2 * Math.PI) / 0.3) + 1;
                };
            }
            this.w.globals.easing = t5;
          }
        } }, { key: "animateLine", value: function(t5, e4, i4, a4) {
          t5.attr(e4).animate(a4).attr(i4);
        } }, { key: "animateMarker", value: function(t5, e4, i4, a4) {
          t5.attr({ opacity: 0 }).animate(e4, i4).attr({ opacity: 1 }).afterAll((function() {
            a4();
          }));
        } }, { key: "animateRect", value: function(t5, e4, i4, a4, s4) {
          t5.attr(e4).animate(a4).attr(i4).afterAll((function() {
            return s4();
          }));
        } }, { key: "animatePathsGradually", value: function(t5) {
          var e4 = t5.el, i4 = t5.realIndex, a4 = t5.j, s4 = t5.fill, r4 = t5.pathFrom, o3 = t5.pathTo, n3 = t5.speed, l4 = t5.delay, h4 = this.w, c4 = 0;
          h4.config.chart.animations.animateGradually.enabled && (c4 = h4.config.chart.animations.animateGradually.delay), h4.config.chart.animations.dynamicAnimation.enabled && h4.globals.dataChanged && "bar" !== h4.config.chart.type && (c4 = 0), this.morphSVG(e4, i4, a4, "line" !== h4.config.chart.type || h4.globals.comboCharts ? s4 : "stroke", r4, o3, n3, l4 * c4);
        } }, { key: "showDelayedElements", value: function() {
          this.w.globals.delayedElements.forEach((function(t5) {
            var e4 = t5.el;
            e4.classList.remove("apexcharts-element-hidden"), e4.classList.add("apexcharts-hidden-element-shown");
          }));
        } }, { key: "animationCompleted", value: function(t5) {
          var e4 = this.w;
          e4.globals.animationEnded || (e4.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e4.config.chart.events.animationEnd && e4.config.chart.events.animationEnd(this.ctx, { el: t5, w: e4 }));
        } }, { key: "morphSVG", value: function(t5, e4, i4, a4, s4, r4, o3, n3) {
          var l4 = this, h4 = this.w;
          s4 || (s4 = t5.attr("pathFrom")), r4 || (r4 = t5.attr("pathTo"));
          var c4 = function(t6) {
            return "radar" === h4.config.chart.type && (o3 = 1), "M 0 ".concat(h4.globals.gridHeight);
          };
          (!s4 || s4.indexOf("undefined") > -1 || s4.indexOf("NaN") > -1) && (s4 = c4()), (!r4 || r4.indexOf("undefined") > -1 || r4.indexOf("NaN") > -1) && (r4 = c4()), h4.globals.shouldAnimate || (o3 = 1), t5.plot(s4).animate(1, h4.globals.easing, n3).plot(s4).animate(o3, h4.globals.easing, n3).plot(r4).afterAll((function() {
            m3.isNumber(i4) ? i4 === h4.globals.series[h4.globals.maxValsInArrayIndex].length - 2 && h4.globals.shouldAnimate && l4.animationCompleted(t5) : "none" !== a4 && h4.globals.shouldAnimate && (!h4.globals.comboCharts && e4 === h4.globals.series.length - 1 || h4.globals.comboCharts) && l4.animationCompleted(t5), l4.showDelayedElements();
          }));
        } }]), t4;
      })();
      var w4 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "getDefaultFilter", value: function(t5, e4) {
          var i4 = this.w;
          t5.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i4.config.states.normal.filter ? this.applyFilter(t5, e4, i4.config.states.normal.filter.type, i4.config.states.normal.filter.value) : i4.config.chart.dropShadow.enabled && this.dropShadow(t5, i4.config.chart.dropShadow, e4);
        } }, { key: "addNormalFilter", value: function(t5, e4) {
          var i4 = this.w;
          i4.config.chart.dropShadow.enabled && !t5.node.classList.contains("apexcharts-marker") && this.dropShadow(t5, i4.config.chart.dropShadow, e4);
        } }, { key: "addLightenFilter", value: function(t5, e4, i4) {
          var a4 = this, s4 = this.w, r4 = i4.intensity;
          t5.unfilter(true);
          new window.SVG.Filter();
          t5.filter((function(t6) {
            var i5 = s4.config.chart.dropShadow;
            (i5.enabled ? a4.addShadow(t6, e4, i5) : t6).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r4 } });
          })), t5.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t5.filterer.node);
        } }, { key: "addDarkenFilter", value: function(t5, e4, i4) {
          var a4 = this, s4 = this.w, r4 = i4.intensity;
          t5.unfilter(true);
          new window.SVG.Filter();
          t5.filter((function(t6) {
            var i5 = s4.config.chart.dropShadow;
            (i5.enabled ? a4.addShadow(t6, e4, i5) : t6).componentTransfer({ rgb: { type: "linear", slope: r4 } });
          })), t5.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t5.filterer.node);
        } }, { key: "applyFilter", value: function(t5, e4, i4) {
          var a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
          switch (i4) {
            case "none":
              this.addNormalFilter(t5, e4);
              break;
            case "lighten":
              this.addLightenFilter(t5, e4, { intensity: a4 });
              break;
            case "darken":
              this.addDarkenFilter(t5, e4, { intensity: a4 });
          }
        } }, { key: "addShadow", value: function(t5, e4, i4) {
          var a4, s4 = this.w, r4 = i4.blur, o3 = i4.top, n3 = i4.left, l4 = i4.color, h4 = i4.opacity;
          if ((null === (a4 = s4.config.chart.dropShadow.enabledOnSeries) || void 0 === a4 ? void 0 : a4.length) > 0 && -1 === s4.config.chart.dropShadow.enabledOnSeries.indexOf(e4)) return t5;
          var c4 = t5.flood(Array.isArray(l4) ? l4[e4] : l4, h4).composite(t5.sourceAlpha, "in").offset(n3, o3).gaussianBlur(r4).merge(t5.source);
          return t5.blend(t5.source, c4);
        } }, { key: "dropShadow", value: function(t5, e4) {
          var i4, a4, s4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r4 = e4.top, o3 = e4.left, n3 = e4.blur, l4 = e4.color, h4 = e4.opacity, c4 = e4.noUserSpaceOnUse, d3 = this.w;
          if (t5.unfilter(true), m3.isMsEdge() && "radialBar" === d3.config.chart.type) return t5;
          if ((null === (i4 = d3.config.chart.dropShadow.enabledOnSeries) || void 0 === i4 ? void 0 : i4.length) > 0 && -1 === (null === (a4 = d3.config.chart.dropShadow.enabledOnSeries) || void 0 === a4 ? void 0 : a4.indexOf(s4))) return t5;
          return l4 = Array.isArray(l4) ? l4[s4] : l4, t5.filter((function(t6) {
            var e5 = null;
            e5 = m3.isSafari() || m3.isFirefox() || m3.isMsEdge() ? t6.flood(l4, h4).composite(t6.sourceAlpha, "in").offset(o3, r4).gaussianBlur(n3) : t6.flood(l4, h4).composite(t6.sourceAlpha, "in").offset(o3, r4).gaussianBlur(n3).merge(t6.source), t6.blend(t6.source, e5);
          })), c4 || t5.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t5.filterer.node), t5;
        } }, { key: "setSelectionFilter", value: function(t5, e4, i4) {
          var a4 = this.w;
          if (void 0 !== a4.globals.selectedDataPoints[e4] && a4.globals.selectedDataPoints[e4].indexOf(i4) > -1) {
            t5.node.setAttribute("selected", true);
            var s4 = a4.config.states.active.filter;
            "none" !== s4 && this.applyFilter(t5, e4, s4.type, s4.value);
          }
        } }, { key: "_scaleFilterSize", value: function(t5) {
          !(function(e4) {
            for (var i4 in e4) e4.hasOwnProperty(i4) && t5.setAttribute(i4, e4[i4]);
          })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
        } }]), t4;
      })();
      var k3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "roundPathCorners", value: function(t5, e4) {
          function i4(t6, e5, i5) {
            var s5 = e5.x - t6.x, r5 = e5.y - t6.y, o4 = Math.sqrt(s5 * s5 + r5 * r5);
            return a4(t6, e5, Math.min(1, i5 / o4));
          }
          function a4(t6, e5, i5) {
            return { x: t6.x + (e5.x - t6.x) * i5, y: t6.y + (e5.y - t6.y) * i5 };
          }
          function s4(t6, e5) {
            t6.length > 2 && (t6[t6.length - 2] = e5.x, t6[t6.length - 1] = e5.y);
          }
          function r4(t6) {
            return { x: parseFloat(t6[t6.length - 2]), y: parseFloat(t6[t6.length - 1]) };
          }
          t5.indexOf("NaN") > -1 && (t5 = "");
          var o3 = t5.split(/[,\s]/).reduce((function(t6, e5) {
            var i5 = e5.match("([a-zA-Z])(.+)");
            return i5 ? (t6.push(i5[1]), t6.push(i5[2])) : t6.push(e5), t6;
          }), []).reduce((function(t6, e5) {
            return parseFloat(e5) == e5 && t6.length ? t6[t6.length - 1].push(e5) : t6.push([e5]), t6;
          }), []), n3 = [];
          if (o3.length > 1) {
            var l4 = r4(o3[0]), h4 = null;
            "Z" == o3[o3.length - 1][0] && o3[0].length > 2 && (h4 = ["L", l4.x, l4.y], o3[o3.length - 1] = h4), n3.push(o3[0]);
            for (var c4 = 1; c4 < o3.length; c4++) {
              var d3 = n3[n3.length - 1], g5 = o3[c4], u4 = g5 == h4 ? o3[1] : o3[c4 + 1];
              if (u4 && d3 && d3.length > 2 && "L" == g5[0] && u4.length > 2 && "L" == u4[0]) {
                var f4, p4, x5 = r4(d3), b4 = r4(g5), v4 = r4(u4);
                f4 = i4(b4, x5, e4), p4 = i4(b4, v4, e4), s4(g5, f4), g5.origPoint = b4, n3.push(g5);
                var m4 = a4(f4, b4, 0.5), y4 = a4(b4, p4, 0.5), w5 = ["C", m4.x, m4.y, y4.x, y4.y, p4.x, p4.y];
                w5.origPoint = b4, n3.push(w5);
              } else n3.push(g5);
            }
            if (h4) {
              var k4 = r4(n3[n3.length - 1]);
              n3.push(["Z"]), s4(n3[0], k4);
            }
          } else n3 = o3;
          return n3.reduce((function(t6, e5) {
            return t6 + e5.join(" ") + " ";
          }), "");
        } }, { key: "drawLine", value: function(t5, e4, i4, a4) {
          var s4 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r4 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, n3 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
          return this.w.globals.dom.Paper.line().attr({ x1: t5, y1: e4, x2: i4, y2: a4, stroke: s4, "stroke-dasharray": r4, "stroke-width": o3, "stroke-linecap": n3 });
        } }, { key: "drawRect", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s4 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r4 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", o3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, n3 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l4 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h4 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c4 = this.w.globals.dom.Paper.rect();
          return c4.attr({ x: t5, y: e4, width: i4 > 0 ? i4 : 0, height: a4 > 0 ? a4 : 0, rx: s4, ry: s4, opacity: o3, "stroke-width": null !== n3 ? n3 : 0, stroke: null !== l4 ? l4 : "none", "stroke-dasharray": h4 }), c4.node.setAttribute("fill", r4), c4;
        } }, { key: "drawPolygon", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
          return this.w.globals.dom.Paper.polygon(t5).attr({ fill: a4, stroke: e4, "stroke-width": i4 });
        } }, { key: "drawCircle", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
          t5 < 0 && (t5 = 0);
          var i4 = this.w.globals.dom.Paper.circle(2 * t5);
          return null !== e4 && i4.attr(e4), i4;
        } }, { key: "drawPath", value: function(t5) {
          var e4 = t5.d, i4 = void 0 === e4 ? "" : e4, a4 = t5.stroke, s4 = void 0 === a4 ? "#a8a8a8" : a4, r4 = t5.strokeWidth, o3 = void 0 === r4 ? 1 : r4, n3 = t5.fill, l4 = t5.fillOpacity, h4 = void 0 === l4 ? 1 : l4, c4 = t5.strokeOpacity, d3 = void 0 === c4 ? 1 : c4, g5 = t5.classes, u4 = t5.strokeLinecap, f4 = void 0 === u4 ? null : u4, p4 = t5.strokeDashArray, x5 = void 0 === p4 ? 0 : p4, b4 = this.w;
          return null === f4 && (f4 = b4.config.stroke.lineCap), (i4.indexOf("undefined") > -1 || i4.indexOf("NaN") > -1) && (i4 = "M 0 ".concat(b4.globals.gridHeight)), b4.globals.dom.Paper.path(i4).attr({ fill: n3, "fill-opacity": h4, stroke: s4, "stroke-opacity": d3, "stroke-linecap": f4, "stroke-width": o3, "stroke-dasharray": x5, class: g5 });
        } }, { key: "group", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e4 = this.w.globals.dom.Paper.group();
          return null !== t5 && e4.attr(t5), e4;
        } }, { key: "move", value: function(t5, e4) {
          var i4 = ["M", t5, e4].join(" ");
          return i4;
        } }, { key: "line", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a4 = null;
          return null === i4 ? a4 = [" L", t5, e4].join(" ") : "H" === i4 ? a4 = [" H", t5].join(" ") : "V" === i4 && (a4 = [" V", e4].join(" ")), a4;
        } }, { key: "curve", value: function(t5, e4, i4, a4, s4, r4) {
          var o3 = ["C", t5, e4, i4, a4, s4, r4].join(" ");
          return o3;
        } }, { key: "quadraticCurve", value: function(t5, e4, i4, a4) {
          return ["Q", t5, e4, i4, a4].join(" ");
        } }, { key: "arc", value: function(t5, e4, i4, a4, s4, r4, o3) {
          var n3 = "A";
          arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (n3 = "a");
          var l4 = [n3, t5, e4, i4, a4, s4, r4, o3].join(" ");
          return l4;
        } }, { key: "renderPaths", value: function(t5) {
          var e4, i4 = t5.j, a4 = t5.realIndex, s4 = t5.pathFrom, r4 = t5.pathTo, o3 = t5.stroke, n3 = t5.strokeWidth, l4 = t5.strokeLinecap, h4 = t5.fill, c4 = t5.animationDelay, d3 = t5.initialSpeed, u4 = t5.dataChangeSpeed, f4 = t5.className, p4 = t5.chartType, x5 = t5.shouldClipToGrid, b4 = void 0 === x5 || x5, v4 = t5.bindEventsOnPaths, m4 = void 0 === v4 || v4, k4 = t5.drawShadow, A4 = void 0 === k4 || k4, S3 = this.w, C4 = new w4(this.ctx), L4 = new y3(this.ctx), P4 = this.w.config.chart.animations.enabled, M3 = P4 && this.w.config.chart.animations.dynamicAnimation.enabled, I4 = !!(P4 && !S3.globals.resized || M3 && S3.globals.dataChanged && S3.globals.shouldAnimate);
          I4 ? e4 = s4 : (e4 = r4, S3.globals.animationEnded = true);
          var T5 = S3.config.stroke.dashArray, z4 = 0;
          z4 = Array.isArray(T5) ? T5[a4] : S3.config.stroke.dashArray;
          var X3 = this.drawPath({ d: e4, stroke: o3, strokeWidth: n3, fill: h4, fillOpacity: 1, classes: f4, strokeLinecap: l4, strokeDashArray: z4 });
          if (X3.attr("index", a4), b4 && ("bar" === p4 && !S3.globals.isHorizontal || S3.globals.comboCharts ? X3.attr({ "clip-path": "url(#gridRectBarMask".concat(S3.globals.cuid, ")") }) : X3.attr({ "clip-path": "url(#gridRectMask".concat(S3.globals.cuid, ")") })), "none" !== S3.config.states.normal.filter.type) C4.getDefaultFilter(X3, a4);
          else if (S3.config.chart.dropShadow.enabled && A4) {
            var E3 = S3.config.chart.dropShadow;
            C4.dropShadow(X3, E3, a4);
          }
          m4 && (X3.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, X3)), X3.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, X3)), X3.node.addEventListener("mousedown", this.pathMouseDown.bind(this, X3))), X3.attr({ pathTo: r4, pathFrom: s4 });
          var Y2 = { el: X3, j: i4, realIndex: a4, pathFrom: s4, pathTo: r4, fill: h4, strokeWidth: n3, delay: c4 };
          return !P4 || S3.globals.resized || S3.globals.dataChanged ? !S3.globals.resized && S3.globals.dataChanged || L4.showDelayedElements() : L4.animatePathsGradually(g4(g4({}, Y2), {}, { speed: d3 })), S3.globals.dataChanged && M3 && I4 && L4.animatePathsGradually(g4(g4({}, Y2), {}, { speed: u4 })), X3;
        } }, { key: "drawPattern", value: function(t5, e4, i4) {
          var a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s4 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
          return this.w.globals.dom.Paper.pattern(e4, i4, (function(r4) {
            "horizontalLines" === t5 ? r4.line(0, 0, i4, 0).stroke({ color: a4, width: s4 + 1 }) : "verticalLines" === t5 ? r4.line(0, 0, 0, e4).stroke({ color: a4, width: s4 + 1 }) : "slantedLines" === t5 ? r4.line(0, 0, e4, i4).stroke({ color: a4, width: s4 }) : "squares" === t5 ? r4.rect(e4, i4).fill("none").stroke({ color: a4, width: s4 }) : "circles" === t5 && r4.circle(e4).fill("none").stroke({ color: a4, width: s4 });
          }));
        } }, { key: "drawGradient", value: function(t5, e4, i4, a4, s4) {
          var r4, o3 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l4 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h4 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c4 = this.w;
          e4.length < 9 && 0 === e4.indexOf("#") && (e4 = m3.hexToRgba(e4, a4)), i4.length < 9 && 0 === i4.indexOf("#") && (i4 = m3.hexToRgba(i4, s4));
          var d3 = 0, g5 = 1, u4 = 1, f4 = null;
          null !== n3 && (d3 = void 0 !== n3[0] ? n3[0] / 100 : 0, g5 = void 0 !== n3[1] ? n3[1] / 100 : 1, u4 = void 0 !== n3[2] ? n3[2] / 100 : 1, f4 = void 0 !== n3[3] ? n3[3] / 100 : null);
          var p4 = !("donut" !== c4.config.chart.type && "pie" !== c4.config.chart.type && "polarArea" !== c4.config.chart.type && "bubble" !== c4.config.chart.type);
          if (r4 = null === l4 || 0 === l4.length ? c4.globals.dom.Paper.gradient(p4 ? "radial" : "linear", (function(t6) {
            t6.at(d3, e4, a4), t6.at(g5, i4, s4), t6.at(u4, i4, s4), null !== f4 && t6.at(f4, e4, a4);
          })) : c4.globals.dom.Paper.gradient(p4 ? "radial" : "linear", (function(t6) {
            (Array.isArray(l4[h4]) ? l4[h4] : l4).forEach((function(e5) {
              t6.at(e5.offset / 100, e5.color, e5.opacity);
            }));
          })), p4) {
            var x5 = c4.globals.gridWidth / 2, b4 = c4.globals.gridHeight / 2;
            "bubble" !== c4.config.chart.type ? r4.attr({ gradientUnits: "userSpaceOnUse", cx: x5, cy: b4, r: o3 }) : r4.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
          } else "vertical" === t5 ? r4.from(0, 0).to(0, 1) : "diagonal" === t5 ? r4.from(0, 0).to(1, 1) : "horizontal" === t5 ? r4.from(0, 1).to(1, 1) : "diagonal2" === t5 && r4.from(1, 0).to(0, 1);
          return r4;
        } }, { key: "getTextBasedOnMaxWidth", value: function(t5) {
          var e4 = t5.text, i4 = t5.maxWidth, a4 = t5.fontSize, s4 = t5.fontFamily, r4 = this.getTextRects(e4, a4, s4), o3 = r4.width / e4.length, n3 = Math.floor(i4 / o3);
          return i4 < r4.width ? e4.slice(0, n3 - 3) + "..." : e4;
        } }, { key: "drawText", value: function(t5) {
          var e4 = this, i4 = t5.x, a4 = t5.y, s4 = t5.text, r4 = t5.textAnchor, o3 = t5.fontSize, n3 = t5.fontFamily, l4 = t5.fontWeight, h4 = t5.foreColor, c4 = t5.opacity, d3 = t5.maxWidth, u4 = t5.cssClass, f4 = void 0 === u4 ? "" : u4, p4 = t5.isPlainText, x5 = void 0 === p4 || p4, b4 = t5.dominantBaseline, v4 = void 0 === b4 ? "auto" : b4, m4 = this.w;
          void 0 === s4 && (s4 = "");
          var y4 = s4;
          r4 || (r4 = "start"), h4 && h4.length || (h4 = m4.config.chart.foreColor), n3 = n3 || m4.config.chart.fontFamily, l4 = l4 || "regular";
          var w5, k4 = { maxWidth: d3, fontSize: o3 = o3 || "11px", fontFamily: n3 };
          return Array.isArray(s4) ? w5 = m4.globals.dom.Paper.text((function(t6) {
            for (var i5 = 0; i5 < s4.length; i5++) y4 = s4[i5], d3 && (y4 = e4.getTextBasedOnMaxWidth(g4({ text: s4[i5] }, k4))), 0 === i5 ? t6.tspan(y4) : t6.tspan(y4).newLine();
          })) : (d3 && (y4 = this.getTextBasedOnMaxWidth(g4({ text: s4 }, k4))), w5 = x5 ? m4.globals.dom.Paper.plain(s4) : m4.globals.dom.Paper.text((function(t6) {
            return t6.tspan(y4);
          }))), w5.attr({ x: i4, y: a4, "text-anchor": r4, "dominant-baseline": v4, "font-size": o3, "font-family": n3, "font-weight": l4, fill: h4, class: "apexcharts-text " + f4 }), w5.node.style.fontFamily = n3, w5.node.style.opacity = c4, w5;
        } }, { key: "getMarkerPath", value: function(t5, e4, i4, a4) {
          var s4 = "";
          switch (i4) {
            case "cross":
              s4 = "M ".concat(t5 - (a4 /= 1.4), " ").concat(e4 - a4, " L ").concat(t5 + a4, " ").concat(e4 + a4, "  M ").concat(t5 - a4, " ").concat(e4 + a4, " L ").concat(t5 + a4, " ").concat(e4 - a4);
              break;
            case "plus":
              s4 = "M ".concat(t5 - (a4 /= 1.12), " ").concat(e4, " L ").concat(t5 + a4, " ").concat(e4, "  M ").concat(t5, " ").concat(e4 - a4, " L ").concat(t5, " ").concat(e4 + a4);
              break;
            case "star":
            case "sparkle":
              var r4 = 5;
              a4 *= 1.15, "sparkle" === i4 && (a4 /= 1.1, r4 = 4);
              for (var o3 = Math.PI / r4, n3 = 0; n3 <= 2 * r4; n3++) {
                var l4 = n3 * o3, h4 = n3 % 2 == 0 ? a4 : a4 / 2;
                s4 += (0 === n3 ? "M" : "L") + (t5 + h4 * Math.sin(l4)) + "," + (e4 - h4 * Math.cos(l4));
              }
              s4 += "Z";
              break;
            case "triangle":
              s4 = "M ".concat(t5, " ").concat(e4 - a4, " \n             L ").concat(t5 + a4, " ").concat(e4 + a4, " \n             L ").concat(t5 - a4, " ").concat(e4 + a4, " \n             Z");
              break;
            case "square":
            case "rect":
              s4 = "M ".concat(t5 - (a4 /= 1.125), " ").concat(e4 - a4, " \n           L ").concat(t5 + a4, " ").concat(e4 - a4, " \n           L ").concat(t5 + a4, " ").concat(e4 + a4, " \n           L ").concat(t5 - a4, " ").concat(e4 + a4, " \n           Z");
              break;
            case "diamond":
              a4 *= 1.05, s4 = "M ".concat(t5, " ").concat(e4 - a4, " \n             L ").concat(t5 + a4, " ").concat(e4, " \n             L ").concat(t5, " ").concat(e4 + a4, " \n             L ").concat(t5 - a4, " ").concat(e4, " \n            Z");
              break;
            case "line":
              s4 = "M ".concat(t5 - (a4 /= 1.1), " ").concat(e4, " \n           L ").concat(t5 + a4, " ").concat(e4);
              break;
            default:
              a4 *= 2, s4 = "M ".concat(t5, ", ").concat(e4, " \n           m -").concat(a4 / 2, ", 0 \n           a ").concat(a4 / 2, ",").concat(a4 / 2, " 0 1,0 ").concat(a4, ",0 \n           a ").concat(a4 / 2, ",").concat(a4 / 2, " 0 1,0 -").concat(a4, ",0");
          }
          return s4;
        } }, { key: "drawMarkerShape", value: function(t5, e4, i4, a4, s4) {
          var r4 = this.drawPath({ d: this.getMarkerPath(t5, e4, i4, a4, s4), stroke: s4.pointStrokeColor, strokeDashArray: s4.pointStrokeDashArray, strokeWidth: s4.pointStrokeWidth, fill: s4.pointFillColor, fillOpacity: s4.pointFillOpacity, strokeOpacity: s4.pointStrokeOpacity });
          return r4.attr({ cx: t5, cy: e4, shape: s4.shape, class: s4.class ? s4.class : "" }), r4;
        } }, { key: "drawMarker", value: function(t5, e4, i4) {
          t5 = t5 || 0;
          var a4 = i4.pSize || 0;
          return m3.isNumber(e4) || (a4 = 0, e4 = 0), this.drawMarkerShape(t5, e4, null == i4 ? void 0 : i4.shape, a4, g4(g4({}, i4), "line" === i4.shape || "plus" === i4.shape || "cross" === i4.shape ? { pointStrokeColor: i4.pointFillColor, pointStrokeOpacity: i4.pointFillOpacity } : {}));
        } }, { key: "pathMouseEnter", value: function(t5, e4) {
          var i4 = this.w, a4 = new w4(this.ctx), s4 = parseInt(t5.node.getAttribute("index"), 10), r4 = parseInt(t5.node.getAttribute("j"), 10);
          if ("function" == typeof i4.config.chart.events.dataPointMouseEnter && i4.config.chart.events.dataPointMouseEnter(e4, this.ctx, { seriesIndex: s4, dataPointIndex: r4, w: i4 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e4, this.ctx, { seriesIndex: s4, dataPointIndex: r4, w: i4 }]), ("none" === i4.config.states.active.filter.type || "true" !== t5.node.getAttribute("selected")) && "none" !== i4.config.states.hover.filter.type && !i4.globals.isTouchDevice) {
            var o3 = i4.config.states.hover.filter;
            a4.applyFilter(t5, s4, o3.type, o3.value);
          }
        } }, { key: "pathMouseLeave", value: function(t5, e4) {
          var i4 = this.w, a4 = new w4(this.ctx), s4 = parseInt(t5.node.getAttribute("index"), 10), r4 = parseInt(t5.node.getAttribute("j"), 10);
          "function" == typeof i4.config.chart.events.dataPointMouseLeave && i4.config.chart.events.dataPointMouseLeave(e4, this.ctx, { seriesIndex: s4, dataPointIndex: r4, w: i4 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e4, this.ctx, { seriesIndex: s4, dataPointIndex: r4, w: i4 }]), "none" !== i4.config.states.active.filter.type && "true" === t5.node.getAttribute("selected") || "none" !== i4.config.states.hover.filter.type && a4.getDefaultFilter(t5, s4);
        } }, { key: "pathMouseDown", value: function(t5, e4) {
          var i4 = this.w, a4 = new w4(this.ctx), s4 = parseInt(t5.node.getAttribute("index"), 10), r4 = parseInt(t5.node.getAttribute("j"), 10), o3 = "false";
          if ("true" === t5.node.getAttribute("selected")) {
            if (t5.node.setAttribute("selected", "false"), i4.globals.selectedDataPoints[s4].indexOf(r4) > -1) {
              var n3 = i4.globals.selectedDataPoints[s4].indexOf(r4);
              i4.globals.selectedDataPoints[s4].splice(n3, 1);
            }
          } else {
            if (!i4.config.states.active.allowMultipleDataPointsSelection && i4.globals.selectedDataPoints.length > 0) {
              i4.globals.selectedDataPoints = [];
              var l4 = i4.globals.dom.Paper.select(".apexcharts-series path").members, h4 = i4.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c4 = function(t6) {
                Array.prototype.forEach.call(t6, (function(t7) {
                  t7.node.setAttribute("selected", "false"), a4.getDefaultFilter(t7, s4);
                }));
              };
              c4(l4), c4(h4);
            }
            t5.node.setAttribute("selected", "true"), o3 = "true", void 0 === i4.globals.selectedDataPoints[s4] && (i4.globals.selectedDataPoints[s4] = []), i4.globals.selectedDataPoints[s4].push(r4);
          }
          if ("true" === o3) {
            var d3 = i4.config.states.active.filter;
            if ("none" !== d3) a4.applyFilter(t5, s4, d3.type, d3.value);
            else if ("none" !== i4.config.states.hover.filter && !i4.globals.isTouchDevice) {
              var g5 = i4.config.states.hover.filter;
              a4.applyFilter(t5, s4, g5.type, g5.value);
            }
          } else if ("none" !== i4.config.states.active.filter.type) if ("none" === i4.config.states.hover.filter.type || i4.globals.isTouchDevice) a4.getDefaultFilter(t5, s4);
          else {
            g5 = i4.config.states.hover.filter;
            a4.applyFilter(t5, s4, g5.type, g5.value);
          }
          "function" == typeof i4.config.chart.events.dataPointSelection && i4.config.chart.events.dataPointSelection(e4, this.ctx, { selectedDataPoints: i4.globals.selectedDataPoints, seriesIndex: s4, dataPointIndex: r4, w: i4 }), e4 && this.ctx.events.fireEvent("dataPointSelection", [e4, this.ctx, { selectedDataPoints: i4.globals.selectedDataPoints, seriesIndex: s4, dataPointIndex: r4, w: i4 }]);
        } }, { key: "rotateAroundCenter", value: function(t5) {
          var e4 = {};
          return t5 && "function" == typeof t5.getBBox && (e4 = t5.getBBox()), { x: e4.x + e4.width / 2, y: e4.y + e4.height / 2 };
        } }, { key: "getTextRects", value: function(t5, e4, i4, a4) {
          var s4 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r4 = this.w, o3 = this.drawText({ x: -200, y: -200, text: t5, textAnchor: "start", fontSize: e4, fontFamily: i4, foreColor: "#fff", opacity: 0 });
          a4 && o3.attr("transform", a4), r4.globals.dom.Paper.add(o3);
          var n3 = o3.bbox();
          return s4 || (n3 = o3.node.getBoundingClientRect()), o3.remove(), { width: n3.width, height: n3.height };
        } }, { key: "placeTextWithEllipsis", value: function(t5, e4, i4) {
          if ("function" == typeof t5.getComputedTextLength && (t5.textContent = e4, e4.length > 0 && t5.getComputedTextLength() >= i4 / 1.1)) {
            for (var a4 = e4.length - 3; a4 > 0; a4 -= 3) if (t5.getSubStringLength(0, a4) <= i4 / 1.1) return void (t5.textContent = e4.substring(0, a4) + "...");
            t5.textContent = ".";
          }
        } }], [{ key: "setAttrs", value: function(t5, e4) {
          for (var i4 in e4) e4.hasOwnProperty(i4) && t5.setAttribute(i4, e4[i4]);
        } }]), t4;
      })();
      var A3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "getStackedSeriesTotals", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = this.w, i4 = [];
          if (0 === e4.globals.series.length) return i4;
          for (var a4 = 0; a4 < e4.globals.series[e4.globals.maxValsInArrayIndex].length; a4++) {
            for (var s4 = 0, r4 = 0; r4 < e4.globals.series.length; r4++) void 0 !== e4.globals.series[r4][a4] && -1 === t5.indexOf(r4) && (s4 += e4.globals.series[r4][a4]);
            i4.push(s4);
          }
          return i4;
        } }, { key: "getSeriesTotalByIndex", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
          return null === t5 ? this.w.config.series.reduce((function(t6, e4) {
            return t6 + e4;
          }), 0) : this.w.globals.series[t5].reduce((function(t6, e4) {
            return t6 + e4;
          }), 0);
        } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
          var t5 = this, e4 = this.w, i4 = [];
          return e4.globals.seriesGroups.forEach((function(a4) {
            var s4 = [];
            e4.config.series.forEach((function(t6, i5) {
              a4.indexOf(e4.globals.seriesNames[i5]) > -1 && s4.push(i5);
            }));
            var r4 = e4.globals.series.map((function(t6, e5) {
              return -1 === s4.indexOf(e5) ? e5 : -1;
            })).filter((function(t6) {
              return -1 !== t6;
            }));
            i4.push(t5.getStackedSeriesTotals(r4));
          })), i4;
        } }, { key: "setSeriesYAxisMappings", value: function() {
          var t5 = this.w.globals, e4 = this.w.config, i4 = [], a4 = [], s4 = [], r4 = t5.series.length > e4.yaxis.length || e4.yaxis.some((function(t6) {
            return Array.isArray(t6.seriesName);
          }));
          e4.series.forEach((function(t6, e5) {
            s4.push(e5), a4.push(null);
          })), e4.yaxis.forEach((function(t6, e5) {
            i4[e5] = [];
          }));
          var o3 = [];
          e4.yaxis.forEach((function(t6, a5) {
            var n4 = false;
            if (t6.seriesName) {
              var l5 = [];
              Array.isArray(t6.seriesName) ? l5 = t6.seriesName : l5.push(t6.seriesName), l5.forEach((function(t7) {
                e4.series.forEach((function(e5, o4) {
                  if (e5.name === t7) {
                    var l6 = o4;
                    a5 === o4 || r4 ? !r4 || s4.indexOf(o4) > -1 ? i4[a5].push([a5, o4]) : console.warn("Series '" + e5.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i4[o4].push([o4, a5]), l6 = a5), n4 = true, -1 !== (l6 = s4.indexOf(l6)) && s4.splice(l6, 1);
                  }
                }));
              }));
            }
            n4 || o3.push(a5);
          })), i4 = i4.map((function(t6, e5) {
            var i5 = [];
            return t6.forEach((function(t7) {
              a4[t7[1]] = t7[0], i5.push(t7[1]);
            })), i5;
          }));
          for (var n3 = e4.yaxis.length - 1, l4 = 0; l4 < o3.length && (n3 = o3[l4], i4[n3] = [], s4); l4++) {
            var h4 = s4[0];
            s4.shift(), i4[n3].push(h4), a4[h4] = n3;
          }
          s4.forEach((function(t6) {
            i4[n3].push(t6), a4[t6] = n3;
          })), t5.seriesYAxisMap = i4.map((function(t6) {
            return t6;
          })), t5.seriesYAxisReverseMap = a4.map((function(t6) {
            return t6;
          })), t5.seriesYAxisMap.forEach((function(t6, i5) {
            t6.forEach((function(t7) {
              e4.series[t7] && void 0 === e4.series[t7].group && (e4.series[t7].group = "apexcharts-axis-".concat(i5.toString()));
            }));
          }));
        } }, { key: "isSeriesNull", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
          return 0 === (null === t5 ? this.w.config.series.filter((function(t6) {
            return null !== t6;
          })) : this.w.config.series[t5].data.filter((function(t6) {
            return null !== t6;
          }))).length;
        } }, { key: "seriesHaveSameValues", value: function(t5) {
          return this.w.globals.series[t5].every((function(t6, e4, i4) {
            return t6 === i4[0];
          }));
        } }, { key: "getCategoryLabels", value: function(t5) {
          var e4 = this.w, i4 = t5.slice();
          return e4.config.xaxis.convertedCatToNumeric && (i4 = t5.map((function(t6, i5) {
            return e4.config.xaxis.labels.formatter(t6 - e4.globals.minX + 1);
          }))), i4;
        } }, { key: "getLargestSeries", value: function() {
          var t5 = this.w;
          t5.globals.maxValsInArrayIndex = t5.globals.series.map((function(t6) {
            return t6.length;
          })).indexOf(Math.max.apply(Math, t5.globals.series.map((function(t6) {
            return t6.length;
          }))));
        } }, { key: "getLargestMarkerSize", value: function() {
          var t5 = this.w, e4 = 0;
          return t5.globals.markers.size.forEach((function(t6) {
            e4 = Math.max(e4, t6);
          })), t5.config.markers.discrete && t5.config.markers.discrete.length && t5.config.markers.discrete.forEach((function(t6) {
            e4 = Math.max(e4, t6.size);
          })), e4 > 0 && (t5.config.markers.hover.size > 0 ? e4 = t5.config.markers.hover.size : e4 += t5.config.markers.hover.sizeOffset), t5.globals.markers.largestSize = e4, e4;
        } }, { key: "getSeriesTotals", value: function() {
          var t5 = this.w;
          t5.globals.seriesTotals = t5.globals.series.map((function(t6, e4) {
            var i4 = 0;
            if (Array.isArray(t6)) for (var a4 = 0; a4 < t6.length; a4++) i4 += t6[a4];
            else i4 += t6;
            return i4;
          }));
        } }, { key: "getSeriesTotalsXRange", value: function(t5, e4) {
          var i4 = this.w;
          return i4.globals.series.map((function(a4, s4) {
            for (var r4 = 0, o3 = 0; o3 < a4.length; o3++) i4.globals.seriesX[s4][o3] > t5 && i4.globals.seriesX[s4][o3] < e4 && (r4 += a4[o3]);
            return r4;
          }));
        } }, { key: "getPercentSeries", value: function() {
          var t5 = this.w;
          t5.globals.seriesPercent = t5.globals.series.map((function(e4, i4) {
            var a4 = [];
            if (Array.isArray(e4)) for (var s4 = 0; s4 < e4.length; s4++) {
              var r4 = t5.globals.stackedSeriesTotals[s4], o3 = 0;
              r4 && (o3 = 100 * e4[s4] / r4), a4.push(o3);
            }
            else {
              var n3 = 100 * e4 / t5.globals.seriesTotals.reduce((function(t6, e5) {
                return t6 + e5;
              }), 0);
              a4.push(n3);
            }
            return a4;
          }));
        } }, { key: "getCalculatedRatios", value: function() {
          var t5, e4, i4, a4 = this, s4 = this.w, r4 = s4.globals, o3 = [], n3 = 0, l4 = [], h4 = 0.1, c4 = 0;
          if (r4.yRange = [], r4.isMultipleYAxis) for (var d3 = 0; d3 < r4.minYArr.length; d3++) r4.yRange.push(Math.abs(r4.minYArr[d3] - r4.maxYArr[d3])), l4.push(0);
          else r4.yRange.push(Math.abs(r4.minY - r4.maxY));
          r4.xRange = Math.abs(r4.maxX - r4.minX), r4.zRange = Math.abs(r4.maxZ - r4.minZ);
          for (var g5 = 0; g5 < r4.yRange.length; g5++) o3.push(r4.yRange[g5] / r4.gridHeight);
          if (e4 = r4.xRange / r4.gridWidth, t5 = r4.yRange / r4.gridWidth, i4 = r4.xRange / r4.gridHeight, (n3 = r4.zRange / r4.gridHeight * 16) || (n3 = 1), r4.minY !== Number.MIN_VALUE && 0 !== Math.abs(r4.minY) && (r4.hasNegs = true), s4.globals.seriesYAxisReverseMap.length > 0) {
            var u4 = function(t6, e5) {
              var i5 = s4.config.yaxis[s4.globals.seriesYAxisReverseMap[e5]], r5 = t6 < 0 ? -1 : 1;
              return t6 = Math.abs(t6), i5.logarithmic && (t6 = a4.getBaseLog(i5.logBase, t6)), -r5 * t6 / o3[e5];
            };
            if (r4.isMultipleYAxis) {
              l4 = [];
              for (var f4 = 0; f4 < o3.length; f4++) l4.push(u4(r4.minYArr[f4], f4));
            } else (l4 = []).push(u4(r4.minY, 0)), r4.minY !== Number.MIN_VALUE && 0 !== Math.abs(r4.minY) && (h4 = -r4.minY / t5, c4 = r4.minX / e4);
          } else (l4 = []).push(0), h4 = 0, c4 = 0;
          return { yRatio: o3, invertedYRatio: t5, zRatio: n3, xRatio: e4, invertedXRatio: i4, baseLineInvertedY: h4, baseLineY: l4, baseLineX: c4 };
        } }, { key: "getLogSeries", value: function(t5) {
          var e4 = this, i4 = this.w;
          return i4.globals.seriesLog = t5.map((function(t6, a4) {
            var s4 = i4.globals.seriesYAxisReverseMap[a4];
            return i4.config.yaxis[s4] && i4.config.yaxis[s4].logarithmic ? t6.map((function(t7) {
              return null === t7 ? null : e4.getLogVal(i4.config.yaxis[s4].logBase, t7, a4);
            })) : t6;
          })), i4.globals.invalidLogScale ? t5 : i4.globals.seriesLog;
        } }, { key: "getBaseLog", value: function(t5, e4) {
          return Math.log(e4) / Math.log(t5);
        } }, { key: "getLogVal", value: function(t5, e4, i4) {
          if (e4 <= 0) return 0;
          var a4 = this.w, s4 = 0 === a4.globals.minYArr[i4] ? -1 : this.getBaseLog(t5, a4.globals.minYArr[i4]), r4 = (0 === a4.globals.maxYArr[i4] ? 0 : this.getBaseLog(t5, a4.globals.maxYArr[i4])) - s4;
          return e4 < 1 ? e4 / r4 : (this.getBaseLog(t5, e4) - s4) / r4;
        } }, { key: "getLogYRatios", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = this.w.globals;
          return a4.yLogRatio = t5.slice(), a4.logYRange = a4.yRange.map((function(t6, s4) {
            var r4 = i4.globals.seriesYAxisReverseMap[s4];
            if (i4.config.yaxis[r4] && e4.w.config.yaxis[r4].logarithmic) {
              var o3, n3 = -Number.MAX_VALUE, l4 = Number.MIN_VALUE;
              return a4.seriesLog.forEach((function(t7, e5) {
                t7.forEach((function(t8) {
                  i4.config.yaxis[e5] && i4.config.yaxis[e5].logarithmic && (n3 = Math.max(t8, n3), l4 = Math.min(t8, l4));
                }));
              })), o3 = Math.pow(a4.yRange[s4], Math.abs(l4 - n3) / a4.yRange[s4]), a4.yLogRatio[s4] = o3 / a4.gridHeight, o3;
            }
          })), a4.invalidLogScale ? t5.slice() : a4.yLogRatio;
        } }, { key: "drawSeriesByGroup", value: function(t5, e4, i4, a4) {
          var s4 = this.w, r4 = [];
          return t5.series.length > 0 && e4.forEach((function(e5) {
            var o3 = [], n3 = [];
            t5.i.forEach((function(i5, a5) {
              s4.config.series[i5].group === e5 && (o3.push(t5.series[a5]), n3.push(i5));
            })), o3.length > 0 && r4.push(a4.draw(o3, i4, n3));
          })), r4;
        } }], [{ key: "checkComboSeries", value: function(t5, e4) {
          var i4 = false, a4 = 0, s4 = 0;
          return void 0 === e4 && (e4 = "line"), t5.length && void 0 !== t5[0].type && t5.forEach((function(t6) {
            "bar" !== t6.type && "column" !== t6.type && "candlestick" !== t6.type && "boxPlot" !== t6.type || a4++, void 0 !== t6.type && t6.type !== e4 && s4++;
          })), s4 > 0 && (i4 = true), { comboBarCount: a4, comboCharts: i4 };
        } }, { key: "extendArrayProps", value: function(t5, e4, i4) {
          var a4, s4, r4, o3, n3, l4;
          (null !== (a4 = e4) && void 0 !== a4 && a4.yaxis && (e4 = t5.extendYAxis(e4, i4)), null !== (s4 = e4) && void 0 !== s4 && s4.annotations) && (e4.annotations.yaxis && (e4 = t5.extendYAxisAnnotations(e4)), null !== (r4 = e4) && void 0 !== r4 && null !== (o3 = r4.annotations) && void 0 !== o3 && o3.xaxis && (e4 = t5.extendXAxisAnnotations(e4)), null !== (n3 = e4) && void 0 !== n3 && null !== (l4 = n3.annotations) && void 0 !== l4 && l4.points && (e4 = t5.extendPointAnnotations(e4)));
          return e4;
        } }]), t4;
      })();
      var S2 = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.annoCtx = e4;
        }
        return s3(t4, [{ key: "setOrientations", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i4 = this.w;
          if ("vertical" === t5.label.orientation) {
            var a4 = null !== e4 ? e4 : 0, s4 = i4.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a4, "']"));
            if (null !== s4) {
              var r4 = s4.getBoundingClientRect();
              s4.setAttribute("x", parseFloat(s4.getAttribute("x")) - r4.height + 4);
              var o3 = "top" === t5.label.position ? r4.width : -r4.width;
              s4.setAttribute("y", parseFloat(s4.getAttribute("y")) + o3);
              var n3 = this.annoCtx.graphics.rotateAroundCenter(s4), l4 = n3.x, h4 = n3.y;
              s4.setAttribute("transform", "rotate(-90 ".concat(l4, " ").concat(h4, ")"));
            }
          }
        } }, { key: "addBackgroundToAnno", value: function(t5, e4) {
          var i4 = this.w;
          if (!t5 || !e4.label.text || !String(e4.label.text).trim()) return null;
          var a4 = i4.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s4 = t5.getBoundingClientRect(), r4 = e4.label.style.padding, o3 = r4.left, n3 = r4.right, l4 = r4.top, h4 = r4.bottom;
          if ("vertical" === e4.label.orientation) {
            var c4 = [o3, n3, l4, h4];
            l4 = c4[0], h4 = c4[1], o3 = c4[2], n3 = c4[3];
          }
          var d3 = s4.left - a4.left - o3, g5 = s4.top - a4.top - l4, u4 = this.annoCtx.graphics.drawRect(d3 - i4.globals.barPadForNumericAxis, g5, s4.width + o3 + n3, s4.height + l4 + h4, e4.label.borderRadius, e4.label.style.background, 1, e4.label.borderWidth, e4.label.borderColor, 0);
          return e4.id && u4.node.classList.add(e4.id), u4;
        } }, { key: "annotationsBackground", value: function() {
          var t5 = this, e4 = this.w, i4 = function(i5, a4, s4) {
            var r4 = e4.globals.dom.baseEl.querySelector(".apexcharts-".concat(s4, "-annotations .apexcharts-").concat(s4, "-annotation-label[rel='").concat(a4, "']"));
            if (r4) {
              var o3 = r4.parentNode, n3 = t5.addBackgroundToAnno(r4, i5);
              n3 && (o3.insertBefore(n3.node, r4), i5.label.mouseEnter && n3.node.addEventListener("mouseenter", i5.label.mouseEnter.bind(t5, i5)), i5.label.mouseLeave && n3.node.addEventListener("mouseleave", i5.label.mouseLeave.bind(t5, i5)), i5.label.click && n3.node.addEventListener("click", i5.label.click.bind(t5, i5)));
            }
          };
          e4.config.annotations.xaxis.forEach((function(t6, e5) {
            return i4(t6, e5, "xaxis");
          })), e4.config.annotations.yaxis.forEach((function(t6, e5) {
            return i4(t6, e5, "yaxis");
          })), e4.config.annotations.points.forEach((function(t6, e5) {
            return i4(t6, e5, "point");
          }));
        } }, { key: "getY1Y2", value: function(t5, e4) {
          var i4, a4 = this.w, s4 = "y1" === t5 ? e4.y : e4.y2, r4 = false;
          if (this.annoCtx.invertAxis) {
            var o3 = a4.config.xaxis.convertedCatToNumeric ? a4.globals.categoryLabels : a4.globals.labels, n3 = o3.indexOf(s4), l4 = a4.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(n3 + 1, ")"));
            i4 = l4 ? parseFloat(l4.getAttribute("y")) : (a4.globals.gridHeight / o3.length - 1) * (n3 + 1) - a4.globals.barHeight, void 0 !== e4.seriesIndex && a4.globals.barHeight && (i4 -= a4.globals.barHeight / 2 * (a4.globals.series.length - 1) - a4.globals.barHeight * e4.seriesIndex);
          } else {
            var h4, c4 = a4.globals.seriesYAxisMap[e4.yAxisIndex][0], d3 = a4.config.yaxis[e4.yAxisIndex].logarithmic ? new A3(this.annoCtx.ctx).getLogVal(a4.config.yaxis[e4.yAxisIndex].logBase, s4, c4) / a4.globals.yLogRatio[c4] : (s4 - a4.globals.minYArr[c4]) / (a4.globals.yRange[c4] / a4.globals.gridHeight);
            i4 = a4.globals.gridHeight - Math.min(Math.max(d3, 0), a4.globals.gridHeight), r4 = d3 > a4.globals.gridHeight || d3 < 0, !e4.marker || void 0 !== e4.y && null !== e4.y || (i4 = 0), null !== (h4 = a4.config.yaxis[e4.yAxisIndex]) && void 0 !== h4 && h4.reversed && (i4 = d3);
          }
          return "string" == typeof s4 && s4.includes("px") && (i4 = parseFloat(s4)), { yP: i4, clipped: r4 };
        } }, { key: "getX1X2", value: function(t5, e4) {
          var i4 = this.w, a4 = "x1" === t5 ? e4.x : e4.x2, s4 = this.annoCtx.invertAxis ? i4.globals.minY : i4.globals.minX, r4 = this.annoCtx.invertAxis ? i4.globals.maxY : i4.globals.maxX, o3 = this.annoCtx.invertAxis ? i4.globals.yRange[0] : i4.globals.xRange, n3 = false, l4 = this.annoCtx.inversedReversedAxis ? (r4 - a4) / (o3 / i4.globals.gridWidth) : (a4 - s4) / (o3 / i4.globals.gridWidth);
          return "category" !== i4.config.xaxis.type && !i4.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i4.globals.dataFormatXNumeric || i4.config.chart.sparkline.enabled || (l4 = this.getStringX(a4)), "string" == typeof a4 && a4.includes("px") && (l4 = parseFloat(a4)), null == a4 && e4.marker && (l4 = i4.globals.gridWidth), void 0 !== e4.seriesIndex && i4.globals.barWidth && !this.annoCtx.invertAxis && (l4 -= i4.globals.barWidth / 2 * (i4.globals.series.length - 1) - i4.globals.barWidth * e4.seriesIndex), l4 > i4.globals.gridWidth ? (l4 = i4.globals.gridWidth, n3 = true) : l4 < 0 && (l4 = 0, n3 = true), { x: l4, clipped: n3 };
        } }, { key: "getStringX", value: function(t5) {
          var e4 = this.w, i4 = t5;
          e4.config.xaxis.convertedCatToNumeric && e4.globals.categoryLabels.length && (t5 = e4.globals.categoryLabels.indexOf(t5) + 1);
          var a4 = e4.globals.labels.map((function(t6) {
            return Array.isArray(t6) ? t6.join(" ") : t6;
          })).indexOf(t5), s4 = e4.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(a4 + 1, ")"));
          return s4 && (i4 = parseFloat(s4.getAttribute("x"))), i4;
        } }]), t4;
      })();
      var C3 = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.annoCtx = e4, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new S2(this.annoCtx);
        }
        return s3(t4, [{ key: "addXaxisAnnotation", value: function(t5, e4, i4) {
          var a4, s4 = this.w, r4 = this.helpers.getX1X2("x1", t5), o3 = r4.x, n3 = r4.clipped, l4 = true, h4 = t5.label.text, c4 = t5.strokeDashArray;
          if (m3.isNumber(o3)) {
            if (null === t5.x2 || void 0 === t5.x2) {
              if (!n3) {
                var d3 = this.annoCtx.graphics.drawLine(o3 + t5.offsetX, 0 + t5.offsetY, o3 + t5.offsetX, s4.globals.gridHeight + t5.offsetY, t5.borderColor, c4, t5.borderWidth);
                e4.appendChild(d3.node), t5.id && d3.node.classList.add(t5.id);
              }
            } else {
              var g5 = this.helpers.getX1X2("x2", t5);
              if (a4 = g5.x, l4 = g5.clipped, !n3 || !l4) {
                if (a4 < o3) {
                  var u4 = o3;
                  o3 = a4, a4 = u4;
                }
                var f4 = this.annoCtx.graphics.drawRect(o3 + t5.offsetX, 0 + t5.offsetY, a4 - o3, s4.globals.gridHeight + t5.offsetY, 0, t5.fillColor, t5.opacity, 1, t5.borderColor, c4);
                f4.node.classList.add("apexcharts-annotation-rect"), f4.attr("clip-path", "url(#gridRectMask".concat(s4.globals.cuid, ")")), e4.appendChild(f4.node), t5.id && f4.node.classList.add(t5.id);
              }
            }
            if (!n3 || !l4) {
              var p4 = this.annoCtx.graphics.getTextRects(h4, parseFloat(t5.label.style.fontSize)), x5 = "top" === t5.label.position ? 4 : "center" === t5.label.position ? s4.globals.gridHeight / 2 + ("vertical" === t5.label.orientation ? p4.width / 2 : 0) : s4.globals.gridHeight, b4 = this.annoCtx.graphics.drawText({ x: o3 + t5.label.offsetX, y: x5 + t5.label.offsetY - ("vertical" === t5.label.orientation ? "top" === t5.label.position ? p4.width / 2 - 12 : -p4.width / 2 : 0), text: h4, textAnchor: t5.label.textAnchor, fontSize: t5.label.style.fontSize, fontFamily: t5.label.style.fontFamily, fontWeight: t5.label.style.fontWeight, foreColor: t5.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t5.label.style.cssClass, " ").concat(t5.id ? t5.id : "") });
              b4.attr({ rel: i4 }), e4.appendChild(b4.node), this.annoCtx.helpers.setOrientations(t5, i4);
            }
          }
        } }, { key: "drawXAxisAnnotations", value: function() {
          var t5 = this, e4 = this.w, i4 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
          return e4.config.annotations.xaxis.map((function(e5, a4) {
            t5.addXaxisAnnotation(e5, i4.node, a4);
          })), i4;
        } }]), t4;
      })();
      var L3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        }
        return s3(t4, [{ key: "isValidDate", value: function(t5) {
          return "number" != typeof t5 && !isNaN(this.parseDate(t5));
        } }, { key: "getTimeStamp", value: function(t5) {
          return Date.parse(t5) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t5).toISOString().substr(0, 25)).getTime() : new Date(t5).getTime() : t5;
        } }, { key: "getDate", value: function(t5) {
          return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t5).toUTCString()) : new Date(t5);
        } }, { key: "parseDate", value: function(t5) {
          var e4 = Date.parse(t5);
          if (!isNaN(e4)) return this.getTimeStamp(t5);
          var i4 = Date.parse(t5.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
          return i4 = this.getTimeStamp(i4);
        } }, { key: "parseDateWithTimezone", value: function(t5) {
          return Date.parse(t5.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
        } }, { key: "formatDate", value: function(t5, e4) {
          var i4 = this.w.globals.locale, a4 = this.w.config.xaxis.labels.datetimeUTC, s4 = ["\0"].concat(p3(i4.months)), r4 = [""].concat(p3(i4.shortMonths)), o3 = [""].concat(p3(i4.days)), n3 = [""].concat(p3(i4.shortDays));
          function l4(t6, e5) {
            var i5 = t6 + "";
            for (e5 = e5 || 2; i5.length < e5; ) i5 = "0" + i5;
            return i5;
          }
          var h4 = a4 ? t5.getUTCFullYear() : t5.getFullYear();
          e4 = (e4 = (e4 = e4.replace(/(^|[^\\])yyyy+/g, "$1" + h4)).replace(/(^|[^\\])yy/g, "$1" + h4.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h4);
          var c4 = (a4 ? t5.getUTCMonth() : t5.getMonth()) + 1;
          e4 = (e4 = (e4 = (e4 = e4.replace(/(^|[^\\])MMMM+/g, "$1" + s4[0])).replace(/(^|[^\\])MMM/g, "$1" + r4[0])).replace(/(^|[^\\])MM/g, "$1" + l4(c4))).replace(/(^|[^\\])M/g, "$1" + c4);
          var d3 = a4 ? t5.getUTCDate() : t5.getDate();
          e4 = (e4 = (e4 = (e4 = e4.replace(/(^|[^\\])dddd+/g, "$1" + o3[0])).replace(/(^|[^\\])ddd/g, "$1" + n3[0])).replace(/(^|[^\\])dd/g, "$1" + l4(d3))).replace(/(^|[^\\])d/g, "$1" + d3);
          var g5 = a4 ? t5.getUTCHours() : t5.getHours(), u4 = g5 > 12 ? g5 - 12 : 0 === g5 ? 12 : g5;
          e4 = (e4 = (e4 = (e4 = e4.replace(/(^|[^\\])HH+/g, "$1" + l4(g5))).replace(/(^|[^\\])H/g, "$1" + g5)).replace(/(^|[^\\])hh+/g, "$1" + l4(u4))).replace(/(^|[^\\])h/g, "$1" + u4);
          var f4 = a4 ? t5.getUTCMinutes() : t5.getMinutes();
          e4 = (e4 = e4.replace(/(^|[^\\])mm+/g, "$1" + l4(f4))).replace(/(^|[^\\])m/g, "$1" + f4);
          var x5 = a4 ? t5.getUTCSeconds() : t5.getSeconds();
          e4 = (e4 = e4.replace(/(^|[^\\])ss+/g, "$1" + l4(x5))).replace(/(^|[^\\])s/g, "$1" + x5);
          var b4 = a4 ? t5.getUTCMilliseconds() : t5.getMilliseconds();
          e4 = e4.replace(/(^|[^\\])fff+/g, "$1" + l4(b4, 3)), b4 = Math.round(b4 / 10), e4 = e4.replace(/(^|[^\\])ff/g, "$1" + l4(b4)), b4 = Math.round(b4 / 10);
          var v4 = g5 < 12 ? "AM" : "PM";
          e4 = (e4 = (e4 = e4.replace(/(^|[^\\])f/g, "$1" + b4)).replace(/(^|[^\\])TT+/g, "$1" + v4)).replace(/(^|[^\\])T/g, "$1" + v4.charAt(0));
          var m4 = v4.toLowerCase();
          e4 = (e4 = e4.replace(/(^|[^\\])tt+/g, "$1" + m4)).replace(/(^|[^\\])t/g, "$1" + m4.charAt(0));
          var y4 = -t5.getTimezoneOffset(), w5 = a4 || !y4 ? "Z" : y4 > 0 ? "+" : "-";
          if (!a4) {
            var k4 = (y4 = Math.abs(y4)) % 60;
            w5 += l4(Math.floor(y4 / 60)) + ":" + l4(k4);
          }
          e4 = e4.replace(/(^|[^\\])K/g, "$1" + w5);
          var A4 = (a4 ? t5.getUTCDay() : t5.getDay()) + 1;
          return e4 = (e4 = (e4 = (e4 = (e4 = e4.replace(new RegExp(o3[0], "g"), o3[A4])).replace(new RegExp(n3[0], "g"), n3[A4])).replace(new RegExp(s4[0], "g"), s4[c4])).replace(new RegExp(r4[0], "g"), r4[c4])).replace(/\\(.)/g, "$1");
        } }, { key: "getTimeUnitsfromTimestamp", value: function(t5, e4, i4) {
          var a4 = this.w;
          void 0 !== a4.config.xaxis.min && (t5 = a4.config.xaxis.min), void 0 !== a4.config.xaxis.max && (e4 = a4.config.xaxis.max);
          var s4 = this.getDate(t5), r4 = this.getDate(e4), o3 = this.formatDate(s4, "yyyy MM dd HH mm ss fff").split(" "), n3 = this.formatDate(r4, "yyyy MM dd HH mm ss fff").split(" ");
          return { minMillisecond: parseInt(o3[6], 10), maxMillisecond: parseInt(n3[6], 10), minSecond: parseInt(o3[5], 10), maxSecond: parseInt(n3[5], 10), minMinute: parseInt(o3[4], 10), maxMinute: parseInt(n3[4], 10), minHour: parseInt(o3[3], 10), maxHour: parseInt(n3[3], 10), minDate: parseInt(o3[2], 10), maxDate: parseInt(n3[2], 10), minMonth: parseInt(o3[1], 10) - 1, maxMonth: parseInt(n3[1], 10) - 1, minYear: parseInt(o3[0], 10), maxYear: parseInt(n3[0], 10) };
        } }, { key: "isLeapYear", value: function(t5) {
          return t5 % 4 == 0 && t5 % 100 != 0 || t5 % 400 == 0;
        } }, { key: "calculcateLastDaysOfMonth", value: function(t5, e4, i4) {
          return this.determineDaysOfMonths(t5, e4) - i4;
        } }, { key: "determineDaysOfYear", value: function(t5) {
          var e4 = 365;
          return this.isLeapYear(t5) && (e4 = 366), e4;
        } }, { key: "determineRemainingDaysOfYear", value: function(t5, e4, i4) {
          var a4 = this.daysCntOfYear[e4] + i4;
          return e4 > 1 && this.isLeapYear() && a4++, a4;
        } }, { key: "determineDaysOfMonths", value: function(t5, e4) {
          var i4 = 30;
          switch (t5 = m3.monthMod(t5), true) {
            case this.months30.indexOf(t5) > -1:
              2 === t5 && (i4 = this.isLeapYear(e4) ? 29 : 28);
              break;
            case this.months31.indexOf(t5) > -1:
            default:
              i4 = 31;
          }
          return i4;
        } }]), t4;
      })();
      var P3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.tooltipKeyFormat = "dd MMM";
        }
        return s3(t4, [{ key: "xLabelFormat", value: function(t5, e4, i4, a4) {
          var s4 = this.w;
          if ("datetime" === s4.config.xaxis.type && void 0 === s4.config.xaxis.labels.formatter && void 0 === s4.config.tooltip.x.formatter) {
            var r4 = new L3(this.ctx);
            return r4.formatDate(r4.getDate(e4), s4.config.tooltip.x.format);
          }
          return t5(e4, i4, a4);
        } }, { key: "defaultGeneralFormatter", value: function(t5) {
          return Array.isArray(t5) ? t5.map((function(t6) {
            return t6;
          })) : t5;
        } }, { key: "defaultYFormatter", value: function(t5, e4, i4) {
          var a4 = this.w;
          if (m3.isNumber(t5)) if (0 !== a4.globals.yValueDecimal) t5 = t5.toFixed(void 0 !== e4.decimalsInFloat ? e4.decimalsInFloat : a4.globals.yValueDecimal);
          else {
            var s4 = t5.toFixed(0);
            t5 = t5 == s4 ? s4 : t5.toFixed(1);
          }
          return t5;
        } }, { key: "setLabelFormatters", value: function() {
          var t5 = this, e4 = this.w;
          return e4.globals.xaxisTooltipFormatter = function(e5) {
            return t5.defaultGeneralFormatter(e5);
          }, e4.globals.ttKeyFormatter = function(e5) {
            return t5.defaultGeneralFormatter(e5);
          }, e4.globals.ttZFormatter = function(t6) {
            return t6;
          }, e4.globals.legendFormatter = function(e5) {
            return t5.defaultGeneralFormatter(e5);
          }, void 0 !== e4.config.xaxis.labels.formatter ? e4.globals.xLabelFormatter = e4.config.xaxis.labels.formatter : e4.globals.xLabelFormatter = function(t6) {
            if (m3.isNumber(t6)) {
              if (!e4.config.xaxis.convertedCatToNumeric && "numeric" === e4.config.xaxis.type) {
                if (m3.isNumber(e4.config.xaxis.decimalsInFloat)) return t6.toFixed(e4.config.xaxis.decimalsInFloat);
                var i4 = e4.globals.maxX - e4.globals.minX;
                return i4 > 0 && i4 < 100 ? t6.toFixed(1) : t6.toFixed(0);
              }
              if (e4.globals.isBarHorizontal) {
                if (e4.globals.maxY - e4.globals.minYArr < 4) return t6.toFixed(1);
              }
              return t6.toFixed(0);
            }
            return t6;
          }, "function" == typeof e4.config.tooltip.x.formatter ? e4.globals.ttKeyFormatter = e4.config.tooltip.x.formatter : e4.globals.ttKeyFormatter = e4.globals.xLabelFormatter, "function" == typeof e4.config.xaxis.tooltip.formatter && (e4.globals.xaxisTooltipFormatter = e4.config.xaxis.tooltip.formatter), (Array.isArray(e4.config.tooltip.y) || void 0 !== e4.config.tooltip.y.formatter) && (e4.globals.ttVal = e4.config.tooltip.y), void 0 !== e4.config.tooltip.z.formatter && (e4.globals.ttZFormatter = e4.config.tooltip.z.formatter), void 0 !== e4.config.legend.formatter && (e4.globals.legendFormatter = e4.config.legend.formatter), e4.config.yaxis.forEach((function(i4, a4) {
            void 0 !== i4.labels.formatter ? e4.globals.yLabelFormatters[a4] = i4.labels.formatter : e4.globals.yLabelFormatters[a4] = function(s4) {
              return e4.globals.xyCharts ? Array.isArray(s4) ? s4.map((function(e5) {
                return t5.defaultYFormatter(e5, i4, a4);
              })) : t5.defaultYFormatter(s4, i4, a4) : s4;
            };
          })), e4.globals;
        } }, { key: "heatmapLabelFormatters", value: function() {
          var t5 = this.w;
          if ("heatmap" === t5.config.chart.type) {
            t5.globals.yAxisScale[0].result = t5.globals.seriesNames.slice();
            var e4 = t5.globals.seriesNames.reduce((function(t6, e5) {
              return t6.length > e5.length ? t6 : e5;
            }), 0);
            t5.globals.yAxisScale[0].niceMax = e4, t5.globals.yAxisScale[0].niceMin = e4;
          }
        } }]), t4;
      })();
      var M2 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "getLabel", value: function(t5, e4, i4, a4) {
          var s4 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r4 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o3 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], n3 = this.w, l4 = void 0 === t5[a4] ? "" : t5[a4], h4 = l4, c4 = n3.globals.xLabelFormatter, d3 = n3.config.xaxis.labels.formatter, g5 = false, u4 = new P3(this.ctx), f4 = l4;
          o3 && (h4 = u4.xLabelFormat(c4, l4, f4, { i: a4, dateFormatter: new L3(this.ctx).formatDate, w: n3 }), void 0 !== d3 && (h4 = d3(l4, t5[a4], { i: a4, dateFormatter: new L3(this.ctx).formatDate, w: n3 })));
          var p4, x5;
          e4.length > 0 ? (p4 = e4[a4].unit, x5 = null, e4.forEach((function(t6) {
            "month" === t6.unit ? x5 = "year" : "day" === t6.unit ? x5 = "month" : "hour" === t6.unit ? x5 = "day" : "minute" === t6.unit && (x5 = "hour");
          })), g5 = x5 === p4, i4 = e4[a4].position, h4 = e4[a4].value) : "datetime" === n3.config.xaxis.type && void 0 === d3 && (h4 = ""), void 0 === h4 && (h4 = ""), h4 = Array.isArray(h4) ? h4 : h4.toString();
          var b4 = new k3(this.ctx), v4 = {};
          v4 = n3.globals.rotateXLabels && o3 ? b4.getTextRects(h4, parseInt(r4, 10), null, "rotate(".concat(n3.config.xaxis.labels.rotate, " 0 0)"), false) : b4.getTextRects(h4, parseInt(r4, 10));
          var m4 = !n3.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
          return !Array.isArray(h4) && ("NaN" === String(h4) || s4.indexOf(h4) >= 0 && m4) && (h4 = ""), { x: i4, text: h4, textRect: v4, isBold: g5 };
        } }, { key: "checkLabelBasedOnTickamount", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = a4.config.xaxis.tickAmount;
          return "dataPoints" === s4 && (s4 = Math.round(a4.globals.gridWidth / 120)), s4 > i4 || t5 % Math.round(i4 / (s4 + 1)) == 0 || (e4.text = ""), e4;
        } }, { key: "checkForOverflowingLabels", value: function(t5, e4, i4, a4, s4) {
          var r4 = this.w;
          if (0 === t5 && r4.globals.skipFirstTimelinelabel && (e4.text = ""), t5 === i4 - 1 && r4.globals.skipLastTimelinelabel && (e4.text = ""), r4.config.xaxis.labels.hideOverlappingLabels && a4.length > 0) {
            var o3 = s4[s4.length - 1];
            e4.x < o3.textRect.width / (r4.globals.rotateXLabels ? Math.abs(r4.config.xaxis.labels.rotate) / 12 : 1.01) + o3.x && (e4.text = "");
          }
          return e4;
        } }, { key: "checkForReversedLabels", value: function(t5, e4) {
          var i4 = this.w;
          return i4.config.yaxis[t5] && i4.config.yaxis[t5].reversed && e4.reverse(), e4;
        } }, { key: "yAxisAllSeriesCollapsed", value: function(t5) {
          var e4 = this.w.globals;
          return !e4.seriesYAxisMap[t5].some((function(t6) {
            return -1 === e4.collapsedSeriesIndices.indexOf(t6);
          }));
        } }, { key: "translateYAxisIndex", value: function(t5) {
          var e4 = this.w, i4 = e4.globals, a4 = e4.config.yaxis;
          return i4.series.length > a4.length || a4.some((function(t6) {
            return Array.isArray(t6.seriesName);
          })) ? t5 : i4.seriesYAxisReverseMap[t5];
        } }, { key: "isYAxisHidden", value: function(t5) {
          var e4 = this.w, i4 = e4.config.yaxis[t5];
          if (!i4.show || this.yAxisAllSeriesCollapsed(t5)) return true;
          if (!i4.showForNullSeries) {
            var a4 = e4.globals.seriesYAxisMap[t5], s4 = new A3(this.ctx);
            return a4.every((function(t6) {
              return s4.isSeriesNull(t6);
            }));
          }
          return false;
        } }, { key: "getYAxisForeColor", value: function(t5, e4) {
          var i4 = this.w;
          return Array.isArray(t5) && i4.globals.yAxisScale[e4] && this.ctx.theme.pushExtraColors(t5, i4.globals.yAxisScale[e4].result.length, false), t5;
        } }, { key: "drawYAxisTicks", value: function(t5, e4, i4, a4, s4, r4, o3) {
          var n3 = this.w, l4 = new k3(this.ctx), h4 = n3.globals.translateY + n3.config.yaxis[s4].labels.offsetY;
          if (n3.globals.isBarHorizontal ? h4 = 0 : "heatmap" === n3.config.chart.type && (h4 += r4 / 2), a4.show && e4 > 0) {
            true === n3.config.yaxis[s4].opposite && (t5 += a4.width);
            for (var c4 = e4; c4 >= 0; c4--) {
              var d3 = l4.drawLine(t5 + i4.offsetX - a4.width + a4.offsetX, h4 + a4.offsetY, t5 + i4.offsetX + a4.offsetX, h4 + a4.offsetY, a4.color);
              o3.add(d3), h4 += r4;
            }
          }
        } }]), t4;
      })();
      var I3 = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.annoCtx = e4, this.helpers = new S2(this.annoCtx), this.axesUtils = new M2(this.annoCtx);
        }
        return s3(t4, [{ key: "addYaxisAnnotation", value: function(t5, e4, i4) {
          var a4, s4 = this.w, r4 = t5.strokeDashArray, o3 = this.helpers.getY1Y2("y1", t5), n3 = o3.yP, l4 = o3.clipped, h4 = true, c4 = false, d3 = t5.label.text;
          if (null === t5.y2 || void 0 === t5.y2) {
            if (!l4) {
              c4 = true;
              var g5 = this.annoCtx.graphics.drawLine(0 + t5.offsetX, n3 + t5.offsetY, this._getYAxisAnnotationWidth(t5), n3 + t5.offsetY, t5.borderColor, r4, t5.borderWidth);
              e4.appendChild(g5.node), t5.id && g5.node.classList.add(t5.id);
            }
          } else {
            if (a4 = (o3 = this.helpers.getY1Y2("y2", t5)).yP, h4 = o3.clipped, a4 > n3) {
              var u4 = n3;
              n3 = a4, a4 = u4;
            }
            if (!l4 || !h4) {
              c4 = true;
              var f4 = this.annoCtx.graphics.drawRect(0 + t5.offsetX, a4 + t5.offsetY, this._getYAxisAnnotationWidth(t5), n3 - a4, 0, t5.fillColor, t5.opacity, 1, t5.borderColor, r4);
              f4.node.classList.add("apexcharts-annotation-rect"), f4.attr("clip-path", "url(#gridRectMask".concat(s4.globals.cuid, ")")), e4.appendChild(f4.node), t5.id && f4.node.classList.add(t5.id);
            }
          }
          if (c4) {
            var p4 = "right" === t5.label.position ? s4.globals.gridWidth : "center" === t5.label.position ? s4.globals.gridWidth / 2 : 0, x5 = this.annoCtx.graphics.drawText({ x: p4 + t5.label.offsetX, y: (null != a4 ? a4 : n3) + t5.label.offsetY - 3, text: d3, textAnchor: t5.label.textAnchor, fontSize: t5.label.style.fontSize, fontFamily: t5.label.style.fontFamily, fontWeight: t5.label.style.fontWeight, foreColor: t5.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t5.label.style.cssClass, " ").concat(t5.id ? t5.id : "") });
            x5.attr({ rel: i4 }), e4.appendChild(x5.node);
          }
        } }, { key: "_getYAxisAnnotationWidth", value: function(t5) {
          var e4 = this.w;
          e4.globals.gridWidth;
          return (t5.width.indexOf("%") > -1 ? e4.globals.gridWidth * parseInt(t5.width, 10) / 100 : parseInt(t5.width, 10)) + t5.offsetX;
        } }, { key: "drawYAxisAnnotations", value: function() {
          var t5 = this, e4 = this.w, i4 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
          return e4.config.annotations.yaxis.forEach((function(e5, a4) {
            e5.yAxisIndex = t5.axesUtils.translateYAxisIndex(e5.yAxisIndex), t5.axesUtils.isYAxisHidden(e5.yAxisIndex) && t5.axesUtils.yAxisAllSeriesCollapsed(e5.yAxisIndex) || t5.addYaxisAnnotation(e5, i4.node, a4);
          })), i4;
        } }]), t4;
      })();
      var T4 = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.annoCtx = e4, this.helpers = new S2(this.annoCtx);
        }
        return s3(t4, [{ key: "addPointAnnotation", value: function(t5, e4, i4) {
          if (!(this.w.globals.collapsedSeriesIndices.indexOf(t5.seriesIndex) > -1)) {
            var a4 = this.helpers.getX1X2("x1", t5), s4 = a4.x, r4 = a4.clipped, o3 = (a4 = this.helpers.getY1Y2("y1", t5)).yP, n3 = a4.clipped;
            if (m3.isNumber(s4) && !n3 && !r4) {
              var l4 = { pSize: t5.marker.size, pointStrokeWidth: t5.marker.strokeWidth, pointFillColor: t5.marker.fillColor, pointStrokeColor: t5.marker.strokeColor, shape: t5.marker.shape, pRadius: t5.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t5.marker.cssClass, " ").concat(t5.id ? t5.id : "") }, h4 = this.annoCtx.graphics.drawMarker(s4 + t5.marker.offsetX, o3 + t5.marker.offsetY, l4);
              e4.appendChild(h4.node);
              var c4 = t5.label.text ? t5.label.text : "", d3 = this.annoCtx.graphics.drawText({ x: s4 + t5.label.offsetX, y: o3 + t5.label.offsetY - t5.marker.size - parseFloat(t5.label.style.fontSize) / 1.6, text: c4, textAnchor: t5.label.textAnchor, fontSize: t5.label.style.fontSize, fontFamily: t5.label.style.fontFamily, fontWeight: t5.label.style.fontWeight, foreColor: t5.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t5.label.style.cssClass, " ").concat(t5.id ? t5.id : "") });
              if (d3.attr({ rel: i4 }), e4.appendChild(d3.node), t5.customSVG.SVG) {
                var g5 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t5.customSVG.cssClass });
                g5.attr({ transform: "translate(".concat(s4 + t5.customSVG.offsetX, ", ").concat(o3 + t5.customSVG.offsetY, ")") }), g5.node.innerHTML = t5.customSVG.SVG, e4.appendChild(g5.node);
              }
              if (t5.image.path) {
                var u4 = t5.image.width ? t5.image.width : 20, f4 = t5.image.height ? t5.image.height : 20;
                h4 = this.annoCtx.addImage({ x: s4 + t5.image.offsetX - u4 / 2, y: o3 + t5.image.offsetY - f4 / 2, width: u4, height: f4, path: t5.image.path, appendTo: ".apexcharts-point-annotations" });
              }
              t5.mouseEnter && h4.node.addEventListener("mouseenter", t5.mouseEnter.bind(this, t5)), t5.mouseLeave && h4.node.addEventListener("mouseleave", t5.mouseLeave.bind(this, t5)), t5.click && h4.node.addEventListener("click", t5.click.bind(this, t5));
            }
          }
        } }, { key: "drawPointAnnotations", value: function() {
          var t5 = this, e4 = this.w, i4 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
          return e4.config.annotations.points.map((function(e5, a4) {
            t5.addPointAnnotation(e5, i4.node, a4);
          })), i4;
        } }]), t4;
      })();
      var z3 = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } };
      var X2 = (function() {
        function t4() {
          i3(this, t4), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, showDuplicates: false, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
        }
        return s3(t4, [{ key: "init", value: function() {
          return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "", locales: [z3], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, allowMouseWheelZoom: true, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false }, area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t5) {
            return t5;
          } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t5) {
            return t5 + "%";
          } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t5) {
            return t5.globals.seriesTotals.reduce((function(t6, e4) {
              return t6 + e4;
            }), 0) / t5.globals.series.length + "%";
          } } }, barLabels: { enabled: false, offsetX: 0, offsetY: 0, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(t5) {
            return t5;
          }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t5) {
            return t5;
          } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t5) {
            return t5;
          } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t5) {
            return t5.globals.seriesTotals.reduce((function(t6, e4) {
              return t6 + e4;
            }), 0);
          } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t5) {
            return null !== t5 ? t5 : "";
          }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: true, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t5) {
            return t5 ? t5 + ": " : "";
          } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
        } }]), t4;
      })();
      var E2 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.graphics = new k3(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new S2(this), this.xAxisAnnotations = new C3(this), this.yAxisAnnotations = new I3(this), this.pointsAnnotations = new T4(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
        }
        return s3(t4, [{ key: "drawAxesAnnotations", value: function() {
          var t5 = this.w;
          if (t5.globals.axisCharts && t5.globals.dataPoints) {
            for (var e4 = this.yAxisAnnotations.drawYAxisAnnotations(), i4 = this.xAxisAnnotations.drawXAxisAnnotations(), a4 = this.pointsAnnotations.drawPointAnnotations(), s4 = t5.config.chart.animations.enabled, r4 = [e4, i4, a4], o3 = [i4.node, e4.node, a4.node], n3 = 0; n3 < 3; n3++) t5.globals.dom.elGraphical.add(r4[n3]), !s4 || t5.globals.resized || t5.globals.dataChanged || "scatter" !== t5.config.chart.type && "bubble" !== t5.config.chart.type && t5.globals.dataPoints > 1 && o3[n3].classList.add("apexcharts-element-hidden"), t5.globals.delayedElements.push({ el: o3[n3], index: 0 });
            this.helpers.annotationsBackground();
          }
        } }, { key: "drawImageAnnos", value: function() {
          var t5 = this;
          this.w.config.annotations.images.map((function(e4, i4) {
            t5.addImage(e4, i4);
          }));
        } }, { key: "drawTextAnnos", value: function() {
          var t5 = this;
          this.w.config.annotations.texts.map((function(e4, i4) {
            t5.addText(e4, i4);
          }));
        } }, { key: "addXaxisAnnotation", value: function(t5, e4, i4) {
          this.xAxisAnnotations.addXaxisAnnotation(t5, e4, i4);
        } }, { key: "addYaxisAnnotation", value: function(t5, e4, i4) {
          this.yAxisAnnotations.addYaxisAnnotation(t5, e4, i4);
        } }, { key: "addPointAnnotation", value: function(t5, e4, i4) {
          this.pointsAnnotations.addPointAnnotation(t5, e4, i4);
        } }, { key: "addText", value: function(t5, e4) {
          var i4 = t5.x, a4 = t5.y, s4 = t5.text, r4 = t5.textAnchor, o3 = t5.foreColor, n3 = t5.fontSize, l4 = t5.fontFamily, h4 = t5.fontWeight, c4 = t5.cssClass, d3 = t5.backgroundColor, g5 = t5.borderWidth, u4 = t5.strokeDashArray, f4 = t5.borderRadius, p4 = t5.borderColor, x5 = t5.appendTo, b4 = void 0 === x5 ? ".apexcharts-svg" : x5, v4 = t5.paddingLeft, m4 = void 0 === v4 ? 4 : v4, y4 = t5.paddingRight, w5 = void 0 === y4 ? 4 : y4, k4 = t5.paddingBottom, A4 = void 0 === k4 ? 2 : k4, S3 = t5.paddingTop, C4 = void 0 === S3 ? 2 : S3, L4 = this.w, P4 = this.graphics.drawText({ x: i4, y: a4, text: s4, textAnchor: r4 || "start", fontSize: n3 || "12px", fontWeight: h4 || "regular", fontFamily: l4 || L4.config.chart.fontFamily, foreColor: o3 || L4.config.chart.foreColor, cssClass: c4 }), M3 = L4.globals.dom.baseEl.querySelector(b4);
          M3 && M3.appendChild(P4.node);
          var I4 = P4.bbox();
          if (s4) {
            var T5 = this.graphics.drawRect(I4.x - m4, I4.y - C4, I4.width + m4 + w5, I4.height + A4 + C4, f4, d3 || "transparent", 1, g5, p4, u4);
            M3.insertBefore(T5.node, P4.node);
          }
        } }, { key: "addImage", value: function(t5, e4) {
          var i4 = this.w, a4 = t5.path, s4 = t5.x, r4 = void 0 === s4 ? 0 : s4, o3 = t5.y, n3 = void 0 === o3 ? 0 : o3, l4 = t5.width, h4 = void 0 === l4 ? 20 : l4, c4 = t5.height, d3 = void 0 === c4 ? 20 : c4, g5 = t5.appendTo, u4 = void 0 === g5 ? ".apexcharts-svg" : g5, f4 = i4.globals.dom.Paper.image(a4);
          f4.size(h4, d3).move(r4, n3);
          var p4 = i4.globals.dom.baseEl.querySelector(u4);
          return p4 && p4.appendChild(f4.node), f4;
        } }, { key: "addXaxisAnnotationExternal", value: function(t5, e4, i4) {
          return this.addAnnotationExternal({ params: t5, pushToMemory: e4, context: i4, type: "xaxis", contextMethod: i4.addXaxisAnnotation }), i4;
        } }, { key: "addYaxisAnnotationExternal", value: function(t5, e4, i4) {
          return this.addAnnotationExternal({ params: t5, pushToMemory: e4, context: i4, type: "yaxis", contextMethod: i4.addYaxisAnnotation }), i4;
        } }, { key: "addPointAnnotationExternal", value: function(t5, e4, i4) {
          return void 0 === this.invertAxis && (this.invertAxis = i4.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t5, pushToMemory: e4, context: i4, type: "point", contextMethod: i4.addPointAnnotation }), i4;
        } }, { key: "addAnnotationExternal", value: function(t5) {
          var e4 = t5.params, i4 = t5.pushToMemory, a4 = t5.context, s4 = t5.type, r4 = t5.contextMethod, o3 = a4, n3 = o3.w, l4 = n3.globals.dom.baseEl.querySelector(".apexcharts-".concat(s4, "-annotations")), h4 = l4.childNodes.length + 1, c4 = new X2(), d3 = Object.assign({}, "xaxis" === s4 ? c4.xAxisAnnotation : "yaxis" === s4 ? c4.yAxisAnnotation : c4.pointAnnotation), g5 = m3.extend(d3, e4);
          switch (s4) {
            case "xaxis":
              this.addXaxisAnnotation(g5, l4, h4);
              break;
            case "yaxis":
              this.addYaxisAnnotation(g5, l4, h4);
              break;
            case "point":
              this.addPointAnnotation(g5, l4, h4);
          }
          var u4 = n3.globals.dom.baseEl.querySelector(".apexcharts-".concat(s4, "-annotations .apexcharts-").concat(s4, "-annotation-label[rel='").concat(h4, "']")), f4 = this.helpers.addBackgroundToAnno(u4, g5);
          return f4 && l4.insertBefore(f4.node, u4), i4 && n3.globals.memory.methodsToExec.push({ context: o3, id: g5.id ? g5.id : m3.randomId(), method: r4, label: "addAnnotation", params: e4 }), a4;
        } }, { key: "clearAnnotations", value: function(t5) {
          for (var e4 = t5.w, i4 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), a4 = e4.globals.memory.methodsToExec.length - 1; a4 >= 0; a4--) "addText" !== e4.globals.memory.methodsToExec[a4].label && "addAnnotation" !== e4.globals.memory.methodsToExec[a4].label || e4.globals.memory.methodsToExec.splice(a4, 1);
          i4 = m3.listToArray(i4), Array.prototype.forEach.call(i4, (function(t6) {
            for (; t6.firstChild; ) t6.removeChild(t6.firstChild);
          }));
        } }, { key: "removeAnnotation", value: function(t5, e4) {
          var i4 = t5.w, a4 = i4.globals.dom.baseEl.querySelectorAll(".".concat(e4));
          a4 && (i4.globals.memory.methodsToExec.map((function(t6, a5) {
            t6.id === e4 && i4.globals.memory.methodsToExec.splice(a5, 1);
          })), Array.prototype.forEach.call(a4, (function(t6) {
            t6.parentElement.removeChild(t6);
          })));
        } }]), t4;
      })();
      var Y = function(t4) {
        var e4, i4 = t4.isTimeline, a4 = t4.ctx, s4 = t4.seriesIndex, r4 = t4.dataPointIndex, o3 = t4.y1, n3 = t4.y2, l4 = t4.w, h4 = l4.globals.seriesRangeStart[s4][r4], c4 = l4.globals.seriesRangeEnd[s4][r4], d3 = l4.globals.labels[r4], g5 = l4.config.series[s4].name ? l4.config.series[s4].name : "", u4 = l4.globals.ttKeyFormatter, f4 = l4.config.tooltip.y.title.formatter, p4 = { w: l4, seriesIndex: s4, dataPointIndex: r4, start: h4, end: c4 };
        ("function" == typeof f4 && (g5 = f4(g5, p4)), null !== (e4 = l4.config.series[s4].data[r4]) && void 0 !== e4 && e4.x && (d3 = l4.config.series[s4].data[r4].x), i4) || "datetime" === l4.config.xaxis.type && (d3 = new P3(a4).xLabelFormat(l4.globals.ttKeyFormatter, d3, d3, { i: void 0, dateFormatter: new L3(a4).formatDate, w: l4 }));
        "function" == typeof u4 && (d3 = u4(d3, p4)), Number.isFinite(o3) && Number.isFinite(n3) && (h4 = o3, c4 = n3);
        var x5 = "", b4 = "", v4 = l4.globals.colors[s4];
        if (void 0 === l4.config.tooltip.x.formatter) if ("datetime" === l4.config.xaxis.type) {
          var m4 = new L3(a4);
          x5 = m4.formatDate(m4.getDate(h4), l4.config.tooltip.x.format), b4 = m4.formatDate(m4.getDate(c4), l4.config.tooltip.x.format);
        } else x5 = h4, b4 = c4;
        else x5 = l4.config.tooltip.x.formatter(h4), b4 = l4.config.tooltip.x.formatter(c4);
        return { start: h4, end: c4, startVal: x5, endVal: b4, ylabel: d3, color: v4, seriesName: g5 };
      };
      var R = function(t4) {
        var e4 = t4.color, i4 = t4.seriesName, a4 = t4.ylabel, s4 = t4.start, r4 = t4.end, o3 = t4.seriesIndex, n3 = t4.dataPointIndex, l4 = t4.ctx.tooltip.tooltipLabels.getFormatters(o3);
        s4 = l4.yLbFormatter(s4), r4 = l4.yLbFormatter(r4);
        var h4 = l4.yLbFormatter(t4.w.globals.series[o3][n3]), c4 = '<span class="value start-value">\n  '.concat(s4, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r4, "\n  </span>");
        return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e4 + '">' + (i4 || "") + '</span></div><div> <span class="category">' + a4 + ": </span> " + (t4.w.globals.comboCharts ? "rangeArea" === t4.w.config.series[o3].type || "rangeBar" === t4.w.config.series[o3].type ? c4 : "<span>".concat(h4, "</span>") : c4) + " </div></div>";
      };
      var F4 = (function() {
        function t4(e4) {
          i3(this, t4), this.opts = e4;
        }
        return s3(t4, [{ key: "hideYAxis", value: function() {
          this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
        } }, { key: "line", value: function() {
          return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
        } }, { key: "sparkline", value: function(t5) {
          this.hideYAxis();
          return m3.extend(t5, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
        } }, { key: "slope", value: function() {
          return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t5, e4) {
            var i4 = e4.w.config.series[e4.seriesIndex].name;
            return null !== t5 ? i4 + ": " + t5 : "";
          }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: "straight" } };
        } }, { key: "bar", value: function() {
          return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
        } }, { key: "funnel", value: function() {
          return this.hideYAxis(), g4(g4({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
        } }, { key: "candlestick", value: function() {
          var t5 = this;
          return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e4) {
            var i4 = e4.seriesIndex, a4 = e4.dataPointIndex, s4 = e4.w;
            return t5._getBoxTooltip(s4, i4, a4, ["Open", "High", "", "Low", "Close"], "candlestick");
          } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
        } }, { key: "boxPlot", value: function() {
          var t5 = this;
          return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e4) {
            var i4 = e4.seriesIndex, a4 = e4.dataPointIndex, s4 = e4.w;
            return t5._getBoxTooltip(s4, i4, a4, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
          } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
        } }, { key: "rangeBar", value: function() {
          return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t5, e4) {
            e4.ctx;
            var i4 = e4.seriesIndex, a4 = e4.dataPointIndex, s4 = e4.w, r4 = function() {
              var t6 = s4.globals.seriesRangeStart[i4][a4];
              return s4.globals.seriesRangeEnd[i4][a4] - t6;
            };
            return s4.globals.comboCharts ? "rangeBar" === s4.config.series[i4].type || "rangeArea" === s4.config.series[i4].type ? r4() : t5 : r4();
          }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t5) {
            return t5.w.config.plotOptions && t5.w.config.plotOptions.bar && t5.w.config.plotOptions.bar.horizontal ? (function(t6) {
              var e4 = Y(g4(g4({}, t6), {}, { isTimeline: true })), i4 = e4.color, a4 = e4.seriesName, s4 = e4.ylabel, r4 = e4.startVal, o3 = e4.endVal;
              return R(g4(g4({}, t6), {}, { color: i4, seriesName: a4, ylabel: s4, start: r4, end: o3 }));
            })(t5) : (function(t6) {
              var e4 = Y(t6), i4 = e4.color, a4 = e4.seriesName, s4 = e4.ylabel, r4 = e4.start, o3 = e4.end;
              return R(g4(g4({}, t6), {}, { color: i4, seriesName: a4, ylabel: s4, start: r4, end: o3 }));
            })(t5);
          } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
        } }, { key: "dumbbell", value: function(t5) {
          var e4, i4;
          return null !== (e4 = t5.plotOptions.bar) && void 0 !== e4 && e4.barHeight || (t5.plotOptions.bar.barHeight = 2), null !== (i4 = t5.plotOptions.bar) && void 0 !== i4 && i4.columnWidth || (t5.plotOptions.bar.columnWidth = 2), t5;
        } }, { key: "area", value: function() {
          return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
        } }, { key: "rangeArea", value: function() {
          return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t5) {
            return (function(t6) {
              var e4 = Y(t6), i4 = e4.color, a4 = e4.seriesName, s4 = e4.ylabel, r4 = e4.start, o3 = e4.end;
              return R(g4(g4({}, t6), {}, { color: i4, seriesName: a4, ylabel: s4, start: r4, end: o3 }));
            })(t5);
          } } };
        } }, { key: "brush", value: function(t5) {
          return m3.extend(t5, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
        } }, { key: "stacked100", value: function(t5) {
          t5.dataLabels = t5.dataLabels || {}, t5.dataLabels.formatter = t5.dataLabels.formatter || void 0;
          var e4 = t5.dataLabels.formatter;
          return t5.yaxis.forEach((function(e5, i4) {
            t5.yaxis[i4].min = 0, t5.yaxis[i4].max = 100;
          })), "bar" === t5.chart.type && (t5.dataLabels.formatter = e4 || function(t6) {
            return "number" == typeof t6 && t6 ? t6.toFixed(0) + "%" : t6;
          }), t5;
        } }, { key: "stackedBars", value: function() {
          var t5 = this.bar();
          return g4(g4({}, t5), {}, { plotOptions: g4(g4({}, t5.plotOptions), {}, { bar: g4(g4({}, t5.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
        } }, { key: "convertCatToNumeric", value: function(t5) {
          return t5.xaxis.convertedCatToNumeric = true, t5;
        } }, { key: "convertCatToNumericXaxis", value: function(t5, e4, i4) {
          t5.xaxis.type = "numeric", t5.xaxis.labels = t5.xaxis.labels || {}, t5.xaxis.labels.formatter = t5.xaxis.labels.formatter || function(t6) {
            return m3.isNumber(t6) ? Math.floor(t6) : t6;
          };
          var a4 = t5.xaxis.labels.formatter, s4 = t5.xaxis.categories && t5.xaxis.categories.length ? t5.xaxis.categories : t5.labels;
          return i4 && i4.length && (s4 = i4.map((function(t6) {
            return Array.isArray(t6) ? t6 : String(t6);
          }))), s4 && s4.length && (t5.xaxis.labels.formatter = function(t6) {
            return m3.isNumber(t6) ? a4(s4[Math.floor(t6) - 1]) : a4(t6);
          }), t5.xaxis.categories = [], t5.labels = [], t5.xaxis.tickAmount = t5.xaxis.tickAmount || "dataPoints", t5;
        } }, { key: "bubble", value: function() {
          return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
        } }, { key: "scatter", value: function() {
          return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
        } }, { key: "heatmap", value: function() {
          return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
        } }, { key: "treemap", value: function() {
          return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
        } }, { key: "pie", value: function() {
          return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t5) {
            return t5.toFixed(1) + "%";
          }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
        } }, { key: "donut", value: function() {
          return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t5) {
            return t5.toFixed(1) + "%";
          }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
        } }, { key: "polarArea", value: function() {
          return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t5) {
            return t5.toFixed(1) + "%";
          }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
        } }, { key: "radar", value: function() {
          return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(t5) {
            return t5;
          }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
        } }, { key: "radialBar", value: function() {
          return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
        } }, { key: "_getBoxTooltip", value: function(t5, e4, i4, a4, s4) {
          var r4 = t5.globals.seriesCandleO[e4][i4], o3 = t5.globals.seriesCandleH[e4][i4], n3 = t5.globals.seriesCandleM[e4][i4], l4 = t5.globals.seriesCandleL[e4][i4], h4 = t5.globals.seriesCandleC[e4][i4];
          return t5.config.series[e4].type && t5.config.series[e4].type !== s4 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t5.config.series[e4].name ? t5.config.series[e4].name : "series-" + (e4 + 1), ": <strong>").concat(t5.globals.series[e4][i4], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t5.config.chart.type, '">') + "<div>".concat(a4[0], ': <span class="value">') + r4 + "</span></div>" + "<div>".concat(a4[1], ': <span class="value">') + o3 + "</span></div>" + (n3 ? "<div>".concat(a4[2], ': <span class="value">') + n3 + "</span></div>" : "") + "<div>".concat(a4[3], ': <span class="value">') + l4 + "</span></div>" + "<div>".concat(a4[4], ': <span class="value">') + h4 + "</span></div></div>";
        } }]), t4;
      })();
      var D3 = (function() {
        function t4(e4) {
          i3(this, t4), this.opts = e4;
        }
        return s3(t4, [{ key: "init", value: function(t5) {
          var e4 = t5.responsiveOverride, i4 = this.opts, a4 = new X2(), s4 = new F4(i4);
          this.chartType = i4.chart.type, i4 = this.extendYAxis(i4), i4 = this.extendAnnotations(i4);
          var r4 = a4.init(), o3 = {};
          if (i4 && "object" === b3(i4)) {
            var n3, l4, h4, c4, d3, g5, u4, f4, p4, x5, v4 = {};
            v4 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i4.chart.type) ? s4[i4.chart.type]() : s4.line(), null !== (n3 = i4.plotOptions) && void 0 !== n3 && null !== (l4 = n3.bar) && void 0 !== l4 && l4.isFunnel && (v4 = s4.funnel()), i4.chart.stacked && "bar" === i4.chart.type && (v4 = s4.stackedBars()), null !== (h4 = i4.chart.brush) && void 0 !== h4 && h4.enabled && (v4 = s4.brush(v4)), null !== (c4 = i4.plotOptions) && void 0 !== c4 && null !== (d3 = c4.line) && void 0 !== d3 && d3.isSlopeChart && (v4 = s4.slope()), i4.chart.stacked && "100%" === i4.chart.stackType && (i4 = s4.stacked100(i4)), null !== (g5 = i4.plotOptions) && void 0 !== g5 && null !== (u4 = g5.bar) && void 0 !== u4 && u4.isDumbbell && (i4 = s4.dumbbell(i4)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i4), i4.xaxis = i4.xaxis || window.Apex.xaxis || {}, e4 || (i4.xaxis.convertedCatToNumeric = false), (null !== (f4 = (i4 = this.checkForCatToNumericXAxis(this.chartType, v4, i4)).chart.sparkline) && void 0 !== f4 && f4.enabled || null !== (p4 = window.Apex.chart) && void 0 !== p4 && null !== (x5 = p4.sparkline) && void 0 !== x5 && x5.enabled) && (v4 = s4.sparkline(v4)), o3 = m3.extend(r4, v4);
          }
          var y4 = m3.extend(o3, window.Apex);
          return r4 = m3.extend(y4, i4), r4 = this.handleUserInputErrors(r4);
        } }, { key: "checkForCatToNumericXAxis", value: function(t5, e4, i4) {
          var a4, s4, r4 = new F4(i4), o3 = ("bar" === t5 || "boxPlot" === t5) && (null === (a4 = i4.plotOptions) || void 0 === a4 || null === (s4 = a4.bar) || void 0 === s4 ? void 0 : s4.horizontal), n3 = "pie" === t5 || "polarArea" === t5 || "donut" === t5 || "radar" === t5 || "radialBar" === t5 || "heatmap" === t5, l4 = "datetime" !== i4.xaxis.type && "numeric" !== i4.xaxis.type, h4 = i4.xaxis.tickPlacement ? i4.xaxis.tickPlacement : e4.xaxis && e4.xaxis.tickPlacement;
          return o3 || n3 || !l4 || "between" === h4 || (i4 = r4.convertCatToNumeric(i4)), i4;
        } }, { key: "extendYAxis", value: function(t5, e4) {
          var i4 = new X2();
          (void 0 === t5.yaxis || !t5.yaxis || Array.isArray(t5.yaxis) && 0 === t5.yaxis.length) && (t5.yaxis = {}), t5.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t5.yaxis = m3.extend(t5.yaxis, window.Apex.yaxis)), t5.yaxis.constructor !== Array ? t5.yaxis = [m3.extend(i4.yAxis, t5.yaxis)] : t5.yaxis = m3.extendArray(t5.yaxis, i4.yAxis);
          var a4 = false;
          t5.yaxis.forEach((function(t6) {
            t6.logarithmic && (a4 = true);
          }));
          var s4 = t5.series;
          return e4 && !s4 && (s4 = e4.config.series), a4 && s4.length !== t5.yaxis.length && s4.length && (t5.yaxis = s4.map((function(e5, a5) {
            if (e5.name || (s4[a5].name = "series-".concat(a5 + 1)), t5.yaxis[a5]) return t5.yaxis[a5].seriesName = s4[a5].name, t5.yaxis[a5];
            var r4 = m3.extend(i4.yAxis, t5.yaxis[0]);
            return r4.show = false, r4;
          }))), a4 && s4.length > 1 && s4.length !== t5.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t5;
        } }, { key: "extendAnnotations", value: function(t5) {
          return void 0 === t5.annotations && (t5.annotations = {}, t5.annotations.yaxis = [], t5.annotations.xaxis = [], t5.annotations.points = []), t5 = this.extendYAxisAnnotations(t5), t5 = this.extendXAxisAnnotations(t5), t5 = this.extendPointAnnotations(t5);
        } }, { key: "extendYAxisAnnotations", value: function(t5) {
          var e4 = new X2();
          return t5.annotations.yaxis = m3.extendArray(void 0 !== t5.annotations.yaxis ? t5.annotations.yaxis : [], e4.yAxisAnnotation), t5;
        } }, { key: "extendXAxisAnnotations", value: function(t5) {
          var e4 = new X2();
          return t5.annotations.xaxis = m3.extendArray(void 0 !== t5.annotations.xaxis ? t5.annotations.xaxis : [], e4.xAxisAnnotation), t5;
        } }, { key: "extendPointAnnotations", value: function(t5) {
          var e4 = new X2();
          return t5.annotations.points = m3.extendArray(void 0 !== t5.annotations.points ? t5.annotations.points : [], e4.pointAnnotation), t5;
        } }, { key: "checkForDarkTheme", value: function(t5) {
          t5.theme && "dark" === t5.theme.mode && (t5.tooltip || (t5.tooltip = {}), "light" !== t5.tooltip.theme && (t5.tooltip.theme = "dark"), t5.chart.foreColor || (t5.chart.foreColor = "#f6f7f8"), t5.theme.palette || (t5.theme.palette = "palette4"));
        } }, { key: "handleUserInputErrors", value: function(t5) {
          var e4 = t5;
          if (e4.tooltip.shared && e4.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
          if ("bar" === e4.chart.type && e4.plotOptions.bar.horizontal) {
            if (e4.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
            e4.yaxis[0].reversed && (e4.yaxis[0].opposite = true), e4.xaxis.tooltip.enabled = false, e4.yaxis[0].tooltip.enabled = false, e4.chart.zoom.enabled = false;
          }
          return "bar" !== e4.chart.type && "rangeBar" !== e4.chart.type || e4.tooltip.shared && "barWidth" === e4.xaxis.crosshairs.width && e4.series.length > 1 && (e4.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e4.chart.type && "boxPlot" !== e4.chart.type || e4.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e4.chart.type, " chart is not supported.")), e4.yaxis[0].reversed = false), e4;
        } }]), t4;
      })();
      var H3 = (function() {
        function t4() {
          i3(this, t4);
        }
        return s3(t4, [{ key: "initGlobalVars", value: function(t5) {
          t5.series = [], t5.seriesCandleO = [], t5.seriesCandleH = [], t5.seriesCandleM = [], t5.seriesCandleL = [], t5.seriesCandleC = [], t5.seriesRangeStart = [], t5.seriesRangeEnd = [], t5.seriesRange = [], t5.seriesPercent = [], t5.seriesGoals = [], t5.seriesX = [], t5.seriesZ = [], t5.seriesNames = [], t5.seriesTotals = [], t5.seriesLog = [], t5.seriesColors = [], t5.stackedSeriesTotals = [], t5.seriesXvalues = [], t5.seriesYvalues = [], t5.labels = [], t5.hasXaxisGroups = false, t5.groups = [], t5.barGroups = [], t5.lineGroups = [], t5.areaGroups = [], t5.hasSeriesGroups = false, t5.seriesGroups = [], t5.categoryLabels = [], t5.timescaleLabels = [], t5.noLabelsProvided = false, t5.resizeTimer = null, t5.selectionResizeTimer = null, t5.lastWheelExecution = 0, t5.delayedElements = [], t5.pointsArray = [], t5.dataLabelsRects = [], t5.isXNumeric = false, t5.skipLastTimelinelabel = false, t5.skipFirstTimelinelabel = false, t5.isDataXYZ = false, t5.isMultiLineX = false, t5.isMultipleYAxis = false, t5.maxY = -Number.MAX_VALUE, t5.minY = Number.MIN_VALUE, t5.minYArr = [], t5.maxYArr = [], t5.maxX = -Number.MAX_VALUE, t5.minX = Number.MAX_VALUE, t5.initialMaxX = -Number.MAX_VALUE, t5.initialMinX = Number.MAX_VALUE, t5.maxDate = 0, t5.minDate = Number.MAX_VALUE, t5.minZ = Number.MAX_VALUE, t5.maxZ = -Number.MAX_VALUE, t5.minXDiff = Number.MAX_VALUE, t5.yAxisScale = [], t5.xAxisScale = null, t5.xAxisTicksPositions = [], t5.yLabelsCoords = [], t5.yTitleCoords = [], t5.barPadForNumericAxis = 0, t5.padHorizontal = 0, t5.xRange = 0, t5.yRange = [], t5.zRange = 0, t5.dataPoints = 0, t5.xTickAmount = 0, t5.multiAxisTickAmount = 0;
        } }, { key: "globalVars", value: function(t5) {
          return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t5.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t5.chart.toolbar.autoSelected && t5.chart.toolbar.tools.zoom && t5.chart.zoom.enabled, panEnabled: "pan" === t5.chart.toolbar.autoSelected && t5.chart.toolbar.tools.pan, selectionEnabled: "selection" === t5.chart.toolbar.autoSelected && t5.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t5.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
        } }, { key: "init", value: function(t5) {
          var e4 = this.globalVars(t5);
          return this.initGlobalVars(e4), e4.initialConfig = m3.extend({}, t5), e4.initialSeries = m3.clone(t5.series), e4.lastXAxis = m3.clone(e4.initialConfig.xaxis), e4.lastYAxis = m3.clone(e4.initialConfig.yaxis), e4;
        } }]), t4;
      })();
      var O2 = (function() {
        function t4(e4) {
          i3(this, t4), this.opts = e4;
        }
        return s3(t4, [{ key: "init", value: function() {
          var t5 = new D3(this.opts).init({ responsiveOverride: false });
          return { config: t5, globals: new H3().init(t5) };
        } }]), t4;
      })();
      var N3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
        }
        return s3(t4, [{ key: "clippedImgArea", value: function(t5) {
          var e4 = this.w, i4 = e4.config, a4 = parseInt(e4.globals.gridWidth, 10), s4 = parseInt(e4.globals.gridHeight, 10), r4 = a4 > s4 ? a4 : s4, o3 = t5.image, n3 = 0, l4 = 0;
          void 0 === t5.width && void 0 === t5.height ? void 0 !== i4.fill.image.width && void 0 !== i4.fill.image.height ? (n3 = i4.fill.image.width + 1, l4 = i4.fill.image.height) : (n3 = r4 + 1, l4 = r4) : (n3 = t5.width, l4 = t5.height);
          var h4 = document.createElementNS(e4.globals.SVGNS, "pattern");
          k3.setAttrs(h4, { id: t5.patternID, patternUnits: t5.patternUnits ? t5.patternUnits : "userSpaceOnUse", width: n3 + "px", height: l4 + "px" });
          var c4 = document.createElementNS(e4.globals.SVGNS, "image");
          h4.appendChild(c4), c4.setAttributeNS(window.SVG.xlink, "href", o3), k3.setAttrs(c4, { x: 0, y: 0, preserveAspectRatio: "none", width: n3 + "px", height: l4 + "px" }), c4.style.opacity = t5.opacity, e4.globals.dom.elDefs.node.appendChild(h4);
        } }, { key: "getSeriesIndex", value: function(t5) {
          var e4 = this.w, i4 = e4.config.chart.type;
          return ("bar" === i4 || "rangeBar" === i4) && e4.config.plotOptions.bar.distributed || "heatmap" === i4 || "treemap" === i4 ? this.seriesIndex = t5.seriesNumber : this.seriesIndex = t5.seriesNumber % e4.globals.series.length, this.seriesIndex;
        } }, { key: "fillPath", value: function(t5) {
          var e4 = this.w;
          this.opts = t5;
          var i4, a4, s4, r4 = this.w.config;
          this.seriesIndex = this.getSeriesIndex(t5);
          var o3 = this.getFillColors()[this.seriesIndex];
          void 0 !== e4.globals.seriesColors[this.seriesIndex] && (o3 = e4.globals.seriesColors[this.seriesIndex]), "function" == typeof o3 && (o3 = o3({ seriesIndex: this.seriesIndex, dataPointIndex: t5.dataPointIndex, value: t5.value, w: e4 }));
          var n3 = t5.fillType ? t5.fillType : this.getFillType(this.seriesIndex), l4 = Array.isArray(r4.fill.opacity) ? r4.fill.opacity[this.seriesIndex] : r4.fill.opacity;
          t5.color && (o3 = t5.color), o3 || (o3 = "#fff", console.warn("undefined color - ApexCharts"));
          var h4 = o3;
          if (-1 === o3.indexOf("rgb") ? o3.length < 9 && (h4 = m3.hexToRgba(o3, l4)) : o3.indexOf("rgba") > -1 && (l4 = m3.getOpacityFromRGBA(o3)), t5.opacity && (l4 = t5.opacity), "pattern" === n3 && (a4 = this.handlePatternFill({ fillConfig: t5.fillConfig, patternFill: a4, fillColor: o3, fillOpacity: l4, defaultColor: h4 })), "gradient" === n3 && (s4 = this.handleGradientFill({ fillConfig: t5.fillConfig, fillColor: o3, fillOpacity: l4, i: this.seriesIndex })), "image" === n3) {
            var c4 = r4.fill.image.src, d3 = t5.patternID ? t5.patternID : "", g5 = "pattern".concat(e4.globals.cuid).concat(t5.seriesNumber + 1).concat(d3);
            -1 === this.patternIDs.indexOf(g5) && (this.clippedImgArea({ opacity: l4, image: Array.isArray(c4) ? t5.seriesNumber < c4.length ? c4[t5.seriesNumber] : c4[0] : c4, width: t5.width ? t5.width : void 0, height: t5.height ? t5.height : void 0, patternUnits: t5.patternUnits, patternID: g5 }), this.patternIDs.push(g5)), i4 = "url(#".concat(g5, ")");
          } else i4 = "gradient" === n3 ? s4 : "pattern" === n3 ? a4 : h4;
          return t5.solid && (i4 = h4), i4;
        } }, { key: "getFillType", value: function(t5) {
          var e4 = this.w;
          return Array.isArray(e4.config.fill.type) ? e4.config.fill.type[t5] : e4.config.fill.type;
        } }, { key: "getFillColors", value: function() {
          var t5 = this.w, e4 = t5.config, i4 = this.opts, a4 = [];
          return t5.globals.comboCharts ? "line" === t5.config.series[this.seriesIndex].type ? Array.isArray(t5.globals.stroke.colors) ? a4 = t5.globals.stroke.colors : a4.push(t5.globals.stroke.colors) : Array.isArray(t5.globals.fill.colors) ? a4 = t5.globals.fill.colors : a4.push(t5.globals.fill.colors) : "line" === e4.chart.type ? Array.isArray(t5.globals.stroke.colors) ? a4 = t5.globals.stroke.colors : a4.push(t5.globals.stroke.colors) : Array.isArray(t5.globals.fill.colors) ? a4 = t5.globals.fill.colors : a4.push(t5.globals.fill.colors), void 0 !== i4.fillColors && (a4 = [], Array.isArray(i4.fillColors) ? a4 = i4.fillColors.slice() : a4.push(i4.fillColors)), a4;
        } }, { key: "handlePatternFill", value: function(t5) {
          var e4 = t5.fillConfig, i4 = t5.patternFill, a4 = t5.fillColor, s4 = t5.fillOpacity, r4 = t5.defaultColor, o3 = this.w.config.fill;
          e4 && (o3 = e4);
          var n3 = this.opts, l4 = new k3(this.ctx), h4 = Array.isArray(o3.pattern.strokeWidth) ? o3.pattern.strokeWidth[this.seriesIndex] : o3.pattern.strokeWidth, c4 = a4;
          Array.isArray(o3.pattern.style) ? i4 = void 0 !== o3.pattern.style[n3.seriesNumber] ? l4.drawPattern(o3.pattern.style[n3.seriesNumber], o3.pattern.width, o3.pattern.height, c4, h4, s4) : r4 : i4 = l4.drawPattern(o3.pattern.style, o3.pattern.width, o3.pattern.height, c4, h4, s4);
          return i4;
        } }, { key: "handleGradientFill", value: function(t5) {
          var e4 = t5.fillColor, i4 = t5.fillOpacity, a4 = t5.fillConfig, s4 = t5.i, r4 = this.w.config.fill;
          a4 && (r4 = g4(g4({}, r4), a4));
          var o3, n3 = this.opts, l4 = new k3(this.ctx), h4 = new m3(), c4 = r4.gradient.type, d3 = e4, u4 = void 0 === r4.gradient.opacityFrom ? i4 : Array.isArray(r4.gradient.opacityFrom) ? r4.gradient.opacityFrom[s4] : r4.gradient.opacityFrom;
          d3.indexOf("rgba") > -1 && (u4 = m3.getOpacityFromRGBA(d3));
          var f4 = void 0 === r4.gradient.opacityTo ? i4 : Array.isArray(r4.gradient.opacityTo) ? r4.gradient.opacityTo[s4] : r4.gradient.opacityTo;
          if (void 0 === r4.gradient.gradientToColors || 0 === r4.gradient.gradientToColors.length) o3 = "dark" === r4.gradient.shade ? h4.shadeColor(-1 * parseFloat(r4.gradient.shadeIntensity), e4.indexOf("rgb") > -1 ? m3.rgb2hex(e4) : e4) : h4.shadeColor(parseFloat(r4.gradient.shadeIntensity), e4.indexOf("rgb") > -1 ? m3.rgb2hex(e4) : e4);
          else if (r4.gradient.gradientToColors[n3.seriesNumber]) {
            var p4 = r4.gradient.gradientToColors[n3.seriesNumber];
            o3 = p4, p4.indexOf("rgba") > -1 && (f4 = m3.getOpacityFromRGBA(p4));
          } else o3 = e4;
          if (r4.gradient.gradientFrom && (d3 = r4.gradient.gradientFrom), r4.gradient.gradientTo && (o3 = r4.gradient.gradientTo), r4.gradient.inverseColors) {
            var x5 = d3;
            d3 = o3, o3 = x5;
          }
          return d3.indexOf("rgb") > -1 && (d3 = m3.rgb2hex(d3)), o3.indexOf("rgb") > -1 && (o3 = m3.rgb2hex(o3)), l4.drawGradient(c4, d3, o3, u4, f4, n3.size, r4.gradient.stops, r4.gradient.colorStops, s4);
        } }]), t4;
      })();
      var W2 = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "setGlobalMarkerSize", value: function() {
          var t5 = this.w;
          if (t5.globals.markers.size = Array.isArray(t5.config.markers.size) ? t5.config.markers.size : [t5.config.markers.size], t5.globals.markers.size.length > 0) {
            if (t5.globals.markers.size.length < t5.globals.series.length + 1) for (var e4 = 0; e4 <= t5.globals.series.length; e4++) void 0 === t5.globals.markers.size[e4] && t5.globals.markers.size.push(t5.globals.markers.size[0]);
          } else t5.globals.markers.size = t5.config.series.map((function(e5) {
            return t5.config.markers.size;
          }));
        } }, { key: "plotChartMarkers", value: function(t5, e4, i4, a4) {
          var s4, r4 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = this.w, n3 = e4, l4 = t5, h4 = null, c4 = new k3(this.ctx), d3 = o3.config.markers.discrete && o3.config.markers.discrete.length;
          if ((o3.globals.markers.size[e4] > 0 || r4 || d3) && (h4 = c4.group({ class: r4 || d3 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(o3.globals.cuid, ")")), Array.isArray(l4.x)) for (var g5 = 0; g5 < l4.x.length; g5++) {
            var u4 = i4;
            1 === i4 && 0 === g5 && (u4 = 0), 1 === i4 && 1 === g5 && (u4 = 1);
            var f4 = "apexcharts-marker";
            if ("line" !== o3.config.chart.type && "area" !== o3.config.chart.type || o3.globals.comboCharts || o3.config.tooltip.intersect || (f4 += " no-pointer-events"), (Array.isArray(o3.config.markers.size) ? o3.globals.markers.size[e4] > 0 : o3.config.markers.size > 0) || r4 || d3) {
              m3.isNumber(l4.y[g5]) ? f4 += " w".concat(m3.randomId()) : f4 = "apexcharts-nullpoint";
              var p4 = this.getMarkerConfig({ cssClass: f4, seriesIndex: e4, dataPointIndex: u4 });
              o3.config.series[n3].data[u4] && (o3.config.series[n3].data[u4].fillColor && (p4.pointFillColor = o3.config.series[n3].data[u4].fillColor), o3.config.series[n3].data[u4].strokeColor && (p4.pointStrokeColor = o3.config.series[n3].data[u4].strokeColor)), void 0 !== a4 && (p4.pSize = a4), (l4.x[g5] < -o3.globals.markers.largestSize || l4.x[g5] > o3.globals.gridWidth + o3.globals.markers.largestSize || l4.y[g5] < -o3.globals.markers.largestSize || l4.y[g5] > o3.globals.gridHeight + o3.globals.markers.largestSize) && (p4.pSize = 0), (s4 = c4.drawMarker(l4.x[g5], l4.y[g5], p4)).attr("rel", u4), s4.attr("j", u4), s4.attr("index", e4), s4.node.setAttribute("default-marker-size", p4.pSize), new w4(this.ctx).setSelectionFilter(s4, e4, u4), this.addEvents(s4), h4 && h4.add(s4);
            } else void 0 === o3.globals.pointsArray[e4] && (o3.globals.pointsArray[e4] = []), o3.globals.pointsArray[e4].push([l4.x[g5], l4.y[g5]]);
          }
          return h4;
        } }, { key: "getMarkerConfig", value: function(t5) {
          var e4 = t5.cssClass, i4 = t5.seriesIndex, a4 = t5.dataPointIndex, s4 = void 0 === a4 ? null : a4, r4 = t5.radius, o3 = void 0 === r4 ? null : r4, n3 = t5.size, l4 = void 0 === n3 ? null : n3, h4 = t5.strokeWidth, c4 = void 0 === h4 ? null : h4, d3 = this.w, g5 = this.getMarkerStyle(i4), u4 = null === l4 ? d3.globals.markers.size[i4] : l4, f4 = d3.config.markers;
          return null !== s4 && f4.discrete.length && f4.discrete.map((function(t6) {
            t6.seriesIndex === i4 && t6.dataPointIndex === s4 && (g5.pointStrokeColor = t6.strokeColor, g5.pointFillColor = t6.fillColor, u4 = t6.size, g5.pointShape = t6.shape);
          })), { pSize: null === o3 ? u4 : o3, pRadius: null !== o3 ? o3 : f4.radius, pointStrokeWidth: null !== c4 ? c4 : Array.isArray(f4.strokeWidth) ? f4.strokeWidth[i4] : f4.strokeWidth, pointStrokeColor: g5.pointStrokeColor, pointFillColor: g5.pointFillColor, shape: g5.pointShape || (Array.isArray(f4.shape) ? f4.shape[i4] : f4.shape), class: e4, pointStrokeOpacity: Array.isArray(f4.strokeOpacity) ? f4.strokeOpacity[i4] : f4.strokeOpacity, pointStrokeDashArray: Array.isArray(f4.strokeDashArray) ? f4.strokeDashArray[i4] : f4.strokeDashArray, pointFillOpacity: Array.isArray(f4.fillOpacity) ? f4.fillOpacity[i4] : f4.fillOpacity, seriesIndex: i4 };
        } }, { key: "addEvents", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx);
          t5.node.addEventListener("mouseenter", i4.pathMouseEnter.bind(this.ctx, t5)), t5.node.addEventListener("mouseleave", i4.pathMouseLeave.bind(this.ctx, t5)), t5.node.addEventListener("mousedown", i4.pathMouseDown.bind(this.ctx, t5)), t5.node.addEventListener("click", e4.config.markers.onClick), t5.node.addEventListener("dblclick", e4.config.markers.onDblClick), t5.node.addEventListener("touchstart", i4.pathMouseDown.bind(this.ctx, t5), { passive: true });
        } }, { key: "getMarkerStyle", value: function(t5) {
          var e4 = this.w, i4 = e4.globals.markers.colors, a4 = e4.config.markers.strokeColor || e4.config.markers.strokeColors;
          return { pointStrokeColor: Array.isArray(a4) ? a4[t5] : a4, pointFillColor: Array.isArray(i4) ? i4[t5] : i4 };
        } }]), t4;
      })();
      var B3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.initialAnim = this.w.config.chart.animations.enabled;
        }
        return s3(t4, [{ key: "draw", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = new k3(this.ctx), r4 = i4.realIndex, o3 = i4.pointsPos, n3 = i4.zRatio, l4 = i4.elParent, h4 = s4.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a4.config.chart.type) });
          if (h4.attr("clip-path", "url(#gridRectMarkerMask".concat(a4.globals.cuid, ")")), Array.isArray(o3.x)) for (var c4 = 0; c4 < o3.x.length; c4++) {
            var d3 = e4 + 1, g5 = true;
            0 === e4 && 0 === c4 && (d3 = 0), 0 === e4 && 1 === c4 && (d3 = 1);
            var u4 = a4.globals.markers.size[r4];
            if (n3 !== 1 / 0) {
              var f4 = a4.config.plotOptions.bubble;
              u4 = a4.globals.seriesZ[r4][d3], f4.zScaling && (u4 /= n3), f4.minBubbleRadius && u4 < f4.minBubbleRadius && (u4 = f4.minBubbleRadius), f4.maxBubbleRadius && u4 > f4.maxBubbleRadius && (u4 = f4.maxBubbleRadius);
            }
            var p4 = o3.x[c4], x5 = o3.y[c4];
            if (u4 = u4 || 0, null !== x5 && void 0 !== a4.globals.series[r4][d3] || (g5 = false), g5) {
              var b4 = this.drawPoint(p4, x5, u4, r4, d3, e4);
              h4.add(b4);
            }
            l4.add(h4);
          }
        } }, { key: "drawPoint", value: function(t5, e4, i4, a4, s4, r4) {
          var o3 = this.w, n3 = a4, l4 = new y3(this.ctx), h4 = new w4(this.ctx), c4 = new N3(this.ctx), d3 = new W2(this.ctx), g5 = new k3(this.ctx), u4 = d3.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: s4, radius: "bubble" === o3.config.chart.type || o3.globals.comboCharts && o3.config.series[a4] && "bubble" === o3.config.series[a4].type ? i4 : null }), f4 = c4.fillPath({ seriesNumber: a4, dataPointIndex: s4, color: u4.pointFillColor, patternUnits: "objectBoundingBox", value: o3.globals.series[a4][r4] }), p4 = g5.drawMarker(t5, e4, u4);
          if (o3.config.series[n3].data[s4] && o3.config.series[n3].data[s4].fillColor && (f4 = o3.config.series[n3].data[s4].fillColor), p4.attr({ fill: f4 }), o3.config.chart.dropShadow.enabled) {
            var x5 = o3.config.chart.dropShadow;
            h4.dropShadow(p4, x5, a4);
          }
          if (!this.initialAnim || o3.globals.dataChanged || o3.globals.resized) o3.globals.animationEnded = true;
          else {
            var b4 = o3.config.chart.animations.speed;
            l4.animateMarker(p4, b4, o3.globals.easing, (function() {
              window.setTimeout((function() {
                l4.animationCompleted(p4);
              }), 100);
            }));
          }
          return p4.attr({ rel: s4, j: s4, index: a4, "default-marker-size": u4.pSize }), h4.setSelectionFilter(p4, a4, s4), d3.addEvents(p4), p4.node.classList.add("apexcharts-marker"), p4;
        } }, { key: "centerTextInBubble", value: function(t5) {
          var e4 = this.w;
          return { y: t5 += parseInt(e4.config.dataLabels.style.fontSize, 10) / 4 };
        } }]), t4;
      })();
      var G3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "dataLabelsCorrection", value: function(t5, e4, i4, a4, s4, r4, o3) {
          var n3 = this.w, l4 = false, h4 = new k3(this.ctx).getTextRects(i4, o3), c4 = h4.width, d3 = h4.height;
          e4 < 0 && (e4 = 0), e4 > n3.globals.gridHeight + d3 && (e4 = n3.globals.gridHeight + d3 / 2), void 0 === n3.globals.dataLabelsRects[a4] && (n3.globals.dataLabelsRects[a4] = []), n3.globals.dataLabelsRects[a4].push({ x: t5, y: e4, width: c4, height: d3 });
          var g5 = n3.globals.dataLabelsRects[a4].length - 2, u4 = void 0 !== n3.globals.lastDrawnDataLabelsIndexes[a4] ? n3.globals.lastDrawnDataLabelsIndexes[a4][n3.globals.lastDrawnDataLabelsIndexes[a4].length - 1] : 0;
          if (void 0 !== n3.globals.dataLabelsRects[a4][g5]) {
            var f4 = n3.globals.dataLabelsRects[a4][u4];
            (t5 > f4.x + f4.width || e4 > f4.y + f4.height || e4 + d3 < f4.y || t5 + c4 < f4.x) && (l4 = true);
          }
          return (0 === s4 || r4) && (l4 = true), { x: t5, y: e4, textRects: h4, drawnextLabel: l4 };
        } }, { key: "drawDataLabel", value: function(t5) {
          var e4 = this, i4 = t5.type, a4 = t5.pos, s4 = t5.i, r4 = t5.j, o3 = t5.isRangeStart, n3 = t5.strokeWidth, l4 = void 0 === n3 ? 2 : n3, h4 = this.w, c4 = new k3(this.ctx), d3 = h4.config.dataLabels, g5 = 0, u4 = 0, f4 = r4, p4 = null;
          if (-1 !== h4.globals.collapsedSeriesIndices.indexOf(s4) || !d3.enabled || !Array.isArray(a4.x)) return p4;
          p4 = c4.group({ class: "apexcharts-data-labels" });
          for (var x5 = 0; x5 < a4.x.length; x5++) if (g5 = a4.x[x5] + d3.offsetX, u4 = a4.y[x5] + d3.offsetY + l4, !isNaN(g5)) {
            1 === r4 && 0 === x5 && (f4 = 0), 1 === r4 && 1 === x5 && (f4 = 1);
            var b4 = h4.globals.series[s4][f4];
            "rangeArea" === i4 && (b4 = o3 ? h4.globals.seriesRangeStart[s4][f4] : h4.globals.seriesRangeEnd[s4][f4]);
            var v4 = "", m4 = function(t6) {
              return h4.config.dataLabels.formatter(t6, { ctx: e4.ctx, seriesIndex: s4, dataPointIndex: f4, w: h4 });
            };
            if ("bubble" === h4.config.chart.type) v4 = m4(b4 = h4.globals.seriesZ[s4][f4]), u4 = a4.y[x5], u4 = new B3(this.ctx).centerTextInBubble(u4, s4, f4).y;
            else void 0 !== b4 && (v4 = m4(b4));
            var y4 = h4.config.dataLabels.textAnchor;
            h4.globals.isSlopeChart && (y4 = 0 === f4 ? "end" : f4 === h4.config.series[s4].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: g5, y: u4, text: v4, i: s4, j: f4, parent: p4, offsetCorrection: true, dataLabelsConfig: h4.config.dataLabels, textAnchor: y4 });
          }
          return p4;
        } }, { key: "plotDataLabelsText", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a4 = t5.x, s4 = t5.y, r4 = t5.i, o3 = t5.j, n3 = t5.text, l4 = t5.textAnchor, h4 = t5.fontSize, c4 = t5.parent, d3 = t5.dataLabelsConfig, g5 = t5.color, u4 = t5.alwaysDrawDataLabel, f4 = t5.offsetCorrection, p4 = t5.className, x5 = null;
          if (Array.isArray(e4.config.dataLabels.enabledOnSeries) && e4.config.dataLabels.enabledOnSeries.indexOf(r4) < 0) return x5;
          var b4 = { x: a4, y: s4, drawnextLabel: true, textRects: null };
          f4 && (b4 = this.dataLabelsCorrection(a4, s4, n3, r4, o3, u4, parseInt(d3.style.fontSize, 10))), e4.globals.zoomed || (a4 = b4.x, s4 = b4.y), b4.textRects && (a4 < -20 - b4.textRects.width || a4 > e4.globals.gridWidth + b4.textRects.width + 30) && (n3 = "");
          var v4 = e4.globals.dataLabels.style.colors[r4];
          (("bar" === e4.config.chart.type || "rangeBar" === e4.config.chart.type) && e4.config.plotOptions.bar.distributed || e4.config.dataLabels.distributed) && (v4 = e4.globals.dataLabels.style.colors[o3]), "function" == typeof v4 && (v4 = v4({ series: e4.globals.series, seriesIndex: r4, dataPointIndex: o3, w: e4 })), g5 && (v4 = g5);
          var m4 = d3.offsetX, y4 = d3.offsetY;
          if ("bar" !== e4.config.chart.type && "rangeBar" !== e4.config.chart.type || (m4 = 0, y4 = 0), e4.globals.isSlopeChart && (0 !== o3 && (m4 = -2 * d3.offsetX + 5), 0 !== o3 && o3 !== e4.config.series[r4].data.length - 1 && (m4 = 0)), b4.drawnextLabel) {
            if ((x5 = i4.drawText({ width: 100, height: parseInt(d3.style.fontSize, 10), x: a4 + m4, y: s4 + y4, foreColor: v4, textAnchor: l4 || d3.textAnchor, text: n3, fontSize: h4 || d3.style.fontSize, fontFamily: d3.style.fontFamily, fontWeight: d3.style.fontWeight || "normal" })).attr({ class: p4 || "apexcharts-datalabel", cx: a4, cy: s4 }), d3.dropShadow.enabled) {
              var A4 = d3.dropShadow;
              new w4(this.ctx).dropShadow(x5, A4);
            }
            c4.add(x5), void 0 === e4.globals.lastDrawnDataLabelsIndexes[r4] && (e4.globals.lastDrawnDataLabelsIndexes[r4] = []), e4.globals.lastDrawnDataLabelsIndexes[r4].push(o3);
          }
          return x5;
        } }, { key: "addBackgroundToDataLabel", value: function(t5, e4) {
          var i4 = this.w, a4 = i4.config.dataLabels.background, s4 = a4.padding, r4 = a4.padding / 2, o3 = e4.width, n3 = e4.height, l4 = new k3(this.ctx).drawRect(e4.x - s4, e4.y - r4 / 2, o3 + 2 * s4, n3 + r4, a4.borderRadius, "transparent" !== i4.config.chart.background && i4.config.chart.background ? i4.config.chart.background : "#fff", a4.opacity, a4.borderWidth, a4.borderColor);
          a4.dropShadow.enabled && new w4(this.ctx).dropShadow(l4, a4.dropShadow);
          return l4;
        } }, { key: "dataLabelsBackground", value: function() {
          var t5 = this.w;
          if ("bubble" !== t5.config.chart.type) for (var e4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i4 = 0; i4 < e4.length; i4++) {
            var a4 = e4[i4], s4 = a4.getBBox(), r4 = null;
            if (s4.width && s4.height && (r4 = this.addBackgroundToDataLabel(a4, s4)), r4) {
              a4.parentNode.insertBefore(r4.node, a4);
              var o3 = a4.getAttribute("fill");
              t5.config.chart.animations.enabled && !t5.globals.resized && !t5.globals.dataChanged ? r4.animate().attr({ fill: o3 }) : r4.attr({ fill: o3 }), a4.setAttribute("fill", t5.config.dataLabels.background.foreColor);
            }
          }
        } }, { key: "bringForward", value: function() {
          for (var t5 = this.w, e4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i4 = t5.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a4 = 0; a4 < e4.length; a4++) i4 && i4.insertBefore(e4[a4], i4.nextSibling);
        } }]), t4;
      })();
      var V3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.legendInactiveClass = "legend-mouseover-inactive";
        }
        return s3(t4, [{ key: "getAllSeriesEls", value: function() {
          return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
        } }, { key: "getSeriesByName", value: function(t5) {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(m3.escapeString(t5), "']"));
        } }, { key: "isSeriesHidden", value: function(t5) {
          var e4 = this.getSeriesByName(t5), i4 = parseInt(e4.getAttribute("data:realIndex"), 10);
          return { isHidden: e4.classList.contains("apexcharts-series-collapsed"), realIndex: i4 };
        } }, { key: "addCollapsedClassToSeries", value: function(t5, e4) {
          var i4 = this.w;
          function a4(i5) {
            for (var a5 = 0; a5 < i5.length; a5++) i5[a5].index === e4 && t5.node.classList.add("apexcharts-series-collapsed");
          }
          a4(i4.globals.collapsedSeries), a4(i4.globals.ancillaryCollapsedSeries);
        } }, { key: "toggleSeries", value: function(t5) {
          var e4 = this.isSeriesHidden(t5);
          return this.ctx.legend.legendHelpers.toggleDataSeries(e4.realIndex, e4.isHidden), e4.isHidden;
        } }, { key: "showSeries", value: function(t5) {
          var e4 = this.isSeriesHidden(t5);
          e4.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e4.realIndex, true);
        } }, { key: "hideSeries", value: function(t5) {
          var e4 = this.isSeriesHidden(t5);
          e4.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e4.realIndex, false);
        } }, { key: "resetSeries", value: function() {
          var t5 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a4 = this.w, s4 = m3.clone(a4.globals.initialSeries);
          a4.globals.previousPaths = [], i4 ? (a4.globals.collapsedSeries = [], a4.globals.ancillaryCollapsedSeries = [], a4.globals.collapsedSeriesIndices = [], a4.globals.ancillaryCollapsedSeriesIndices = []) : s4 = this.emptyCollapsedSeries(s4), a4.config.series = s4, t5 && (e4 && (a4.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s4, a4.config.chart.animations.dynamicAnimation.enabled));
        } }, { key: "emptyCollapsedSeries", value: function(t5) {
          for (var e4 = this.w, i4 = 0; i4 < t5.length; i4++) e4.globals.collapsedSeriesIndices.indexOf(i4) > -1 && (t5[i4].data = []);
          return t5;
        } }, { key: "highlightSeries", value: function(t5) {
          var e4 = this.w, i4 = this.getSeriesByName(t5), a4 = parseInt(null == i4 ? void 0 : i4.getAttribute("data:realIndex"), 10), s4 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), r4 = null, o3 = null, n3 = null;
          if (e4.globals.axisCharts || "radialBar" === e4.config.chart.type) if (e4.globals.axisCharts) {
            r4 = e4.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a4, "']")), o3 = e4.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a4, "']"));
            var l4 = e4.globals.seriesYAxisReverseMap[a4];
            n3 = e4.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l4, "']"));
          } else r4 = e4.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a4 + 1, "']"));
          else r4 = e4.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a4 + 1, "'] path"));
          for (var h4 = 0; h4 < s4.length; h4++) s4[h4].classList.add(this.legendInactiveClass);
          if (r4) e4.globals.axisCharts || r4.parentNode.classList.remove(this.legendInactiveClass), r4.classList.remove(this.legendInactiveClass), null !== o3 && o3.classList.remove(this.legendInactiveClass), null !== n3 && n3.classList.remove(this.legendInactiveClass);
          else for (var c4 = 0; c4 < s4.length; c4++) s4[c4].classList.remove(this.legendInactiveClass);
        } }, { key: "toggleSeriesOnHover", value: function(t5, e4) {
          var i4 = this.w;
          e4 || (e4 = t5.target);
          var a4 = i4.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
          if ("mousemove" === t5.type) {
            var s4 = parseInt(e4.getAttribute("rel"), 10) - 1;
            this.highlightSeries(i4.globals.seriesNames[s4]);
          } else if ("mouseout" === t5.type) for (var r4 = 0; r4 < a4.length; r4++) a4[r4].classList.remove(this.legendInactiveClass);
        } }, { key: "highlightRangeInSeries", value: function(t5, e4) {
          var i4 = this, a4 = this.w, s4 = a4.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r4 = function(t6) {
            for (var e5 = 0; e5 < s4.length; e5++) s4[e5].classList[t6](i4.legendInactiveClass);
          };
          if ("mousemove" === t5.type) {
            var o3 = parseInt(e4.getAttribute("rel"), 10) - 1;
            r4("add");
            var n3 = a4.config.plotOptions.heatmap.colorScale.ranges;
            !(function(t6, e5) {
              for (var a5 = 0; a5 < s4.length; a5++) {
                var r5 = Number(s4[a5].getAttribute("val"));
                r5 >= t6.from && (r5 < t6.to || t6.to === e5 && r5 === e5) && s4[a5].classList.remove(i4.legendInactiveClass);
              }
            })(n3[o3], n3.reduce((function(t6, e5) {
              return Math.max(t6, e5.to);
            }), 0));
          } else "mouseout" === t5.type && r4("remove");
        } }, { key: "getActiveConfigSeriesIndex", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i4 = this.w, a4 = 0;
          if (i4.config.series.length > 1) {
            for (var s4 = i4.config.series.map((function(t6, a5) {
              return t6.data && t6.data.length > 0 && -1 === i4.globals.collapsedSeriesIndices.indexOf(a5) && (!i4.globals.comboCharts || 0 === e4.length || e4.length && e4.indexOf(i4.config.series[a5].type) > -1) ? a5 : -1;
            })), r4 = "asc" === t5 ? 0 : s4.length - 1; "asc" === t5 ? r4 < s4.length : r4 >= 0; "asc" === t5 ? r4++ : r4--) if (-1 !== s4[r4]) {
              a4 = s4[r4];
              break;
            }
          }
          return a4;
        } }, { key: "getBarSeriesIndices", value: function() {
          return this.w.globals.comboCharts ? this.w.config.series.map((function(t5, e4) {
            return "bar" === t5.type || "column" === t5.type ? e4 : -1;
          })).filter((function(t5) {
            return -1 !== t5;
          })) : this.w.config.series.map((function(t5, e4) {
            return e4;
          }));
        } }, { key: "getPreviousPaths", value: function() {
          var t5 = this.w;
          function e4(e5, i5, a5) {
            for (var s5 = e5[i5].childNodes, r4 = { type: a5, paths: [], realIndex: e5[i5].getAttribute("data:realIndex") }, o3 = 0; o3 < s5.length; o3++) if (s5[o3].hasAttribute("pathTo")) {
              var n3 = s5[o3].getAttribute("pathTo");
              r4.paths.push({ d: n3 });
            }
            t5.globals.previousPaths.push(r4);
          }
          t5.globals.previousPaths = [];
          ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach((function(i5) {
            for (var a5, s5 = (a5 = i5, t5.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a5, "-series .apexcharts-series"))), r4 = 0; r4 < s5.length; r4++) e4(s5, r4, i5);
          })), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
          var i4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t5.config.chart.type, " .apexcharts-series"));
          if (i4.length > 0) for (var a4 = function(e5) {
            for (var i5 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t5.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e5, "'] rect")), a5 = [], s5 = function(t6) {
              var e6 = function(e7) {
                return i5[t6].getAttribute(e7);
              }, s6 = { x: parseFloat(e6("x")), y: parseFloat(e6("y")), width: parseFloat(e6("width")), height: parseFloat(e6("height")) };
              a5.push({ rect: s6, color: i5[t6].getAttribute("color") });
            }, r4 = 0; r4 < i5.length; r4++) s5(r4);
            t5.globals.previousPaths.push(a5);
          }, s4 = 0; s4 < i4.length; s4++) a4(s4);
          t5.globals.axisCharts || (t5.globals.previousPaths = t5.globals.series);
        } }, { key: "handlePrevBubbleScatterPaths", value: function(t5) {
          var e4 = this.w, i4 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t5, "-series .apexcharts-series"));
          if (i4.length > 0) for (var a4 = 0; a4 < i4.length; a4++) {
            for (var s4 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t5, "-series .apexcharts-series[data\\:realIndex='").concat(a4, "'] circle")), r4 = [], o3 = 0; o3 < s4.length; o3++) r4.push({ x: s4[o3].getAttribute("cx"), y: s4[o3].getAttribute("cy"), r: s4[o3].getAttribute("r") });
            e4.globals.previousPaths.push(r4);
          }
        } }, { key: "clearPreviousPaths", value: function() {
          var t5 = this.w;
          t5.globals.previousPaths = [], t5.globals.allSeriesCollapsed = false;
        } }, { key: "handleNoData", value: function() {
          var t5 = this.w, e4 = t5.config.noData, i4 = new k3(this.ctx), a4 = t5.globals.svgWidth / 2, s4 = t5.globals.svgHeight / 2, r4 = "middle";
          if (t5.globals.noData = true, t5.globals.animationEnded = true, "left" === e4.align ? (a4 = 10, r4 = "start") : "right" === e4.align && (a4 = t5.globals.svgWidth - 10, r4 = "end"), "top" === e4.verticalAlign ? s4 = 50 : "bottom" === e4.verticalAlign && (s4 = t5.globals.svgHeight - 50), a4 += e4.offsetX, s4 = s4 + parseInt(e4.style.fontSize, 10) + 2 + e4.offsetY, void 0 !== e4.text && "" !== e4.text) {
            var o3 = i4.drawText({ x: a4, y: s4, text: e4.text, textAnchor: r4, fontSize: e4.style.fontSize, fontFamily: e4.style.fontFamily, foreColor: e4.style.color, opacity: 1, class: "apexcharts-text-nodata" });
            t5.globals.dom.Paper.add(o3);
          }
        } }, { key: "setNullSeriesToZeroValues", value: function(t5) {
          for (var e4 = this.w, i4 = 0; i4 < t5.length; i4++) if (0 === t5[i4].length) for (var a4 = 0; a4 < t5[e4.globals.maxValsInArrayIndex].length; a4++) t5[i4].push(0);
          return t5;
        } }, { key: "hasAllSeriesEqualX", value: function() {
          for (var t5 = true, e4 = this.w, i4 = this.filteredSeriesX(), a4 = 0; a4 < i4.length - 1; a4++) if (i4[a4][0] !== i4[a4 + 1][0]) {
            t5 = false;
            break;
          }
          return e4.globals.allSeriesHasEqualX = t5, t5;
        } }, { key: "filteredSeriesX", value: function() {
          var t5 = this.w.globals.seriesX.map((function(t6) {
            return t6.length > 0 ? t6 : [];
          }));
          return t5;
        } }]), t4;
      })();
      var _3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new A3(this.ctx);
        }
        return s3(t4, [{ key: "isMultiFormat", value: function() {
          return this.isFormatXY() || this.isFormat2DArray();
        } }, { key: "isFormatXY", value: function() {
          var t5 = this.w.config.series.slice(), e4 = new V3(this.ctx);
          if (this.activeSeriesIndex = e4.getActiveConfigSeriesIndex(), void 0 !== t5[this.activeSeriesIndex].data && t5[this.activeSeriesIndex].data.length > 0 && null !== t5[this.activeSeriesIndex].data[0] && void 0 !== t5[this.activeSeriesIndex].data[0].x && null !== t5[this.activeSeriesIndex].data[0]) return true;
        } }, { key: "isFormat2DArray", value: function() {
          var t5 = this.w.config.series.slice(), e4 = new V3(this.ctx);
          if (this.activeSeriesIndex = e4.getActiveConfigSeriesIndex(), void 0 !== t5[this.activeSeriesIndex].data && t5[this.activeSeriesIndex].data.length > 0 && void 0 !== t5[this.activeSeriesIndex].data[0] && null !== t5[this.activeSeriesIndex].data[0] && t5[this.activeSeriesIndex].data[0].constructor === Array) return true;
        } }, { key: "handleFormat2DArray", value: function(t5, e4) {
          for (var i4 = this.w.config, a4 = this.w.globals, s4 = "boxPlot" === i4.chart.type || "boxPlot" === i4.series[e4].type, r4 = 0; r4 < t5[e4].data.length; r4++) if (void 0 !== t5[e4].data[r4][1] && (Array.isArray(t5[e4].data[r4][1]) && 4 === t5[e4].data[r4][1].length && !s4 ? this.twoDSeries.push(m3.parseNumber(t5[e4].data[r4][1][3])) : t5[e4].data[r4].length >= 5 ? this.twoDSeries.push(m3.parseNumber(t5[e4].data[r4][4])) : this.twoDSeries.push(m3.parseNumber(t5[e4].data[r4][1])), a4.dataFormatXNumeric = true), "datetime" === i4.xaxis.type) {
            var o3 = new Date(t5[e4].data[r4][0]);
            o3 = new Date(o3).getTime(), this.twoDSeriesX.push(o3);
          } else this.twoDSeriesX.push(t5[e4].data[r4][0]);
          for (var n3 = 0; n3 < t5[e4].data.length; n3++) void 0 !== t5[e4].data[n3][2] && (this.threeDSeries.push(t5[e4].data[n3][2]), a4.isDataXYZ = true);
        } }, { key: "handleFormatXY", value: function(t5, e4) {
          var i4 = this.w.config, a4 = this.w.globals, s4 = new L3(this.ctx), r4 = e4;
          a4.collapsedSeriesIndices.indexOf(e4) > -1 && (r4 = this.activeSeriesIndex);
          for (var o3 = 0; o3 < t5[e4].data.length; o3++) void 0 !== t5[e4].data[o3].y && (Array.isArray(t5[e4].data[o3].y) ? this.twoDSeries.push(m3.parseNumber(t5[e4].data[o3].y[t5[e4].data[o3].y.length - 1])) : this.twoDSeries.push(m3.parseNumber(t5[e4].data[o3].y))), void 0 !== t5[e4].data[o3].goals && Array.isArray(t5[e4].data[o3].goals) ? (void 0 === this.seriesGoals[e4] && (this.seriesGoals[e4] = []), this.seriesGoals[e4].push(t5[e4].data[o3].goals)) : (void 0 === this.seriesGoals[e4] && (this.seriesGoals[e4] = []), this.seriesGoals[e4].push(null));
          for (var n3 = 0; n3 < t5[r4].data.length; n3++) {
            var l4 = "string" == typeof t5[r4].data[n3].x, h4 = Array.isArray(t5[r4].data[n3].x), c4 = !h4 && !!s4.isValidDate(t5[r4].data[n3].x);
            if (l4 || c4) if (l4 || i4.xaxis.convertedCatToNumeric) {
              var d3 = a4.isBarHorizontal && a4.isRangeData;
              "datetime" !== i4.xaxis.type || d3 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t5[r4].data[n3].x), isNaN(t5[r4].data[n3].x) || "category" === this.w.config.xaxis.type || "string" == typeof t5[r4].data[n3].x || (a4.isXNumeric = true)) : this.twoDSeriesX.push(s4.parseDate(t5[r4].data[n3].x));
            } else "datetime" === i4.xaxis.type ? this.twoDSeriesX.push(s4.parseDate(t5[r4].data[n3].x.toString())) : (a4.dataFormatXNumeric = true, a4.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t5[r4].data[n3].x)));
            else h4 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t5[r4].data[n3].x)) : (a4.isXNumeric = true, a4.dataFormatXNumeric = true, this.twoDSeriesX.push(t5[r4].data[n3].x));
          }
          if (t5[e4].data[0] && void 0 !== t5[e4].data[0].z) {
            for (var g5 = 0; g5 < t5[e4].data.length; g5++) this.threeDSeries.push(t5[e4].data[g5].z);
            a4.isDataXYZ = true;
          }
        } }, { key: "handleRangeData", value: function(t5, e4) {
          var i4 = this.w.globals, a4 = {};
          return this.isFormat2DArray() ? a4 = this.handleRangeDataFormat("array", t5, e4) : this.isFormatXY() && (a4 = this.handleRangeDataFormat("xy", t5, e4)), i4.seriesRangeStart.push(void 0 === a4.start ? [] : a4.start), i4.seriesRangeEnd.push(void 0 === a4.end ? [] : a4.end), i4.seriesRange.push(a4.rangeUniques), i4.seriesRange.forEach((function(t6, e5) {
            t6 && t6.forEach((function(t7, e6) {
              t7.y.forEach((function(e7, i5) {
                for (var a5 = 0; a5 < t7.y.length; a5++) if (i5 !== a5) {
                  var s4 = e7.y1, r4 = e7.y2, o3 = t7.y[a5].y1;
                  s4 <= t7.y[a5].y2 && o3 <= r4 && (t7.overlaps.indexOf(e7.rangeName) < 0 && t7.overlaps.push(e7.rangeName), t7.overlaps.indexOf(t7.y[a5].rangeName) < 0 && t7.overlaps.push(t7.y[a5].rangeName));
                }
              }));
            }));
          })), a4;
        } }, { key: "handleCandleStickBoxData", value: function(t5, e4) {
          var i4 = this.w.globals, a4 = {};
          return this.isFormat2DArray() ? a4 = this.handleCandleStickBoxDataFormat("array", t5, e4) : this.isFormatXY() && (a4 = this.handleCandleStickBoxDataFormat("xy", t5, e4)), i4.seriesCandleO[e4] = a4.o, i4.seriesCandleH[e4] = a4.h, i4.seriesCandleM[e4] = a4.m, i4.seriesCandleL[e4] = a4.l, i4.seriesCandleC[e4] = a4.c, a4;
        } }, { key: "handleRangeDataFormat", value: function(t5, e4, i4) {
          var a4 = [], s4 = [], r4 = e4[i4].data.filter((function(t6, e5, i5) {
            return e5 === i5.findIndex((function(e6) {
              return e6.x === t6.x;
            }));
          })).map((function(t6, e5) {
            return { x: t6.x, overlaps: [], y: [] };
          }));
          if ("array" === t5) for (var o3 = 0; o3 < e4[i4].data.length; o3++) Array.isArray(e4[i4].data[o3]) ? (a4.push(e4[i4].data[o3][1][0]), s4.push(e4[i4].data[o3][1][1])) : (a4.push(e4[i4].data[o3]), s4.push(e4[i4].data[o3]));
          else if ("xy" === t5) for (var n3 = function(t6) {
            var o4 = Array.isArray(e4[i4].data[t6].y), n4 = m3.randomId(), l5 = e4[i4].data[t6].x, h4 = { y1: o4 ? e4[i4].data[t6].y[0] : e4[i4].data[t6].y, y2: o4 ? e4[i4].data[t6].y[1] : e4[i4].data[t6].y, rangeName: n4 };
            e4[i4].data[t6].rangeName = n4;
            var c4 = r4.findIndex((function(t7) {
              return t7.x === l5;
            }));
            r4[c4].y.push(h4), a4.push(h4.y1), s4.push(h4.y2);
          }, l4 = 0; l4 < e4[i4].data.length; l4++) n3(l4);
          return { start: a4, end: s4, rangeUniques: r4 };
        } }, { key: "handleCandleStickBoxDataFormat", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = "boxPlot" === a4.config.chart.type || "boxPlot" === a4.config.series[i4].type, r4 = [], o3 = [], n3 = [], l4 = [], h4 = [];
          if ("array" === t5) if (s4 && 6 === e4[i4].data[0].length || !s4 && 5 === e4[i4].data[0].length) for (var c4 = 0; c4 < e4[i4].data.length; c4++) r4.push(e4[i4].data[c4][1]), o3.push(e4[i4].data[c4][2]), s4 ? (n3.push(e4[i4].data[c4][3]), l4.push(e4[i4].data[c4][4]), h4.push(e4[i4].data[c4][5])) : (l4.push(e4[i4].data[c4][3]), h4.push(e4[i4].data[c4][4]));
          else for (var d3 = 0; d3 < e4[i4].data.length; d3++) Array.isArray(e4[i4].data[d3][1]) && (r4.push(e4[i4].data[d3][1][0]), o3.push(e4[i4].data[d3][1][1]), s4 ? (n3.push(e4[i4].data[d3][1][2]), l4.push(e4[i4].data[d3][1][3]), h4.push(e4[i4].data[d3][1][4])) : (l4.push(e4[i4].data[d3][1][2]), h4.push(e4[i4].data[d3][1][3])));
          else if ("xy" === t5) for (var g5 = 0; g5 < e4[i4].data.length; g5++) Array.isArray(e4[i4].data[g5].y) && (r4.push(e4[i4].data[g5].y[0]), o3.push(e4[i4].data[g5].y[1]), s4 ? (n3.push(e4[i4].data[g5].y[2]), l4.push(e4[i4].data[g5].y[3]), h4.push(e4[i4].data[g5].y[4])) : (l4.push(e4[i4].data[g5].y[2]), h4.push(e4[i4].data[g5].y[3])));
          return { o: r4, h: o3, m: n3, l: l4, c: h4 };
        } }, { key: "parseDataAxisCharts", value: function(t5) {
          var e4 = this, i4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a4 = this.w.config, s4 = this.w.globals, r4 = new L3(i4), o3 = a4.labels.length > 0 ? a4.labels.slice() : a4.xaxis.categories.slice();
          s4.isRangeBar = "rangeBar" === a4.chart.type && s4.isBarHorizontal, s4.hasXaxisGroups = "category" === a4.xaxis.type && a4.xaxis.group.groups.length > 0, s4.hasXaxisGroups && (s4.groups = a4.xaxis.group.groups), t5.forEach((function(t6, e5) {
            void 0 !== t6.name ? s4.seriesNames.push(t6.name) : s4.seriesNames.push("series-" + parseInt(e5 + 1, 10));
          })), this.coreUtils.setSeriesYAxisMappings();
          var n3 = [], l4 = p3(new Set(a4.series.map((function(t6) {
            return t6.group;
          }))));
          a4.series.forEach((function(t6, e5) {
            var i5 = l4.indexOf(t6.group);
            n3[i5] || (n3[i5] = []), n3[i5].push(s4.seriesNames[e5]);
          })), s4.seriesGroups = n3;
          for (var h4 = function() {
            for (var t6 = 0; t6 < o3.length; t6++) if ("string" == typeof o3[t6]) {
              if (!r4.isValidDate(o3[t6])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
              e4.twoDSeriesX.push(r4.parseDate(o3[t6]));
            } else e4.twoDSeriesX.push(o3[t6]);
          }, c4 = 0; c4 < t5.length; c4++) {
            if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t5[c4].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
            if ("rangeBar" !== a4.chart.type && "rangeArea" !== a4.chart.type && "rangeBar" !== t5[c4].type && "rangeArea" !== t5[c4].type || (s4.isRangeData = true, "rangeBar" !== a4.chart.type && "rangeArea" !== a4.chart.type || this.handleRangeData(t5, c4)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t5, c4) : this.isFormatXY() && this.handleFormatXY(t5, c4), "candlestick" !== a4.chart.type && "candlestick" !== t5[c4].type && "boxPlot" !== a4.chart.type && "boxPlot" !== t5[c4].type || this.handleCandleStickBoxData(t5, c4), s4.series.push(this.twoDSeries), s4.labels.push(this.twoDSeriesX), s4.seriesX.push(this.twoDSeriesX), s4.seriesGoals = this.seriesGoals, c4 !== this.activeSeriesIndex || this.fallbackToCategory || (s4.isXNumeric = true);
            else {
              "datetime" === a4.xaxis.type ? (s4.isXNumeric = true, h4(), s4.seriesX.push(this.twoDSeriesX)) : "numeric" === a4.xaxis.type && (s4.isXNumeric = true, o3.length > 0 && (this.twoDSeriesX = o3, s4.seriesX.push(this.twoDSeriesX))), s4.labels.push(this.twoDSeriesX);
              var d3 = t5[c4].data.map((function(t6) {
                return m3.parseNumber(t6);
              }));
              s4.series.push(d3);
            }
            s4.seriesZ.push(this.threeDSeries), void 0 !== t5[c4].color ? s4.seriesColors.push(t5[c4].color) : s4.seriesColors.push(void 0);
          }
          return this.w;
        } }, { key: "parseDataNonAxisCharts", value: function(t5) {
          var e4 = this.w.globals, i4 = this.w.config;
          e4.series = t5.slice(), e4.seriesNames = i4.labels.slice();
          for (var a4 = 0; a4 < e4.series.length; a4++) void 0 === e4.seriesNames[a4] && e4.seriesNames.push("series-" + (a4 + 1));
          return this.w;
        } }, { key: "handleExternalLabelsData", value: function(t5) {
          var e4 = this.w.config, i4 = this.w.globals;
          if (e4.xaxis.categories.length > 0) i4.labels = e4.xaxis.categories;
          else if (e4.labels.length > 0) i4.labels = e4.labels.slice();
          else if (this.fallbackToCategory) {
            if (i4.labels = i4.labels[0], i4.seriesRange.length && (i4.seriesRange.map((function(t6) {
              t6.forEach((function(t7) {
                i4.labels.indexOf(t7.x) < 0 && t7.x && i4.labels.push(t7.x);
              }));
            })), i4.labels = Array.from(new Set(i4.labels.map(JSON.stringify)), JSON.parse)), e4.xaxis.convertedCatToNumeric) new F4(e4).convertCatToNumericXaxis(e4, this.ctx, i4.seriesX[0]), this._generateExternalLabels(t5);
          } else this._generateExternalLabels(t5);
        } }, { key: "_generateExternalLabels", value: function(t5) {
          var e4 = this.w.globals, i4 = this.w.config, a4 = [];
          if (e4.axisCharts) {
            if (e4.series.length > 0) if (this.isFormatXY()) for (var s4 = i4.series.map((function(t6, e5) {
              return t6.data.filter((function(t7, e6, i5) {
                return i5.findIndex((function(e7) {
                  return e7.x === t7.x;
                })) === e6;
              }));
            })), r4 = s4.reduce((function(t6, e5, i5, a5) {
              return a5[t6].length > e5.length ? t6 : i5;
            }), 0), o3 = 0; o3 < s4[r4].length; o3++) a4.push(o3 + 1);
            else for (var n3 = 0; n3 < e4.series[e4.maxValsInArrayIndex].length; n3++) a4.push(n3 + 1);
            e4.seriesX = [];
            for (var l4 = 0; l4 < t5.length; l4++) e4.seriesX.push(a4);
            this.w.globals.isBarHorizontal || (e4.isXNumeric = true);
          }
          if (0 === a4.length) {
            a4 = e4.axisCharts ? [] : e4.series.map((function(t6, e5) {
              return e5 + 1;
            }));
            for (var h4 = 0; h4 < t5.length; h4++) e4.seriesX.push(a4);
          }
          e4.labels = a4, i4.xaxis.convertedCatToNumeric && (e4.categoryLabels = a4.map((function(t6) {
            return i4.xaxis.labels.formatter(t6);
          }))), e4.noLabelsProvided = true;
        } }, { key: "parseData", value: function(t5) {
          var e4 = this.w, i4 = e4.config, a4 = e4.globals;
          if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a4.axisCharts ? (this.parseDataAxisCharts(t5), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t5), i4.chart.stacked) {
            var s4 = new V3(this.ctx);
            a4.series = s4.setNullSeriesToZeroValues(a4.series);
          }
          this.coreUtils.getSeriesTotals(), a4.axisCharts && (a4.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a4.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a4.dataFormatXNumeric || a4.isXNumeric && ("numeric" !== i4.xaxis.type || 0 !== i4.labels.length || 0 !== i4.xaxis.categories.length) || this.handleExternalLabelsData(t5);
          for (var r4 = this.coreUtils.getCategoryLabels(a4.labels), o3 = 0; o3 < r4.length; o3++) if (Array.isArray(r4[o3])) {
            a4.isMultiLineX = true;
            break;
          }
        } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
          var t5 = this.w, e4 = [];
          t5.globals.seriesYAxisMap.forEach((function(i4, a4) {
            var s4 = 0;
            i4.forEach((function(e5) {
              -1 !== t5.globals.collapsedSeriesIndices.indexOf(e5) && s4++;
            })), s4 > 0 && s4 == i4.length && e4.push(a4);
          })), t5.globals.ignoreYAxisIndexes = e4.map((function(t6) {
            return t6;
          }));
        } }]), t4;
      })();
      var U2 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "scaleSvgNode", value: function(t5, e4) {
          var i4 = parseFloat(t5.getAttributeNS(null, "width")), a4 = parseFloat(t5.getAttributeNS(null, "height"));
          t5.setAttributeNS(null, "width", i4 * e4), t5.setAttributeNS(null, "height", a4 * e4), t5.setAttributeNS(null, "viewBox", "0 0 " + i4 + " " + a4);
        } }, { key: "getSvgString", value: function() {
          var t5 = this;
          return new Promise((function(e4) {
            var i4 = t5.w, a4 = i4.config.chart.toolbar.export.width, s4 = i4.config.chart.toolbar.export.scale || a4 / i4.globals.svgWidth;
            s4 || (s4 = 1);
            var r4 = t5.w.globals.dom.Paper.svg(), o3 = t5.w.globals.dom.Paper.node.cloneNode(true);
            1 !== s4 && t5.scaleSvgNode(o3, s4), t5.convertImagesToBase64(o3).then((function() {
              r4 = new XMLSerializer().serializeToString(o3), e4(r4.replace(/&nbsp;/g, "&#160;"));
            }));
          }));
        } }, { key: "convertImagesToBase64", value: function(t5) {
          var e4 = this, i4 = t5.getElementsByTagName("image"), a4 = Array.from(i4).map((function(t6) {
            var i5 = t6.getAttributeNS("http://www.w3.org/1999/xlink", "href");
            return i5 && !i5.startsWith("data:") ? e4.getBase64FromUrl(i5).then((function(e5) {
              t6.setAttributeNS("http://www.w3.org/1999/xlink", "href", e5);
            })).catch((function(t7) {
              console.error("Error converting image to base64:", t7);
            })) : Promise.resolve();
          }));
          return Promise.all(a4);
        } }, { key: "getBase64FromUrl", value: function(t5) {
          return new Promise((function(e4, i4) {
            var a4 = new Image();
            a4.crossOrigin = "Anonymous", a4.onload = function() {
              var t6 = document.createElement("canvas");
              t6.width = a4.width, t6.height = a4.height, t6.getContext("2d").drawImage(a4, 0, 0), e4(t6.toDataURL());
            }, a4.onerror = i4, a4.src = t5;
          }));
        } }, { key: "cleanup", value: function() {
          var t5 = this.w, e4 = t5.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i4 = t5.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
          Array.prototype.forEach.call(a4, (function(t6) {
            t6.setAttribute("width", 0);
          })), e4 && e4[0] && (e4[0].setAttribute("x", -500), e4[0].setAttribute("x1", -500), e4[0].setAttribute("x2", -500)), i4 && i4[0] && (i4[0].setAttribute("y", -100), i4[0].setAttribute("y1", -100), i4[0].setAttribute("y2", -100));
        } }, { key: "svgUrl", value: function() {
          var t5 = this;
          return new Promise((function(e4) {
            t5.cleanup(), t5.getSvgString().then((function(t6) {
              var i4 = new Blob([t6], { type: "image/svg+xml;charset=utf-8" });
              e4(URL.createObjectURL(i4));
            }));
          }));
        } }, { key: "dataURI", value: function(t5) {
          var e4 = this;
          return new Promise((function(i4) {
            var a4 = e4.w, s4 = t5 ? t5.scale || t5.width / a4.globals.svgWidth : 1;
            e4.cleanup();
            var r4 = document.createElement("canvas");
            r4.width = a4.globals.svgWidth * s4, r4.height = parseInt(a4.globals.dom.elWrap.style.height, 10) * s4;
            var o3 = "transparent" !== a4.config.chart.background && a4.config.chart.background ? a4.config.chart.background : "#fff", n3 = r4.getContext("2d");
            n3.fillStyle = o3, n3.fillRect(0, 0, r4.width * s4, r4.height * s4), e4.getSvgString().then((function(t6) {
              var e5 = "data:image/svg+xml," + encodeURIComponent(t6), a5 = new Image();
              a5.crossOrigin = "anonymous", a5.onload = function() {
                if (n3.drawImage(a5, 0, 0), r4.msToBlob) {
                  var t7 = r4.msToBlob();
                  i4({ blob: t7 });
                } else {
                  var e6 = r4.toDataURL("image/png");
                  i4({ imgURI: e6 });
                }
              }, a5.src = e5;
            }));
          }));
        } }, { key: "exportToSVG", value: function() {
          var t5 = this;
          this.svgUrl().then((function(e4) {
            t5.triggerDownload(e4, t5.w.config.chart.toolbar.export.svg.filename, ".svg");
          }));
        } }, { key: "exportToPng", value: function() {
          var t5 = this, e4 = this.w.config.chart.toolbar.export.scale, i4 = this.w.config.chart.toolbar.export.width, a4 = e4 ? { scale: e4 } : i4 ? { width: i4 } : void 0;
          this.dataURI(a4).then((function(e5) {
            var i5 = e5.imgURI, a5 = e5.blob;
            a5 ? navigator.msSaveOrOpenBlob(a5, t5.w.globals.chartID + ".png") : t5.triggerDownload(i5, t5.w.config.chart.toolbar.export.png.filename, ".png");
          }));
        } }, { key: "exportToCSV", value: function(t5) {
          var e4 = this, i4 = t5.series, a4 = t5.fileName, s4 = t5.columnDelimiter, r4 = void 0 === s4 ? "," : s4, o3 = t5.lineDelimiter, n3 = void 0 === o3 ? "\n" : o3, l4 = this.w;
          i4 || (i4 = l4.config.series);
          var h4, c4, d3 = [], g5 = [], u4 = "", f4 = l4.globals.series.map((function(t6, e5) {
            return -1 === l4.globals.collapsedSeriesIndices.indexOf(e5) ? t6 : [];
          })), x5 = function(t6) {
            return "function" == typeof l4.config.chart.toolbar.export.csv.categoryFormatter ? l4.config.chart.toolbar.export.csv.categoryFormatter(t6) : "datetime" === l4.config.xaxis.type && String(t6).length >= 10 ? new Date(t6).toDateString() : m3.isNumber(t6) ? t6 : t6.split(r4).join("");
          }, b4 = function(t6) {
            return "function" == typeof l4.config.chart.toolbar.export.csv.valueFormatter ? l4.config.chart.toolbar.export.csv.valueFormatter(t6) : t6;
          }, v4 = Math.max.apply(Math, p3(i4.map((function(t6) {
            return t6.data ? t6.data.length : 0;
          })))), y4 = new _3(this.ctx), w5 = new M2(this.ctx), k4 = function(t6) {
            var i5 = "";
            if (l4.globals.axisCharts) {
              if ("category" === l4.config.xaxis.type || l4.config.xaxis.convertedCatToNumeric) if (l4.globals.isBarHorizontal) {
                var a5 = l4.globals.yLabelFormatters[0], s5 = new V3(e4.ctx).getActiveConfigSeriesIndex();
                i5 = a5(l4.globals.labels[t6], { seriesIndex: s5, dataPointIndex: t6, w: l4 });
              } else i5 = w5.getLabel(l4.globals.labels, l4.globals.timescaleLabels, 0, t6).text;
              "datetime" === l4.config.xaxis.type && (l4.config.xaxis.categories.length ? i5 = l4.config.xaxis.categories[t6] : l4.config.labels.length && (i5 = l4.config.labels[t6]));
            } else i5 = l4.config.labels[t6];
            return null === i5 ? "nullvalue" : (Array.isArray(i5) && (i5 = i5.join(" ")), m3.isNumber(i5) ? i5 : i5.split(r4).join(""));
          }, A4 = function(t6, e5) {
            if (d3.length && 0 === e5 && g5.push(d3.join(r4)), t6.data) {
              t6.data = t6.data.length && t6.data || p3(Array(v4)).map((function() {
                return "";
              }));
              for (var a5 = 0; a5 < t6.data.length; a5++) {
                d3 = [];
                var s5 = k4(a5);
                if ("nullvalue" !== s5) {
                  if (s5 || (y4.isFormatXY() ? s5 = i4[e5].data[a5].x : y4.isFormat2DArray() && (s5 = i4[e5].data[a5] ? i4[e5].data[a5][0] : "")), 0 === e5) {
                    d3.push(x5(s5));
                    for (var o4 = 0; o4 < l4.globals.series.length; o4++) {
                      var n4, h5 = y4.isFormatXY() ? null === (n4 = i4[o4].data[a5]) || void 0 === n4 ? void 0 : n4.y : f4[o4][a5];
                      d3.push(b4(h5));
                    }
                  }
                  ("candlestick" === l4.config.chart.type || t6.type && "candlestick" === t6.type) && (d3.pop(), d3.push(l4.globals.seriesCandleO[e5][a5]), d3.push(l4.globals.seriesCandleH[e5][a5]), d3.push(l4.globals.seriesCandleL[e5][a5]), d3.push(l4.globals.seriesCandleC[e5][a5])), ("boxPlot" === l4.config.chart.type || t6.type && "boxPlot" === t6.type) && (d3.pop(), d3.push(l4.globals.seriesCandleO[e5][a5]), d3.push(l4.globals.seriesCandleH[e5][a5]), d3.push(l4.globals.seriesCandleM[e5][a5]), d3.push(l4.globals.seriesCandleL[e5][a5]), d3.push(l4.globals.seriesCandleC[e5][a5])), "rangeBar" === l4.config.chart.type && (d3.pop(), d3.push(l4.globals.seriesRangeStart[e5][a5]), d3.push(l4.globals.seriesRangeEnd[e5][a5])), d3.length && g5.push(d3.join(r4));
                }
              }
            }
          };
          d3.push(l4.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l4.config.chart.type ? (d3.push("minimum"), d3.push("q1"), d3.push("median"), d3.push("q3"), d3.push("maximum")) : "candlestick" === l4.config.chart.type ? (d3.push("open"), d3.push("high"), d3.push("low"), d3.push("close")) : "rangeBar" === l4.config.chart.type ? (d3.push("minimum"), d3.push("maximum")) : i4.map((function(t6, e5) {
            var i5 = (t6.name ? t6.name : "series-".concat(e5)) + "";
            l4.globals.axisCharts && d3.push(i5.split(r4).join("") ? i5.split(r4).join("") : "series-".concat(e5));
          })), l4.globals.axisCharts || (d3.push(l4.config.chart.toolbar.export.csv.headerValue), g5.push(d3.join(r4))), l4.globals.allSeriesHasEqualX || !l4.globals.axisCharts || l4.config.xaxis.categories.length || l4.config.labels.length ? i4.map((function(t6, e5) {
            l4.globals.axisCharts ? A4(t6, e5) : ((d3 = []).push(x5(l4.globals.labels[e5])), d3.push(b4(f4[e5])), g5.push(d3.join(r4)));
          })) : (h4 = /* @__PURE__ */ new Set(), c4 = {}, i4.forEach((function(t6, e5) {
            null == t6 || t6.data.forEach((function(t7) {
              var a5, s5;
              if (y4.isFormatXY()) a5 = t7.x, s5 = t7.y;
              else {
                if (!y4.isFormat2DArray()) return;
                a5 = t7[0], s5 = t7[1];
              }
              c4[a5] || (c4[a5] = Array(i4.length).fill("")), c4[a5][e5] = b4(s5), h4.add(a5);
            }));
          })), d3.length && g5.push(d3.join(r4)), Array.from(h4).sort().forEach((function(t6) {
            g5.push([x5(t6), c4[t6].join(r4)]);
          }))), u4 += g5.join(n3), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + u4), a4 || l4.config.chart.toolbar.export.csv.filename, ".csv");
        } }, { key: "triggerDownload", value: function(t5, e4, i4) {
          var a4 = document.createElement("a");
          a4.href = t5, a4.download = (e4 || this.w.globals.chartID) + i4, document.body.appendChild(a4), a4.click(), document.body.removeChild(a4);
        } }]), t4;
      })();
      var q3 = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = e4, this.elgrid = a4, this.w = e4.w;
          var s4 = this.w;
          this.axesUtils = new M2(e4), this.xaxisLabels = s4.globals.labels.slice(), s4.globals.timescaleLabels.length > 0 && !s4.globals.isBarHorizontal && (this.xaxisLabels = s4.globals.timescaleLabels.slice()), s4.config.xaxis.overwriteCategories && (this.xaxisLabels = s4.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s4.config.xaxis.position ? this.offY = 0 : this.offY = s4.globals.gridHeight, this.offY = this.offY + s4.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s4.config.chart.type && s4.config.plotOptions.bar.horizontal, this.xaxisFontSize = s4.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s4.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s4.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s4.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s4.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s4.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s4.config.xaxis.axisBorder.height, this.yaxis = s4.config.yaxis[0];
        }
        return s3(t4, [{ key: "drawXaxis", value: function() {
          var t5 = this.w, e4 = new k3(this.ctx), i4 = e4.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t5.config.xaxis.offsetX, ", ").concat(t5.config.xaxis.offsetY, ")") }), a4 = e4.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t5.globals.translateXAxisX, ", ").concat(t5.globals.translateXAxisY, ")") });
          i4.add(a4);
          for (var s4 = [], r4 = 0; r4 < this.xaxisLabels.length; r4++) s4.push(this.xaxisLabels[r4]);
          if (this.drawXAxisLabelAndGroup(true, e4, a4, s4, t5.globals.isXNumeric, (function(t6, e5) {
            return e5;
          })), t5.globals.hasXaxisGroups) {
            var o3 = t5.globals.groups;
            s4 = [];
            for (var n3 = 0; n3 < o3.length; n3++) s4.push(o3[n3].title);
            var l4 = {};
            t5.config.xaxis.group.style && (l4.xaxisFontSize = t5.config.xaxis.group.style.fontSize, l4.xaxisFontFamily = t5.config.xaxis.group.style.fontFamily, l4.xaxisForeColors = t5.config.xaxis.group.style.colors, l4.fontWeight = t5.config.xaxis.group.style.fontWeight, l4.cssClass = t5.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e4, a4, s4, false, (function(t6, e5) {
              return o3[t6].cols * e5;
            }), l4);
          }
          if (void 0 !== t5.config.xaxis.title.text) {
            var h4 = e4.group({ class: "apexcharts-xaxis-title" }), c4 = e4.drawText({ x: t5.globals.gridWidth / 2 + t5.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t5.config.xaxis.position ? t5.globals.xAxisLabelsHeight : -t5.globals.xAxisLabelsHeight - 10) + t5.config.xaxis.title.offsetY, text: t5.config.xaxis.title.text, textAnchor: "middle", fontSize: t5.config.xaxis.title.style.fontSize, fontFamily: t5.config.xaxis.title.style.fontFamily, fontWeight: t5.config.xaxis.title.style.fontWeight, foreColor: t5.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t5.config.xaxis.title.style.cssClass });
            h4.add(c4), i4.add(h4);
          }
          if (t5.config.xaxis.axisBorder.show) {
            var d3 = t5.globals.barPadForNumericAxis, g5 = e4.drawLine(t5.globals.padHorizontal + t5.config.xaxis.axisBorder.offsetX - d3, this.offY, this.xaxisBorderWidth + d3, this.offY, t5.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
            this.elgrid && this.elgrid.elGridBorders && t5.config.grid.show ? this.elgrid.elGridBorders.add(g5) : i4.add(g5);
          }
          return i4;
        } }, { key: "drawXAxisLabelAndGroup", value: function(t5, e4, i4, a4, s4, r4) {
          var o3, n3 = this, l4 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h4 = [], c4 = [], d3 = this.w, g5 = l4.xaxisFontSize || this.xaxisFontSize, u4 = l4.xaxisFontFamily || this.xaxisFontFamily, f4 = l4.xaxisForeColors || this.xaxisForeColors, p4 = l4.fontWeight || d3.config.xaxis.labels.style.fontWeight, x5 = l4.cssClass || d3.config.xaxis.labels.style.cssClass, b4 = d3.globals.padHorizontal, v4 = a4.length, m4 = "category" === d3.config.xaxis.type ? d3.globals.dataPoints : v4;
          if (0 === m4 && v4 > m4 && (m4 = v4), s4) {
            var y4 = m4 > 1 ? m4 - 1 : m4;
            o3 = d3.globals.gridWidth / Math.min(y4, v4 - 1), b4 = b4 + r4(0, o3) / 2 + d3.config.xaxis.labels.offsetX;
          } else o3 = d3.globals.gridWidth / m4, b4 = b4 + r4(0, o3) + d3.config.xaxis.labels.offsetX;
          for (var w5 = function(s5) {
            var l5 = b4 - r4(s5, o3) / 2 + d3.config.xaxis.labels.offsetX;
            0 === s5 && 1 === v4 && o3 / 2 === b4 && 1 === m4 && (l5 = d3.globals.gridWidth / 2);
            var y5 = n3.axesUtils.getLabel(a4, d3.globals.timescaleLabels, l5, s5, h4, g5, t5), w6 = 28;
            d3.globals.rotateXLabels && t5 && (w6 = 22), d3.config.xaxis.title.text && "top" === d3.config.xaxis.position && (w6 += parseFloat(d3.config.xaxis.title.style.fontSize) + 2), t5 || (w6 = w6 + parseFloat(g5) + (d3.globals.xAxisLabelsHeight - d3.globals.xAxisGroupLabelsHeight) + (d3.globals.rotateXLabels ? 10 : 0)), y5 = void 0 !== d3.config.xaxis.tickAmount && "dataPoints" !== d3.config.xaxis.tickAmount && "datetime" !== d3.config.xaxis.type ? n3.axesUtils.checkLabelBasedOnTickamount(s5, y5, v4) : n3.axesUtils.checkForOverflowingLabels(s5, y5, v4, h4, c4);
            if (d3.config.xaxis.labels.show) {
              var k5 = e4.drawText({ x: y5.x, y: n3.offY + d3.config.xaxis.labels.offsetY + w6 - ("top" === d3.config.xaxis.position ? d3.globals.xAxisHeight + d3.config.xaxis.axisTicks.height - 2 : 0), text: y5.text, textAnchor: "middle", fontWeight: y5.isBold ? 600 : p4, fontSize: g5, fontFamily: u4, foreColor: Array.isArray(f4) ? t5 && d3.config.xaxis.convertedCatToNumeric ? f4[d3.globals.minX + s5 - 1] : f4[s5] : f4, isPlainText: false, cssClass: (t5 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x5 });
              if (i4.add(k5), k5.on("click", (function(t6) {
                if ("function" == typeof d3.config.chart.events.xAxisLabelClick) {
                  var e5 = Object.assign({}, d3, { labelIndex: s5 });
                  d3.config.chart.events.xAxisLabelClick(t6, n3.ctx, e5);
                }
              })), t5) {
                var A4 = document.createElementNS(d3.globals.SVGNS, "title");
                A4.textContent = Array.isArray(y5.text) ? y5.text.join(" ") : y5.text, k5.node.appendChild(A4), "" !== y5.text && (h4.push(y5.text), c4.push(y5));
              }
            }
            s5 < v4 - 1 && (b4 += r4(s5 + 1, o3));
          }, k4 = 0; k4 <= v4 - 1; k4++) w5(k4);
        } }, { key: "drawXaxisInversed", value: function(t5) {
          var e4, i4, a4 = this, s4 = this.w, r4 = new k3(this.ctx), o3 = s4.config.yaxis[0].opposite ? s4.globals.translateYAxisX[t5] : 0, n3 = r4.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t5 }), l4 = r4.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o3 + ", 0)" });
          n3.add(l4);
          var h4 = [];
          if (s4.config.yaxis[t5].show) for (var c4 = 0; c4 < this.xaxisLabels.length; c4++) h4.push(this.xaxisLabels[c4]);
          e4 = s4.globals.gridHeight / h4.length, i4 = -e4 / 2.2;
          var d3 = s4.globals.yLabelFormatters[0], g5 = s4.config.yaxis[0].labels;
          if (g5.show) for (var u4 = function(o4) {
            var n4 = void 0 === h4[o4] ? "" : h4[o4];
            n4 = d3(n4, { seriesIndex: t5, dataPointIndex: o4, w: s4 });
            var c5 = a4.axesUtils.getYAxisForeColor(g5.style.colors, t5), u5 = 0;
            Array.isArray(n4) && (u5 = n4.length / 2 * parseInt(g5.style.fontSize, 10));
            var f5 = g5.offsetX - 15, p5 = "end";
            a4.yaxis.opposite && (p5 = "start"), "left" === s4.config.yaxis[0].labels.align ? (f5 = g5.offsetX, p5 = "start") : "center" === s4.config.yaxis[0].labels.align ? (f5 = g5.offsetX, p5 = "middle") : "right" === s4.config.yaxis[0].labels.align && (p5 = "end");
            var x6 = r4.drawText({ x: f5, y: i4 + e4 + g5.offsetY - u5, text: n4, textAnchor: p5, foreColor: Array.isArray(c5) ? c5[o4] : c5, fontSize: g5.style.fontSize, fontFamily: g5.style.fontFamily, fontWeight: g5.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + g5.style.cssClass, maxWidth: g5.maxWidth });
            l4.add(x6), x6.on("click", (function(t6) {
              if ("function" == typeof s4.config.chart.events.xAxisLabelClick) {
                var e5 = Object.assign({}, s4, { labelIndex: o4 });
                s4.config.chart.events.xAxisLabelClick(t6, a4.ctx, e5);
              }
            }));
            var b5 = document.createElementNS(s4.globals.SVGNS, "title");
            if (b5.textContent = Array.isArray(n4) ? n4.join(" ") : n4, x6.node.appendChild(b5), 0 !== s4.config.yaxis[t5].labels.rotate) {
              var v5 = r4.rotateAroundCenter(x6.node);
              x6.node.setAttribute("transform", "rotate(".concat(s4.config.yaxis[t5].labels.rotate, " 0 ").concat(v5.y, ")"));
            }
            i4 += e4;
          }, f4 = 0; f4 <= h4.length - 1; f4++) u4(f4);
          if (void 0 !== s4.config.yaxis[0].title.text) {
            var p4 = r4.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o3 + ", 0)" }), x5 = r4.drawText({ x: s4.config.yaxis[0].title.offsetX, y: s4.globals.gridHeight / 2 + s4.config.yaxis[0].title.offsetY, text: s4.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s4.config.yaxis[0].title.style.color, fontSize: s4.config.yaxis[0].title.style.fontSize, fontWeight: s4.config.yaxis[0].title.style.fontWeight, fontFamily: s4.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s4.config.yaxis[0].title.style.cssClass });
            p4.add(x5), n3.add(p4);
          }
          var b4 = 0;
          this.isCategoryBarHorizontal && s4.config.yaxis[0].opposite && (b4 = s4.globals.gridWidth);
          var v4 = s4.config.xaxis.axisBorder;
          if (v4.show) {
            var m4 = r4.drawLine(s4.globals.padHorizontal + v4.offsetX + b4, 1 + v4.offsetY, s4.globals.padHorizontal + v4.offsetX + b4, s4.globals.gridHeight + v4.offsetY, v4.color, 0);
            this.elgrid && this.elgrid.elGridBorders && s4.config.grid.show ? this.elgrid.elGridBorders.add(m4) : n3.add(m4);
          }
          return s4.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b4, h4.length, s4.config.yaxis[0].axisBorder, s4.config.yaxis[0].axisTicks, 0, e4, n3), n3;
        } }, { key: "drawXaxisTicks", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = t5;
          if (!(t5 < 0 || t5 - 2 > a4.globals.gridWidth)) {
            var r4 = this.offY + a4.config.xaxis.axisTicks.offsetY;
            if (e4 = e4 + r4 + a4.config.xaxis.axisTicks.height, "top" === a4.config.xaxis.position && (e4 = r4 - a4.config.xaxis.axisTicks.height), a4.config.xaxis.axisTicks.show) {
              var o3 = new k3(this.ctx).drawLine(t5 + a4.config.xaxis.axisTicks.offsetX, r4 + a4.config.xaxis.offsetY, s4 + a4.config.xaxis.axisTicks.offsetX, e4 + a4.config.xaxis.offsetY, a4.config.xaxis.axisTicks.color);
              i4.add(o3), o3.node.classList.add("apexcharts-xaxis-tick");
            }
          }
        } }, { key: "getXAxisTicksPositions", value: function() {
          var t5 = this.w, e4 = [], i4 = this.xaxisLabels.length, a4 = t5.globals.padHorizontal;
          if (t5.globals.timescaleLabels.length > 0) for (var s4 = 0; s4 < i4; s4++) a4 = this.xaxisLabels[s4].position, e4.push(a4);
          else for (var r4 = i4, o3 = 0; o3 < r4; o3++) {
            var n3 = r4;
            t5.globals.isXNumeric && "bar" !== t5.config.chart.type && (n3 -= 1), a4 += t5.globals.gridWidth / n3, e4.push(a4);
          }
          return e4;
        } }, { key: "xAxisLabelCorrections", value: function() {
          var t5 = this.w, e4 = new k3(this.ctx), i4 = t5.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
          if (t5.globals.rotateXLabels || t5.config.xaxis.labels.rotateAlways) for (var o3 = 0; o3 < a4.length; o3++) {
            var n3 = e4.rotateAroundCenter(a4[o3]);
            n3.y = n3.y - 1, n3.x = n3.x + 1, a4[o3].setAttribute("transform", "rotate(".concat(t5.config.xaxis.labels.rotate, " ").concat(n3.x, " ").concat(n3.y, ")")), a4[o3].setAttribute("text-anchor", "end");
            i4.setAttribute("transform", "translate(0, ".concat(-10, ")"));
            var l4 = a4[o3].childNodes;
            t5.config.xaxis.labels.trim && Array.prototype.forEach.call(l4, (function(i5) {
              e4.placeTextWithEllipsis(i5, i5.textContent, t5.globals.xAxisLabelsHeight - ("bottom" === t5.config.legend.position ? 20 : 10));
            }));
          }
          else !(function() {
            for (var i5 = t5.globals.gridWidth / (t5.globals.labels.length + 1), s5 = 0; s5 < a4.length; s5++) {
              var r5 = a4[s5].childNodes;
              t5.config.xaxis.labels.trim && "datetime" !== t5.config.xaxis.type && Array.prototype.forEach.call(r5, (function(t6) {
                e4.placeTextWithEllipsis(t6, t6.textContent, i5);
              }));
            }
          })();
          if (s4.length > 0) {
            var h4 = s4[s4.length - 1].getBBox(), c4 = s4[0].getBBox();
            h4.x < -20 && s4[s4.length - 1].parentNode.removeChild(s4[s4.length - 1]), c4.x + c4.width > t5.globals.gridWidth && !t5.globals.isBarHorizontal && s4[0].parentNode.removeChild(s4[0]);
            for (var d3 = 0; d3 < r4.length; d3++) e4.placeTextWithEllipsis(r4[d3], r4[d3].textContent, t5.config.yaxis[0].labels.maxWidth - (t5.config.yaxis[0].title.text ? 2 * parseFloat(t5.config.yaxis[0].title.style.fontSize) : 0) - 15);
          }
        } }]), t4;
      })();
      var Z2 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
          var a4 = this.w;
          this.xaxisLabels = a4.globals.labels.slice(), this.axesUtils = new M2(e4), this.isRangeBar = a4.globals.seriesRange.length && a4.globals.isBarHorizontal, a4.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a4.globals.timescaleLabels.slice());
        }
        return s3(t4, [{ key: "drawGridArea", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e4 = this.w, i4 = new k3(this.ctx);
          t5 || (t5 = i4.group({ class: "apexcharts-grid" }));
          var a4 = i4.drawLine(e4.globals.padHorizontal, 1, e4.globals.padHorizontal, e4.globals.gridHeight, "transparent"), s4 = i4.drawLine(e4.globals.padHorizontal, e4.globals.gridHeight, e4.globals.gridWidth, e4.globals.gridHeight, "transparent");
          return t5.add(s4), t5.add(a4), t5;
        } }, { key: "drawGrid", value: function() {
          if (this.w.globals.axisCharts) {
            var t5 = this.renderGrid();
            return this.drawGridArea(t5.el), t5;
          }
          return null;
        } }, { key: "createGridMask", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = new k3(this.ctx), a4 = Array.isArray(t5.config.stroke.width) ? Math.max.apply(Math, p3(t5.config.stroke.width)) : t5.config.stroke.width, s4 = function(t6) {
            var i5 = document.createElementNS(e4.SVGNS, "clipPath");
            return i5.setAttribute("id", t6), i5;
          };
          e4.dom.elGridRectMask = s4("gridRectMask".concat(e4.cuid)), e4.dom.elGridRectBarMask = s4("gridRectBarMask".concat(e4.cuid)), e4.dom.elGridRectMarkerMask = s4("gridRectMarkerMask".concat(e4.cuid)), e4.dom.elForecastMask = s4("forecastMask".concat(e4.cuid)), e4.dom.elNonForecastMask = s4("nonForecastMask".concat(e4.cuid));
          var r4 = 0, o3 = 0;
          (["bar", "rangeBar", "candlestick", "boxPlot"].includes(t5.config.chart.type) || t5.globals.comboBarCount > 0) && t5.globals.isXNumeric && !t5.globals.isBarHorizontal && (r4 = Math.max(t5.config.grid.padding.left, e4.barPadForNumericAxis), o3 = Math.max(t5.config.grid.padding.right, e4.barPadForNumericAxis)), e4.dom.elGridRect = i4.drawRect(0, 0, e4.gridWidth, e4.gridHeight, 0, "#fff"), e4.dom.elGridRectBar = i4.drawRect(-a4 / 2 - r4 - 2, -a4 / 2 - 2, e4.gridWidth + a4 + o3 + r4 + 4, e4.gridHeight + a4 + 4, 0, "#fff");
          var n3 = t5.globals.markers.largestSize;
          e4.dom.elGridRectMarker = i4.drawRect(-n3, -n3, e4.gridWidth + 2 * n3, e4.gridHeight + 2 * n3, 0, "#fff"), e4.dom.elGridRectMask.appendChild(e4.dom.elGridRect.node), e4.dom.elGridRectBarMask.appendChild(e4.dom.elGridRectBar.node), e4.dom.elGridRectMarkerMask.appendChild(e4.dom.elGridRectMarker.node);
          var l4 = e4.dom.baseEl.querySelector("defs");
          l4.appendChild(e4.dom.elGridRectMask), l4.appendChild(e4.dom.elGridRectBarMask), l4.appendChild(e4.dom.elGridRectMarkerMask), l4.appendChild(e4.dom.elForecastMask), l4.appendChild(e4.dom.elNonForecastMask);
        } }, { key: "_drawGridLines", value: function(t5) {
          var e4 = t5.i, i4 = t5.x1, a4 = t5.y1, s4 = t5.x2, r4 = t5.y2, o3 = t5.xCount, n3 = t5.parent, l4 = this.w;
          if (!(0 === e4 && l4.globals.skipFirstTimelinelabel || e4 === o3 - 1 && l4.globals.skipLastTimelinelabel && !l4.config.xaxis.labels.formatter || "radar" === l4.config.chart.type)) {
            l4.config.grid.xaxis.lines.show && this._drawGridLine({ i: e4, x1: i4, y1: a4, x2: s4, y2: r4, xCount: o3, parent: n3 });
            var h4 = 0;
            if (l4.globals.hasXaxisGroups && "between" === l4.config.xaxis.tickPlacement) {
              var c4 = l4.globals.groups;
              if (c4) {
                for (var d3 = 0, g5 = 0; d3 < e4 && g5 < c4.length; g5++) d3 += c4[g5].cols;
                d3 === e4 && (h4 = 0.6 * l4.globals.xAxisLabelsHeight);
              }
            }
            new q3(this.ctx).drawXaxisTicks(i4, h4, l4.globals.dom.elGraphical);
          }
        } }, { key: "_drawGridLine", value: function(t5) {
          var e4 = t5.i, i4 = t5.x1, a4 = t5.y1, s4 = t5.x2, r4 = t5.y2, o3 = t5.xCount, n3 = t5.parent, l4 = this.w, h4 = n3.node.classList.contains("apexcharts-gridlines-horizontal"), c4 = l4.globals.barPadForNumericAxis, d3 = 0 === a4 && 0 === r4 || 0 === i4 && 0 === s4 || a4 === l4.globals.gridHeight && r4 === l4.globals.gridHeight || l4.globals.isBarHorizontal && (0 === e4 || e4 === o3 - 1), g5 = new k3(this).drawLine(i4 - (h4 ? c4 : 0), a4, s4 + (h4 ? c4 : 0), r4, l4.config.grid.borderColor, l4.config.grid.strokeDashArray);
          g5.node.classList.add("apexcharts-gridline"), d3 && l4.config.grid.show ? this.elGridBorders.add(g5) : n3.add(g5);
        } }, { key: "_drawGridBandRect", value: function(t5) {
          var e4 = t5.c, i4 = t5.x1, a4 = t5.y1, s4 = t5.x2, r4 = t5.y2, o3 = t5.type, n3 = this.w, l4 = new k3(this.ctx), h4 = n3.globals.barPadForNumericAxis, c4 = n3.config.grid[o3].colors[e4], d3 = l4.drawRect(i4 - ("row" === o3 ? h4 : 0), a4, s4 + ("row" === o3 ? 2 * h4 : 0), r4, 0, c4, n3.config.grid[o3].opacity);
          this.elg.add(d3), d3.attr("clip-path", "url(#gridRectMask".concat(n3.globals.cuid, ")")), d3.node.classList.add("apexcharts-grid-".concat(o3));
        } }, { key: "_drawXYLines", value: function(t5) {
          var e4 = this, i4 = t5.xCount, a4 = t5.tickAmount, s4 = this.w;
          if (s4.config.grid.xaxis.lines.show || s4.config.xaxis.axisTicks.show) {
            var r4, o3 = s4.globals.padHorizontal, n3 = s4.globals.gridHeight;
            s4.globals.timescaleLabels.length ? (function(t6) {
              for (var a5 = t6.xC, s5 = t6.x1, r5 = t6.y1, o4 = t6.x2, n4 = t6.y2, l5 = 0; l5 < a5; l5++) s5 = e4.xaxisLabels[l5].position, o4 = e4.xaxisLabels[l5].position, e4._drawGridLines({ i: l5, x1: s5, y1: r5, x2: o4, y2: n4, xCount: i4, parent: e4.elgridLinesV });
            })({ xC: i4, x1: o3, y1: 0, x2: r4, y2: n3 }) : (s4.globals.isXNumeric && (i4 = s4.globals.xAxisScale.result.length), (function(t6) {
              for (var a5 = t6.xC, r5 = t6.x1, o4 = t6.y1, n4 = t6.x2, l5 = t6.y2, h5 = 0; h5 < a5 + (s4.globals.isXNumeric ? 0 : 1); h5++) 0 === h5 && 1 === a5 && 1 === s4.globals.dataPoints && (n4 = r5 = s4.globals.gridWidth / 2), e4._drawGridLines({ i: h5, x1: r5, y1: o4, x2: n4, y2: l5, xCount: i4, parent: e4.elgridLinesV }), n4 = r5 += s4.globals.gridWidth / (s4.globals.isXNumeric ? a5 - 1 : a5);
            })({ xC: i4, x1: o3, y1: 0, x2: r4, y2: n3 }));
          }
          if (s4.config.grid.yaxis.lines.show) {
            var l4 = 0, h4 = 0, c4 = s4.globals.gridWidth, d3 = a4 + 1;
            this.isRangeBar && (d3 = s4.globals.labels.length);
            for (var g5 = 0; g5 < d3 + (this.isRangeBar ? 1 : 0); g5++) this._drawGridLine({ i: g5, xCount: d3 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l4, x2: c4, y2: h4, parent: this.elgridLinesH }), h4 = l4 += s4.globals.gridHeight / (this.isRangeBar ? d3 : a4);
          }
        } }, { key: "_drawInvertedXYLines", value: function(t5) {
          var e4 = t5.xCount, i4 = this.w;
          if (i4.config.grid.xaxis.lines.show || i4.config.xaxis.axisTicks.show) for (var a4, s4 = i4.globals.padHorizontal, r4 = i4.globals.gridHeight, o3 = 0; o3 < e4 + 1; o3++) {
            i4.config.grid.xaxis.lines.show && this._drawGridLine({ i: o3, xCount: e4 + 1, x1: s4, y1: 0, x2: a4, y2: r4, parent: this.elgridLinesV }), new q3(this.ctx).drawXaxisTicks(s4, 0, i4.globals.dom.elGraphical), a4 = s4 += i4.globals.gridWidth / e4;
          }
          if (i4.config.grid.yaxis.lines.show) for (var n3 = 0, l4 = 0, h4 = i4.globals.gridWidth, c4 = 0; c4 < i4.globals.dataPoints + 1; c4++) this._drawGridLine({ i: c4, xCount: i4.globals.dataPoints + 1, x1: 0, y1: n3, x2: h4, y2: l4, parent: this.elgridLinesH }), l4 = n3 += i4.globals.gridHeight / i4.globals.dataPoints;
        } }, { key: "renderGrid", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = new k3(this.ctx);
          this.elg = i4.group({ class: "apexcharts-grid" }), this.elgridLinesH = i4.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i4.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i4.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t5.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
          for (var a4 = 0; a4 < e4.seriesYAxisMap.length && e4.ignoreYAxisIndexes.includes(a4); ) a4++;
          a4 === e4.seriesYAxisMap.length && (a4 = 0);
          var s4, r4 = e4.yAxisScale[a4].result.length - 1;
          if (!e4.isBarHorizontal || this.isRangeBar) {
            var o3, n3, l4;
            if (s4 = this.xaxisLabels.length, this.isRangeBar) r4 = e4.labels.length, t5.config.xaxis.tickAmount && t5.config.xaxis.labels.formatter && (s4 = t5.config.xaxis.tickAmount), (null === (o3 = e4.yAxisScale) || void 0 === o3 || null === (n3 = o3[a4]) || void 0 === n3 || null === (l4 = n3.result) || void 0 === l4 ? void 0 : l4.length) > 0 && "datetime" !== t5.config.xaxis.type && (s4 = e4.yAxisScale[a4].result.length - 1);
            this._drawXYLines({ xCount: s4, tickAmount: r4 });
          } else s4 = r4, r4 = e4.xTickAmount, this._drawInvertedXYLines({ xCount: s4, tickAmount: r4 });
          return this.drawGridBands(s4, r4), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e4.gridWidth / s4 };
        } }, { key: "drawGridBands", value: function(t5, e4) {
          var i4, a4, s4 = this, r4 = this.w;
          if ((null === (i4 = r4.config.grid.row.colors) || void 0 === i4 ? void 0 : i4.length) > 0 && (function(t6, i5, a5, o4, n4, l5) {
            for (var h5 = 0, c5 = 0; h5 < i5; h5++, c5++) c5 >= r4.config.grid[t6].colors.length && (c5 = 0), s4._drawGridBandRect({ c: c5, x1: a5, y1: o4, x2: n4, y2: l5, type: t6 }), o4 += r4.globals.gridHeight / e4;
          })("row", e4, 0, 0, r4.globals.gridWidth, r4.globals.gridHeight / e4), (null === (a4 = r4.config.grid.column.colors) || void 0 === a4 ? void 0 : a4.length) > 0) {
            var o3 = r4.globals.isBarHorizontal || "on" !== r4.config.xaxis.tickPlacement || "category" !== r4.config.xaxis.type && !r4.config.xaxis.convertedCatToNumeric ? t5 : t5 - 1;
            r4.globals.isXNumeric && (o3 = r4.globals.xAxisScale.result.length - 1);
            for (var n3 = r4.globals.padHorizontal, l4 = r4.globals.padHorizontal + r4.globals.gridWidth / o3, h4 = r4.globals.gridHeight, c4 = 0, d3 = 0; c4 < t5; c4++, d3++) {
              var g5;
              if (d3 >= r4.config.grid.column.colors.length && (d3 = 0), "datetime" === r4.config.xaxis.type) n3 = this.xaxisLabels[c4].position, l4 = ((null === (g5 = this.xaxisLabels[c4 + 1]) || void 0 === g5 ? void 0 : g5.position) || r4.globals.gridWidth) - this.xaxisLabels[c4].position;
              this._drawGridBandRect({ c: d3, x1: n3, y1: 0, x2: l4, y2: h4, type: "column" }), n3 += r4.globals.gridWidth / o3;
            }
          }
        } }]), t4;
      })();
      var $3 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.coreUtils = new A3(this.ctx);
        }
        return s3(t4, [{ key: "niceScale", value: function(t5, e4) {
          var i4, a4, s4, r4, o3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, n3 = 1e-11, l4 = this.w, h4 = l4.globals;
          h4.isBarHorizontal ? (i4 = l4.config.xaxis, a4 = Math.max((h4.svgWidth - 100) / 25, 2)) : (i4 = l4.config.yaxis[o3], a4 = Math.max((h4.svgHeight - 100) / 15, 2)), m3.isNumber(a4) || (a4 = 10), s4 = void 0 !== i4.min && null !== i4.min, r4 = void 0 !== i4.max && null !== i4.min;
          var c4 = void 0 !== i4.stepSize && null !== i4.stepSize, d3 = void 0 !== i4.tickAmount && null !== i4.tickAmount, g5 = d3 ? i4.tickAmount : h4.niceScaleDefaultTicks[Math.min(Math.round(a4 / 2), h4.niceScaleDefaultTicks.length - 1)];
          if (h4.isMultipleYAxis && !d3 && h4.multiAxisTickAmount > 0 && (g5 = h4.multiAxisTickAmount, d3 = true), g5 = "dataPoints" === g5 ? h4.dataPoints - 1 : Math.abs(Math.round(g5)), (t5 === Number.MIN_VALUE && 0 === e4 || !m3.isNumber(t5) && !m3.isNumber(e4) || t5 === Number.MIN_VALUE && e4 === -Number.MAX_VALUE) && (t5 = m3.isNumber(i4.min) ? i4.min : 0, e4 = m3.isNumber(i4.max) ? i4.max : t5 + g5, h4.allSeriesCollapsed = false), t5 > e4) {
            console.warn("axis.min cannot be greater than axis.max: swapping min and max");
            var u4 = e4;
            e4 = t5, t5 = u4;
          } else t5 === e4 && (t5 = 0 === t5 ? 0 : t5 - 1, e4 = 0 === e4 ? 2 : e4 + 1);
          var f4 = [];
          g5 < 1 && (g5 = 1);
          var p4 = g5, x5 = Math.abs(e4 - t5);
          !s4 && t5 > 0 && t5 / x5 < 0.15 && (t5 = 0, s4 = true), !r4 && e4 < 0 && -e4 / x5 < 0.15 && (e4 = 0, r4 = true);
          var b4 = (x5 = Math.abs(e4 - t5)) / p4, v4 = b4, y4 = Math.floor(Math.log10(v4)), w5 = Math.pow(10, y4), k4 = Math.ceil(v4 / w5);
          if (b4 = v4 = (k4 = h4.niceScaleAllowedMagMsd[0 === h4.yValueDecimal ? 0 : 1][k4]) * w5, h4.isBarHorizontal && i4.stepSize && "datetime" !== i4.type ? (b4 = i4.stepSize, c4 = true) : c4 && (b4 = i4.stepSize), c4 && i4.forceNiceScale) {
            var A4 = Math.floor(Math.log10(b4));
            b4 *= Math.pow(10, y4 - A4);
          }
          if (s4 && r4) {
            var S3 = x5 / p4;
            if (d3) if (c4) if (0 != m3.mod(x5, b4)) {
              var C4 = m3.getGCD(b4, S3);
              b4 = S3 / C4 < 10 ? C4 : S3;
            } else 0 == m3.mod(b4, S3) ? b4 = S3 : (S3 = b4, d3 = false);
            else b4 = S3;
            else if (c4) 0 == m3.mod(x5, b4) ? S3 = b4 : b4 = S3;
            else if (0 == m3.mod(x5, b4)) S3 = b4;
            else {
              S3 = x5 / (p4 = Math.ceil(x5 / b4));
              var L4 = m3.getGCD(x5, b4);
              x5 / L4 < a4 && (S3 = L4), b4 = S3;
            }
            p4 = Math.round(x5 / b4);
          } else {
            if (s4 || r4) {
              if (r4) if (d3) t5 = e4 - b4 * p4;
              else {
                var P4 = t5;
                t5 = b4 * Math.floor(t5 / b4), Math.abs(e4 - t5) / m3.getGCD(x5, b4) > a4 && (t5 = e4 - b4 * g5, t5 += b4 * Math.floor((P4 - t5) / b4));
              }
              else if (s4) if (d3) e4 = t5 + b4 * p4;
              else {
                var M3 = e4;
                e4 = b4 * Math.ceil(e4 / b4), Math.abs(e4 - t5) / m3.getGCD(x5, b4) > a4 && (e4 = t5 + b4 * g5, e4 += b4 * Math.ceil((M3 - e4) / b4));
              }
            } else if (h4.isMultipleYAxis && d3) {
              var I4 = b4 * Math.floor(t5 / b4), T5 = I4 + b4 * p4;
              T5 < e4 && (b4 *= 2), T5 = e4, e4 = (t5 = I4) + b4 * p4, x5 = Math.abs(e4 - t5), t5 > 0 && t5 < Math.abs(T5 - e4) && (t5 = 0, e4 = b4 * p4), e4 < 0 && -e4 < Math.abs(I4 - t5) && (e4 = 0, t5 = -b4 * p4);
            } else t5 = b4 * Math.floor(t5 / b4), e4 = b4 * Math.ceil(e4 / b4);
            x5 = Math.abs(e4 - t5), b4 = m3.getGCD(x5, b4), p4 = Math.round(x5 / b4);
          }
          if (d3 || s4 || r4 || (p4 = Math.ceil((x5 - n3) / (b4 + n3))) > 16 && m3.getPrimeFactors(p4).length < 2 && p4++, !d3 && i4.forceNiceScale && 0 === h4.yValueDecimal && p4 > x5 && (p4 = x5, b4 = Math.round(x5 / p4)), p4 > a4 && (!d3 && !c4 || i4.forceNiceScale)) {
            var z4 = m3.getPrimeFactors(p4), X3 = z4.length - 1, E3 = p4;
            t: for (var Y2 = 0; Y2 < X3; Y2++) for (var R2 = 0; R2 <= X3 - Y2; R2++) {
              for (var F5 = Math.min(R2 + Y2, X3), D4 = E3, H4 = 1, O3 = R2; O3 <= F5; O3++) H4 *= z4[O3];
              if ((D4 /= H4) < a4) {
                E3 = D4;
                break t;
              }
            }
            b4 = E3 === p4 ? x5 : x5 / E3, p4 = Math.round(x5 / b4);
          }
          h4.isMultipleYAxis && 0 == h4.multiAxisTickAmount && h4.ignoreYAxisIndexes.indexOf(o3) < 0 && (h4.multiAxisTickAmount = p4);
          var N4 = t5 - b4, W3 = b4 * n3;
          do {
            N4 += b4, f4.push(m3.stripNumber(N4, 7));
          } while (e4 - N4 > W3);
          return { result: f4, niceMin: f4[0], niceMax: f4[f4.length - 1] };
        } }, { key: "linearScale", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s4 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r4 = Math.abs(e4 - t5), o3 = [];
          if (t5 === e4) return { result: o3 = [t5], niceMin: o3[0], niceMax: o3[o3.length - 1] };
          "dataPoints" === (i4 = this._adjustTicksForSmallRange(i4, a4, r4)) && (i4 = this.w.globals.dataPoints - 1), s4 || (s4 = r4 / i4), s4 = Math.round(10 * (s4 + Number.EPSILON)) / 10, i4 === Number.MAX_VALUE && (i4 = 5, s4 = 1);
          for (var n3 = t5; i4 >= 0; ) o3.push(n3), n3 = m3.preciseAddition(n3, s4), i4 -= 1;
          return { result: o3, niceMin: o3[0], niceMax: o3[o3.length - 1] };
        } }, { key: "logarithmicScaleNice", value: function(t5, e4, i4) {
          e4 <= 0 && (e4 = Math.max(t5, i4)), t5 <= 0 && (t5 = Math.min(e4, i4));
          for (var a4 = [], s4 = Math.ceil(Math.log(e4) / Math.log(i4) + 1), r4 = Math.floor(Math.log(t5) / Math.log(i4)); r4 < s4; r4++) a4.push(Math.pow(i4, r4));
          return { result: a4, niceMin: a4[0], niceMax: a4[a4.length - 1] };
        } }, { key: "logarithmicScale", value: function(t5, e4, i4) {
          e4 <= 0 && (e4 = Math.max(t5, i4)), t5 <= 0 && (t5 = Math.min(e4, i4));
          for (var a4 = [], s4 = Math.log(e4) / Math.log(i4), r4 = Math.log(t5) / Math.log(i4), o3 = s4 - r4, n3 = Math.round(o3), l4 = o3 / n3, h4 = 0, c4 = r4; h4 < n3; h4++, c4 += l4) a4.push(Math.pow(i4, c4));
          return a4.push(Math.pow(i4, s4)), { result: a4, niceMin: t5, niceMax: e4 };
        } }, { key: "_adjustTicksForSmallRange", value: function(t5, e4, i4) {
          var a4 = t5;
          if (void 0 !== e4 && this.w.config.yaxis[e4].labels.formatter && void 0 === this.w.config.yaxis[e4].tickAmount) {
            var s4 = Number(this.w.config.yaxis[e4].labels.formatter(1));
            m3.isNumber(s4) && 0 === this.w.globals.yValueDecimal && (a4 = Math.ceil(i4));
          }
          return a4 < t5 ? a4 : t5;
        } }, { key: "setYScaleForIndex", value: function(t5, e4, i4) {
          var a4 = this.w.globals, s4 = this.w.config, r4 = a4.isBarHorizontal ? s4.xaxis : s4.yaxis[t5];
          void 0 === a4.yAxisScale[t5] && (a4.yAxisScale[t5] = []);
          var o3 = Math.abs(i4 - e4);
          r4.logarithmic && o3 <= 5 && (a4.invalidLogScale = true), r4.logarithmic && o3 > 5 ? (a4.allSeriesCollapsed = false, a4.yAxisScale[t5] = r4.forceNiceScale ? this.logarithmicScaleNice(e4, i4, r4.logBase) : this.logarithmicScale(e4, i4, r4.logBase)) : i4 !== -Number.MAX_VALUE && m3.isNumber(i4) && e4 !== Number.MAX_VALUE && m3.isNumber(e4) ? (a4.allSeriesCollapsed = false, a4.yAxisScale[t5] = this.niceScale(e4, i4, t5)) : a4.yAxisScale[t5] = this.niceScale(Number.MIN_VALUE, 0, t5);
        } }, { key: "setXScale", value: function(t5, e4) {
          var i4 = this.w, a4 = i4.globals, s4 = Math.abs(e4 - t5);
          if (e4 !== -Number.MAX_VALUE && m3.isNumber(e4)) {
            var r4 = a4.xTickAmount + 1;
            s4 < 10 && s4 > 1 && (r4 = s4), a4.xAxisScale = this.linearScale(t5, e4, r4, 0, i4.config.xaxis.stepSize);
          } else a4.xAxisScale = this.linearScale(0, 10, 10);
          return a4.xAxisScale;
        } }, { key: "scaleMultipleYAxes", value: function() {
          var t5 = this, e4 = this.w.config, i4 = this.w.globals;
          this.coreUtils.setSeriesYAxisMappings();
          var a4 = i4.seriesYAxisMap, s4 = i4.minYArr, r4 = i4.maxYArr;
          i4.allSeriesCollapsed = true, i4.barGroups = [], a4.forEach((function(a5, o3) {
            var n3 = [];
            a5.forEach((function(t6) {
              var i5 = e4.series[t6].group;
              n3.indexOf(i5) < 0 && n3.push(i5);
            })), a5.length > 0 ? (function() {
              var l4, h4, c4 = Number.MAX_VALUE, d3 = -Number.MAX_VALUE, g5 = c4, u4 = d3;
              if (e4.chart.stacked) !(function() {
                var t6 = new Array(i4.dataPoints).fill(0), s5 = [], r5 = [], f5 = [];
                n3.forEach((function() {
                  s5.push(t6.map((function() {
                    return Number.MIN_VALUE;
                  }))), r5.push(t6.map((function() {
                    return Number.MIN_VALUE;
                  }))), f5.push(t6.map((function() {
                    return Number.MIN_VALUE;
                  })));
                }));
                for (var p5 = function(t7) {
                  !l4 && e4.series[a5[t7]].type && (l4 = e4.series[a5[t7]].type);
                  var c5 = a5[t7];
                  h4 = e4.series[c5].group ? e4.series[c5].group : "axis-".concat(o3), !(i4.collapsedSeriesIndices.indexOf(c5) < 0 && i4.ancillaryCollapsedSeriesIndices.indexOf(c5) < 0) || (i4.allSeriesCollapsed = false, n3.forEach((function(t8, a6) {
                    if (e4.series[c5].group === t8) for (var o4 = 0; o4 < i4.series[c5].length; o4++) {
                      var n4 = i4.series[c5][o4];
                      n4 >= 0 ? r5[a6][o4] += n4 : f5[a6][o4] += n4, s5[a6][o4] += n4, g5 = Math.min(g5, n4), u4 = Math.max(u4, n4);
                    }
                  }))), "bar" !== l4 && "column" !== l4 || i4.barGroups.push(h4);
                }, x5 = 0; x5 < a5.length; x5++) p5(x5);
                l4 || (l4 = e4.chart.type), "bar" === l4 || "column" === l4 ? n3.forEach((function(t7, e5) {
                  c4 = Math.min(c4, Math.min.apply(null, f5[e5])), d3 = Math.max(d3, Math.max.apply(null, r5[e5]));
                })) : (n3.forEach((function(t7, e5) {
                  g5 = Math.min(g5, Math.min.apply(null, s5[e5])), u4 = Math.max(u4, Math.max.apply(null, s5[e5]));
                })), c4 = g5, d3 = u4), c4 === Number.MIN_VALUE && d3 === Number.MIN_VALUE && (d3 = -Number.MAX_VALUE);
              })();
              else for (var f4 = 0; f4 < a5.length; f4++) {
                var p4 = a5[f4];
                c4 = Math.min(c4, s4[p4]), d3 = Math.max(d3, r4[p4]), !(i4.collapsedSeriesIndices.indexOf(p4) < 0 && i4.ancillaryCollapsedSeriesIndices.indexOf(p4) < 0) || (i4.allSeriesCollapsed = false);
              }
              void 0 !== e4.yaxis[o3].min && (c4 = "function" == typeof e4.yaxis[o3].min ? e4.yaxis[o3].min(c4) : e4.yaxis[o3].min), void 0 !== e4.yaxis[o3].max && (d3 = "function" == typeof e4.yaxis[o3].max ? e4.yaxis[o3].max(d3) : e4.yaxis[o3].max), i4.barGroups = i4.barGroups.filter((function(t6, e5, i5) {
                return i5.indexOf(t6) === e5;
              })), t5.setYScaleForIndex(o3, c4, d3), a5.forEach((function(t6) {
                s4[t6] = i4.yAxisScale[o3].niceMin, r4[t6] = i4.yAxisScale[o3].niceMax;
              }));
            })() : t5.setYScaleForIndex(o3, 0, -Number.MAX_VALUE);
          }));
        } }]), t4;
      })();
      var J2 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.scales = new $3(e4);
        }
        return s3(t4, [{ key: "init", value: function() {
          this.setYRange(), this.setXRange(), this.setZRange();
        } }, { key: "getMinYMaxY", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s4 = this.w.config, r4 = this.w.globals, o3 = -Number.MAX_VALUE, n3 = Number.MIN_VALUE;
          null === a4 && (a4 = t5 + 1);
          var l4 = r4.series, h4 = l4, c4 = l4;
          "candlestick" === s4.chart.type ? (h4 = r4.seriesCandleL, c4 = r4.seriesCandleH) : "boxPlot" === s4.chart.type ? (h4 = r4.seriesCandleO, c4 = r4.seriesCandleC) : r4.isRangeData && (h4 = r4.seriesRangeStart, c4 = r4.seriesRangeEnd);
          var d3 = false;
          if (r4.seriesX.length >= a4) {
            var g5, u4 = null === (g5 = r4.brushSource) || void 0 === g5 ? void 0 : g5.w.config.chart.brush;
            (s4.chart.zoom.enabled && s4.chart.zoom.autoScaleYaxis || null != u4 && u4.enabled && null != u4 && u4.autoScaleYaxis) && (d3 = true);
          }
          for (var f4 = t5; f4 < a4; f4++) {
            r4.dataPoints = Math.max(r4.dataPoints, l4[f4].length);
            var p4 = s4.series[f4].type;
            r4.categoryLabels.length && (r4.dataPoints = r4.categoryLabels.filter((function(t6) {
              return void 0 !== t6;
            })).length), r4.labels.length && "datetime" !== s4.xaxis.type && 0 !== r4.series.reduce((function(t6, e5) {
              return t6 + e5.length;
            }), 0) && (r4.dataPoints = Math.max(r4.dataPoints, r4.labels.length));
            var x5 = 0, b4 = l4[f4].length - 1;
            if (d3) {
              if (s4.xaxis.min) for (; x5 < b4 && r4.seriesX[f4][x5] < s4.xaxis.min; x5++) ;
              if (s4.xaxis.max) for (; b4 > x5 && r4.seriesX[f4][b4] > s4.xaxis.max; b4--) ;
            }
            for (var v4 = x5; v4 <= b4 && v4 < r4.series[f4].length; v4++) {
              var y4 = l4[f4][v4];
              if (null !== y4 && m3.isNumber(y4)) {
                switch (void 0 !== c4[f4][v4] && (o3 = Math.max(o3, c4[f4][v4]), e4 = Math.min(e4, c4[f4][v4])), void 0 !== h4[f4][v4] && (e4 = Math.min(e4, h4[f4][v4]), i4 = Math.max(i4, h4[f4][v4])), p4) {
                  case "candlestick":
                    void 0 !== r4.seriesCandleC[f4][v4] && (o3 = Math.max(o3, r4.seriesCandleH[f4][v4]), e4 = Math.min(e4, r4.seriesCandleL[f4][v4]));
                    break;
                  case "boxPlot":
                    void 0 !== r4.seriesCandleC[f4][v4] && (o3 = Math.max(o3, r4.seriesCandleC[f4][v4]), e4 = Math.min(e4, r4.seriesCandleO[f4][v4]));
                }
                p4 && "candlestick" !== p4 && "boxPlot" !== p4 && "rangeArea" !== p4 && "rangeBar" !== p4 && (o3 = Math.max(o3, r4.series[f4][v4]), e4 = Math.min(e4, r4.series[f4][v4])), i4 = o3, r4.seriesGoals[f4] && r4.seriesGoals[f4][v4] && Array.isArray(r4.seriesGoals[f4][v4]) && r4.seriesGoals[f4][v4].forEach((function(t6) {
                  n3 !== Number.MIN_VALUE && (n3 = Math.min(n3, t6.value), e4 = n3), o3 = Math.max(o3, t6.value), i4 = o3;
                })), m3.isFloat(y4) && (y4 = m3.noExponents(y4), r4.yValueDecimal = Math.max(r4.yValueDecimal, y4.toString().split(".")[1].length)), n3 > h4[f4][v4] && h4[f4][v4] < 0 && (n3 = h4[f4][v4]);
              } else r4.hasNullValues = true;
            }
            "bar" !== p4 && "column" !== p4 || (n3 < 0 && o3 < 0 && (o3 = 0, i4 = Math.max(i4, 0)), n3 === Number.MIN_VALUE && (n3 = 0, e4 = Math.min(e4, 0)));
          }
          return "rangeBar" === s4.chart.type && r4.seriesRangeStart.length && r4.isBarHorizontal && (n3 = e4), "bar" === s4.chart.type && (n3 < 0 && o3 < 0 && (o3 = 0), n3 === Number.MIN_VALUE && (n3 = 0)), { minY: n3, maxY: o3, lowestY: e4, highestY: i4 };
        } }, { key: "setYRange", value: function() {
          var t5 = this.w.globals, e4 = this.w.config;
          t5.maxY = -Number.MAX_VALUE, t5.minY = Number.MIN_VALUE;
          var i4, a4 = Number.MAX_VALUE;
          if (t5.isMultipleYAxis) {
            a4 = Number.MAX_VALUE;
            for (var s4 = 0; s4 < t5.series.length; s4++) i4 = this.getMinYMaxY(s4), t5.minYArr[s4] = i4.lowestY, t5.maxYArr[s4] = i4.highestY, a4 = Math.min(a4, i4.lowestY);
          }
          if (i4 = this.getMinYMaxY(0, a4, null, t5.series.length), "bar" === e4.chart.type ? (t5.minY = i4.minY, t5.maxY = i4.maxY) : (t5.minY = i4.lowestY, t5.maxY = i4.highestY), a4 = i4.lowestY, e4.chart.stacked && this._setStackedMinMax(), "line" === e4.chart.type || "area" === e4.chart.type || "scatter" === e4.chart.type || "candlestick" === e4.chart.type || "boxPlot" === e4.chart.type || "rangeBar" === e4.chart.type && !t5.isBarHorizontal ? t5.minY === Number.MIN_VALUE && a4 !== -Number.MAX_VALUE && a4 !== t5.maxY && (t5.minY = a4) : t5.minY = t5.minY !== Number.MIN_VALUE ? Math.min(i4.minY, t5.minY) : i4.minY, e4.yaxis.forEach((function(e5, i5) {
            void 0 !== e5.max && ("number" == typeof e5.max ? t5.maxYArr[i5] = e5.max : "function" == typeof e5.max && (t5.maxYArr[i5] = e5.max(t5.isMultipleYAxis ? t5.maxYArr[i5] : t5.maxY)), t5.maxY = t5.maxYArr[i5]), void 0 !== e5.min && ("number" == typeof e5.min ? t5.minYArr[i5] = e5.min : "function" == typeof e5.min && (t5.minYArr[i5] = e5.min(t5.isMultipleYAxis ? t5.minYArr[i5] === Number.MIN_VALUE ? 0 : t5.minYArr[i5] : t5.minY)), t5.minY = t5.minYArr[i5]);
          })), t5.isBarHorizontal) {
            ["min", "max"].forEach((function(i5) {
              void 0 !== e4.xaxis[i5] && "number" == typeof e4.xaxis[i5] && ("min" === i5 ? t5.minY = e4.xaxis[i5] : t5.maxY = e4.xaxis[i5]);
            }));
          }
          return t5.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t5.minY = a4) : (this.scales.setYScaleForIndex(0, t5.minY, t5.maxY), t5.minY = t5.yAxisScale[0].niceMin, t5.maxY = t5.yAxisScale[0].niceMax, t5.minYArr[0] = t5.minY, t5.maxYArr[0] = t5.maxY), t5.barGroups = [], t5.lineGroups = [], t5.areaGroups = [], e4.series.forEach((function(i5) {
            switch (i5.type || e4.chart.type) {
              case "bar":
              case "column":
                t5.barGroups.push(i5.group);
                break;
              case "line":
                t5.lineGroups.push(i5.group);
                break;
              case "area":
                t5.areaGroups.push(i5.group);
            }
          })), t5.barGroups = t5.barGroups.filter((function(t6, e5, i5) {
            return i5.indexOf(t6) === e5;
          })), t5.lineGroups = t5.lineGroups.filter((function(t6, e5, i5) {
            return i5.indexOf(t6) === e5;
          })), t5.areaGroups = t5.areaGroups.filter((function(t6, e5, i5) {
            return i5.indexOf(t6) === e5;
          })), { minY: t5.minY, maxY: t5.maxY, minYArr: t5.minYArr, maxYArr: t5.maxYArr, yAxisScale: t5.yAxisScale };
        } }, { key: "setXRange", value: function() {
          var t5 = this.w.globals, e4 = this.w.config, i4 = "numeric" === e4.xaxis.type || "datetime" === e4.xaxis.type || "category" === e4.xaxis.type && !t5.noLabelsProvided || t5.noLabelsProvided || t5.isXNumeric;
          if (t5.isXNumeric && (function() {
            for (var e5 = 0; e5 < t5.series.length; e5++) if (t5.labels[e5]) for (var i5 = 0; i5 < t5.labels[e5].length; i5++) null !== t5.labels[e5][i5] && m3.isNumber(t5.labels[e5][i5]) && (t5.maxX = Math.max(t5.maxX, t5.labels[e5][i5]), t5.initialMaxX = Math.max(t5.maxX, t5.labels[e5][i5]), t5.minX = Math.min(t5.minX, t5.labels[e5][i5]), t5.initialMinX = Math.min(t5.minX, t5.labels[e5][i5]));
          })(), t5.noLabelsProvided && 0 === e4.xaxis.categories.length && (t5.maxX = t5.labels[t5.labels.length - 1], t5.initialMaxX = t5.labels[t5.labels.length - 1], t5.minX = 1, t5.initialMinX = 1), t5.isXNumeric || t5.noLabelsProvided || t5.dataFormatXNumeric) {
            var a4 = 10;
            if (void 0 === e4.xaxis.tickAmount) a4 = Math.round(t5.svgWidth / 150), "numeric" === e4.xaxis.type && t5.dataPoints < 30 && (a4 = t5.dataPoints - 1), a4 > t5.dataPoints && 0 !== t5.dataPoints && (a4 = t5.dataPoints - 1);
            else if ("dataPoints" === e4.xaxis.tickAmount) {
              if (t5.series.length > 1 && (a4 = t5.series[t5.maxValsInArrayIndex].length - 1), t5.isXNumeric) {
                var s4 = t5.maxX - t5.minX;
                s4 < 30 && (a4 = s4 - 1);
              }
            } else a4 = e4.xaxis.tickAmount;
            if (t5.xTickAmount = a4, void 0 !== e4.xaxis.max && "number" == typeof e4.xaxis.max && (t5.maxX = e4.xaxis.max), void 0 !== e4.xaxis.min && "number" == typeof e4.xaxis.min && (t5.minX = e4.xaxis.min), void 0 !== e4.xaxis.range && (t5.minX = t5.maxX - e4.xaxis.range), t5.minX !== Number.MAX_VALUE && t5.maxX !== -Number.MAX_VALUE) if (e4.xaxis.convertedCatToNumeric && !t5.dataFormatXNumeric) {
              for (var r4 = [], o3 = t5.minX - 1; o3 < t5.maxX; o3++) r4.push(o3 + 1);
              t5.xAxisScale = { result: r4, niceMin: r4[0], niceMax: r4[r4.length - 1] };
            } else t5.xAxisScale = this.scales.setXScale(t5.minX, t5.maxX);
            else t5.xAxisScale = this.scales.linearScale(0, a4, a4, 0, e4.xaxis.stepSize), t5.noLabelsProvided && t5.labels.length > 0 && (t5.xAxisScale = this.scales.linearScale(1, t5.labels.length, a4 - 1, 0, e4.xaxis.stepSize), t5.seriesX = t5.labels.slice());
            i4 && (t5.labels = t5.xAxisScale.result.slice());
          }
          return t5.isBarHorizontal && t5.labels.length && (t5.xTickAmount = t5.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t5.minX, maxX: t5.maxX };
        } }, { key: "setZRange", value: function() {
          var t5 = this.w.globals;
          if (t5.isDataXYZ) {
            for (var e4 = 0; e4 < t5.series.length; e4++) if (void 0 !== t5.seriesZ[e4]) for (var i4 = 0; i4 < t5.seriesZ[e4].length; i4++) null !== t5.seriesZ[e4][i4] && m3.isNumber(t5.seriesZ[e4][i4]) && (t5.maxZ = Math.max(t5.maxZ, t5.seriesZ[e4][i4]), t5.minZ = Math.min(t5.minZ, t5.seriesZ[e4][i4]));
          }
        } }, { key: "_handleSingleDataPoint", value: function() {
          var t5 = this.w.globals, e4 = this.w.config;
          if (t5.minX === t5.maxX) {
            var i4 = new L3(this.ctx);
            if ("datetime" === e4.xaxis.type) {
              var a4 = i4.getDate(t5.minX);
              e4.xaxis.labels.datetimeUTC ? a4.setUTCDate(a4.getUTCDate() - 2) : a4.setDate(a4.getDate() - 2), t5.minX = new Date(a4).getTime();
              var s4 = i4.getDate(t5.maxX);
              e4.xaxis.labels.datetimeUTC ? s4.setUTCDate(s4.getUTCDate() + 2) : s4.setDate(s4.getDate() + 2), t5.maxX = new Date(s4).getTime();
            } else ("numeric" === e4.xaxis.type || "category" === e4.xaxis.type && !t5.noLabelsProvided) && (t5.minX = t5.minX - 2, t5.initialMinX = t5.minX, t5.maxX = t5.maxX + 2, t5.initialMaxX = t5.maxX);
          }
        } }, { key: "_getMinXDiff", value: function() {
          var t5 = this.w.globals;
          t5.isXNumeric && t5.seriesX.forEach((function(e4, i4) {
            1 === e4.length && e4.push(t5.seriesX[t5.maxValsInArrayIndex][t5.seriesX[t5.maxValsInArrayIndex].length - 1]);
            var a4 = e4.slice();
            a4.sort((function(t6, e5) {
              return t6 - e5;
            })), a4.forEach((function(e5, i5) {
              if (i5 > 0) {
                var s4 = e5 - a4[i5 - 1];
                s4 > 0 && (t5.minXDiff = Math.min(s4, t5.minXDiff));
              }
            })), 1 !== t5.dataPoints && t5.minXDiff !== Number.MAX_VALUE || (t5.minXDiff = 0.5);
          }));
        } }, { key: "_setStackedMinMax", value: function() {
          var t5 = this, e4 = this.w.globals;
          if (e4.series.length) {
            var i4 = e4.seriesGroups;
            i4.length || (i4 = [this.w.globals.seriesNames.map((function(t6) {
              return t6;
            }))]);
            var a4 = {}, s4 = {};
            i4.forEach((function(i5) {
              a4[i5] = [], s4[i5] = [], t5.w.config.series.map((function(t6, a5) {
                return i5.indexOf(e4.seriesNames[a5]) > -1 ? a5 : null;
              })).filter((function(t6) {
                return null !== t6;
              })).forEach((function(r4) {
                for (var o3 = 0; o3 < e4.series[e4.maxValsInArrayIndex].length; o3++) {
                  var n3, l4, h4, c4;
                  void 0 === a4[i5][o3] && (a4[i5][o3] = 0, s4[i5][o3] = 0), (t5.w.config.chart.stacked && !e4.comboCharts || t5.w.config.chart.stacked && e4.comboCharts && (!t5.w.config.chart.stackOnlyBar || "bar" === (null === (n3 = t5.w.config.series) || void 0 === n3 || null === (l4 = n3[r4]) || void 0 === l4 ? void 0 : l4.type) || "column" === (null === (h4 = t5.w.config.series) || void 0 === h4 || null === (c4 = h4[r4]) || void 0 === c4 ? void 0 : c4.type))) && null !== e4.series[r4][o3] && m3.isNumber(e4.series[r4][o3]) && (e4.series[r4][o3] > 0 ? a4[i5][o3] += parseFloat(e4.series[r4][o3]) + 1e-4 : s4[i5][o3] += parseFloat(e4.series[r4][o3]));
                }
              }));
            })), Object.entries(a4).forEach((function(t6) {
              var i5 = f3(t6, 1)[0];
              a4[i5].forEach((function(t7, r4) {
                e4.maxY = Math.max(e4.maxY, a4[i5][r4]), e4.minY = Math.min(e4.minY, s4[i5][r4]);
              }));
            }));
          }
        } }]), t4;
      })();
      var Q2 = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = e4, this.elgrid = a4, this.w = e4.w;
          var s4 = this.w;
          this.xaxisFontSize = s4.config.xaxis.labels.style.fontSize, this.axisFontFamily = s4.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s4.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s4.config.chart.type && s4.config.plotOptions.bar.horizontal, this.xAxisoffX = "bottom" === s4.config.xaxis.position ? s4.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new M2(e4);
        }
        return s3(t4, [{ key: "drawYaxis", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a4 = e4.config.yaxis[t5].labels.style, s4 = a4.fontSize, r4 = a4.fontFamily, o3 = a4.fontWeight, n3 = i4.group({ class: "apexcharts-yaxis", rel: t5, transform: "translate(".concat(e4.globals.translateYAxisX[t5], ", 0)") });
          if (this.axesUtils.isYAxisHidden(t5)) return n3;
          var l4 = i4.group({ class: "apexcharts-yaxis-texts-g" });
          n3.add(l4);
          var h4 = e4.globals.yAxisScale[t5].result.length - 1, c4 = e4.globals.gridHeight / h4, d3 = e4.globals.yLabelFormatters[t5], g5 = this.axesUtils.checkForReversedLabels(t5, e4.globals.yAxisScale[t5].result.slice());
          if (e4.config.yaxis[t5].labels.show) {
            var u4 = e4.globals.translateY + e4.config.yaxis[t5].labels.offsetY;
            e4.globals.isBarHorizontal ? u4 = 0 : "heatmap" === e4.config.chart.type && (u4 -= c4 / 2), u4 += parseInt(s4, 10) / 3;
            for (var f4 = h4; f4 >= 0; f4--) {
              var p4 = d3(g5[f4], f4, e4), x5 = e4.config.yaxis[t5].labels.padding;
              e4.config.yaxis[t5].opposite && 0 !== e4.config.yaxis.length && (x5 *= -1);
              var b4 = this.getTextAnchor(e4.config.yaxis[t5].labels.align, e4.config.yaxis[t5].opposite), v4 = this.axesUtils.getYAxisForeColor(a4.colors, t5), y4 = Array.isArray(v4) ? v4[f4] : v4, w5 = m3.listToArray(e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t5, "'] .apexcharts-yaxis-label tspan"))).map((function(t6) {
                return t6.textContent;
              })), A4 = i4.drawText({ x: x5, y: u4, text: w5.includes(p4) && !e4.config.yaxis[t5].labels.showDuplicates ? "" : p4, textAnchor: b4, fontSize: s4, fontFamily: r4, fontWeight: o3, maxWidth: e4.config.yaxis[t5].labels.maxWidth, foreColor: y4, isPlainText: false, cssClass: "apexcharts-yaxis-label ".concat(a4.cssClass) });
              l4.add(A4), this.addTooltip(A4, p4), 0 !== e4.config.yaxis[t5].labels.rotate && this.rotateLabel(i4, A4, firstLabel, e4.config.yaxis[t5].labels.rotate), u4 += c4;
            }
          }
          return this.addYAxisTitle(i4, n3, t5), this.addAxisBorder(i4, n3, t5, h4, c4), n3;
        } }, { key: "getTextAnchor", value: function(t5, e4) {
          return "left" === t5 ? "start" : "center" === t5 ? "middle" : "right" === t5 ? "end" : e4 ? "start" : "end";
        } }, { key: "addTooltip", value: function(t5, e4) {
          var i4 = document.createElementNS(this.w.globals.SVGNS, "title");
          i4.textContent = Array.isArray(e4) ? e4.join(" ") : e4, t5.node.appendChild(i4);
        } }, { key: "rotateLabel", value: function(t5, e4, i4, a4) {
          var s4 = t5.rotateAroundCenter(i4.node), r4 = t5.rotateAroundCenter(e4.node);
          e4.node.setAttribute("transform", "rotate(".concat(a4, " ").concat(s4.x, " ").concat(r4.y, ")"));
        } }, { key: "addYAxisTitle", value: function(t5, e4, i4) {
          var a4 = this.w;
          if (void 0 !== a4.config.yaxis[i4].title.text) {
            var s4 = t5.group({ class: "apexcharts-yaxis-title" }), r4 = a4.config.yaxis[i4].opposite ? a4.globals.translateYAxisX[i4] : 0, o3 = t5.drawText({ x: r4, y: a4.globals.gridHeight / 2 + a4.globals.translateY + a4.config.yaxis[i4].title.offsetY, text: a4.config.yaxis[i4].title.text, textAnchor: "end", foreColor: a4.config.yaxis[i4].title.style.color, fontSize: a4.config.yaxis[i4].title.style.fontSize, fontWeight: a4.config.yaxis[i4].title.style.fontWeight, fontFamily: a4.config.yaxis[i4].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(a4.config.yaxis[i4].title.style.cssClass) });
            s4.add(o3), e4.add(s4);
          }
        } }, { key: "addAxisBorder", value: function(t5, e4, i4, a4, s4) {
          var r4 = this.w, o3 = r4.config.yaxis[i4].axisBorder, n3 = 31 + o3.offsetX;
          if (r4.config.yaxis[i4].opposite && (n3 = -31 - o3.offsetX), o3.show) {
            var l4 = t5.drawLine(n3, r4.globals.translateY + o3.offsetY - 2, n3, r4.globals.gridHeight + r4.globals.translateY + o3.offsetY + 2, o3.color, 0, o3.width);
            e4.add(l4);
          }
          r4.config.yaxis[i4].axisTicks.show && this.axesUtils.drawYAxisTicks(n3, a4, o3, r4.config.yaxis[i4].axisTicks, i4, s4, e4);
        } }, { key: "drawYaxisInversed", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a4 = i4.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s4 = i4.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e4.globals.translateXAxisX, ", ").concat(e4.globals.translateXAxisY, ")") });
          a4.add(s4);
          var r4 = e4.globals.yAxisScale[t5].result.length - 1, o3 = e4.globals.gridWidth / r4 + 0.1, n3 = o3 + e4.config.xaxis.labels.offsetX, l4 = e4.globals.xLabelFormatter, h4 = this.axesUtils.checkForReversedLabels(t5, e4.globals.yAxisScale[t5].result.slice()), c4 = e4.globals.timescaleLabels;
          if (c4.length > 0 && (this.xaxisLabels = c4.slice(), r4 = (h4 = c4.slice()).length), e4.config.xaxis.labels.show) for (var d3 = c4.length ? 0 : r4; c4.length ? d3 < c4.length : d3 >= 0; c4.length ? d3++ : d3--) {
            var g5 = l4(h4[d3], d3, e4), u4 = e4.globals.gridWidth + e4.globals.padHorizontal - (n3 - o3 + e4.config.xaxis.labels.offsetX);
            if (c4.length) {
              var f4 = this.axesUtils.getLabel(h4, c4, u4, d3, this.drawnLabels, this.xaxisFontSize);
              u4 = f4.x, g5 = f4.text, this.drawnLabels.push(f4.text), 0 === d3 && e4.globals.skipFirstTimelinelabel && (g5 = ""), d3 === h4.length - 1 && e4.globals.skipLastTimelinelabel && (g5 = "");
            }
            var p4 = i4.drawText({ x: u4, y: this.xAxisoffX + e4.config.xaxis.labels.offsetY + 30 - ("top" === e4.config.xaxis.position ? e4.globals.xAxisHeight + e4.config.xaxis.axisTicks.height - 2 : 0), text: g5, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t5] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e4.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label ".concat(e4.config.xaxis.labels.style.cssClass) });
            s4.add(p4), p4.tspan(g5), this.addTooltip(p4, g5), n3 += o3;
          }
          return this.inversedYAxisTitleText(a4), this.inversedYAxisBorder(a4), a4;
        } }, { key: "inversedYAxisBorder", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a4 = e4.config.xaxis.axisBorder;
          if (a4.show) {
            var s4 = 0;
            "bar" === e4.config.chart.type && e4.globals.isXNumeric && (s4 -= 15);
            var r4 = i4.drawLine(e4.globals.padHorizontal + s4 + a4.offsetX, this.xAxisoffX, e4.globals.gridWidth, this.xAxisoffX, a4.color, 0, a4.height);
            this.elgrid && this.elgrid.elGridBorders && e4.config.grid.show ? this.elgrid.elGridBorders.add(r4) : t5.add(r4);
          }
        } }, { key: "inversedYAxisTitleText", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx);
          if (void 0 !== e4.config.xaxis.title.text) {
            var a4 = i4.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s4 = i4.drawText({ x: e4.globals.gridWidth / 2 + e4.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e4.config.xaxis.title.style.fontSize) + e4.config.xaxis.title.offsetY + 20, text: e4.config.xaxis.title.text, textAnchor: "middle", fontSize: e4.config.xaxis.title.style.fontSize, fontFamily: e4.config.xaxis.title.style.fontFamily, fontWeight: e4.config.xaxis.title.style.fontWeight, foreColor: e4.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(e4.config.xaxis.title.style.cssClass) });
            a4.add(s4), t5.add(a4);
          }
        } }, { key: "yAxisTitleRotate", value: function(t5, e4) {
          var i4 = this.w, a4 = new k3(this.ctx), s4 = i4.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t5, "'] .apexcharts-yaxis-texts-g")), r4 = s4 ? s4.getBoundingClientRect() : { width: 0, height: 0 }, o3 = i4.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t5, "'] .apexcharts-yaxis-title text")), n3 = o3 ? o3.getBoundingClientRect() : { width: 0, height: 0 };
          if (o3) {
            var l4 = this.xPaddingForYAxisTitle(t5, r4, n3, e4);
            o3.setAttribute("x", l4.xPos - (e4 ? 10 : 0));
            var h4 = a4.rotateAroundCenter(o3);
            o3.setAttribute("transform", "rotate(".concat(e4 ? -1 * i4.config.yaxis[t5].title.rotate : i4.config.yaxis[t5].title.rotate, " ").concat(h4.x, " ").concat(h4.y, ")"));
          }
        } }, { key: "xPaddingForYAxisTitle", value: function(t5, e4, i4, a4) {
          var s4 = this.w, r4 = 0, o3 = 10;
          return void 0 === s4.config.yaxis[t5].title.text || t5 < 0 ? { xPos: r4, padd: 0 } : (a4 ? r4 = e4.width + s4.config.yaxis[t5].title.offsetX + i4.width / 2 + o3 / 2 : (r4 = -1 * e4.width + s4.config.yaxis[t5].title.offsetX + o3 / 2 + i4.width / 2, s4.globals.isBarHorizontal && (o3 = 25, r4 = -1 * e4.width - s4.config.yaxis[t5].title.offsetX - o3)), { xPos: r4, padd: o3 });
        } }, { key: "setYAxisXPosition", value: function(t5, e4) {
          var i4 = this.w, a4 = 0, s4 = 0, r4 = 18, o3 = 1;
          i4.config.yaxis.length > 1 && (this.multipleYs = true), i4.config.yaxis.forEach((function(n3, l4) {
            var h4 = i4.globals.ignoreYAxisIndexes.includes(l4) || !n3.show || n3.floating || 0 === t5[l4].width, c4 = t5[l4].width + e4[l4].width;
            n3.opposite ? i4.globals.isBarHorizontal ? (s4 = i4.globals.gridWidth + i4.globals.translateX - 1, i4.globals.translateYAxisX[l4] = s4 - n3.labels.offsetX) : (s4 = i4.globals.gridWidth + i4.globals.translateX + o3, h4 || (o3 += c4 + 20), i4.globals.translateYAxisX[l4] = s4 - n3.labels.offsetX + 20) : (a4 = i4.globals.translateX - r4, h4 || (r4 += c4 + 20), i4.globals.translateYAxisX[l4] = a4 + n3.labels.offsetX);
          }));
        } }, { key: "setYAxisTextAlignments", value: function() {
          var t5 = this.w;
          m3.listToArray(t5.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach((function(e4, i4) {
            var a4 = t5.config.yaxis[i4];
            if (a4 && !a4.floating && void 0 !== a4.labels.align) {
              var s4 = t5.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i4, "'] .apexcharts-yaxis-texts-g")), r4 = m3.listToArray(t5.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i4, "'] .apexcharts-yaxis-label"))), o3 = s4.getBoundingClientRect();
              r4.forEach((function(t6) {
                t6.setAttribute("text-anchor", a4.labels.align);
              })), "left" !== a4.labels.align || a4.opposite ? "center" === a4.labels.align ? s4.setAttribute("transform", "translate(".concat(o3.width / 2 * (a4.opposite ? 1 : -1), ", 0)")) : "right" === a4.labels.align && a4.opposite && s4.setAttribute("transform", "translate(".concat(o3.width, ", 0)")) : s4.setAttribute("transform", "translate(-".concat(o3.width, ", 0)"));
            }
          }));
        } }]), t4;
      })();
      var K2 = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.documentEvent = m3.bind(this.documentEvent, this);
        }
        return s3(t4, [{ key: "addEventListener", value: function(t5, e4) {
          var i4 = this.w;
          i4.globals.events.hasOwnProperty(t5) ? i4.globals.events[t5].push(e4) : i4.globals.events[t5] = [e4];
        } }, { key: "removeEventListener", value: function(t5, e4) {
          var i4 = this.w;
          if (i4.globals.events.hasOwnProperty(t5)) {
            var a4 = i4.globals.events[t5].indexOf(e4);
            -1 !== a4 && i4.globals.events[t5].splice(a4, 1);
          }
        } }, { key: "fireEvent", value: function(t5, e4) {
          var i4 = this.w;
          if (i4.globals.events.hasOwnProperty(t5)) {
            e4 && e4.length || (e4 = []);
            for (var a4 = i4.globals.events[t5], s4 = a4.length, r4 = 0; r4 < s4; r4++) a4[r4].apply(null, e4);
          }
        } }, { key: "setupEventHandlers", value: function() {
          var t5 = this, e4 = this.w, i4 = this.ctx, a4 = e4.globals.dom.baseEl.querySelector(e4.globals.chartClass);
          this.ctx.eventList.forEach((function(t6) {
            a4.addEventListener(t6, (function(t7) {
              var a5 = Object.assign({}, e4, { seriesIndex: e4.globals.axisCharts ? e4.globals.capturedSeriesIndex : 0, dataPointIndex: e4.globals.capturedDataPointIndex });
              "mousemove" === t7.type || "touchmove" === t7.type ? "function" == typeof e4.config.chart.events.mouseMove && e4.config.chart.events.mouseMove(t7, i4, a5) : "mouseleave" === t7.type || "touchleave" === t7.type ? "function" == typeof e4.config.chart.events.mouseLeave && e4.config.chart.events.mouseLeave(t7, i4, a5) : ("mouseup" === t7.type && 1 === t7.which || "touchend" === t7.type) && ("function" == typeof e4.config.chart.events.click && e4.config.chart.events.click(t7, i4, a5), i4.ctx.events.fireEvent("click", [t7, i4, a5]));
            }), { capture: false, passive: true });
          })), this.ctx.eventList.forEach((function(i5) {
            e4.globals.dom.baseEl.addEventListener(i5, t5.documentEvent, { passive: true });
          })), this.ctx.core.setupBrushHandler();
        } }, { key: "documentEvent", value: function(t5) {
          var e4 = this.w, i4 = t5.target.className;
          if ("click" === t5.type) {
            var a4 = e4.globals.dom.baseEl.querySelector(".apexcharts-menu");
            a4 && a4.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i4 && a4.classList.remove("apexcharts-menu-open");
          }
          e4.globals.clientX = "touchmove" === t5.type ? t5.touches[0].clientX : t5.clientX, e4.globals.clientY = "touchmove" === t5.type ? t5.touches[0].clientY : t5.clientY;
        } }]), t4;
      })();
      var tt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "setCurrentLocaleValues", value: function(t5) {
          var e4 = this.w.config.chart.locales;
          window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e4 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
          var i4 = e4.filter((function(e5) {
            return e5.name === t5;
          }))[0];
          if (!i4) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
          var a4 = m3.extend(z3, i4);
          this.w.globals.locale = a4.options;
        } }]), t4;
      })();
      var et = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "drawAxis", value: function(t5, e4) {
          var i4, a4, s4 = this, r4 = this.w.globals, o3 = this.w.config, n3 = new q3(this.ctx, e4), l4 = new Q2(this.ctx, e4);
          r4.axisCharts && "radar" !== t5 && (r4.isBarHorizontal ? (a4 = l4.drawYaxisInversed(0), i4 = n3.drawXaxisInversed(0), r4.dom.elGraphical.add(i4), r4.dom.elGraphical.add(a4)) : (i4 = n3.drawXaxis(), r4.dom.elGraphical.add(i4), o3.yaxis.map((function(t6, e5) {
            if (-1 === r4.ignoreYAxisIndexes.indexOf(e5) && (a4 = l4.drawYaxis(e5), r4.dom.Paper.add(a4), "back" === s4.w.config.grid.position)) {
              var i5 = r4.dom.Paper.children()[1];
              i5.remove(), r4.dom.Paper.add(i5);
            }
          }))));
        } }]), t4;
      })();
      var it = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "drawXCrosshairs", value: function() {
          var t5 = this.w, e4 = new k3(this.ctx), i4 = new w4(this.ctx), a4 = t5.config.xaxis.crosshairs.fill.gradient, s4 = t5.config.xaxis.crosshairs.dropShadow, r4 = t5.config.xaxis.crosshairs.fill.type, o3 = a4.colorFrom, n3 = a4.colorTo, l4 = a4.opacityFrom, h4 = a4.opacityTo, c4 = a4.stops, d3 = s4.enabled, g5 = s4.left, u4 = s4.top, f4 = s4.blur, p4 = s4.color, x5 = s4.opacity, b4 = t5.config.xaxis.crosshairs.fill.color;
          if (t5.config.xaxis.crosshairs.show) {
            "gradient" === r4 && (b4 = e4.drawGradient("vertical", o3, n3, l4, h4, null, c4, null));
            var v4 = e4.drawRect();
            1 === t5.config.xaxis.crosshairs.width && (v4 = e4.drawLine());
            var y4 = t5.globals.gridHeight;
            (!m3.isNumber(y4) || y4 < 0) && (y4 = 0);
            var A4 = t5.config.xaxis.crosshairs.width;
            (!m3.isNumber(A4) || A4 < 0) && (A4 = 0), v4.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: y4, width: A4, height: y4, fill: b4, filter: "none", "fill-opacity": t5.config.xaxis.crosshairs.opacity, stroke: t5.config.xaxis.crosshairs.stroke.color, "stroke-width": t5.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t5.config.xaxis.crosshairs.stroke.dashArray }), d3 && (v4 = i4.dropShadow(v4, { left: g5, top: u4, blur: f4, color: p4, opacity: x5 })), t5.globals.dom.elGraphical.add(v4);
          }
        } }, { key: "drawYCrosshairs", value: function() {
          var t5 = this.w, e4 = new k3(this.ctx), i4 = t5.config.yaxis[0].crosshairs, a4 = t5.globals.barPadForNumericAxis;
          if (t5.config.yaxis[0].crosshairs.show) {
            var s4 = e4.drawLine(-a4, 0, t5.globals.gridWidth + a4, 0, i4.stroke.color, i4.stroke.dashArray, i4.stroke.width);
            s4.attr({ class: "apexcharts-ycrosshairs" }), t5.globals.dom.elGraphical.add(s4);
          }
          var r4 = e4.drawLine(-a4, 0, t5.globals.gridWidth + a4, 0, i4.stroke.color, 0, 0);
          r4.attr({ class: "apexcharts-ycrosshairs-hidden" }), t5.globals.dom.elGraphical.add(r4);
        } }]), t4;
      })();
      var at = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "checkResponsiveConfig", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = i4.config;
          if (0 !== a4.responsive.length) {
            var s4 = a4.responsive.slice();
            s4.sort((function(t6, e5) {
              return t6.breakpoint > e5.breakpoint ? 1 : e5.breakpoint > t6.breakpoint ? -1 : 0;
            })).reverse();
            var r4 = new D3({}), o3 = function() {
              var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a5 = s4[0].breakpoint, o4 = window.innerWidth > 0 ? window.innerWidth : screen.width;
              if (o4 > a5) {
                var n4 = m3.clone(i4.globals.initialConfig);
                n4.series = m3.clone(i4.config.series);
                var l4 = A3.extendArrayProps(r4, n4, i4);
                t6 = m3.extend(l4, t6), t6 = m3.extend(i4.config, t6), e4.overrideResponsiveOptions(t6);
              } else for (var h4 = 0; h4 < s4.length; h4++) o4 < s4[h4].breakpoint && (t6 = A3.extendArrayProps(r4, s4[h4].options, i4), t6 = m3.extend(i4.config, t6), e4.overrideResponsiveOptions(t6));
            };
            if (t5) {
              var n3 = A3.extendArrayProps(r4, t5, i4);
              n3 = m3.extend(i4.config, n3), o3(n3 = m3.extend(n3, t5));
            } else o3({});
          }
        } }, { key: "overrideResponsiveOptions", value: function(t5) {
          var e4 = new D3(t5).init({ responsiveOverride: true });
          this.w.config = e4;
        } }]), t4;
      })();
      var st = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.colors = [], this.isColorFn = false, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
        }
        return s3(t4, [{ key: "checkHeatmapDistributed", value: function() {
          var t5 = this.w.config, e4 = t5.chart, i4 = t5.plotOptions;
          return "treemap" === e4.type && i4.treemap && i4.treemap.distributed || "heatmap" === e4.type && i4.heatmap && i4.heatmap.distributed;
        } }, { key: "checkBarDistributed", value: function() {
          var t5 = this.w.config, e4 = t5.chart, i4 = t5.plotOptions;
          return i4.bar && i4.bar.distributed && ("bar" === e4.type || "rangeBar" === e4.type);
        } }, { key: "init", value: function() {
          this.setDefaultColors();
        } }, { key: "setDefaultColors", value: function() {
          var t5 = this.w, e4 = new m3();
          t5.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t5.config.theme.mode));
          var i4 = p3(t5.config.colors || t5.config.fill.colors || []);
          t5.globals.colors = this.getColors(i4), this.applySeriesColors(t5.globals.seriesColors, t5.globals.colors), t5.config.theme.monochrome.enabled && (t5.globals.colors = this.getMonochromeColors(t5.config.theme.monochrome, t5.globals.series, e4));
          var a4 = t5.globals.colors.slice();
          this.pushExtraColors(t5.globals.colors), this.applyColorTypes(["fill", "stroke"], a4), this.applyDataLabelsColors(a4), this.applyRadarPolygonsColors(), this.applyMarkersColors(a4);
        } }, { key: "getColors", value: function(t5) {
          var e4 = this, i4 = this.w;
          return t5 && 0 !== t5.length ? Array.isArray(t5) && t5.length > 0 && "function" == typeof t5[0] ? (this.isColorFn = true, i4.config.series.map((function(a4, s4) {
            var r4 = t5[s4] || t5[0];
            return "function" == typeof r4 ? r4({ value: i4.globals.axisCharts ? i4.globals.series[s4][0] || 0 : i4.globals.series[s4], seriesIndex: s4, dataPointIndex: s4, w: e4.w }) : r4;
          }))) : t5 : this.predefined();
        } }, { key: "applySeriesColors", value: function(t5, e4) {
          t5.forEach((function(t6, i4) {
            t6 && (e4[i4] = t6);
          }));
        } }, { key: "getMonochromeColors", value: function(t5, e4, i4) {
          var a4 = t5.color, s4 = t5.shadeIntensity, r4 = t5.shadeTo, o3 = this.isBarDistributed || this.isHeatmapDistributed ? e4[0].length * e4.length : e4.length, n3 = 1 / (o3 / s4), l4 = 0;
          return Array.from({ length: o3 }, (function() {
            var t6 = "dark" === r4 ? i4.shadeColor(-1 * l4, a4) : i4.shadeColor(l4, a4);
            return l4 += n3, t6;
          }));
        } }, { key: "applyColorTypes", value: function(t5, e4) {
          var i4 = this, a4 = this.w;
          t5.forEach((function(t6) {
            a4.globals[t6].colors = void 0 === a4.config[t6].colors ? i4.isColorFn ? a4.config.colors : e4 : a4.config[t6].colors.slice(), i4.pushExtraColors(a4.globals[t6].colors);
          }));
        } }, { key: "applyDataLabelsColors", value: function(t5) {
          var e4 = this.w;
          e4.globals.dataLabels.style.colors = void 0 === e4.config.dataLabels.style.colors ? t5 : e4.config.dataLabels.style.colors.slice(), this.pushExtraColors(e4.globals.dataLabels.style.colors, 50);
        } }, { key: "applyRadarPolygonsColors", value: function() {
          var t5 = this.w;
          t5.globals.radarPolygons.fill.colors = void 0 === t5.config.plotOptions.radar.polygons.fill.colors ? ["dark" === t5.config.theme.mode ? "#424242" : "none"] : t5.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(t5.globals.radarPolygons.fill.colors, 20);
        } }, { key: "applyMarkersColors", value: function(t5) {
          var e4 = this.w;
          e4.globals.markers.colors = void 0 === e4.config.markers.colors ? t5 : e4.config.markers.colors.slice(), this.pushExtraColors(e4.globals.markers.colors);
        } }, { key: "pushExtraColors", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a4 = this.w, s4 = e4 || a4.globals.series.length;
          if (null === i4 && (i4 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a4.config.chart.type && a4.config.plotOptions.heatmap && a4.config.plotOptions.heatmap.colorScale.inverse), i4 && a4.globals.series.length && (s4 = a4.globals.series[a4.globals.maxValsInArrayIndex].length * a4.globals.series.length), t5.length < s4) for (var r4 = s4 - t5.length, o3 = 0; o3 < r4; o3++) t5.push(t5[o3]);
        } }, { key: "updateThemeOptions", value: function(t5) {
          t5.chart = t5.chart || {}, t5.tooltip = t5.tooltip || {};
          var e4 = t5.theme.mode, i4 = "dark" === e4 ? "palette4" : "light" === e4 ? "palette1" : t5.theme.palette || "palette1", a4 = "dark" === e4 ? "#f6f7f8" : "light" === e4 ? "#373d3f" : t5.chart.foreColor || "#373d3f";
          return t5.tooltip.theme = e4 || "light", t5.chart.foreColor = a4, t5.theme.palette = i4, t5;
        } }, { key: "predefined", value: function() {
          var t5 = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
          return t5[this.w.config.theme.palette] || t5.default;
        } }]), t4;
      })();
      var rt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "draw", value: function() {
          this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
        } }, { key: "drawTitleSubtitle", value: function(t5) {
          var e4 = this.w, i4 = "title" === t5 ? e4.config.title : e4.config.subtitle, a4 = e4.globals.svgWidth / 2, s4 = i4.offsetY, r4 = "middle";
          if ("left" === i4.align ? (a4 = 10, r4 = "start") : "right" === i4.align && (a4 = e4.globals.svgWidth - 10, r4 = "end"), a4 += i4.offsetX, s4 = s4 + parseInt(i4.style.fontSize, 10) + i4.margin / 2, void 0 !== i4.text) {
            var o3 = new k3(this.ctx).drawText({ x: a4, y: s4, text: i4.text, textAnchor: r4, fontSize: i4.style.fontSize, fontFamily: i4.style.fontFamily, fontWeight: i4.style.fontWeight, foreColor: i4.style.color, opacity: 1 });
            o3.node.setAttribute("class", "apexcharts-".concat(t5, "-text")), e4.globals.dom.Paper.add(o3);
          }
        } }]), t4;
      })();
      var ot = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.dCtx = e4;
        }
        return s3(t4, [{ key: "getTitleSubtitleCoords", value: function(t5) {
          var e4 = this.w, i4 = 0, a4 = 0, s4 = "title" === t5 ? e4.config.title.floating : e4.config.subtitle.floating, r4 = e4.globals.dom.baseEl.querySelector(".apexcharts-".concat(t5, "-text"));
          if (null !== r4 && !s4) {
            var o3 = r4.getBoundingClientRect();
            i4 = o3.width, a4 = e4.globals.axisCharts ? o3.height + 5 : o3.height;
          }
          return { width: i4, height: a4 };
        } }, { key: "getLegendsRect", value: function() {
          var t5 = this.w, e4 = t5.globals.dom.elLegendWrap;
          t5.config.legend.height || "top" !== t5.config.legend.position && "bottom" !== t5.config.legend.position || (e4.style.maxHeight = t5.globals.svgHeight / 2 + "px");
          var i4 = Object.assign({}, m3.getBoundingClientRect(e4));
          return null !== e4 && !t5.config.legend.floating && t5.config.legend.show ? this.dCtx.lgRect = { x: i4.x, y: i4.y, height: i4.height, width: 0 === i4.height ? 0 : i4.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t5.config.legend.position && "right" !== t5.config.legend.position || 1.5 * this.dCtx.lgRect.width > t5.globals.svgWidth && (this.dCtx.lgRect.width = t5.globals.svgWidth / 1.5), this.dCtx.lgRect;
        } }, { key: "getDatalabelsRect", value: function() {
          var t5 = this, e4 = this.w, i4 = [];
          e4.config.series.forEach((function(s5, r5) {
            s5.data.forEach((function(s6, o4) {
              var n3;
              n3 = e4.globals.series[r5][o4], a4 = e4.config.dataLabels.formatter(n3, { ctx: t5.dCtx.ctx, seriesIndex: r5, dataPointIndex: o4, w: e4 }), i4.push(a4);
            }));
          }));
          var a4 = m3.getLargestStringFromArr(i4), s4 = new k3(this.dCtx.ctx), r4 = e4.config.dataLabels.style, o3 = s4.getTextRects(a4, parseInt(r4.fontSize), r4.fontFamily);
          return { width: 1.05 * o3.width, height: o3.height };
        } }, { key: "getLargestStringFromMultiArr", value: function(t5, e4) {
          var i4 = t5;
          if (this.w.globals.isMultiLineX) {
            var a4 = e4.map((function(t6, e5) {
              return Array.isArray(t6) ? t6.length : 1;
            })), s4 = Math.max.apply(Math, p3(a4));
            i4 = e4[a4.indexOf(s4)];
          }
          return i4;
        } }]), t4;
      })();
      var nt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.dCtx = e4;
        }
        return s3(t4, [{ key: "getxAxisLabelsCoords", value: function() {
          var t5, e4 = this.w, i4 = e4.globals.labels.slice();
          if (e4.config.xaxis.convertedCatToNumeric && 0 === i4.length && (i4 = e4.globals.categoryLabels), e4.globals.timescaleLabels.length > 0) {
            var a4 = this.getxAxisTimeScaleLabelsCoords();
            t5 = { width: a4.width, height: a4.height }, e4.globals.rotateXLabels = false;
          } else {
            this.dCtx.lgWidthForSideLegends = "left" !== e4.config.legend.position && "right" !== e4.config.legend.position || e4.config.legend.floating ? 0 : this.dCtx.lgRect.width;
            var s4 = e4.globals.xLabelFormatter, r4 = m3.getLargestStringFromArr(i4), o3 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r4, i4);
            e4.globals.isBarHorizontal && (o3 = r4 = e4.globals.yAxisScale[0].result.reduce((function(t6, e5) {
              return t6.length > e5.length ? t6 : e5;
            }), 0));
            var n3 = new P3(this.dCtx.ctx), l4 = r4;
            r4 = n3.xLabelFormat(s4, r4, l4, { i: void 0, dateFormatter: new L3(this.dCtx.ctx).formatDate, w: e4 }), o3 = n3.xLabelFormat(s4, o3, l4, { i: void 0, dateFormatter: new L3(this.dCtx.ctx).formatDate, w: e4 }), (e4.config.xaxis.convertedCatToNumeric && void 0 === r4 || "" === String(r4).trim()) && (o3 = r4 = "1");
            var h4 = new k3(this.dCtx.ctx), c4 = h4.getTextRects(r4, e4.config.xaxis.labels.style.fontSize), d3 = c4;
            if (r4 !== o3 && (d3 = h4.getTextRects(o3, e4.config.xaxis.labels.style.fontSize)), (t5 = { width: c4.width >= d3.width ? c4.width : d3.width, height: c4.height >= d3.height ? c4.height : d3.height }).width * i4.length > e4.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e4.config.xaxis.labels.rotate || e4.config.xaxis.labels.rotateAlways) {
              if (!e4.globals.isBarHorizontal) {
                e4.globals.rotateXLabels = true;
                var g5 = function(t6) {
                  return h4.getTextRects(t6, e4.config.xaxis.labels.style.fontSize, e4.config.xaxis.labels.style.fontFamily, "rotate(".concat(e4.config.xaxis.labels.rotate, " 0 0)"), false);
                };
                c4 = g5(r4), r4 !== o3 && (d3 = g5(o3)), t5.height = (c4.height > d3.height ? c4.height : d3.height) / 1.5, t5.width = c4.width > d3.width ? c4.width : d3.width;
              }
            } else e4.globals.rotateXLabels = false;
          }
          return e4.config.xaxis.labels.show || (t5 = { width: 0, height: 0 }), { width: t5.width, height: t5.height };
        } }, { key: "getxAxisGroupLabelsCoords", value: function() {
          var t5, e4 = this.w;
          if (!e4.globals.hasXaxisGroups) return { width: 0, height: 0 };
          var i4, a4 = (null === (t5 = e4.config.xaxis.group.style) || void 0 === t5 ? void 0 : t5.fontSize) || e4.config.xaxis.labels.style.fontSize, s4 = e4.globals.groups.map((function(t6) {
            return t6.title;
          })), r4 = m3.getLargestStringFromArr(s4), o3 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r4, s4), n3 = new k3(this.dCtx.ctx), l4 = n3.getTextRects(r4, a4), h4 = l4;
          return r4 !== o3 && (h4 = n3.getTextRects(o3, a4)), i4 = { width: l4.width >= h4.width ? l4.width : h4.width, height: l4.height >= h4.height ? l4.height : h4.height }, e4.config.xaxis.labels.show || (i4 = { width: 0, height: 0 }), { width: i4.width, height: i4.height };
        } }, { key: "getxAxisTitleCoords", value: function() {
          var t5 = this.w, e4 = 0, i4 = 0;
          if (void 0 !== t5.config.xaxis.title.text) {
            var a4 = new k3(this.dCtx.ctx).getTextRects(t5.config.xaxis.title.text, t5.config.xaxis.title.style.fontSize);
            e4 = a4.width, i4 = a4.height;
          }
          return { width: e4, height: i4 };
        } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
          var t5, e4 = this.w;
          this.dCtx.timescaleLabels = e4.globals.timescaleLabels.slice();
          var i4 = this.dCtx.timescaleLabels.map((function(t6) {
            return t6.value;
          })), a4 = i4.reduce((function(t6, e5) {
            return void 0 === t6 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t6.length > e5.length ? t6 : e5;
          }), 0);
          return 1.05 * (t5 = new k3(this.dCtx.ctx).getTextRects(a4, e4.config.xaxis.labels.style.fontSize)).width * i4.length > e4.globals.gridWidth && 0 !== e4.config.xaxis.labels.rotate && (e4.globals.overlappingXLabels = true), t5;
        } }, { key: "additionalPaddingXLabels", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = i4.globals, s4 = i4.config, r4 = s4.xaxis.type, o3 = t5.width;
          a4.skipLastTimelinelabel = false, a4.skipFirstTimelinelabel = false;
          var n3 = i4.config.yaxis[0].opposite && i4.globals.isBarHorizontal, l4 = function(t6, n4) {
            s4.yaxis.length > 1 && (function(t7) {
              return -1 !== a4.collapsedSeriesIndices.indexOf(t7);
            })(n4) || (function(t7) {
              if (e4.dCtx.timescaleLabels && e4.dCtx.timescaleLabels.length) {
                var n5 = e4.dCtx.timescaleLabels[0], l5 = e4.dCtx.timescaleLabels[e4.dCtx.timescaleLabels.length - 1].position + o3 / 1.75 - e4.dCtx.yAxisWidthRight, h4 = n5.position - o3 / 1.75 + e4.dCtx.yAxisWidthLeft, c4 = "right" === i4.config.legend.position && e4.dCtx.lgRect.width > 0 ? e4.dCtx.lgRect.width : 0;
                l5 > a4.svgWidth - a4.translateX - c4 && (a4.skipLastTimelinelabel = true), h4 < -(t7.show && !t7.floating || "bar" !== s4.chart.type && "candlestick" !== s4.chart.type && "rangeBar" !== s4.chart.type && "boxPlot" !== s4.chart.type ? 10 : o3 / 1.75) && (a4.skipFirstTimelinelabel = true);
              } else "datetime" === r4 ? e4.dCtx.gridPad.right < o3 && !a4.rotateXLabels && (a4.skipLastTimelinelabel = true) : "datetime" !== r4 && e4.dCtx.gridPad.right < o3 / 2 - e4.dCtx.yAxisWidthRight && !a4.rotateXLabels && !i4.config.xaxis.labels.trim && (e4.dCtx.xPadRight = o3 / 2 + 1);
            })(t6);
          };
          s4.yaxis.forEach((function(t6, i5) {
            n3 ? (e4.dCtx.gridPad.left < o3 && (e4.dCtx.xPadLeft = o3 / 2 + 1), e4.dCtx.xPadRight = o3 / 2 + 1) : l4(t6, i5);
          }));
        } }]), t4;
      })();
      var lt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.dCtx = e4;
        }
        return s3(t4, [{ key: "getyAxisLabelsCoords", value: function() {
          var t5 = this, e4 = this.w, i4 = [], a4 = 10, s4 = new M2(this.dCtx.ctx);
          return e4.config.yaxis.map((function(r4, o3) {
            var n3 = { seriesIndex: o3, dataPointIndex: -1, w: e4 }, l4 = e4.globals.yAxisScale[o3], h4 = 0;
            if (!s4.isYAxisHidden(o3) && r4.labels.show && void 0 !== r4.labels.minWidth && (h4 = r4.labels.minWidth), !s4.isYAxisHidden(o3) && r4.labels.show && l4.result.length) {
              var c4 = e4.globals.yLabelFormatters[o3], d3 = l4.niceMin === Number.MIN_VALUE ? 0 : l4.niceMin, g5 = l4.result.reduce((function(t6, e5) {
                var i5, a5;
                return (null === (i5 = String(c4(t6, n3))) || void 0 === i5 ? void 0 : i5.length) > (null === (a5 = String(c4(e5, n3))) || void 0 === a5 ? void 0 : a5.length) ? t6 : e5;
              }), d3), u4 = g5 = c4(g5, n3);
              if (void 0 !== g5 && 0 !== g5.length || (g5 = l4.niceMax), e4.globals.isBarHorizontal) {
                a4 = 0;
                var f4 = e4.globals.labels.slice();
                g5 = m3.getLargestStringFromArr(f4), g5 = c4(g5, { seriesIndex: o3, dataPointIndex: -1, w: e4 }), u4 = t5.dCtx.dimHelpers.getLargestStringFromMultiArr(g5, f4);
              }
              var p4 = new k3(t5.dCtx.ctx), x5 = "rotate(".concat(r4.labels.rotate, " 0 0)"), b4 = p4.getTextRects(g5, r4.labels.style.fontSize, r4.labels.style.fontFamily, x5, false), v4 = b4;
              g5 !== u4 && (v4 = p4.getTextRects(u4, r4.labels.style.fontSize, r4.labels.style.fontFamily, x5, false)), i4.push({ width: (h4 > v4.width || h4 > b4.width ? h4 : v4.width > b4.width ? v4.width : b4.width) + a4, height: v4.height > b4.height ? v4.height : b4.height });
            } else i4.push({ width: 0, height: 0 });
          })), i4;
        } }, { key: "getyAxisTitleCoords", value: function() {
          var t5 = this, e4 = this.w, i4 = [];
          return e4.config.yaxis.map((function(e5, a4) {
            if (e5.show && void 0 !== e5.title.text) {
              var s4 = new k3(t5.dCtx.ctx), r4 = "rotate(".concat(e5.title.rotate, " 0 0)"), o3 = s4.getTextRects(e5.title.text, e5.title.style.fontSize, e5.title.style.fontFamily, r4, false);
              i4.push({ width: o3.width, height: o3.height });
            } else i4.push({ width: 0, height: 0 });
          })), i4;
        } }, { key: "getTotalYAxisWidth", value: function() {
          var t5 = this.w, e4 = 0, i4 = 0, a4 = 0, s4 = t5.globals.yAxisScale.length > 1 ? 10 : 0, r4 = new M2(this.dCtx.ctx), o3 = function(o4, n3) {
            var l4 = t5.config.yaxis[n3].floating, h4 = 0;
            o4.width > 0 && !l4 ? (h4 = o4.width + s4, (function(e5) {
              return t5.globals.ignoreYAxisIndexes.indexOf(e5) > -1;
            })(n3) && (h4 = h4 - o4.width - s4)) : h4 = l4 || r4.isYAxisHidden(n3) ? 0 : 5, t5.config.yaxis[n3].opposite ? a4 += h4 : i4 += h4, e4 += h4;
          };
          return t5.globals.yLabelsCoords.map((function(t6, e5) {
            o3(t6, e5);
          })), t5.globals.yTitleCoords.map((function(t6, e5) {
            o3(t6, e5);
          })), t5.globals.isBarHorizontal && !t5.config.yaxis[0].floating && (e4 = t5.globals.yLabelsCoords[0].width + t5.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i4, this.dCtx.yAxisWidthRight = a4, e4;
        } }]), t4;
      })();
      var ht = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.dCtx = e4;
        }
        return s3(t4, [{ key: "gridPadForColumnsInNumericAxis", value: function(t5) {
          var e4 = this.w, i4 = e4.config, a4 = e4.globals;
          if (a4.noData || a4.collapsedSeries.length + a4.ancillaryCollapsedSeries.length === i4.series.length) return 0;
          var s4 = function(t6) {
            return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(t6);
          }, r4 = i4.chart.type, o3 = 0, n3 = s4(r4) ? i4.series.length : 1;
          a4.comboBarCount > 0 && (n3 = a4.comboBarCount), a4.collapsedSeries.forEach((function(t6) {
            s4(t6.type) && (n3 -= 1);
          })), i4.chart.stacked && (n3 = 1);
          var l4 = s4(r4) || a4.comboBarCount > 0, h4 = Math.abs(a4.initialMaxX - a4.initialMinX);
          if (l4 && a4.isXNumeric && !a4.isBarHorizontal && n3 > 0 && 0 !== h4) {
            h4 <= 3 && (h4 = a4.dataPoints);
            var c4 = h4 / t5, d3 = a4.minXDiff && a4.minXDiff / c4 > 0 ? a4.minXDiff / c4 : 0;
            d3 > t5 / 2 && (d3 /= 2), (o3 = d3 * parseInt(i4.plotOptions.bar.columnWidth, 10) / 100) < 1 && (o3 = 1), a4.barPadForNumericAxis = o3;
          }
          return o3;
        } }, { key: "gridPadFortitleSubtitle", value: function() {
          var t5 = this, e4 = this.w, i4 = e4.globals, a4 = this.dCtx.isSparkline || !i4.axisCharts ? 0 : 10;
          ["title", "subtitle"].forEach((function(s5) {
            void 0 !== e4.config[s5].text ? a4 += e4.config[s5].margin : a4 += t5.dCtx.isSparkline || !i4.axisCharts ? 0 : 5;
          })), !e4.config.legend.show || "bottom" !== e4.config.legend.position || e4.config.legend.floating || i4.axisCharts || (a4 += 10);
          var s4 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r4 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
          i4.gridHeight -= s4.height + r4.height + a4, i4.translateY += s4.height + r4.height + a4;
        } }, { key: "setGridXPosForDualYAxis", value: function(t5, e4) {
          var i4 = this.w, a4 = new M2(this.dCtx.ctx);
          i4.config.yaxis.forEach((function(s4, r4) {
            -1 !== i4.globals.ignoreYAxisIndexes.indexOf(r4) || s4.floating || a4.isYAxisHidden(r4) || (s4.opposite && (i4.globals.translateX -= e4[r4].width + t5[r4].width + parseInt(s4.labels.style.fontSize, 10) / 1.2 + 12), i4.globals.translateX < 2 && (i4.globals.translateX = 2));
          }));
        } }]), t4;
      })();
      var ct = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ot(this), this.dimYAxis = new lt(this), this.dimXAxis = new nt(this), this.dimGrid = new ht(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
        }
        return s3(t4, [{ key: "plotCoords", value: function() {
          var t5 = this, e4 = this.w, i4 = e4.globals;
          this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
          var a4 = Array.isArray(e4.config.stroke.width) ? Math.max.apply(Math, p3(e4.config.stroke.width)) : e4.config.stroke.width;
          this.isSparkline && ((e4.config.markers.discrete.length > 0 || e4.config.markers.size > 0) && Object.entries(this.gridPad).forEach((function(e5) {
            var i5 = f3(e5, 2), a5 = i5[0], s5 = i5[1];
            t5.gridPad[a5] = Math.max(s5, t5.w.globals.markers.largestSize / 1.5);
          })), this.gridPad.top = Math.max(a4 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a4 / 2, this.gridPad.bottom)), i4.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i4.gridHeight = i4.gridHeight - this.gridPad.top - this.gridPad.bottom, i4.gridWidth = i4.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
          var s4 = this.dimGrid.gridPadForColumnsInNumericAxis(i4.gridWidth);
          i4.gridWidth = i4.gridWidth - 2 * s4, i4.translateX = i4.translateX + this.gridPad.left + this.xPadLeft + (s4 > 0 ? s4 : 0), i4.translateY = i4.translateY + this.gridPad.top;
        } }, { key: "setDimensionsForAxisCharts", value: function() {
          var t5 = this, e4 = this.w, i4 = e4.globals, a4 = this.dimYAxis.getyAxisLabelsCoords(), s4 = this.dimYAxis.getyAxisTitleCoords();
          i4.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e4.globals.yLabelsCoords = [], e4.globals.yTitleCoords = [], e4.config.yaxis.map((function(t6, i5) {
            e4.globals.yLabelsCoords.push({ width: a4[i5].width, index: i5 }), e4.globals.yTitleCoords.push({ width: s4[i5].width, index: i5 });
          })), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
          var r4 = this.dimXAxis.getxAxisLabelsCoords(), o3 = this.dimXAxis.getxAxisGroupLabelsCoords(), n3 = this.dimXAxis.getxAxisTitleCoords();
          this.conditionalChecksForAxisCoords(r4, n3, o3), i4.translateXAxisY = e4.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i4.translateXAxisX = e4.globals.rotateXLabels && e4.globals.isXNumeric && e4.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e4.globals.isBarHorizontal && (i4.rotateXLabels = false, i4.translateXAxisY = parseInt(e4.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i4.translateXAxisY = i4.translateXAxisY + e4.config.xaxis.labels.offsetY, i4.translateXAxisX = i4.translateXAxisX + e4.config.xaxis.labels.offsetX;
          var l4 = this.yAxisWidth, h4 = this.xAxisHeight;
          i4.xAxisLabelsHeight = this.xAxisHeight - n3.height, i4.xAxisGroupLabelsHeight = i4.xAxisLabelsHeight - r4.height, i4.xAxisLabelsWidth = this.xAxisWidth, i4.xAxisHeight = this.xAxisHeight;
          var c4 = 10;
          ("radar" === e4.config.chart.type || this.isSparkline) && (l4 = 0, h4 = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e4.config.chart.type) && (l4 = 0, h4 = 0, c4 = 0), this.isSparkline || "treemap" === e4.config.chart.type || this.dimXAxis.additionalPaddingXLabels(r4);
          var d3 = function() {
            i4.translateX = l4 + t5.datalabelsCoords.width, i4.gridHeight = i4.svgHeight - t5.lgRect.height - h4 - (t5.isSparkline || "treemap" === e4.config.chart.type ? 0 : e4.globals.rotateXLabels ? 10 : 15), i4.gridWidth = i4.svgWidth - l4 - 2 * t5.datalabelsCoords.width;
          };
          switch ("top" === e4.config.xaxis.position && (c4 = i4.xAxisHeight - e4.config.xaxis.axisTicks.height - 5), e4.config.legend.position) {
            case "bottom":
              i4.translateY = c4, d3();
              break;
            case "top":
              i4.translateY = this.lgRect.height + c4, d3();
              break;
            case "left":
              i4.translateY = c4, i4.translateX = this.lgRect.width + l4 + this.datalabelsCoords.width, i4.gridHeight = i4.svgHeight - h4 - 12, i4.gridWidth = i4.svgWidth - this.lgRect.width - l4 - 2 * this.datalabelsCoords.width;
              break;
            case "right":
              i4.translateY = c4, i4.translateX = l4 + this.datalabelsCoords.width, i4.gridHeight = i4.svgHeight - h4 - 12, i4.gridWidth = i4.svgWidth - this.lgRect.width - l4 - 2 * this.datalabelsCoords.width - 5;
              break;
            default:
              throw new Error("Legend position not supported");
          }
          this.dimGrid.setGridXPosForDualYAxis(s4, a4), new Q2(this.ctx).setYAxisXPosition(a4, s4);
        } }, { key: "setDimensionsForNonAxisCharts", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = t5.config, a4 = 0;
          t5.config.legend.show && !t5.config.legend.floating && (a4 = 20);
          var s4 = "pie" === i4.chart.type || "polarArea" === i4.chart.type || "donut" === i4.chart.type ? "pie" : "radialBar", r4 = i4.plotOptions[s4].offsetY, o3 = i4.plotOptions[s4].offsetX;
          if (!i4.legend.show || i4.legend.floating) {
            e4.gridHeight = e4.svgHeight;
            var n3 = e4.dom.elWrap.getBoundingClientRect().width;
            return e4.gridWidth = Math.min(n3, e4.gridHeight), e4.translateY = r4, void (e4.translateX = o3 + (e4.svgWidth - e4.gridWidth) / 2);
          }
          switch (i4.legend.position) {
            case "bottom":
              e4.gridHeight = e4.svgHeight - this.lgRect.height, e4.gridWidth = e4.svgWidth, e4.translateY = r4 - 10, e4.translateX = o3 + (e4.svgWidth - e4.gridWidth) / 2;
              break;
            case "top":
              e4.gridHeight = e4.svgHeight - this.lgRect.height, e4.gridWidth = e4.svgWidth, e4.translateY = this.lgRect.height + r4 + 10, e4.translateX = o3 + (e4.svgWidth - e4.gridWidth) / 2;
              break;
            case "left":
              e4.gridWidth = e4.svgWidth - this.lgRect.width - a4, e4.gridHeight = "auto" !== i4.chart.height ? e4.svgHeight : e4.gridWidth, e4.translateY = r4, e4.translateX = o3 + this.lgRect.width + a4;
              break;
            case "right":
              e4.gridWidth = e4.svgWidth - this.lgRect.width - a4 - 5, e4.gridHeight = "auto" !== i4.chart.height ? e4.svgHeight : e4.gridWidth, e4.translateY = r4, e4.translateX = o3 + 10;
              break;
            default:
              throw new Error("Legend position not supported");
          }
        } }, { key: "conditionalChecksForAxisCoords", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = a4.globals.hasXaxisGroups ? 2 : 1, r4 = i4.height + t5.height + e4.height, o3 = a4.globals.isMultiLineX ? 1.2 : a4.globals.LINE_HEIGHT_RATIO, n3 = a4.globals.rotateXLabels ? 22 : 10, l4 = a4.globals.rotateXLabels && "bottom" === a4.config.legend.position ? 10 : 0;
          this.xAxisHeight = r4 * o3 + s4 * n3 + l4, this.xAxisWidth = t5.width, this.xAxisHeight - e4.height > a4.config.xaxis.labels.maxHeight && (this.xAxisHeight = a4.config.xaxis.labels.maxHeight), a4.config.xaxis.labels.minHeight && this.xAxisHeight < a4.config.xaxis.labels.minHeight && (this.xAxisHeight = a4.config.xaxis.labels.minHeight), a4.config.xaxis.floating && (this.xAxisHeight = 0);
          var h4 = 0, c4 = 0;
          a4.config.yaxis.forEach((function(t6) {
            h4 += t6.labels.minWidth, c4 += t6.labels.maxWidth;
          })), this.yAxisWidth < h4 && (this.yAxisWidth = h4), this.yAxisWidth > c4 && (this.yAxisWidth = c4);
        } }]), t4;
      })();
      var dt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.lgCtx = e4;
        }
        return s3(t4, [{ key: "getLegendStyles", value: function() {
          var t5, e4, i4, a4 = document.createElement("style");
          a4.setAttribute("type", "text/css");
          var s4 = (null === (t5 = this.lgCtx.ctx) || void 0 === t5 || null === (e4 = t5.opts) || void 0 === e4 || null === (i4 = e4.chart) || void 0 === i4 ? void 0 : i4.nonce) || this.w.config.chart.nonce;
          s4 && a4.setAttribute("nonce", s4);
          var r4 = document.createTextNode("\n      .apexcharts-flip-y {\n        transform: scaleY(-1) translateY(-100%);\n        transform-origin: top;\n        transform-box: fill-box;\n      }\n      .apexcharts-flip-x {\n        transform: scaleX(-1);\n        transform-origin: center;\n        transform-box: fill-box;\n      }\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }");
          return a4.appendChild(r4), a4;
        } }, { key: "getLegendDimensions", value: function() {
          var t5 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e4 = t5.width;
          return { clwh: t5.height, clww: e4 };
        } }, { key: "appendToForeignObject", value: function() {
          this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
        } }, { key: "toggleDataSeries", value: function(t5, e4) {
          var i4 = this, a4 = this.w;
          if (a4.globals.axisCharts || "radialBar" === a4.config.chart.type) {
            a4.globals.resized = true;
            var s4 = null, r4 = null;
            if (a4.globals.risingSeries = [], a4.globals.axisCharts ? (s4 = a4.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t5, "']")), r4 = parseInt(s4.getAttribute("data:realIndex"), 10)) : (s4 = a4.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t5 + 1, "']")), r4 = parseInt(s4.getAttribute("rel"), 10) - 1), e4) [{ cs: a4.globals.collapsedSeries, csi: a4.globals.collapsedSeriesIndices }, { cs: a4.globals.ancillaryCollapsedSeries, csi: a4.globals.ancillaryCollapsedSeriesIndices }].forEach((function(t6) {
              i4.riseCollapsedSeries(t6.cs, t6.csi, r4);
            }));
            else this.hideSeries({ seriesEl: s4, realIndex: r4 });
          } else {
            var o3 = a4.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t5 + 1, "'] path")), n3 = a4.config.chart.type;
            if ("pie" === n3 || "polarArea" === n3 || "donut" === n3) {
              var l4 = a4.config.plotOptions.pie.donut.labels;
              new k3(this.lgCtx.ctx).pathMouseDown(o3.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o3.members[0].node, l4);
            }
            o3.fire("click");
          }
        } }, { key: "getSeriesAfterCollapsing", value: function(t5) {
          var e4 = t5.realIndex, i4 = this.w, a4 = i4.globals, s4 = m3.clone(i4.config.series);
          if (a4.axisCharts) {
            var r4 = i4.config.yaxis[a4.seriesYAxisReverseMap[e4]], o3 = { index: e4, data: s4[e4].data.slice(), type: s4[e4].type || i4.config.chart.type };
            if (r4 && r4.show && r4.showAlways) a4.ancillaryCollapsedSeriesIndices.indexOf(e4) < 0 && (a4.ancillaryCollapsedSeries.push(o3), a4.ancillaryCollapsedSeriesIndices.push(e4));
            else if (a4.collapsedSeriesIndices.indexOf(e4) < 0) {
              a4.collapsedSeries.push(o3), a4.collapsedSeriesIndices.push(e4);
              var n3 = a4.risingSeries.indexOf(e4);
              a4.risingSeries.splice(n3, 1);
            }
          } else a4.collapsedSeries.push({ index: e4, data: s4[e4] }), a4.collapsedSeriesIndices.push(e4);
          return a4.allSeriesCollapsed = a4.collapsedSeries.length + a4.ancillaryCollapsedSeries.length === i4.config.series.length, this._getSeriesBasedOnCollapsedState(s4);
        } }, { key: "hideSeries", value: function(t5) {
          for (var e4 = t5.seriesEl, i4 = t5.realIndex, a4 = this.w, s4 = this.getSeriesAfterCollapsing({ realIndex: i4 }), r4 = e4.childNodes, o3 = 0; o3 < r4.length; o3++) r4[o3].classList.contains("apexcharts-series-markers-wrap") && (r4[o3].classList.contains("apexcharts-hide") ? r4[o3].classList.remove("apexcharts-hide") : r4[o3].classList.add("apexcharts-hide"));
          this.lgCtx.ctx.updateHelpers._updateSeries(s4, a4.config.chart.animations.dynamicAnimation.enabled);
        } }, { key: "riseCollapsedSeries", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = m3.clone(a4.config.series);
          if (t5.length > 0) {
            for (var r4 = 0; r4 < t5.length; r4++) t5[r4].index === i4 && (a4.globals.axisCharts ? s4[i4].data = t5[r4].data.slice() : s4[i4] = t5[r4].data, s4[i4].hidden = false, t5.splice(r4, 1), e4.splice(r4, 1), a4.globals.risingSeries.push(i4));
            s4 = this._getSeriesBasedOnCollapsedState(s4), this.lgCtx.ctx.updateHelpers._updateSeries(s4, a4.config.chart.animations.dynamicAnimation.enabled);
          }
        } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t5) {
          var e4 = this.w, i4 = 0;
          return e4.globals.axisCharts ? t5.forEach((function(a4, s4) {
            e4.globals.collapsedSeriesIndices.indexOf(s4) < 0 && e4.globals.ancillaryCollapsedSeriesIndices.indexOf(s4) < 0 || (t5[s4].data = [], i4++);
          })) : t5.forEach((function(a4, s4) {
            !e4.globals.collapsedSeriesIndices.indexOf(s4) < 0 && (t5[s4] = 0, i4++);
          })), e4.globals.allSeriesCollapsed = i4 === t5.length, t5;
        } }]), t4;
      })();
      var gt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new dt(this);
        }
        return s3(t4, [{ key: "init", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = t5.config, a4 = i4.legend.showForSingleSeries && 1 === e4.series.length || this.isBarsDistributed || e4.series.length > 1;
          if (this.legendHelpers.appendToForeignObject(), (a4 || !e4.axisCharts) && i4.legend.show) {
            for (; e4.dom.elLegendWrap.firstChild; ) e4.dom.elLegendWrap.removeChild(e4.dom.elLegendWrap.firstChild);
            this.drawLegends(), "bottom" === i4.legend.position || "top" === i4.legend.position ? this.legendAlignHorizontal() : "right" !== i4.legend.position && "left" !== i4.legend.position || this.legendAlignVertical();
          }
        } }, { key: "createLegendMarker", value: function(t5) {
          var e4 = t5.i, i4 = t5.fillcolor, a4 = this.w, s4 = document.createElement("span");
          s4.classList.add("apexcharts-legend-marker");
          var r4 = a4.config.legend.markers.shape || a4.config.markers.shape, o3 = r4;
          Array.isArray(r4) && (o3 = r4[e4]);
          var n3 = Array.isArray(a4.config.legend.markers.size) ? parseFloat(a4.config.legend.markers.size[e4]) : parseFloat(a4.config.legend.markers.size), l4 = Array.isArray(a4.config.legend.markers.offsetX) ? parseFloat(a4.config.legend.markers.offsetX[e4]) : parseFloat(a4.config.legend.markers.offsetX), h4 = Array.isArray(a4.config.legend.markers.offsetY) ? parseFloat(a4.config.legend.markers.offsetY[e4]) : parseFloat(a4.config.legend.markers.offsetY), c4 = Array.isArray(a4.config.legend.markers.strokeWidth) ? parseFloat(a4.config.legend.markers.strokeWidth[e4]) : parseFloat(a4.config.legend.markers.strokeWidth), d3 = s4.style;
          if (d3.height = 2 * (n3 + c4) + "px", d3.width = 2 * (n3 + c4) + "px", d3.left = l4 + "px", d3.top = h4 + "px", a4.config.legend.markers.customHTML) d3.background = "transparent", d3.color = i4[e4], Array.isArray(a4.config.legend.markers.customHTML) ? a4.config.legend.markers.customHTML[e4] && (s4.innerHTML = a4.config.legend.markers.customHTML[e4]()) : s4.innerHTML = a4.config.legend.markers.customHTML();
          else {
            var u4 = new W2(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(o3), seriesIndex: e4, strokeWidth: c4, size: n3 }), f4 = SVG(s4).size("100%", "100%"), p4 = new k3(this.ctx).drawMarker(0, 0, g4(g4({}, u4), {}, { pointFillColor: Array.isArray(i4) ? i4[e4] : u4.pointFillColor, shape: o3 }));
            SVG.select(".apexcharts-legend-marker.apexcharts-marker").members.forEach((function(t6) {
              t6.node.classList.contains("apexcharts-marker-triangle") ? t6.node.style.transform = "translate(50%, 45%)" : t6.node.style.transform = "translate(50%, 50%)";
            })), f4.add(p4);
          }
          return s4;
        } }, { key: "drawLegends", value: function() {
          var t5 = this, e4 = this.w, i4 = e4.config.legend.fontFamily, a4 = e4.globals.seriesNames, s4 = e4.config.legend.markers.fillColors ? e4.config.legend.markers.fillColors.slice() : e4.globals.colors.slice();
          if ("heatmap" === e4.config.chart.type) {
            var r4 = e4.config.plotOptions.heatmap.colorScale.ranges;
            a4 = r4.map((function(t6) {
              return t6.name ? t6.name : t6.from + " - " + t6.to;
            })), s4 = r4.map((function(t6) {
              return t6.color;
            }));
          } else this.isBarsDistributed && (a4 = e4.globals.labels.slice());
          e4.config.legend.customLegendItems.length && (a4 = e4.config.legend.customLegendItems);
          for (var o3 = e4.globals.legendFormatter, n3 = e4.config.legend.inverseOrder, l4 = n3 ? a4.length - 1 : 0; n3 ? l4 >= 0 : l4 <= a4.length - 1; n3 ? l4-- : l4++) {
            var h4, c4 = o3(a4[l4], { seriesIndex: l4, w: e4 }), d3 = false, g5 = false;
            if (e4.globals.collapsedSeries.length > 0) for (var u4 = 0; u4 < e4.globals.collapsedSeries.length; u4++) e4.globals.collapsedSeries[u4].index === l4 && (d3 = true);
            if (e4.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var f4 = 0; f4 < e4.globals.ancillaryCollapsedSeriesIndices.length; f4++) e4.globals.ancillaryCollapsedSeriesIndices[f4] === l4 && (g5 = true);
            var p4 = this.createLegendMarker({ i: l4, fillcolor: s4 });
            k3.setAttrs(p4, { rel: l4 + 1, "data:collapsed": d3 || g5 }), (d3 || g5) && p4.classList.add("apexcharts-inactive-legend");
            var x5 = document.createElement("div"), b4 = document.createElement("span");
            b4.classList.add("apexcharts-legend-text"), b4.innerHTML = Array.isArray(c4) ? c4.join(" ") : c4;
            var v4 = e4.config.legend.labels.useSeriesColors ? e4.globals.colors[l4] : Array.isArray(e4.config.legend.labels.colors) ? null === (h4 = e4.config.legend.labels.colors) || void 0 === h4 ? void 0 : h4[l4] : e4.config.legend.labels.colors;
            v4 || (v4 = e4.config.chart.foreColor), b4.style.color = v4, b4.style.fontSize = parseFloat(e4.config.legend.fontSize) + "px", b4.style.fontWeight = e4.config.legend.fontWeight, b4.style.fontFamily = i4 || e4.config.chart.fontFamily, k3.setAttrs(b4, { rel: l4 + 1, i: l4, "data:default-text": encodeURIComponent(c4), "data:collapsed": d3 || g5 }), x5.appendChild(p4), x5.appendChild(b4);
            var y4 = new A3(this.ctx);
            if (!e4.config.legend.showForZeroSeries) 0 === y4.getSeriesTotalByIndex(l4) && y4.seriesHaveSameValues(l4) && !y4.isSeriesNull(l4) && -1 === e4.globals.collapsedSeriesIndices.indexOf(l4) && -1 === e4.globals.ancillaryCollapsedSeriesIndices.indexOf(l4) && x5.classList.add("apexcharts-hidden-zero-series");
            e4.config.legend.showForNullSeries || y4.isSeriesNull(l4) && -1 === e4.globals.collapsedSeriesIndices.indexOf(l4) && -1 === e4.globals.ancillaryCollapsedSeriesIndices.indexOf(l4) && x5.classList.add("apexcharts-hidden-null-series"), e4.globals.dom.elLegendWrap.appendChild(x5), e4.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e4.config.legend.horizontalAlign)), e4.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e4.config.legend.position), x5.classList.add("apexcharts-legend-series"), x5.style.margin = "".concat(e4.config.legend.itemMargin.vertical, "px ").concat(e4.config.legend.itemMargin.horizontal, "px"), e4.globals.dom.elLegendWrap.style.width = e4.config.legend.width ? e4.config.legend.width + "px" : "", e4.globals.dom.elLegendWrap.style.height = e4.config.legend.height ? e4.config.legend.height + "px" : "", k3.setAttrs(x5, { rel: l4 + 1, seriesName: m3.escapeString(a4[l4]), "data:collapsed": d3 || g5 }), (d3 || g5) && x5.classList.add("apexcharts-inactive-legend"), e4.config.legend.onItemClick.toggleDataSeries || x5.classList.add("apexcharts-no-click");
          }
          e4.globals.dom.elWrap.addEventListener("click", t5.onLegendClick, true), e4.config.legend.onItemHover.highlightDataSeries && 0 === e4.config.legend.customLegendItems.length && (e4.globals.dom.elWrap.addEventListener("mousemove", t5.onLegendHovered, true), e4.globals.dom.elWrap.addEventListener("mouseout", t5.onLegendHovered, true));
        } }, { key: "setLegendWrapXY", value: function(t5, e4) {
          var i4 = this.w, a4 = i4.globals.dom.elLegendWrap, s4 = a4.clientHeight, r4 = 0, o3 = 0;
          if ("bottom" === i4.config.legend.position) o3 = i4.globals.svgHeight - Math.min(s4, i4.globals.svgHeight / 2) - 5;
          else if ("top" === i4.config.legend.position) {
            var n3 = new ct(this.ctx), l4 = n3.dimHelpers.getTitleSubtitleCoords("title").height, h4 = n3.dimHelpers.getTitleSubtitleCoords("subtitle").height;
            o3 = (l4 > 0 ? l4 - 10 : 0) + (h4 > 0 ? h4 - 10 : 0);
          }
          a4.style.position = "absolute", r4 = r4 + t5 + i4.config.legend.offsetX, o3 = o3 + e4 + i4.config.legend.offsetY, a4.style.left = r4 + "px", a4.style.top = o3 + "px", "right" === i4.config.legend.position && (a4.style.left = "auto", a4.style.right = 25 + i4.config.legend.offsetX + "px");
          ["width", "height"].forEach((function(t6) {
            a4.style[t6] && (a4.style[t6] = parseInt(i4.config.legend[t6], 10) + "px");
          }));
        } }, { key: "legendAlignHorizontal", value: function() {
          var t5 = this.w;
          t5.globals.dom.elLegendWrap.style.right = 0;
          var e4 = new ct(this.ctx), i4 = e4.dimHelpers.getTitleSubtitleCoords("title"), a4 = e4.dimHelpers.getTitleSubtitleCoords("subtitle"), s4 = 0;
          "top" === t5.config.legend.position && (s4 = i4.height + a4.height + t5.config.title.margin + t5.config.subtitle.margin - 10), this.setLegendWrapXY(20, s4);
        } }, { key: "legendAlignVertical", value: function() {
          var t5 = this.w, e4 = this.legendHelpers.getLegendDimensions(), i4 = 0;
          "left" === t5.config.legend.position && (i4 = 20), "right" === t5.config.legend.position && (i4 = t5.globals.svgWidth - e4.clww - 10), this.setLegendWrapXY(i4, 20);
        } }, { key: "onLegendHovered", value: function(t5) {
          var e4 = this.w, i4 = t5.target.classList.contains("apexcharts-legend-series") || t5.target.classList.contains("apexcharts-legend-text") || t5.target.classList.contains("apexcharts-legend-marker");
          if ("heatmap" === e4.config.chart.type || this.isBarsDistributed) {
            if (i4) {
              var a4 = parseInt(t5.target.getAttribute("rel"), 10) - 1;
              this.ctx.events.fireEvent("legendHover", [this.ctx, a4, this.w]), new V3(this.ctx).highlightRangeInSeries(t5, t5.target);
            }
          } else !t5.target.classList.contains("apexcharts-inactive-legend") && i4 && new V3(this.ctx).toggleSeriesOnHover(t5, t5.target);
        } }, { key: "onLegendClick", value: function(t5) {
          var e4 = this.w;
          if (!e4.config.legend.customLegendItems.length && (t5.target.classList.contains("apexcharts-legend-series") || t5.target.classList.contains("apexcharts-legend-text") || t5.target.classList.contains("apexcharts-legend-marker"))) {
            var i4 = parseInt(t5.target.getAttribute("rel"), 10) - 1, a4 = "true" === t5.target.getAttribute("data:collapsed"), s4 = this.w.config.chart.events.legendClick;
            "function" == typeof s4 && s4(this.ctx, i4, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i4, this.w]);
            var r4 = this.w.config.legend.markers.onClick;
            "function" == typeof r4 && t5.target.classList.contains("apexcharts-legend-marker") && (r4(this.ctx, i4, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i4, this.w])), "treemap" !== e4.config.chart.type && "heatmap" !== e4.config.chart.type && !this.isBarsDistributed && e4.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i4, a4);
          }
        } }]), t4;
      })();
      var ut = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
          var a4 = this.w;
          this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = a4.globals.minX, this.maxX = a4.globals.maxX;
        }
        return s3(t4, [{ key: "createToolbar", value: function() {
          var t5 = this, e4 = this.w, i4 = function() {
            return document.createElement("div");
          }, a4 = i4();
          if (a4.setAttribute("class", "apexcharts-toolbar"), a4.style.top = e4.config.chart.toolbar.offsetY + "px", a4.style.right = 3 - e4.config.chart.toolbar.offsetX + "px", e4.globals.dom.elWrap.appendChild(a4), this.elZoom = i4(), this.elZoomIn = i4(), this.elZoomOut = i4(), this.elPan = i4(), this.elSelection = i4(), this.elZoomReset = i4(), this.elMenuIcon = i4(), this.elMenu = i4(), this.elCustomIcons = [], this.t = e4.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s4 = 0; s4 < this.t.customIcons.length; s4++) this.elCustomIcons.push(i4());
          var r4 = [], o3 = function(i5, a5, s5) {
            var o4 = i5.toLowerCase();
            t5.t[o4] && e4.config.chart.zoom.enabled && r4.push({ el: a5, icon: "string" == typeof t5.t[o4] ? t5.t[o4] : s5, title: t5.localeValues[i5], class: "apexcharts-".concat(o4, "-icon") });
          };
          o3("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o3("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
          var n3 = function(i5) {
            t5.t[i5] && e4.config.chart[i5].enabled && r4.push({ el: "zoom" === i5 ? t5.elZoom : t5.elSelection, icon: "string" == typeof t5.t[i5] ? t5.t[i5] : "zoom" === i5 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t5.localeValues["zoom" === i5 ? "selectionZoom" : "selection"], class: e4.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i5, "-icon") });
          };
          n3("zoom"), n3("selection"), this.t.pan && e4.config.chart.zoom.enabled && r4.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e4.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o3("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r4.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
          for (var l4 = 0; l4 < this.elCustomIcons.length; l4++) r4.push({ el: this.elCustomIcons[l4], icon: this.t.customIcons[l4].icon, title: this.t.customIcons[l4].title, index: this.t.customIcons[l4].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l4].class });
          r4.forEach((function(t6, e5) {
            t6.index && m3.moveIndexInArray(r4, e5, t6.index);
          }));
          for (var h4 = 0; h4 < r4.length; h4++) k3.setAttrs(r4[h4].el, { class: r4[h4].class, title: r4[h4].title }), r4[h4].el.innerHTML = r4[h4].icon, a4.appendChild(r4[h4].el);
          this._createHamburgerMenu(a4), e4.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e4.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e4.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
        } }, { key: "_createHamburgerMenu", value: function(t5) {
          this.elMenuItems = [], t5.appendChild(this.elMenu), k3.setAttrs(this.elMenu, { class: "apexcharts-menu" });
          for (var e4 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i4 = 0; i4 < e4.length; i4++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i4].innerHTML = e4[i4].title, k3.setAttrs(this.elMenuItems[i4], { class: "apexcharts-menu-item ".concat(e4[i4].name), title: e4[i4].title }), this.elMenu.appendChild(this.elMenuItems[i4]);
        } }, { key: "addToolbarEventListeners", value: function() {
          var t5 = this;
          this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach((function(e5) {
            e5.classList.contains("exportSVG") ? e5.addEventListener("click", t5.handleDownload.bind(t5, "svg")) : e5.classList.contains("exportPNG") ? e5.addEventListener("click", t5.handleDownload.bind(t5, "png")) : e5.classList.contains("exportCSV") && e5.addEventListener("click", t5.handleDownload.bind(t5, "csv"));
          }));
          for (var e4 = 0; e4 < this.t.customIcons.length; e4++) this.elCustomIcons[e4].addEventListener("click", this.t.customIcons[e4].click.bind(this, this.ctx, this.ctx.w));
        } }, { key: "toggleZoomSelection", value: function(t5) {
          this.ctx.getSyncedCharts().forEach((function(e4) {
            e4.ctx.toolbar.toggleOtherControls();
            var i4 = "selection" === t5 ? e4.ctx.toolbar.elSelection : e4.ctx.toolbar.elZoom, a4 = "selection" === t5 ? "selectionEnabled" : "zoomEnabled";
            e4.w.globals[a4] = !e4.w.globals[a4], i4.classList.contains(e4.ctx.toolbar.selectedClass) ? i4.classList.remove(e4.ctx.toolbar.selectedClass) : i4.classList.add(e4.ctx.toolbar.selectedClass);
          }));
        } }, { key: "getToolbarIconsReference", value: function() {
          var t5 = this.w;
          this.elZoom || (this.elZoom = t5.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t5.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t5.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
        } }, { key: "enableZoomPanFromToolbar", value: function(t5) {
          this.toggleOtherControls(), "pan" === t5 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
          var e4 = "pan" === t5 ? this.elPan : this.elZoom, i4 = "pan" === t5 ? this.elZoom : this.elPan;
          e4 && e4.classList.add(this.selectedClass), i4 && i4.classList.remove(this.selectedClass);
        } }, { key: "togglePanning", value: function() {
          this.ctx.getSyncedCharts().forEach((function(t5) {
            t5.ctx.toolbar.toggleOtherControls(), t5.w.globals.panEnabled = !t5.w.globals.panEnabled, t5.ctx.toolbar.elPan.classList.contains(t5.ctx.toolbar.selectedClass) ? t5.ctx.toolbar.elPan.classList.remove(t5.ctx.toolbar.selectedClass) : t5.ctx.toolbar.elPan.classList.add(t5.ctx.toolbar.selectedClass);
          }));
        } }, { key: "toggleOtherControls", value: function() {
          var t5 = this, e4 = this.w;
          e4.globals.panEnabled = false, e4.globals.zoomEnabled = false, e4.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach((function(e5) {
            e5 && e5.classList.remove(t5.selectedClass);
          }));
        } }, { key: "handleZoomIn", value: function() {
          var t5 = this.w;
          t5.globals.isRangeBar && (this.minX = t5.globals.minY, this.maxX = t5.globals.maxY);
          var e4 = (this.minX + this.maxX) / 2, i4 = (this.minX + e4) / 2, a4 = (this.maxX + e4) / 2, s4 = this._getNewMinXMaxX(i4, a4);
          t5.globals.disableZoomIn || this.zoomUpdateOptions(s4.minX, s4.maxX);
        } }, { key: "handleZoomOut", value: function() {
          var t5 = this.w;
          if (t5.globals.isRangeBar && (this.minX = t5.globals.minY, this.maxX = t5.globals.maxY), !("datetime" === t5.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
            var e4 = (this.minX + this.maxX) / 2, i4 = this.minX - (e4 - this.minX), a4 = this.maxX - (e4 - this.maxX), s4 = this._getNewMinXMaxX(i4, a4);
            t5.globals.disableZoomOut || this.zoomUpdateOptions(s4.minX, s4.maxX);
          }
        } }, { key: "_getNewMinXMaxX", value: function(t5, e4) {
          var i4 = this.w.config.xaxis.convertedCatToNumeric;
          return { minX: i4 ? Math.floor(t5) : t5, maxX: i4 ? Math.floor(e4) : e4 };
        } }, { key: "zoomUpdateOptions", value: function(t5, e4) {
          var i4 = this.w;
          if (void 0 !== t5 || void 0 !== e4) {
            if (!(i4.config.xaxis.convertedCatToNumeric && (t5 < 1 && (t5 = 1, e4 = i4.globals.dataPoints), e4 - t5 < 2))) {
              var a4 = { min: t5, max: e4 }, s4 = this.getBeforeZoomRange(a4);
              s4 && (a4 = s4.xaxis);
              var r4 = { xaxis: a4 }, o3 = m3.clone(i4.globals.initialConfig.yaxis);
              i4.config.chart.group || (r4.yaxis = o3), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r4, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a4, o3);
            }
          } else this.handleZoomReset();
        } }, { key: "zoomCallback", value: function(t5, e4) {
          "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t5, yaxis: e4 });
        } }, { key: "getBeforeZoomRange", value: function(t5, e4) {
          var i4 = null;
          return "function" == typeof this.ev.beforeZoom && (i4 = this.ev.beforeZoom(this, { xaxis: t5, yaxis: e4 })), i4;
        } }, { key: "toggleMenu", value: function() {
          var t5 = this;
          window.setTimeout((function() {
            t5.elMenu.classList.contains("apexcharts-menu-open") ? t5.elMenu.classList.remove("apexcharts-menu-open") : t5.elMenu.classList.add("apexcharts-menu-open");
          }), 0);
        } }, { key: "handleDownload", value: function(t5) {
          var e4 = this.w, i4 = new U2(this.ctx);
          switch (t5) {
            case "svg":
              i4.exportToSVG(this.ctx);
              break;
            case "png":
              i4.exportToPng(this.ctx);
              break;
            case "csv":
              i4.exportToCSV({ series: e4.config.series, columnDelimiter: e4.config.chart.toolbar.export.csv.columnDelimiter });
          }
        } }, { key: "handleZoomReset", value: function(t5) {
          this.ctx.getSyncedCharts().forEach((function(t6) {
            var e4 = t6.w;
            if (e4.globals.lastXAxis.min = e4.globals.initialConfig.xaxis.min, e4.globals.lastXAxis.max = e4.globals.initialConfig.xaxis.max, t6.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e4.config.chart.events.beforeResetZoom) {
              var i4 = e4.config.chart.events.beforeResetZoom(t6, e4);
              i4 && t6.updateHelpers.revertDefaultAxisMinMax(i4);
            }
            "function" == typeof e4.config.chart.events.zoomed && t6.ctx.toolbar.zoomCallback({ min: e4.config.xaxis.min, max: e4.config.xaxis.max }), e4.globals.zoomed = false;
            var a4 = t6.ctx.series.emptyCollapsedSeries(m3.clone(e4.globals.initialSeries));
            t6.updateHelpers._updateSeries(a4, e4.config.chart.animations.dynamicAnimation.enabled);
          }));
        } }, { key: "destroy", value: function() {
          this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
        } }]), t4;
      })();
      var ft = (function(t4) {
        h3(a4, ut);
        var e4 = o2(a4);
        function a4(t5) {
          var s4;
          return i3(this, a4), (s4 = e4.call(this, t5)).ctx = t5, s4.w = t5.w, s4.dragged = false, s4.graphics = new k3(s4.ctx), s4.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], s4.clientX = 0, s4.clientY = 0, s4.startX = 0, s4.endX = 0, s4.dragX = 0, s4.startY = 0, s4.endY = 0, s4.dragY = 0, s4.moveDirection = "none", s4.debounceTimer = null, s4.debounceDelay = 100, s4.wheelDelay = 400, s4;
        }
        return s3(a4, [{ key: "init", value: function(t5) {
          var e5 = this, i4 = t5.xyRatios, a5 = this.w, s4 = this;
          this.xyRatios = i4, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a5.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a5.globals.dom.elGraphical.add(this.zoomRect), a5.globals.dom.elGraphical.add(this.selectionRect), "x" === a5.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a5.globals.gridWidth, maxY: a5.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a5.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a5.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a5.globals.dom.baseEl.querySelector("".concat(a5.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach((function(t6) {
            e5.hoverArea.addEventListener(t6, s4.svgMouseEvents.bind(s4, i4), { capture: false, passive: true });
          })), a5.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", s4.mouseWheelEvent.bind(s4), { capture: false, passive: false });
        } }, { key: "destroy", value: function() {
          this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
        } }, { key: "svgMouseEvents", value: function(t5, e5) {
          var i4 = this.w, a5 = this, s4 = this.ctx.toolbar, r4 = i4.globals.zoomEnabled ? i4.config.chart.zoom.type : i4.config.chart.selection.type, o3 = i4.config.chart.toolbar.autoSelected;
          if (e5.shiftKey ? (this.shiftWasPressed = true, s4.enableZoomPanFromToolbar("pan" === o3 ? "zoom" : "pan")) : this.shiftWasPressed && (s4.enableZoomPanFromToolbar(o3), this.shiftWasPressed = false), e5.target) {
            var n3, l4 = e5.target.classList;
            if (e5.target.parentNode && null !== e5.target.parentNode && (n3 = e5.target.parentNode.classList), !(l4.contains("apexcharts-selection-rect") || l4.contains("apexcharts-legend-marker") || l4.contains("apexcharts-legend-text") || n3 && n3.contains("apexcharts-toolbar"))) {
              if (a5.clientX = "touchmove" === e5.type || "touchstart" === e5.type ? e5.touches[0].clientX : "touchend" === e5.type ? e5.changedTouches[0].clientX : e5.clientX, a5.clientY = "touchmove" === e5.type || "touchstart" === e5.type ? e5.touches[0].clientY : "touchend" === e5.type ? e5.changedTouches[0].clientY : e5.clientY, "mousedown" === e5.type && 1 === e5.which) {
                var h4 = a5.gridRect.getBoundingClientRect();
                a5.startX = a5.clientX - h4.left, a5.startY = a5.clientY - h4.top, a5.dragged = false, a5.w.globals.mousedown = true;
              }
              if (("mousemove" === e5.type && 1 === e5.which || "touchmove" === e5.type) && (a5.dragged = true, i4.globals.panEnabled ? (i4.globals.selection = null, a5.w.globals.mousedown && a5.panDragging({ context: a5, zoomtype: r4, xyRatios: t5 })) : (a5.w.globals.mousedown && i4.globals.zoomEnabled || a5.w.globals.mousedown && i4.globals.selectionEnabled) && (a5.selection = a5.selectionDrawing({ context: a5, zoomtype: r4 }))), "mouseup" === e5.type || "touchend" === e5.type || "mouseleave" === e5.type) {
                var c4, d3 = null === (c4 = a5.gridRect) || void 0 === c4 ? void 0 : c4.getBoundingClientRect();
                d3 && a5.w.globals.mousedown && (a5.endX = a5.clientX - d3.left, a5.endY = a5.clientY - d3.top, a5.dragX = Math.abs(a5.endX - a5.startX), a5.dragY = Math.abs(a5.endY - a5.startY), (i4.globals.zoomEnabled || i4.globals.selectionEnabled) && a5.selectionDrawn({ context: a5, zoomtype: r4 }), i4.globals.panEnabled && i4.config.xaxis.convertedCatToNumeric && a5.delayedPanScrolled()), i4.globals.zoomEnabled && a5.hideSelectionRect(this.selectionRect), a5.dragged = false, a5.w.globals.mousedown = false;
              }
              this.makeSelectionRectDraggable();
            }
          }
        } }, { key: "mouseWheelEvent", value: function(t5) {
          var e5 = this, i4 = this.w;
          t5.preventDefault();
          var a5 = Date.now();
          a5 - i4.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(t5), i4.globals.lastWheelExecution = a5), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout((function() {
            a5 - i4.globals.lastWheelExecution > e5.wheelDelay && (e5.executeMouseWheelZoom(t5), i4.globals.lastWheelExecution = a5);
          }), this.debounceDelay);
        } }, { key: "executeMouseWheelZoom", value: function(t5) {
          var e5, i4 = this.w;
          this.minX = i4.globals.isRangeBar ? i4.globals.minY : i4.globals.minX, this.maxX = i4.globals.isRangeBar ? i4.globals.maxY : i4.globals.maxX;
          var a5 = null === (e5 = this.gridRect) || void 0 === e5 ? void 0 : e5.getBoundingClientRect();
          if (a5) {
            var s4, r4, o3, n3 = (t5.clientX - a5.left) / a5.width, l4 = this.minX, h4 = this.maxX, c4 = h4 - l4;
            if (t5.deltaY < 0) {
              var d3 = l4 + n3 * c4;
              r4 = d3 - (s4 = 0.5 * c4) / 2, o3 = d3 + s4 / 2;
            } else r4 = l4 - (s4 = 1.5 * c4) / 2, o3 = h4 + s4 / 2;
            if (!i4.globals.isRangeBar) {
              r4 = Math.max(r4, i4.globals.initialMinX), o3 = Math.min(o3, i4.globals.initialMaxX);
              var g5 = 0.01 * (i4.globals.initialMaxX - i4.globals.initialMinX);
              if (o3 - r4 < g5) {
                var u4 = (r4 + o3) / 2;
                r4 = u4 - g5 / 2, o3 = u4 + g5 / 2;
              }
            }
            var f4 = this._getNewMinXMaxX(r4, o3);
            isNaN(f4.minX) || isNaN(f4.maxX) || this.zoomUpdateOptions(f4.minX, f4.maxX);
          }
        } }, { key: "makeSelectionRectDraggable", value: function() {
          var t5 = this.w;
          if (this.selectionRect) {
            var e5 = this.selectionRect.node.getBoundingClientRect();
            e5.width > 0 && e5.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: t5.globals.gridWidth, maxY: t5.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
          }
        } }, { key: "preselectedSelection", value: function() {
          var t5 = this.w, e5 = this.xyRatios;
          if (!t5.globals.zoomEnabled) {
            if (void 0 !== t5.globals.selection && null !== t5.globals.selection) this.drawSelectionRect(t5.globals.selection);
            else if (void 0 !== t5.config.chart.selection.xaxis.min && void 0 !== t5.config.chart.selection.xaxis.max) {
              var i4 = (t5.config.chart.selection.xaxis.min - t5.globals.minX) / e5.xRatio, a5 = t5.globals.gridWidth - (t5.globals.maxX - t5.config.chart.selection.xaxis.max) / e5.xRatio - i4;
              t5.globals.isRangeBar && (i4 = (t5.config.chart.selection.xaxis.min - t5.globals.yAxisScale[0].niceMin) / e5.invertedYRatio, a5 = (t5.config.chart.selection.xaxis.max - t5.config.chart.selection.xaxis.min) / e5.invertedYRatio);
              var s4 = { x: i4, y: 0, width: a5, height: t5.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
              this.drawSelectionRect(s4), this.makeSelectionRectDraggable(), "function" == typeof t5.config.chart.events.selection && t5.config.chart.events.selection(this.ctx, { xaxis: { min: t5.config.chart.selection.xaxis.min, max: t5.config.chart.selection.xaxis.max }, yaxis: {} });
            }
          }
        } }, { key: "drawSelectionRect", value: function(t5) {
          var e5 = t5.x, i4 = t5.y, a5 = t5.width, s4 = t5.height, r4 = t5.translateX, o3 = void 0 === r4 ? 0 : r4, n3 = t5.translateY, l4 = void 0 === n3 ? 0 : n3, h4 = this.w, c4 = this.zoomRect, d3 = this.selectionRect;
          if (this.dragged || null !== h4.globals.selection) {
            var g5 = { transform: "translate(" + o3 + ", " + l4 + ")" };
            h4.globals.zoomEnabled && this.dragged && (a5 < 0 && (a5 = 1), c4.attr({ x: e5, y: i4, width: a5, height: s4, fill: h4.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h4.config.chart.zoom.zoomedArea.fill.opacity, stroke: h4.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h4.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h4.config.chart.zoom.zoomedArea.stroke.opacity }), k3.setAttrs(c4.node, g5)), h4.globals.selectionEnabled && (d3.attr({ x: e5, y: i4, width: a5 > 0 ? a5 : 0, height: s4 > 0 ? s4 : 0, fill: h4.config.chart.selection.fill.color, "fill-opacity": h4.config.chart.selection.fill.opacity, stroke: h4.config.chart.selection.stroke.color, "stroke-width": h4.config.chart.selection.stroke.width, "stroke-dasharray": h4.config.chart.selection.stroke.dashArray, "stroke-opacity": h4.config.chart.selection.stroke.opacity }), k3.setAttrs(d3.node, g5));
          }
        } }, { key: "hideSelectionRect", value: function(t5) {
          t5 && t5.attr({ x: 0, y: 0, width: 0, height: 0 });
        } }, { key: "selectionDrawing", value: function(t5) {
          var e5 = t5.context, i4 = t5.zoomtype, a5 = this.w, s4 = e5, r4 = this.gridRect.getBoundingClientRect(), o3 = s4.startX - 1, n3 = s4.startY, l4 = false, h4 = false, c4 = s4.clientX - r4.left - o3, d3 = s4.clientY - r4.top - n3, g5 = {};
          return Math.abs(c4 + o3) > a5.globals.gridWidth ? c4 = a5.globals.gridWidth - o3 : s4.clientX - r4.left < 0 && (c4 = o3), o3 > s4.clientX - r4.left && (l4 = true, c4 = Math.abs(c4)), n3 > s4.clientY - r4.top && (h4 = true, d3 = Math.abs(d3)), g5 = "x" === i4 ? { x: l4 ? o3 - c4 : o3, y: 0, width: c4, height: a5.globals.gridHeight } : "y" === i4 ? { x: 0, y: h4 ? n3 - d3 : n3, width: a5.globals.gridWidth, height: d3 } : { x: l4 ? o3 - c4 : o3, y: h4 ? n3 - d3 : n3, width: c4, height: d3 }, s4.drawSelectionRect(g5), s4.selectionDragging("resizing"), g5;
        } }, { key: "selectionDragging", value: function(t5, e5) {
          var i4 = this, a5 = this.w, s4 = this.xyRatios, r4 = this.selectionRect, o3 = 0;
          "resizing" === t5 && (o3 = 30);
          var n3 = function(t6) {
            return parseFloat(r4.node.getAttribute(t6));
          }, l4 = { x: n3("x"), y: n3("y"), width: n3("width"), height: n3("height") };
          a5.globals.selection = l4, "function" == typeof a5.config.chart.events.selection && a5.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((function() {
            var t6, e6, o4, n4, l5 = i4.gridRect.getBoundingClientRect(), h4 = r4.node.getBoundingClientRect();
            a5.globals.isRangeBar ? (t6 = a5.globals.yAxisScale[0].niceMin + (h4.left - l5.left) * s4.invertedYRatio, e6 = a5.globals.yAxisScale[0].niceMin + (h4.right - l5.left) * s4.invertedYRatio, o4 = 0, n4 = 1) : (t6 = a5.globals.xAxisScale.niceMin + (h4.left - l5.left) * s4.xRatio, e6 = a5.globals.xAxisScale.niceMin + (h4.right - l5.left) * s4.xRatio, o4 = a5.globals.yAxisScale[0].niceMin + (l5.bottom - h4.bottom) * s4.yRatio[0], n4 = a5.globals.yAxisScale[0].niceMax - (h4.top - l5.top) * s4.yRatio[0]);
            var c4 = { xaxis: { min: t6, max: e6 }, yaxis: { min: o4, max: n4 } };
            a5.config.chart.events.selection(i4.ctx, c4), a5.config.chart.brush.enabled && void 0 !== a5.config.chart.events.brushScrolled && a5.config.chart.events.brushScrolled(i4.ctx, c4);
          }), o3));
        } }, { key: "selectionDrawn", value: function(t5) {
          var e5 = t5.context, i4 = t5.zoomtype, a5 = this.w, s4 = e5, r4 = this.xyRatios, o3 = this.ctx.toolbar;
          if (s4.startX > s4.endX) {
            var n3 = s4.startX;
            s4.startX = s4.endX, s4.endX = n3;
          }
          if (s4.startY > s4.endY) {
            var l4 = s4.startY;
            s4.startY = s4.endY, s4.endY = l4;
          }
          var h4 = void 0, c4 = void 0;
          a5.globals.isRangeBar ? (h4 = a5.globals.yAxisScale[0].niceMin + s4.startX * r4.invertedYRatio, c4 = a5.globals.yAxisScale[0].niceMin + s4.endX * r4.invertedYRatio) : (h4 = a5.globals.xAxisScale.niceMin + s4.startX * r4.xRatio, c4 = a5.globals.xAxisScale.niceMin + s4.endX * r4.xRatio);
          var d3 = [], g5 = [];
          if (a5.config.yaxis.forEach((function(t6, e6) {
            var i5 = a5.globals.seriesYAxisMap[e6][0];
            d3.push(a5.globals.yAxisScale[e6].niceMax - r4.yRatio[i5] * s4.startY), g5.push(a5.globals.yAxisScale[e6].niceMax - r4.yRatio[i5] * s4.endY);
          })), s4.dragged && (s4.dragX > 10 || s4.dragY > 10) && h4 !== c4) {
            if (a5.globals.zoomEnabled) {
              var u4 = m3.clone(a5.globals.initialConfig.yaxis), f4 = m3.clone(a5.globals.initialConfig.xaxis);
              if (a5.globals.zoomed = true, a5.config.xaxis.convertedCatToNumeric && (h4 = Math.floor(h4), c4 = Math.floor(c4), h4 < 1 && (h4 = 1, c4 = a5.globals.dataPoints), c4 - h4 < 2 && (c4 = h4 + 1)), "xy" !== i4 && "x" !== i4 || (f4 = { min: h4, max: c4 }), "xy" !== i4 && "y" !== i4 || u4.forEach((function(t6, e6) {
                u4[e6].min = g5[e6], u4[e6].max = d3[e6];
              })), o3) {
                var p4 = o3.getBeforeZoomRange(f4, u4);
                p4 && (f4 = p4.xaxis ? p4.xaxis : f4, u4 = p4.yaxis ? p4.yaxis : u4);
              }
              var x5 = { xaxis: f4 };
              a5.config.chart.group || (x5.yaxis = u4), s4.ctx.updateHelpers._updateOptions(x5, false, s4.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a5.config.chart.events.zoomed && o3.zoomCallback(f4, u4);
            } else if (a5.globals.selectionEnabled) {
              var b4, v4 = null;
              b4 = { min: h4, max: c4 }, "xy" !== i4 && "y" !== i4 || (v4 = m3.clone(a5.config.yaxis)).forEach((function(t6, e6) {
                v4[e6].min = g5[e6], v4[e6].max = d3[e6];
              })), a5.globals.selection = s4.selection, "function" == typeof a5.config.chart.events.selection && a5.config.chart.events.selection(s4.ctx, { xaxis: b4, yaxis: v4 });
            }
          }
        } }, { key: "panDragging", value: function(t5) {
          var e5 = t5.context, i4 = this.w, a5 = e5;
          if (void 0 !== i4.globals.lastClientPosition.x) {
            var s4 = i4.globals.lastClientPosition.x - a5.clientX, r4 = i4.globals.lastClientPosition.y - a5.clientY;
            Math.abs(s4) > Math.abs(r4) && s4 > 0 ? this.moveDirection = "left" : Math.abs(s4) > Math.abs(r4) && s4 < 0 ? this.moveDirection = "right" : Math.abs(r4) > Math.abs(s4) && r4 > 0 ? this.moveDirection = "up" : Math.abs(r4) > Math.abs(s4) && r4 < 0 && (this.moveDirection = "down");
          }
          i4.globals.lastClientPosition = { x: a5.clientX, y: a5.clientY };
          var o3 = i4.globals.isRangeBar ? i4.globals.minY : i4.globals.minX, n3 = i4.globals.isRangeBar ? i4.globals.maxY : i4.globals.maxX;
          i4.config.xaxis.convertedCatToNumeric || a5.panScrolled(o3, n3);
        } }, { key: "delayedPanScrolled", value: function() {
          var t5 = this.w, e5 = t5.globals.minX, i4 = t5.globals.maxX, a5 = (t5.globals.maxX - t5.globals.minX) / 2;
          "left" === this.moveDirection ? (e5 = t5.globals.minX + a5, i4 = t5.globals.maxX + a5) : "right" === this.moveDirection && (e5 = t5.globals.minX - a5, i4 = t5.globals.maxX - a5), e5 = Math.floor(e5), i4 = Math.floor(i4), this.updateScrolledChart({ xaxis: { min: e5, max: i4 } }, e5, i4);
        } }, { key: "panScrolled", value: function(t5, e5) {
          var i4 = this.w, a5 = this.xyRatios, s4 = m3.clone(i4.globals.initialConfig.yaxis), r4 = a5.xRatio, o3 = i4.globals.minX, n3 = i4.globals.maxX;
          i4.globals.isRangeBar && (r4 = a5.invertedYRatio, o3 = i4.globals.minY, n3 = i4.globals.maxY), "left" === this.moveDirection ? (t5 = o3 + i4.globals.gridWidth / 15 * r4, e5 = n3 + i4.globals.gridWidth / 15 * r4) : "right" === this.moveDirection && (t5 = o3 - i4.globals.gridWidth / 15 * r4, e5 = n3 - i4.globals.gridWidth / 15 * r4), i4.globals.isRangeBar || (t5 < i4.globals.initialMinX || e5 > i4.globals.initialMaxX) && (t5 = o3, e5 = n3);
          var l4 = { xaxis: { min: t5, max: e5 } };
          i4.config.chart.group || (l4.yaxis = s4), this.updateScrolledChart(l4, t5, e5);
        } }, { key: "updateScrolledChart", value: function(t5, e5, i4) {
          var a5 = this.w;
          this.ctx.updateHelpers._updateOptions(t5, false, false), "function" == typeof a5.config.chart.events.scrolled && a5.config.chart.events.scrolled(this.ctx, { xaxis: { min: e5, max: i4 } });
        } }]), a4;
      })();
      var pt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.ttCtx = e4, this.ctx = e4.ctx;
        }
        return s3(t4, [{ key: "getNearestValues", value: function(t5) {
          var e4 = t5.hoverArea, i4 = t5.elGrid, a4 = t5.clientX, s4 = t5.clientY, r4 = this.w, o3 = i4.getBoundingClientRect(), n3 = o3.width, l4 = o3.height, h4 = n3 / (r4.globals.dataPoints - 1), c4 = l4 / r4.globals.dataPoints, d3 = this.hasBars();
          !r4.globals.comboCharts && !d3 || r4.config.xaxis.convertedCatToNumeric || (h4 = n3 / r4.globals.dataPoints);
          var g5 = a4 - o3.left - r4.globals.barPadForNumericAxis, u4 = s4 - o3.top;
          g5 < 0 || u4 < 0 || g5 > n3 || u4 > l4 ? (e4.classList.remove("hovering-zoom"), e4.classList.remove("hovering-pan")) : r4.globals.zoomEnabled ? (e4.classList.remove("hovering-pan"), e4.classList.add("hovering-zoom")) : r4.globals.panEnabled && (e4.classList.remove("hovering-zoom"), e4.classList.add("hovering-pan"));
          var f4 = Math.round(g5 / h4), p4 = Math.floor(u4 / c4);
          d3 && !r4.config.xaxis.convertedCatToNumeric && (f4 = Math.ceil(g5 / h4), f4 -= 1);
          var x5 = null, b4 = null, v4 = r4.globals.seriesXvalues.map((function(t6) {
            return t6.filter((function(t7) {
              return m3.isNumber(t7);
            }));
          })), y4 = r4.globals.seriesYvalues.map((function(t6) {
            return t6.filter((function(t7) {
              return m3.isNumber(t7);
            }));
          }));
          if (r4.globals.isXNumeric) {
            var w5 = this.ttCtx.getElGrid().getBoundingClientRect(), k4 = g5 * (w5.width / n3), A4 = u4 * (w5.height / l4);
            x5 = (b4 = this.closestInMultiArray(k4, A4, v4, y4)).index, f4 = b4.j, null !== x5 && (v4 = r4.globals.seriesXvalues[x5], f4 = (b4 = this.closestInArray(k4, v4)).index);
          }
          return r4.globals.capturedSeriesIndex = null === x5 ? -1 : x5, (!f4 || f4 < 1) && (f4 = 0), r4.globals.isBarHorizontal ? r4.globals.capturedDataPointIndex = p4 : r4.globals.capturedDataPointIndex = f4, { capturedSeries: x5, j: r4.globals.isBarHorizontal ? p4 : f4, hoverX: g5, hoverY: u4 };
        } }, { key: "closestInMultiArray", value: function(t5, e4, i4, a4) {
          var s4 = this.w, r4 = 0, o3 = null, n3 = -1;
          s4.globals.series.length > 1 ? r4 = this.getFirstActiveXArray(i4) : o3 = 0;
          var l4 = i4[r4][0], h4 = Math.abs(t5 - l4);
          if (i4.forEach((function(e5) {
            e5.forEach((function(e6, i5) {
              var a5 = Math.abs(t5 - e6);
              a5 <= h4 && (h4 = a5, n3 = i5);
            }));
          })), -1 !== n3) {
            var c4 = a4[r4][n3], d3 = Math.abs(e4 - c4);
            o3 = r4, a4.forEach((function(t6, i5) {
              var a5 = Math.abs(e4 - t6[n3]);
              a5 <= d3 && (d3 = a5, o3 = i5);
            }));
          }
          return { index: o3, j: n3 };
        } }, { key: "getFirstActiveXArray", value: function(t5) {
          for (var e4 = this.w, i4 = 0, a4 = t5.map((function(t6, e5) {
            return t6.length > 0 ? e5 : -1;
          })), s4 = 0; s4 < a4.length; s4++) if (-1 !== a4[s4] && -1 === e4.globals.collapsedSeriesIndices.indexOf(s4) && -1 === e4.globals.ancillaryCollapsedSeriesIndices.indexOf(s4)) {
            i4 = a4[s4];
            break;
          }
          return i4;
        } }, { key: "closestInArray", value: function(t5, e4) {
          for (var i4 = e4[0], a4 = null, s4 = Math.abs(t5 - i4), r4 = 0; r4 < e4.length; r4++) {
            var o3 = Math.abs(t5 - e4[r4]);
            o3 < s4 && (s4 = o3, a4 = r4);
          }
          return { index: a4 };
        } }, { key: "isXoverlap", value: function(t5) {
          var e4 = [], i4 = this.w.globals.seriesX.filter((function(t6) {
            return void 0 !== t6[0];
          }));
          if (i4.length > 0) for (var a4 = 0; a4 < i4.length - 1; a4++) void 0 !== i4[a4][t5] && void 0 !== i4[a4 + 1][t5] && i4[a4][t5] !== i4[a4 + 1][t5] && e4.push("unEqual");
          return 0 === e4.length;
        } }, { key: "isInitialSeriesSameLen", value: function() {
          for (var t5 = true, e4 = this.w.globals.initialSeries, i4 = 0; i4 < e4.length - 1; i4++) if (e4[i4].data.length !== e4[i4 + 1].data.length) {
            t5 = false;
            break;
          }
          return t5;
        } }, { key: "getBarsHeight", value: function(t5) {
          return p3(t5).reduce((function(t6, e4) {
            return t6 + e4.getBBox().height;
          }), 0);
        } }, { key: "getElMarkers", value: function(t5) {
          return "number" == typeof t5 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t5, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
        } }, { key: "getAllMarkers", value: function() {
          var t5 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
          (t5 = p3(t5)).sort((function(t6, e5) {
            var i4 = Number(t6.getAttribute("data:realIndex")), a4 = Number(e5.getAttribute("data:realIndex"));
            return a4 < i4 ? 1 : a4 > i4 ? -1 : 0;
          }));
          var e4 = [];
          return t5.forEach((function(t6) {
            e4.push(t6.querySelector(".apexcharts-marker"));
          })), e4;
        } }, { key: "hasMarkers", value: function(t5) {
          return this.getElMarkers(t5).length > 0;
        } }, { key: "getPathFromPoint", value: function(t5, e4) {
          var i4 = Number(t5.getAttribute("cx")), a4 = Number(t5.getAttribute("cy")), s4 = t5.getAttribute("shape");
          return new k3(this.ctx).getMarkerPath(i4, a4, s4, e4);
        } }, { key: "getElBars", value: function() {
          return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
        } }, { key: "hasBars", value: function() {
          return this.getElBars().length > 0;
        } }, { key: "getHoverMarkerSize", value: function(t5) {
          var e4 = this.w, i4 = e4.config.markers.hover.size;
          return void 0 === i4 && (i4 = e4.globals.markers.size[t5] + e4.config.markers.hover.sizeOffset), i4;
        } }, { key: "toggleAllTooltipSeriesGroups", value: function(t5) {
          var e4 = this.w, i4 = this.ttCtx;
          0 === i4.allTooltipSeriesGroups.length && (i4.allTooltipSeriesGroups = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
          for (var a4 = i4.allTooltipSeriesGroups, s4 = 0; s4 < a4.length; s4++) "enable" === t5 ? (a4[s4].classList.add("apexcharts-active"), a4[s4].style.display = e4.config.tooltip.items.display) : (a4[s4].classList.remove("apexcharts-active"), a4[s4].style.display = "none");
        } }]), t4;
      })();
      var xt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.ctx = e4.ctx, this.ttCtx = e4, this.tooltipUtil = new pt(e4);
        }
        return s3(t4, [{ key: "drawSeriesTexts", value: function(t5) {
          var e4 = t5.shared, i4 = void 0 === e4 || e4, a4 = t5.ttItems, s4 = t5.i, r4 = void 0 === s4 ? 0 : s4, o3 = t5.j, n3 = void 0 === o3 ? null : o3, l4 = t5.y1, h4 = t5.y2, c4 = t5.e, d3 = this.w;
          void 0 !== d3.config.tooltip.custom ? this.handleCustomTooltip({ i: r4, j: n3, y1: l4, y2: h4, w: d3 }) : this.toggleActiveInactiveSeries(i4, r4);
          var g5 = this.getValuesToPrint({ i: r4, j: n3 });
          this.printLabels({ i: r4, j: n3, values: g5, ttItems: a4, shared: i4, e: c4 });
          var u4 = this.ttCtx.getElTooltip();
          this.ttCtx.tooltipRect.ttWidth = u4.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u4.getBoundingClientRect().height;
        } }, { key: "printLabels", value: function(t5) {
          var e4, i4 = this, a4 = t5.i, s4 = t5.j, r4 = t5.values, o3 = t5.ttItems, n3 = t5.shared, l4 = t5.e, h4 = this.w, c4 = [], d3 = function(t6) {
            return h4.globals.seriesGoals[t6] && h4.globals.seriesGoals[t6][s4] && Array.isArray(h4.globals.seriesGoals[t6][s4]);
          }, u4 = r4.xVal, f4 = r4.zVal, p4 = r4.xAxisTTVal, x5 = "", b4 = h4.globals.colors[a4];
          null !== s4 && h4.config.plotOptions.bar.distributed && (b4 = h4.globals.colors[s4]);
          for (var v4 = function(t6, r5) {
            var v5 = i4.getFormatters(a4);
            x5 = i4.getSeriesName({ fn: v5.yLbTitleFormatter, index: a4, seriesIndex: a4, j: s4 }), "treemap" === h4.config.chart.type && (x5 = v5.yLbTitleFormatter(String(h4.config.series[a4].data[s4].x), { series: h4.globals.series, seriesIndex: a4, dataPointIndex: s4, w: h4 }));
            var m5 = h4.config.tooltip.inverseOrder ? r5 : t6;
            if (h4.globals.axisCharts) {
              var y5 = function(t7) {
                var e5, i5, a5, r6;
                return h4.globals.isRangeData ? v5.yLbFormatter(null === (e5 = h4.globals.seriesRangeStart) || void 0 === e5 || null === (i5 = e5[t7]) || void 0 === i5 ? void 0 : i5[s4], { series: h4.globals.seriesRangeStart, seriesIndex: t7, dataPointIndex: s4, w: h4 }) + " - " + v5.yLbFormatter(null === (a5 = h4.globals.seriesRangeEnd) || void 0 === a5 || null === (r6 = a5[t7]) || void 0 === r6 ? void 0 : r6[s4], { series: h4.globals.seriesRangeEnd, seriesIndex: t7, dataPointIndex: s4, w: h4 }) : v5.yLbFormatter(h4.globals.series[t7][s4], { series: h4.globals.series, seriesIndex: t7, dataPointIndex: s4, w: h4 });
              };
              if (n3) v5 = i4.getFormatters(m5), x5 = i4.getSeriesName({ fn: v5.yLbTitleFormatter, index: m5, seriesIndex: a4, j: s4 }), b4 = h4.globals.colors[m5], e4 = y5(m5), d3(m5) && (c4 = h4.globals.seriesGoals[m5][s4].map((function(t7) {
                return { attrs: t7, val: v5.yLbFormatter(t7.value, { seriesIndex: m5, dataPointIndex: s4, w: h4 }) };
              })));
              else {
                var w5, k4 = null == l4 || null === (w5 = l4.target) || void 0 === w5 ? void 0 : w5.getAttribute("fill");
                k4 && (-1 !== k4.indexOf("url") ? -1 !== k4.indexOf("Pattern") && (b4 = h4.globals.dom.baseEl.querySelector(k4.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : b4 = k4), e4 = y5(a4), d3(a4) && Array.isArray(h4.globals.seriesGoals[a4][s4]) && (c4 = h4.globals.seriesGoals[a4][s4].map((function(t7) {
                  return { attrs: t7, val: v5.yLbFormatter(t7.value, { seriesIndex: a4, dataPointIndex: s4, w: h4 }) };
                })));
              }
            }
            null === s4 && (e4 = v5.yLbFormatter(h4.globals.series[a4], g4(g4({}, h4), {}, { seriesIndex: a4, dataPointIndex: a4 }))), i4.DOMHandling({ i: a4, t: m5, j: s4, ttItems: o3, values: { val: e4, goalVals: c4, xVal: u4, xAxisTTVal: p4, zVal: f4 }, seriesName: x5, shared: n3, pColor: b4 });
          }, m4 = 0, y4 = h4.globals.series.length - 1; m4 < h4.globals.series.length; m4++, y4--) v4(m4, y4);
        } }, { key: "getFormatters", value: function(t5) {
          var e4, i4 = this.w, a4 = i4.globals.yLabelFormatters[t5];
          return void 0 !== i4.globals.ttVal ? Array.isArray(i4.globals.ttVal) ? (a4 = i4.globals.ttVal[t5] && i4.globals.ttVal[t5].formatter, e4 = i4.globals.ttVal[t5] && i4.globals.ttVal[t5].title && i4.globals.ttVal[t5].title.formatter) : (a4 = i4.globals.ttVal.formatter, "function" == typeof i4.globals.ttVal.title.formatter && (e4 = i4.globals.ttVal.title.formatter)) : e4 = i4.config.tooltip.y.title.formatter, "function" != typeof a4 && (a4 = i4.globals.yLabelFormatters[0] ? i4.globals.yLabelFormatters[0] : function(t6) {
            return t6;
          }), "function" != typeof e4 && (e4 = function(t6) {
            return t6;
          }), { yLbFormatter: a4, yLbTitleFormatter: e4 };
        } }, { key: "getSeriesName", value: function(t5) {
          var e4 = t5.fn, i4 = t5.index, a4 = t5.seriesIndex, s4 = t5.j, r4 = this.w;
          return e4(String(r4.globals.seriesNames[i4]), { series: r4.globals.series, seriesIndex: a4, dataPointIndex: s4, w: r4 });
        } }, { key: "DOMHandling", value: function(t5) {
          t5.i;
          var e4 = t5.t, i4 = t5.j, a4 = t5.ttItems, s4 = t5.values, r4 = t5.seriesName, o3 = t5.shared, n3 = t5.pColor, l4 = this.w, h4 = this.ttCtx, c4 = s4.val, d3 = s4.goalVals, g5 = s4.xVal, u4 = s4.xAxisTTVal, f4 = s4.zVal, p4 = null;
          p4 = a4[e4].children, l4.config.tooltip.fillSeriesColor && (a4[e4].style.backgroundColor = n3, p4[0].style.display = "none"), h4.showTooltipTitle && (null === h4.tooltipTitle && (h4.tooltipTitle = l4.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h4.tooltipTitle.innerHTML = g5), h4.isXAxisTooltipEnabled && (h4.xaxisTooltipText.innerHTML = "" !== u4 ? u4 : g5);
          var x5 = a4[e4].querySelector(".apexcharts-tooltip-text-y-label");
          x5 && (x5.innerHTML = r4 || "");
          var b4 = a4[e4].querySelector(".apexcharts-tooltip-text-y-value");
          b4 && (b4.innerHTML = void 0 !== c4 ? c4 : ""), p4[0] && p4[0].classList.contains("apexcharts-tooltip-marker") && (l4.config.tooltip.marker.fillColors && Array.isArray(l4.config.tooltip.marker.fillColors) && (n3 = l4.config.tooltip.marker.fillColors[e4]), p4[0].style.backgroundColor = n3), l4.config.tooltip.marker.show || (p4[0].style.display = "none");
          var v4 = a4[e4].querySelector(".apexcharts-tooltip-text-goals-label"), m4 = a4[e4].querySelector(".apexcharts-tooltip-text-goals-value");
          if (d3.length && l4.globals.seriesGoals[e4]) {
            var y4 = function() {
              var t6 = "<div >", e5 = "<div>";
              d3.forEach((function(i5, a5) {
                t6 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i5.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i5.attrs.name, "</div>"), e5 += "<div>".concat(i5.val, "</div>");
              })), v4.innerHTML = t6 + "</div>", m4.innerHTML = e5 + "</div>";
            };
            o3 ? l4.globals.seriesGoals[e4][i4] && Array.isArray(l4.globals.seriesGoals[e4][i4]) ? y4() : (v4.innerHTML = "", m4.innerHTML = "") : y4();
          } else v4.innerHTML = "", m4.innerHTML = "";
          null !== f4 && (a4[e4].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l4.config.tooltip.z.title, a4[e4].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== f4 ? f4 : "");
          if (o3 && p4[0]) {
            if (l4.config.tooltip.hideEmptySeries) {
              var w5 = a4[e4].querySelector(".apexcharts-tooltip-marker"), k4 = a4[e4].querySelector(".apexcharts-tooltip-text");
              0 == parseFloat(c4) ? (w5.style.display = "none", k4.style.display = "none") : (w5.style.display = "block", k4.style.display = "block");
            }
            null == c4 || l4.globals.ancillaryCollapsedSeriesIndices.indexOf(e4) > -1 || l4.globals.collapsedSeriesIndices.indexOf(e4) > -1 || Array.isArray(h4.tConfig.enabledOnSeries) && -1 === h4.tConfig.enabledOnSeries.indexOf(e4) ? p4[0].parentNode.style.display = "none" : p4[0].parentNode.style.display = l4.config.tooltip.items.display;
          } else Array.isArray(h4.tConfig.enabledOnSeries) && -1 === h4.tConfig.enabledOnSeries.indexOf(e4) && (p4[0].parentNode.style.display = "none");
        } }, { key: "toggleActiveInactiveSeries", value: function(t5, e4) {
          var i4 = this.w;
          if (t5) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
          else {
            this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
            var a4 = i4.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e4));
            a4 && (a4.classList.add("apexcharts-active"), a4.style.display = i4.config.tooltip.items.display);
          }
        } }, { key: "getValuesToPrint", value: function(t5) {
          var e4 = t5.i, i4 = t5.j, a4 = this.w, s4 = this.ctx.series.filteredSeriesX(), r4 = "", o3 = "", n3 = null, l4 = null, h4 = { series: a4.globals.series, seriesIndex: e4, dataPointIndex: i4, w: a4 }, c4 = a4.globals.ttZFormatter;
          null === i4 ? l4 = a4.globals.series[e4] : a4.globals.isXNumeric && "treemap" !== a4.config.chart.type ? (r4 = s4[e4][i4], 0 === s4[e4].length && (r4 = s4[this.tooltipUtil.getFirstActiveXArray(s4)][i4])) : r4 = new _3(this.ctx).isFormatXY() ? void 0 !== a4.config.series[e4].data[i4] ? a4.config.series[e4].data[i4].x : "" : void 0 !== a4.globals.labels[i4] ? a4.globals.labels[i4] : "";
          var d3 = r4;
          a4.globals.isXNumeric && "datetime" === a4.config.xaxis.type ? r4 = new P3(this.ctx).xLabelFormat(a4.globals.ttKeyFormatter, d3, d3, { i: void 0, dateFormatter: new L3(this.ctx).formatDate, w: this.w }) : r4 = a4.globals.isBarHorizontal ? a4.globals.yLabelFormatters[0](d3, h4) : a4.globals.xLabelFormatter(d3, h4);
          return void 0 !== a4.config.tooltip.x.formatter && (r4 = a4.globals.ttKeyFormatter(d3, h4)), a4.globals.seriesZ.length > 0 && a4.globals.seriesZ[e4].length > 0 && (n3 = c4(a4.globals.seriesZ[e4][i4], a4)), o3 = "function" == typeof a4.config.xaxis.tooltip.formatter ? a4.globals.xaxisTooltipFormatter(d3, h4) : r4, { val: Array.isArray(l4) ? l4.join(" ") : l4, xVal: Array.isArray(r4) ? r4.join(" ") : r4, xAxisTTVal: Array.isArray(o3) ? o3.join(" ") : o3, zVal: n3 };
        } }, { key: "handleCustomTooltip", value: function(t5) {
          var e4 = t5.i, i4 = t5.j, a4 = t5.y1, s4 = t5.y2, r4 = t5.w, o3 = this.ttCtx.getElTooltip(), n3 = r4.config.tooltip.custom;
          Array.isArray(n3) && n3[e4] && (n3 = n3[e4]), o3.innerHTML = n3({ ctx: this.ctx, series: r4.globals.series, seriesIndex: e4, dataPointIndex: i4, y1: a4, y2: s4, w: r4 });
        } }]), t4;
      })();
      var bt = (function() {
        function t4(e4) {
          i3(this, t4), this.ttCtx = e4, this.ctx = e4.ctx, this.w = e4.w;
        }
        return s3(t4, [{ key: "moveXCrosshairs", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i4 = this.ttCtx, a4 = this.w, s4 = i4.getElXCrosshairs(), r4 = t5 - i4.xcrosshairsWidth / 2, o3 = a4.globals.labels.slice().length;
          if (null !== e4 && (r4 = a4.globals.gridWidth / o3 * e4), null === s4 || a4.globals.isBarHorizontal || (s4.setAttribute("x", r4), s4.setAttribute("x1", r4), s4.setAttribute("x2", r4), s4.setAttribute("y2", a4.globals.gridHeight), s4.classList.add("apexcharts-active")), r4 < 0 && (r4 = 0), r4 > a4.globals.gridWidth && (r4 = a4.globals.gridWidth), i4.isXAxisTooltipEnabled) {
            var n3 = r4;
            "tickWidth" !== a4.config.xaxis.crosshairs.width && "barWidth" !== a4.config.xaxis.crosshairs.width || (n3 = r4 + i4.xcrosshairsWidth / 2), this.moveXAxisTooltip(n3);
          }
        } }, { key: "moveYCrosshairs", value: function(t5) {
          var e4 = this.ttCtx;
          null !== e4.ycrosshairs && k3.setAttrs(e4.ycrosshairs, { y1: t5, y2: t5 }), null !== e4.ycrosshairsHidden && k3.setAttrs(e4.ycrosshairsHidden, { y1: t5, y2: t5 });
        } }, { key: "moveXAxisTooltip", value: function(t5) {
          var e4 = this.w, i4 = this.ttCtx;
          if (null !== i4.xaxisTooltip && 0 !== i4.xcrosshairsWidth) {
            i4.xaxisTooltip.classList.add("apexcharts-active");
            var a4 = i4.xaxisOffY + e4.config.xaxis.tooltip.offsetY + e4.globals.translateY + 1 + e4.config.xaxis.offsetY;
            if (t5 -= i4.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t5)) {
              t5 += e4.globals.translateX;
              var s4;
              s4 = new k3(this.ctx).getTextRects(i4.xaxisTooltipText.innerHTML), i4.xaxisTooltipText.style.minWidth = s4.width + "px", i4.xaxisTooltip.style.left = t5 + "px", i4.xaxisTooltip.style.top = a4 + "px";
            }
          }
        } }, { key: "moveYAxisTooltip", value: function(t5) {
          var e4 = this.w, i4 = this.ttCtx;
          null === i4.yaxisTTEls && (i4.yaxisTTEls = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
          var a4 = parseInt(i4.ycrosshairsHidden.getAttribute("y1"), 10), s4 = e4.globals.translateY + a4, r4 = i4.yaxisTTEls[t5].getBoundingClientRect().height, o3 = e4.globals.translateYAxisX[t5] - 2;
          e4.config.yaxis[t5].opposite && (o3 -= 26), s4 -= r4 / 2, -1 === e4.globals.ignoreYAxisIndexes.indexOf(t5) ? (i4.yaxisTTEls[t5].classList.add("apexcharts-active"), i4.yaxisTTEls[t5].style.top = s4 + "px", i4.yaxisTTEls[t5].style.left = o3 + e4.config.yaxis[t5].tooltip.offsetX + "px") : i4.yaxisTTEls[t5].classList.remove("apexcharts-active");
        } }, { key: "moveTooltip", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a4 = this.w, s4 = this.ttCtx, r4 = s4.getElTooltip(), o3 = s4.tooltipRect, n3 = null !== i4 ? parseFloat(i4) : 1, l4 = parseFloat(t5) + n3 + 5, h4 = parseFloat(e4) + n3 / 2;
          if (l4 > a4.globals.gridWidth / 2 && (l4 = l4 - o3.ttWidth - n3 - 10), l4 > a4.globals.gridWidth - o3.ttWidth - 10 && (l4 = a4.globals.gridWidth - o3.ttWidth), l4 < -20 && (l4 = -20), a4.config.tooltip.followCursor) {
            var c4 = s4.getElGrid().getBoundingClientRect();
            (l4 = s4.e.clientX - c4.left) > a4.globals.gridWidth / 2 && (l4 -= s4.tooltipRect.ttWidth), (h4 = s4.e.clientY + a4.globals.translateY - c4.top) > a4.globals.gridHeight / 2 && (h4 -= s4.tooltipRect.ttHeight);
          } else a4.globals.isBarHorizontal || o3.ttHeight / 2 + h4 > a4.globals.gridHeight && (h4 = a4.globals.gridHeight - o3.ttHeight + a4.globals.translateY);
          isNaN(l4) || (l4 += a4.globals.translateX, r4.style.left = l4 + "px", r4.style.top = h4 + "px");
        } }, { key: "moveMarkers", value: function(t5, e4) {
          var i4 = this.w, a4 = this.ttCtx;
          if (i4.globals.markers.size[t5] > 0) for (var s4 = i4.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t5, "'] .apexcharts-marker")), r4 = 0; r4 < s4.length; r4++) parseInt(s4[r4].getAttribute("rel"), 10) === e4 && (a4.marker.resetPointsSize(), a4.marker.enlargeCurrentPoint(e4, s4[r4]));
          else a4.marker.resetPointsSize(), this.moveDynamicPointOnHover(e4, t5);
        } }, { key: "moveDynamicPointOnHover", value: function(t5, e4) {
          var i4, a4, s4, r4, o3 = this.w, n3 = this.ttCtx, l4 = new k3(this.ctx), h4 = o3.globals.pointsArray, c4 = n3.tooltipUtil.getHoverMarkerSize(e4), d3 = o3.config.series[e4].type;
          if (!d3 || "column" !== d3 && "candlestick" !== d3 && "boxPlot" !== d3) {
            s4 = null === (i4 = h4[e4][t5]) || void 0 === i4 ? void 0 : i4[0], r4 = (null === (a4 = h4[e4][t5]) || void 0 === a4 ? void 0 : a4[1]) || 0;
            var g5 = o3.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e4, "'] .apexcharts-series-markers path"));
            if (g5 && r4 < o3.globals.gridHeight && r4 > 0) {
              var u4 = g5.getAttribute("shape"), f4 = l4.getMarkerPath(s4, r4, u4, 1.5 * c4);
              g5.setAttribute("d", f4);
            }
            this.moveXCrosshairs(s4), n3.fixedTooltip || this.moveTooltip(s4, r4, c4);
          }
        } }, { key: "moveDynamicPointsOnHover", value: function(t5) {
          var e4, i4 = this.ttCtx, a4 = i4.w, s4 = 0, r4 = 0, o3 = a4.globals.pointsArray, n3 = new V3(this.ctx), l4 = new k3(this.ctx);
          e4 = n3.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
          var h4 = i4.tooltipUtil.getHoverMarkerSize(e4);
          o3[e4] && (s4 = o3[e4][t5][0], r4 = o3[e4][t5][1]);
          var c4 = i4.tooltipUtil.getAllMarkers();
          if (null !== c4) for (var d3 = 0; d3 < a4.globals.series.length; d3++) {
            var g5 = o3[d3];
            if (a4.globals.comboCharts && void 0 === g5 && c4.splice(d3, 0, null), g5 && g5.length) {
              var u4 = o3[d3][t5][1], f4 = void 0;
              c4[d3].setAttribute("cx", s4);
              var p4 = c4[d3].getAttribute("shape");
              if ("rangeArea" === a4.config.chart.type && !a4.globals.comboCharts) {
                var x5 = t5 + a4.globals.series[d3].length;
                f4 = o3[d3][x5][1], u4 -= Math.abs(u4 - f4) / 2;
              }
              if (null !== u4 && !isNaN(u4) && u4 < a4.globals.gridHeight + h4 && u4 + h4 > 0) {
                var b4 = l4.getMarkerPath(s4, u4, p4, h4);
                c4[d3].setAttribute("d", b4);
              } else c4[d3].setAttribute("d", "");
            }
          }
          this.moveXCrosshairs(s4), i4.fixedTooltip || this.moveTooltip(s4, r4 || a4.globals.gridHeight, h4);
        } }, { key: "moveStickyTooltipOverBars", value: function(t5, e4) {
          var i4 = this.w, a4 = this.ttCtx, s4 = i4.globals.columnSeries ? i4.globals.columnSeries.length : i4.globals.series.length, r4 = s4 >= 2 && s4 % 2 == 0 ? Math.floor(s4 / 2) : Math.floor(s4 / 2) + 1;
          i4.globals.isBarHorizontal && (r4 = new V3(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
          var o3 = i4.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r4, "'] path[j='").concat(t5, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r4, "'] path[j='").concat(t5, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r4, "'] path[j='").concat(t5, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r4, "'] path[j='").concat(t5, "']"));
          o3 || "number" != typeof e4 || (o3 = i4.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e4, "'] path[j='").concat(t5, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e4, "'] path[j='").concat(t5, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e4, "'] path[j='").concat(t5, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e4, "'] path[j='").concat(t5, "']")));
          var n3 = o3 ? parseFloat(o3.getAttribute("cx")) : 0, l4 = o3 ? parseFloat(o3.getAttribute("cy")) : 0, h4 = o3 ? parseFloat(o3.getAttribute("barWidth")) : 0, c4 = a4.getElGrid().getBoundingClientRect(), d3 = o3 && (o3.classList.contains("apexcharts-candlestick-area") || o3.classList.contains("apexcharts-boxPlot-area"));
          i4.globals.isXNumeric ? (o3 && !d3 && (n3 -= s4 % 2 != 0 ? h4 / 2 : 0), o3 && d3 && i4.globals.comboCharts && (n3 -= h4 / 2)) : i4.globals.isBarHorizontal || (n3 = a4.xAxisTicksPositions[t5 - 1] + a4.dataPointsDividedWidth / 2, isNaN(n3) && (n3 = a4.xAxisTicksPositions[t5] - a4.dataPointsDividedWidth / 2)), i4.globals.isBarHorizontal ? l4 -= a4.tooltipRect.ttHeight : i4.config.tooltip.followCursor ? l4 = a4.e.clientY - c4.top - a4.tooltipRect.ttHeight / 2 : l4 + a4.tooltipRect.ttHeight + 15 > i4.globals.gridHeight && (l4 = i4.globals.gridHeight), i4.globals.isBarHorizontal || this.moveXCrosshairs(n3), a4.fixedTooltip || this.moveTooltip(n3, l4 || i4.globals.gridHeight);
        } }]), t4;
      })();
      var vt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.ttCtx = e4, this.ctx = e4.ctx, this.tooltipPosition = new bt(e4);
        }
        return s3(t4, [{ key: "drawDynamicPoints", value: function() {
          var t5 = this.w, e4 = new k3(this.ctx), i4 = new W2(this.ctx), a4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
          a4 = p3(a4), t5.config.chart.stacked && a4.sort((function(t6, e5) {
            return parseFloat(t6.getAttribute("data:realIndex")) - parseFloat(e5.getAttribute("data:realIndex"));
          }));
          for (var s4 = 0; s4 < a4.length; s4++) {
            var r4 = a4[s4].querySelector(".apexcharts-series-markers-wrap");
            if (null !== r4) {
              var o3 = void 0, n3 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
              "line" !== t5.config.chart.type && "area" !== t5.config.chart.type || t5.globals.comboCharts || t5.config.tooltip.intersect || (n3 += " no-pointer-events");
              var l4 = i4.getMarkerConfig({ cssClass: n3, seriesIndex: Number(r4.getAttribute("data:realIndex")) });
              (o3 = e4.drawMarker(0, 0, l4)).node.setAttribute("default-marker-size", 0);
              var h4 = document.createElementNS(t5.globals.SVGNS, "g");
              h4.classList.add("apexcharts-series-markers"), h4.appendChild(o3.node), r4.appendChild(h4);
            }
          }
        } }, { key: "enlargeCurrentPoint", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s4 = this.w;
          "bubble" !== s4.config.chart.type && this.newPointSize(t5, e4);
          var r4 = e4.getAttribute("cx"), o3 = e4.getAttribute("cy");
          if (null !== i4 && null !== a4 && (r4 = i4, o3 = a4), this.tooltipPosition.moveXCrosshairs(r4), !this.fixedTooltip) {
            if ("radar" === s4.config.chart.type) {
              var n3 = this.ttCtx.getElGrid().getBoundingClientRect();
              r4 = this.ttCtx.e.clientX - n3.left;
            }
            this.tooltipPosition.moveTooltip(r4, o3, s4.config.markers.hover.size);
          }
        } }, { key: "enlargePoints", value: function(t5) {
          for (var e4 = this.w, i4 = this, a4 = this.ttCtx, s4 = t5, r4 = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o3 = e4.config.markers.hover.size, n3 = 0; n3 < r4.length; n3++) {
            var l4 = r4[n3].getAttribute("rel"), h4 = r4[n3].getAttribute("index");
            if (void 0 === o3 && (o3 = e4.globals.markers.size[h4] + e4.config.markers.hover.sizeOffset), s4 === parseInt(l4, 10)) {
              i4.newPointSize(s4, r4[n3]);
              var c4 = r4[n3].getAttribute("cx"), d3 = r4[n3].getAttribute("cy");
              i4.tooltipPosition.moveXCrosshairs(c4), a4.fixedTooltip || i4.tooltipPosition.moveTooltip(c4, d3, o3);
            } else i4.oldPointSize(r4[n3]);
          }
        } }, { key: "newPointSize", value: function(t5, e4) {
          var i4 = this.w, a4 = i4.config.markers.hover.size, s4 = 0 === t5 ? e4.parentNode.firstChild : e4.parentNode.lastChild;
          if ("0" !== s4.getAttribute("default-marker-size")) {
            var r4 = parseInt(s4.getAttribute("index"), 10);
            void 0 === a4 && (a4 = i4.globals.markers.size[r4] + i4.config.markers.hover.sizeOffset), a4 < 0 && (a4 = 0);
            var o3 = this.ttCtx.tooltipUtil.getPathFromPoint(e4, a4);
            e4.setAttribute("d", o3);
          }
        } }, { key: "oldPointSize", value: function(t5) {
          var e4 = parseFloat(t5.getAttribute("default-marker-size")), i4 = this.ttCtx.tooltipUtil.getPathFromPoint(t5, e4);
          t5.setAttribute("d", i4);
        } }, { key: "resetPointsSize", value: function() {
          for (var t5 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e4 = 0; e4 < t5.length; e4++) {
            var i4 = parseFloat(t5[e4].getAttribute("default-marker-size"));
            if (m3.isNumber(i4) && i4 >= 0) {
              var a4 = this.ttCtx.tooltipUtil.getPathFromPoint(t5[e4], i4);
              t5[e4].setAttribute("d", a4);
            } else t5[e4].setAttribute("d", "M0,0");
          }
        } }]), t4;
      })();
      var mt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w;
          var a4 = this.w;
          this.ttCtx = e4, this.isVerticalGroupedRangeBar = !a4.globals.isBarHorizontal && "rangeBar" === a4.config.chart.type && a4.config.plotOptions.bar.rangeBarGroupRows;
        }
        return s3(t4, [{ key: "getAttr", value: function(t5, e4) {
          return parseFloat(t5.target.getAttribute(e4));
        } }, { key: "handleHeatTreeTooltip", value: function(t5) {
          var e4 = t5.e, i4 = t5.opt, a4 = t5.x, s4 = t5.y, r4 = t5.type, o3 = this.ttCtx, n3 = this.w;
          if (e4.target.classList.contains("apexcharts-".concat(r4, "-rect"))) {
            var l4 = this.getAttr(e4, "i"), h4 = this.getAttr(e4, "j"), c4 = this.getAttr(e4, "cx"), d3 = this.getAttr(e4, "cy"), g5 = this.getAttr(e4, "width"), u4 = this.getAttr(e4, "height");
            if (o3.tooltipLabels.drawSeriesTexts({ ttItems: i4.ttItems, i: l4, j: h4, shared: false, e: e4 }), n3.globals.capturedSeriesIndex = l4, n3.globals.capturedDataPointIndex = h4, a4 = c4 + o3.tooltipRect.ttWidth / 2 + g5, s4 = d3 + o3.tooltipRect.ttHeight / 2 - u4 / 2, o3.tooltipPosition.moveXCrosshairs(c4 + g5 / 2), a4 > n3.globals.gridWidth / 2 && (a4 = c4 - o3.tooltipRect.ttWidth / 2 + g5), o3.w.config.tooltip.followCursor) {
              var f4 = n3.globals.dom.elWrap.getBoundingClientRect();
              a4 = n3.globals.clientX - f4.left - (a4 > n3.globals.gridWidth / 2 ? o3.tooltipRect.ttWidth : 0), s4 = n3.globals.clientY - f4.top - (s4 > n3.globals.gridHeight / 2 ? o3.tooltipRect.ttHeight : 0);
            }
          }
          return { x: a4, y: s4 };
        } }, { key: "handleMarkerTooltip", value: function(t5) {
          var e4, i4, a4 = t5.e, s4 = t5.opt, r4 = t5.x, o3 = t5.y, n3 = this.w, l4 = this.ttCtx;
          if (a4.target.classList.contains("apexcharts-marker")) {
            var h4 = parseInt(s4.paths.getAttribute("cx"), 10), c4 = parseInt(s4.paths.getAttribute("cy"), 10), d3 = parseFloat(s4.paths.getAttribute("val"));
            if (i4 = parseInt(s4.paths.getAttribute("rel"), 10), e4 = parseInt(s4.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l4.intersect) {
              var g5 = m3.findAncestor(s4.paths, "apexcharts-series");
              g5 && (e4 = parseInt(g5.getAttribute("data:realIndex"), 10));
            }
            if (l4.tooltipLabels.drawSeriesTexts({ ttItems: s4.ttItems, i: e4, j: i4, shared: !l4.showOnIntersect && n3.config.tooltip.shared, e: a4 }), "mouseup" === a4.type && l4.markerClick(a4, e4, i4), n3.globals.capturedSeriesIndex = e4, n3.globals.capturedDataPointIndex = i4, r4 = h4, o3 = c4 + n3.globals.translateY - 1.4 * l4.tooltipRect.ttHeight, l4.w.config.tooltip.followCursor) {
              var u4 = l4.getElGrid().getBoundingClientRect();
              o3 = l4.e.clientY + n3.globals.translateY - u4.top;
            }
            d3 < 0 && (o3 = c4), l4.marker.enlargeCurrentPoint(i4, s4.paths, r4, o3);
          }
          return { x: r4, y: o3 };
        } }, { key: "handleBarTooltip", value: function(t5) {
          var e4, i4, a4 = t5.e, s4 = t5.opt, r4 = this.w, o3 = this.ttCtx, n3 = o3.getElTooltip(), l4 = 0, h4 = 0, c4 = 0, d3 = this.getBarTooltipXY({ e: a4, opt: s4 });
          e4 = d3.i;
          var g5 = d3.j;
          r4.globals.capturedSeriesIndex = e4, r4.globals.capturedDataPointIndex = g5, r4.globals.isBarHorizontal && o3.tooltipUtil.hasBars() || !r4.config.tooltip.shared ? (h4 = d3.x, c4 = d3.y, i4 = Array.isArray(r4.config.stroke.width) ? r4.config.stroke.width[e4] : r4.config.stroke.width, l4 = h4) : r4.globals.comboCharts || r4.config.tooltip.shared || (l4 /= 2), isNaN(c4) && (c4 = r4.globals.svgHeight - o3.tooltipRect.ttHeight);
          var u4 = parseInt(s4.paths.parentNode.getAttribute("data:realIndex"), 10);
          if (r4.globals.isMultipleYAxis ? r4.config.yaxis[u4] && r4.config.yaxis[u4].reversed : r4.config.yaxis[0].reversed, h4 + o3.tooltipRect.ttWidth > r4.globals.gridWidth ? h4 -= o3.tooltipRect.ttWidth : h4 < 0 && (h4 = 0), o3.w.config.tooltip.followCursor) {
            var f4 = o3.getElGrid().getBoundingClientRect();
            c4 = o3.e.clientY - f4.top;
          }
          null === o3.tooltip && (o3.tooltip = r4.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r4.config.tooltip.shared || (r4.globals.comboBarCount > 0 ? o3.tooltipPosition.moveXCrosshairs(l4 + i4 / 2) : o3.tooltipPosition.moveXCrosshairs(l4)), !o3.fixedTooltip && (!r4.config.tooltip.shared || r4.globals.isBarHorizontal && o3.tooltipUtil.hasBars()) && (c4 = c4 + r4.globals.translateY - o3.tooltipRect.ttHeight / 2, n3.style.left = h4 + r4.globals.translateX + "px", n3.style.top = c4 + "px");
        } }, { key: "getBarTooltipXY", value: function(t5) {
          var e4 = this, i4 = t5.e, a4 = t5.opt, s4 = this.w, r4 = null, o3 = this.ttCtx, n3 = 0, l4 = 0, h4 = 0, c4 = 0, d3 = 0, g5 = i4.target.classList;
          if (g5.contains("apexcharts-bar-area") || g5.contains("apexcharts-candlestick-area") || g5.contains("apexcharts-boxPlot-area") || g5.contains("apexcharts-rangebar-area")) {
            var u4 = i4.target, f4 = u4.getBoundingClientRect(), p4 = a4.elGrid.getBoundingClientRect(), x5 = f4.height;
            d3 = f4.height;
            var b4 = f4.width, v4 = parseInt(u4.getAttribute("cx"), 10), m4 = parseInt(u4.getAttribute("cy"), 10);
            c4 = parseFloat(u4.getAttribute("barWidth"));
            var y4 = "touchmove" === i4.type ? i4.touches[0].clientX : i4.clientX;
            r4 = parseInt(u4.getAttribute("j"), 10), n3 = parseInt(u4.parentNode.getAttribute("rel"), 10) - 1;
            var w5 = u4.getAttribute("data-range-y1"), k4 = u4.getAttribute("data-range-y2");
            s4.globals.comboCharts && (n3 = parseInt(u4.parentNode.getAttribute("data:realIndex"), 10));
            var A4 = function(t6) {
              return s4.globals.isXNumeric ? v4 - b4 / 2 : e4.isVerticalGroupedRangeBar ? v4 + b4 / 2 : v4 - o3.dataPointsDividedWidth + b4 / 2;
            }, S3 = function() {
              return m4 - o3.dataPointsDividedHeight + x5 / 2 - o3.tooltipRect.ttHeight / 2;
            };
            o3.tooltipLabels.drawSeriesTexts({ ttItems: a4.ttItems, i: n3, j: r4, y1: w5 ? parseInt(w5, 10) : null, y2: k4 ? parseInt(k4, 10) : null, shared: !o3.showOnIntersect && s4.config.tooltip.shared, e: i4 }), s4.config.tooltip.followCursor ? s4.globals.isBarHorizontal ? (l4 = y4 - p4.left + 15, h4 = S3()) : (l4 = A4(), h4 = i4.clientY - p4.top - o3.tooltipRect.ttHeight / 2 - 15) : s4.globals.isBarHorizontal ? ((l4 = v4) < o3.xyRatios.baseLineInvertedY && (l4 = v4 - o3.tooltipRect.ttWidth), h4 = S3()) : (l4 = A4(), h4 = m4);
          }
          return { x: l4, y: h4, barHeight: d3, barWidth: c4, i: n3, j: r4 };
        } }]), t4;
      })();
      var yt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.ttCtx = e4;
        }
        return s3(t4, [{ key: "drawXaxisTooltip", value: function() {
          var t5 = this.w, e4 = this.ttCtx, i4 = "bottom" === t5.config.xaxis.position;
          e4.xaxisOffY = i4 ? t5.globals.gridHeight + 1 : -t5.globals.xAxisHeight - t5.config.xaxis.axisTicks.height + 3;
          var a4 = i4 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s4 = t5.globals.dom.elWrap;
          e4.isXAxisTooltipEnabled && (null === t5.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e4.xaxisTooltip = document.createElement("div"), e4.xaxisTooltip.setAttribute("class", a4 + " apexcharts-theme-" + t5.config.tooltip.theme), s4.appendChild(e4.xaxisTooltip), e4.xaxisTooltipText = document.createElement("div"), e4.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e4.xaxisTooltipText.style.fontFamily = t5.config.xaxis.tooltip.style.fontFamily || t5.config.chart.fontFamily, e4.xaxisTooltipText.style.fontSize = t5.config.xaxis.tooltip.style.fontSize, e4.xaxisTooltip.appendChild(e4.xaxisTooltipText)));
        } }, { key: "drawYaxisTooltip", value: function() {
          for (var t5 = this.w, e4 = this.ttCtx, i4 = 0; i4 < t5.config.yaxis.length; i4++) {
            var a4 = t5.config.yaxis[i4].opposite || t5.config.yaxis[i4].crosshairs.opposite;
            e4.yaxisOffX = a4 ? t5.globals.gridWidth + 1 : 1;
            var s4 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i4, a4 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r4 = t5.globals.dom.elWrap;
            null === t5.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i4)) && (e4.yaxisTooltip = document.createElement("div"), e4.yaxisTooltip.setAttribute("class", s4 + " apexcharts-theme-" + t5.config.tooltip.theme), r4.appendChild(e4.yaxisTooltip), 0 === i4 && (e4.yaxisTooltipText = []), e4.yaxisTooltipText[i4] = document.createElement("div"), e4.yaxisTooltipText[i4].classList.add("apexcharts-yaxistooltip-text"), e4.yaxisTooltip.appendChild(e4.yaxisTooltipText[i4]));
          }
        } }, { key: "setXCrosshairWidth", value: function() {
          var t5 = this.w, e4 = this.ttCtx, i4 = e4.getElXCrosshairs();
          if (e4.xcrosshairsWidth = parseInt(t5.config.xaxis.crosshairs.width, 10), t5.globals.comboCharts) {
            var a4 = t5.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
            if (null !== a4 && "barWidth" === t5.config.xaxis.crosshairs.width) {
              var s4 = parseFloat(a4.getAttribute("barWidth"));
              e4.xcrosshairsWidth = s4;
            } else if ("tickWidth" === t5.config.xaxis.crosshairs.width) {
              var r4 = t5.globals.labels.length;
              e4.xcrosshairsWidth = t5.globals.gridWidth / r4;
            }
          } else if ("tickWidth" === t5.config.xaxis.crosshairs.width) {
            var o3 = t5.globals.labels.length;
            e4.xcrosshairsWidth = t5.globals.gridWidth / o3;
          } else if ("barWidth" === t5.config.xaxis.crosshairs.width) {
            var n3 = t5.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
            if (null !== n3) {
              var l4 = parseFloat(n3.getAttribute("barWidth"));
              e4.xcrosshairsWidth = l4;
            } else e4.xcrosshairsWidth = 1;
          }
          t5.globals.isBarHorizontal && (e4.xcrosshairsWidth = 0), null !== i4 && e4.xcrosshairsWidth > 0 && i4.setAttribute("width", e4.xcrosshairsWidth);
        } }, { key: "handleYCrosshair", value: function() {
          var t5 = this.w, e4 = this.ttCtx;
          e4.ycrosshairs = t5.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e4.ycrosshairsHidden = t5.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
        } }, { key: "drawYaxisTooltipText", value: function(t5, e4, i4) {
          var a4 = this.ttCtx, s4 = this.w, r4 = s4.globals, o3 = r4.seriesYAxisMap[t5];
          if (a4.yaxisTooltips[t5] && o3.length > 0) {
            var n3 = r4.yLabelFormatters[t5], l4 = a4.getElGrid().getBoundingClientRect(), h4 = o3[0], c4 = 0;
            i4.yRatio.length > 1 && (c4 = h4);
            var d3 = (e4 - l4.top) * i4.yRatio[c4], g5 = r4.maxYArr[h4] - r4.minYArr[h4], u4 = r4.minYArr[h4] + (g5 - d3);
            s4.config.yaxis[t5].reversed && (u4 = r4.maxYArr[h4] - (g5 - d3)), a4.tooltipPosition.moveYCrosshairs(e4 - l4.top), a4.yaxisTooltipText[t5].innerHTML = n3(u4), a4.tooltipPosition.moveYAxisTooltip(t5);
          }
        } }]), t4;
      })();
      var wt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
          var a4 = this.w;
          this.tConfig = a4.config.tooltip, this.tooltipUtil = new pt(this), this.tooltipLabels = new xt(this), this.tooltipPosition = new bt(this), this.marker = new vt(this), this.intersect = new mt(this), this.axesTooltip = new yt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a4.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
        }
        return s3(t4, [{ key: "getElTooltip", value: function(t5) {
          return t5 || (t5 = this), t5.w.globals.dom.baseEl ? t5.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
        } }, { key: "getElXCrosshairs", value: function() {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
        } }, { key: "getElGrid", value: function() {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
        } }, { key: "drawTooltip", value: function(t5) {
          var e4 = this.w;
          this.xyRatios = t5, this.isXAxisTooltipEnabled = e4.config.xaxis.tooltip.enabled && e4.globals.axisCharts, this.yaxisTooltips = e4.config.yaxis.map((function(t6, i5) {
            return !!(t6.show && t6.tooltip.enabled && e4.globals.axisCharts);
          })), this.allTooltipSeriesGroups = [], e4.globals.axisCharts || (this.showTooltipTitle = false);
          var i4 = document.createElement("div");
          if (i4.classList.add("apexcharts-tooltip"), e4.config.tooltip.cssClass && i4.classList.add(e4.config.tooltip.cssClass), i4.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e4.globals.dom.elWrap.appendChild(i4), e4.globals.axisCharts) {
            this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
            var a4 = new q3(this.ctx);
            this.xAxisTicksPositions = a4.getXAxisTicksPositions();
          }
          if (!e4.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e4.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e4.config.markers.size && 0 !== e4.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e4.globals.collapsedSeries.length !== e4.globals.series.length) {
            this.dataPointsDividedHeight = e4.globals.gridHeight / e4.globals.dataPoints, this.dataPointsDividedWidth = e4.globals.gridWidth / e4.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e4.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i4.appendChild(this.tooltipTitle));
            var s4 = e4.globals.series.length;
            (e4.globals.xyCharts || e4.globals.comboCharts) && this.tConfig.shared && (s4 = this.showOnIntersect ? 1 : e4.globals.series.length), this.legendLabels = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s4), this.addSVGEvents();
          }
        } }, { key: "createTTElements", value: function(t5) {
          for (var e4 = this, i4 = this.w, a4 = [], s4 = this.getElTooltip(), r4 = function(r5) {
            var o4 = document.createElement("div");
            o4.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(r5)), o4.style.order = i4.config.tooltip.inverseOrder ? t5 - r5 : r5 + 1;
            var n3 = document.createElement("span");
            n3.classList.add("apexcharts-tooltip-marker"), n3.style.backgroundColor = i4.globals.colors[r5], o4.appendChild(n3);
            var l4 = document.createElement("div");
            l4.classList.add("apexcharts-tooltip-text"), l4.style.fontFamily = e4.tConfig.style.fontFamily || i4.config.chart.fontFamily, l4.style.fontSize = e4.tConfig.style.fontSize, ["y", "goals", "z"].forEach((function(t6) {
              var e5 = document.createElement("div");
              e5.classList.add("apexcharts-tooltip-".concat(t6, "-group"));
              var i5 = document.createElement("span");
              i5.classList.add("apexcharts-tooltip-text-".concat(t6, "-label")), e5.appendChild(i5);
              var a5 = document.createElement("span");
              a5.classList.add("apexcharts-tooltip-text-".concat(t6, "-value")), e5.appendChild(a5), l4.appendChild(e5);
            })), o4.appendChild(l4), s4.appendChild(o4), a4.push(o4);
          }, o3 = 0; o3 < t5; o3++) r4(o3);
          return a4;
        } }, { key: "addSVGEvents", value: function() {
          var t5 = this.w, e4 = t5.config.chart.type, i4 = this.getElTooltip(), a4 = !("bar" !== e4 && "candlestick" !== e4 && "boxPlot" !== e4 && "rangeBar" !== e4), s4 = "area" === e4 || "line" === e4 || "scatter" === e4 || "bubble" === e4 || "radar" === e4, r4 = t5.globals.dom.Paper.node, o3 = this.getElGrid();
          o3 && (this.seriesBound = o3.getBoundingClientRect());
          var n3, l4 = [], h4 = [], c4 = { hoverArea: r4, elGrid: o3, tooltipEl: i4, tooltipY: l4, tooltipX: h4, ttItems: this.ttItems };
          if (t5.globals.axisCharts && (s4 ? n3 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a4 ? n3 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e4 && "treemap" !== e4 || (n3 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n3 && n3.length)) for (var d3 = 0; d3 < n3.length; d3++) l4.push(n3[d3].getAttribute("cy")), h4.push(n3[d3].getAttribute("cx"));
          if (t5.globals.xyCharts && !this.showOnIntersect || t5.globals.comboCharts && !this.showOnIntersect || a4 && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r4], c4);
          else if (a4 && !t5.globals.comboCharts || s4 && this.showOnIntersect) this.addDatapointEventsListeners(c4);
          else if (!t5.globals.axisCharts || "heatmap" === e4 || "treemap" === e4) {
            var g5 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
            this.addPathsEventListeners(g5, c4);
          }
          if (this.showOnIntersect) {
            var u4 = t5.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
            u4.length > 0 && this.addPathsEventListeners(u4, c4), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c4);
          }
        } }, { key: "drawFixedTooltipRect", value: function() {
          var t5 = this.w, e4 = this.getElTooltip(), i4 = e4.getBoundingClientRect(), a4 = i4.width + 10, s4 = i4.height + 10, r4 = this.tConfig.fixed.offsetX, o3 = this.tConfig.fixed.offsetY, n3 = this.tConfig.fixed.position.toLowerCase();
          return n3.indexOf("right") > -1 && (r4 = r4 + t5.globals.svgWidth - a4 + 10), n3.indexOf("bottom") > -1 && (o3 = o3 + t5.globals.svgHeight - s4 - 10), e4.style.left = r4 + "px", e4.style.top = o3 + "px", { x: r4, y: o3, ttWidth: a4, ttHeight: s4 };
        } }, { key: "addDatapointEventsListeners", value: function(t5) {
          var e4 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
          this.addPathsEventListeners(e4, t5);
        } }, { key: "addPathsEventListeners", value: function(t5, e4) {
          for (var i4 = this, a4 = function(a5) {
            var s5 = { paths: t5[a5], tooltipEl: e4.tooltipEl, tooltipY: e4.tooltipY, tooltipX: e4.tooltipX, elGrid: e4.elGrid, hoverArea: e4.hoverArea, ttItems: e4.ttItems };
            ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map((function(e5) {
              return t5[a5].addEventListener(e5, i4.onSeriesHover.bind(i4, s5), { capture: false, passive: true });
            }));
          }, s4 = 0; s4 < t5.length; s4++) a4(s4);
        } }, { key: "onSeriesHover", value: function(t5, e4) {
          var i4 = this, a4 = Date.now() - this.lastHoverTime;
          a4 >= 100 ? this.seriesHover(t5, e4) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout((function() {
            i4.seriesHover(t5, e4);
          }), 100 - a4));
        } }, { key: "seriesHover", value: function(t5, e4) {
          var i4 = this;
          this.lastHoverTime = Date.now();
          var a4 = [], s4 = this.w;
          s4.config.chart.group && (a4 = this.ctx.getGroupedCharts()), s4.globals.axisCharts && (s4.globals.minX === -1 / 0 && s4.globals.maxX === 1 / 0 || 0 === s4.globals.dataPoints) || (a4.length ? a4.forEach((function(a5) {
            var s5 = i4.getElTooltip(a5), r4 = { paths: t5.paths, tooltipEl: s5, tooltipY: t5.tooltipY, tooltipX: t5.tooltipX, elGrid: t5.elGrid, hoverArea: t5.hoverArea, ttItems: a5.w.globals.tooltip.ttItems };
            a5.w.globals.minX === i4.w.globals.minX && a5.w.globals.maxX === i4.w.globals.maxX && a5.w.globals.tooltip.seriesHoverByContext({ chartCtx: a5, ttCtx: a5.w.globals.tooltip, opt: r4, e: e4 });
          })) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t5, e: e4 }));
        } }, { key: "seriesHoverByContext", value: function(t5) {
          var e4 = t5.chartCtx, i4 = t5.ttCtx, a4 = t5.opt, s4 = t5.e, r4 = e4.w, o3 = this.getElTooltip(e4);
          if (o3) {
            if (i4.tooltipRect = { x: 0, y: 0, ttWidth: o3.getBoundingClientRect().width, ttHeight: o3.getBoundingClientRect().height }, i4.e = s4, i4.tooltipUtil.hasBars() && !r4.globals.comboCharts && !i4.isBarShared) {
              if (this.tConfig.onDatasetHover.highlightDataSeries) new V3(e4).toggleSeriesOnHover(s4, s4.target.parentNode);
            }
            i4.fixedTooltip && i4.drawFixedTooltipRect(), r4.globals.axisCharts ? i4.axisChartsTooltips({ e: s4, opt: a4, tooltipRect: i4.tooltipRect }) : i4.nonAxisChartsTooltips({ e: s4, opt: a4, tooltipRect: i4.tooltipRect });
          }
        } }, { key: "axisChartsTooltips", value: function(t5) {
          var e4, i4, a4 = t5.e, s4 = t5.opt, r4 = this.w, o3 = s4.elGrid.getBoundingClientRect(), n3 = "touchmove" === a4.type ? a4.touches[0].clientX : a4.clientX, l4 = "touchmove" === a4.type ? a4.touches[0].clientY : a4.clientY;
          if (this.clientY = l4, this.clientX = n3, r4.globals.capturedSeriesIndex = -1, r4.globals.capturedDataPointIndex = -1, l4 < o3.top || l4 > o3.top + o3.height) this.handleMouseOut(s4);
          else {
            if (Array.isArray(this.tConfig.enabledOnSeries) && !r4.config.tooltip.shared) {
              var h4 = parseInt(s4.paths.getAttribute("index"), 10);
              if (this.tConfig.enabledOnSeries.indexOf(h4) < 0) return void this.handleMouseOut(s4);
            }
            var c4 = this.getElTooltip(), d3 = this.getElXCrosshairs(), g5 = [];
            r4.config.chart.group && (g5 = this.ctx.getSyncedCharts());
            var u4 = r4.globals.xyCharts || "bar" === r4.config.chart.type && !r4.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r4.globals.comboCharts && this.tooltipUtil.hasBars();
            if ("mousemove" === a4.type || "touchmove" === a4.type || "mouseup" === a4.type) {
              if (r4.globals.collapsedSeries.length + r4.globals.ancillaryCollapsedSeries.length === r4.globals.series.length) return;
              null !== d3 && d3.classList.add("apexcharts-active");
              var f4 = this.yaxisTooltips.filter((function(t6) {
                return true === t6;
              }));
              if (null !== this.ycrosshairs && f4.length && this.ycrosshairs.classList.add("apexcharts-active"), u4 && !this.showOnIntersect || g5.length > 1) this.handleStickyTooltip(a4, n3, l4, s4);
              else if ("heatmap" === r4.config.chart.type || "treemap" === r4.config.chart.type) {
                var p4 = this.intersect.handleHeatTreeTooltip({ e: a4, opt: s4, x: e4, y: i4, type: r4.config.chart.type });
                e4 = p4.x, i4 = p4.y, c4.style.left = e4 + "px", c4.style.top = i4 + "px";
              } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a4, opt: s4 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a4, opt: s4, x: e4, y: i4 });
              if (this.yaxisTooltips.length) for (var x5 = 0; x5 < r4.config.yaxis.length; x5++) this.axesTooltip.drawYaxisTooltipText(x5, l4, this.xyRatios);
              r4.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), s4.tooltipEl.classList.add("apexcharts-active");
            } else "mouseout" !== a4.type && "touchend" !== a4.type || this.handleMouseOut(s4);
          }
        } }, { key: "nonAxisChartsTooltips", value: function(t5) {
          var e4 = t5.e, i4 = t5.opt, a4 = t5.tooltipRect, s4 = this.w, r4 = i4.paths.getAttribute("rel"), o3 = this.getElTooltip(), n3 = s4.globals.dom.elWrap.getBoundingClientRect();
          if ("mousemove" === e4.type || "touchmove" === e4.type) {
            s4.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), o3.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i4.ttItems, i: parseInt(r4, 10) - 1, shared: false });
            var l4 = s4.globals.clientX - n3.left - a4.ttWidth / 2, h4 = s4.globals.clientY - n3.top - a4.ttHeight - 10;
            if (o3.style.left = l4 + "px", o3.style.top = h4 + "px", s4.config.legend.tooltipHoverFormatter) {
              var c4 = r4 - 1, d3 = (0, s4.config.legend.tooltipHoverFormatter)(this.legendLabels[c4].getAttribute("data:default-text"), { seriesIndex: c4, dataPointIndex: c4, w: s4 });
              this.legendLabels[c4].innerHTML = d3;
            }
          } else "mouseout" !== e4.type && "touchend" !== e4.type || (o3.classList.remove("apexcharts-active"), s4.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s4.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t6) {
            var e5 = t6.getAttribute("data:default-text");
            t6.innerHTML = decodeURIComponent(e5);
          })));
        } }, { key: "handleStickyTooltip", value: function(t5, e4, i4, a4) {
          var s4 = this.w, r4 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a4.hoverArea, elGrid: a4.elGrid, clientX: e4, clientY: i4 }), o3 = r4.j, n3 = r4.capturedSeries;
          s4.globals.collapsedSeriesIndices.includes(n3) && (n3 = null);
          var l4 = a4.elGrid.getBoundingClientRect();
          if (r4.hoverX < 0 || r4.hoverX > l4.width) this.handleMouseOut(a4);
          else if (null !== n3) this.handleStickyCapturedSeries(t5, n3, a4, o3);
          else if (this.tooltipUtil.isXoverlap(o3) || s4.globals.isBarHorizontal) {
            var h4 = s4.globals.series.findIndex((function(t6, e5) {
              return !s4.globals.collapsedSeriesIndices.includes(e5);
            }));
            this.create(t5, this, h4, o3, a4.ttItems);
          }
        } }, { key: "handleStickyCapturedSeries", value: function(t5, e4, i4, a4) {
          var s4 = this.w;
          if (!this.tConfig.shared && null === s4.globals.series[e4][a4]) return void this.handleMouseOut(i4);
          if (void 0 !== s4.globals.series[e4][a4]) this.tConfig.shared && this.tooltipUtil.isXoverlap(a4) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t5, this, e4, a4, i4.ttItems) : this.create(t5, this, e4, a4, i4.ttItems, false);
          else if (this.tooltipUtil.isXoverlap(a4)) {
            var r4 = s4.globals.series.findIndex((function(t6, e5) {
              return !s4.globals.collapsedSeriesIndices.includes(e5);
            }));
            this.create(t5, this, r4, a4, i4.ttItems);
          }
        } }, { key: "deactivateHoverFilter", value: function() {
          for (var t5 = this.w, e4 = new k3(this.ctx), i4 = t5.globals.dom.Paper.select(".apexcharts-bar-area"), a4 = 0; a4 < i4.length; a4++) e4.pathMouseLeave(i4[a4]);
        } }, { key: "handleMouseOut", value: function(t5) {
          var e4 = this.w, i4 = this.getElXCrosshairs();
          if (e4.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), t5.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e4.config.chart.type && this.marker.resetPointsSize(), null !== i4 && i4.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
            null === this.yaxisTTEls && (this.yaxisTTEls = e4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
            for (var a4 = 0; a4 < this.yaxisTTEls.length; a4++) this.yaxisTTEls[a4].classList.remove("apexcharts-active");
          }
          e4.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t6) {
            var e5 = t6.getAttribute("data:default-text");
            t6.innerHTML = decodeURIComponent(e5);
          }));
        } }, { key: "markerClick", value: function(t5, e4, i4) {
          var a4 = this.w;
          "function" == typeof a4.config.chart.events.markerClick && a4.config.chart.events.markerClick(t5, this.ctx, { seriesIndex: e4, dataPointIndex: i4, w: a4 }), this.ctx.events.fireEvent("markerClick", [t5, this.ctx, { seriesIndex: e4, dataPointIndex: i4, w: a4 }]);
        } }, { key: "create", value: function(t5, e4, i4, a4, s4) {
          var r4, o3, n3, l4, h4, c4, d3, u4, f4, p4, x5, b4, v4, m4, y4, w5, A4 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, S3 = this.w, C4 = e4;
          "mouseup" === t5.type && this.markerClick(t5, i4, a4), null === A4 && (A4 = this.tConfig.shared);
          var L4 = this.tooltipUtil.hasMarkers(i4), P4 = this.tooltipUtil.getElBars();
          if (S3.config.legend.tooltipHoverFormatter) {
            var M3 = S3.config.legend.tooltipHoverFormatter, I4 = Array.from(this.legendLabels);
            I4.forEach((function(t6) {
              var e5 = t6.getAttribute("data:default-text");
              t6.innerHTML = decodeURIComponent(e5);
            }));
            for (var T5 = 0; T5 < I4.length; T5++) {
              var z4 = I4[T5], X3 = parseInt(z4.getAttribute("i"), 10), E3 = decodeURIComponent(z4.getAttribute("data:default-text")), Y2 = M3(E3, { seriesIndex: A4 ? X3 : i4, dataPointIndex: a4, w: S3 });
              if (A4) z4.innerHTML = S3.globals.collapsedSeriesIndices.indexOf(X3) < 0 ? Y2 : E3;
              else if (z4.innerHTML = X3 === i4 ? Y2 : E3, i4 === X3) break;
            }
          }
          var R2 = g4(g4({ ttItems: s4, i: i4, j: a4 }, void 0 !== (null === (r4 = S3.globals.seriesRange) || void 0 === r4 || null === (o3 = r4[i4]) || void 0 === o3 || null === (n3 = o3[a4]) || void 0 === n3 || null === (l4 = n3.y[0]) || void 0 === l4 ? void 0 : l4.y1) && { y1: null === (h4 = S3.globals.seriesRange) || void 0 === h4 || null === (c4 = h4[i4]) || void 0 === c4 || null === (d3 = c4[a4]) || void 0 === d3 || null === (u4 = d3.y[0]) || void 0 === u4 ? void 0 : u4.y1 }), void 0 !== (null === (f4 = S3.globals.seriesRange) || void 0 === f4 || null === (p4 = f4[i4]) || void 0 === p4 || null === (x5 = p4[a4]) || void 0 === x5 || null === (b4 = x5.y[0]) || void 0 === b4 ? void 0 : b4.y2) && { y2: null === (v4 = S3.globals.seriesRange) || void 0 === v4 || null === (m4 = v4[i4]) || void 0 === m4 || null === (y4 = m4[a4]) || void 0 === y4 || null === (w5 = y4.y[0]) || void 0 === w5 ? void 0 : w5.y2 });
          if (A4) {
            if (C4.tooltipLabels.drawSeriesTexts(g4(g4({}, R2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), L4) S3.globals.markers.largestSize > 0 ? C4.marker.enlargePoints(a4) : C4.tooltipPosition.moveDynamicPointsOnHover(a4);
            else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(P4), this.barSeriesHeight > 0)) {
              var F5 = new k3(this.ctx), D4 = S3.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a4, "']"));
              this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a4, i4);
              for (var H4 = 0; H4 < D4.length; H4++) F5.pathMouseEnter(D4[H4]);
            }
          } else C4.tooltipLabels.drawSeriesTexts(g4({ shared: false }, R2)), this.tooltipUtil.hasBars() && C4.tooltipPosition.moveStickyTooltipOverBars(a4, i4), L4 && C4.tooltipPosition.moveMarkers(i4, a4);
        } }]), t4;
      })();
      var kt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.barCtx = e4, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
        }
        return s3(t4, [{ key: "handleBarDataLabels", value: function(t5) {
          var e4, i4, a4 = t5.x, s4 = t5.y, r4 = t5.y1, o3 = t5.y2, n3 = t5.i, l4 = t5.j, h4 = t5.realIndex, c4 = t5.columnGroupIndex, d3 = t5.series, u4 = t5.barHeight, f4 = t5.barWidth, p4 = t5.barXPosition, x5 = t5.barYPosition, b4 = t5.visibleSeries, v4 = t5.renderedPath, m4 = this.w, y4 = new k3(this.barCtx.ctx), w5 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h4] : this.barCtx.strokeWidth;
          m4.globals.isXNumeric && !m4.globals.isBarHorizontal ? (e4 = a4 + parseFloat(f4 * (b4 + 1)), i4 = s4 + parseFloat(u4 * (b4 + 1)) - w5) : (e4 = a4 + parseFloat(f4 * b4), i4 = s4 + parseFloat(u4 * b4));
          var A4, S3 = null, C4 = a4, L4 = s4, P4 = {}, M3 = m4.config.dataLabels, I4 = this.barCtx.barOptions.dataLabels, T5 = this.barCtx.barOptions.dataLabels.total;
          void 0 !== x5 && this.barCtx.isRangeBar && (i4 = x5, L4 = x5), void 0 !== p4 && this.barCtx.isVerticalGroupedRangeBar && (e4 = p4, C4 = p4);
          var z4 = M3.offsetX, X3 = M3.offsetY, E3 = { width: 0, height: 0 };
          if (m4.config.dataLabels.enabled) {
            var Y2 = m4.globals.series[n3][l4];
            E3 = y4.getTextRects(m4.config.dataLabels.formatter ? m4.config.dataLabels.formatter(Y2, g4(g4({}, m4), {}, { seriesIndex: n3, dataPointIndex: l4, w: m4 })) : m4.globals.yLabelFormatters[0](Y2), parseFloat(M3.style.fontSize));
          }
          var R2 = { x: a4, y: s4, i: n3, j: l4, realIndex: h4, columnGroupIndex: c4, renderedPath: v4, bcx: e4, bcy: i4, barHeight: u4, barWidth: f4, textRects: E3, strokeWidth: w5, dataLabelsX: C4, dataLabelsY: L4, dataLabelsConfig: M3, barDataLabelsConfig: I4, barTotalDataLabelsConfig: T5, offX: z4, offY: X3 };
          return P4 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(R2) : this.calculateColumnsDataLabelsPosition(R2), v4.attr({ cy: P4.bcy, cx: P4.bcx, j: l4, val: m4.globals.series[n3][l4], barHeight: u4, barWidth: f4 }), A4 = this.drawCalculatedDataLabels({ x: P4.dataLabelsX, y: P4.dataLabelsY, val: this.barCtx.isRangeBar ? [r4, o3] : "100%" === m4.config.chart.stackType ? d3[h4][l4] : m4.globals.series[h4][l4], i: h4, j: l4, barWidth: f4, barHeight: u4, textRects: E3, dataLabelsConfig: M3 }), m4.config.chart.stacked && T5.enabled && (S3 = this.drawTotalDataLabels({ x: P4.totalDataLabelsX, y: P4.totalDataLabelsY, barWidth: f4, barHeight: u4, realIndex: h4, textAnchor: P4.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h4, j: l4 }), dataLabelsConfig: M3, barTotalDataLabelsConfig: T5 })), { dataLabels: A4, totalDataLabels: S3 };
        } }, { key: "getStackedTotalDataLabel", value: function(t5) {
          var e4 = t5.realIndex, i4 = t5.j, a4 = this.w, s4 = this.barCtx.stackedSeriesTotals[i4];
          return this.totalFormatter && (s4 = this.totalFormatter(s4, g4(g4({}, a4), {}, { seriesIndex: e4, dataPointIndex: i4, w: a4 }))), s4;
        } }, { key: "calculateColumnsDataLabelsPosition", value: function(t5) {
          var e4 = this.w, i4 = t5.i, a4 = t5.j, s4 = t5.realIndex;
          t5.columnGroupIndex;
          var r4, o3, n3 = t5.y, l4 = t5.bcx, h4 = t5.barWidth, c4 = t5.barHeight, d3 = t5.textRects, g5 = t5.dataLabelsX, u4 = t5.dataLabelsY, f4 = t5.dataLabelsConfig, p4 = t5.barDataLabelsConfig, x5 = t5.barTotalDataLabelsConfig, b4 = t5.strokeWidth, v4 = t5.offX, m4 = t5.offY, y4 = l4;
          c4 = Math.abs(c4);
          var w5 = "vertical" === e4.config.plotOptions.bar.dataLabels.orientation, A4 = this.barCtx.barHelpers.getZeroValueEncounters({ i: i4, j: a4 }).zeroEncounters;
          l4 -= b4 / 2;
          var S3 = e4.globals.gridWidth / e4.globals.dataPoints;
          if (this.barCtx.isVerticalGroupedRangeBar ? g5 += h4 / 2 : (g5 = e4.globals.isXNumeric ? l4 - h4 / 2 + v4 : l4 - S3 + h4 / 2 + v4, A4 > 0 && e4.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g5 -= h4 * A4)), w5) {
            g5 = g5 + d3.height / 2 - b4 / 2 - 2;
          }
          var C4 = e4.globals.series[i4][a4] < 0, L4 = n3;
          switch (this.barCtx.isReversed && (L4 = n3 + (C4 ? c4 : -c4)), p4.position) {
            case "center":
              u4 = w5 ? C4 ? L4 - c4 / 2 + m4 : L4 + c4 / 2 - m4 : C4 ? L4 - c4 / 2 + d3.height / 2 + m4 : L4 + c4 / 2 + d3.height / 2 - m4;
              break;
            case "bottom":
              u4 = w5 ? C4 ? L4 - c4 + m4 : L4 + c4 - m4 : C4 ? L4 - c4 + d3.height + b4 + m4 : L4 + c4 - d3.height / 2 + b4 - m4;
              break;
            case "top":
              u4 = w5 ? C4 ? L4 + m4 : L4 - m4 : C4 ? L4 - d3.height / 2 - m4 : L4 + d3.height + m4;
          }
          if (this.barCtx.lastActiveBarSerieIndex === s4 && x5.enabled) {
            var P4 = new k3(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: s4, j: a4 }), f4.fontSize);
            r4 = C4 ? L4 - P4.height / 2 - m4 - x5.offsetY + 18 : L4 + P4.height + m4 + x5.offsetY - 18;
            var M3 = S3;
            o3 = y4 + (e4.globals.isXNumeric ? -h4 * e4.globals.barGroups.length / 2 : e4.globals.barGroups.length * h4 / 2 - (e4.globals.barGroups.length - 1) * h4 - M3) + x5.offsetX;
          }
          return e4.config.chart.stacked || (u4 < 0 ? u4 = 0 + b4 : u4 + d3.height / 3 > e4.globals.gridHeight && (u4 = e4.globals.gridHeight - b4)), { bcx: l4, bcy: n3, dataLabelsX: g5, dataLabelsY: u4, totalDataLabelsX: o3, totalDataLabelsY: r4, totalDataLabelsAnchor: "middle" };
        } }, { key: "calculateBarsDataLabelsPosition", value: function(t5) {
          var e4 = this.w, i4 = t5.x, a4 = t5.i, s4 = t5.j, r4 = t5.realIndex, o3 = t5.bcy, n3 = t5.barHeight, l4 = t5.barWidth, h4 = t5.textRects, c4 = t5.dataLabelsX, d3 = t5.strokeWidth, g5 = t5.dataLabelsConfig, u4 = t5.barDataLabelsConfig, f4 = t5.barTotalDataLabelsConfig, p4 = t5.offX, x5 = t5.offY, b4 = e4.globals.gridHeight / e4.globals.dataPoints;
          l4 = Math.abs(l4);
          var v4, m4, y4 = o3 - (this.barCtx.isRangeBar ? 0 : b4) + n3 / 2 + h4.height / 2 + x5 - 3, w5 = "start", A4 = e4.globals.series[a4][s4] < 0, S3 = i4;
          switch (this.barCtx.isReversed && (S3 = i4 + (A4 ? -l4 : l4), w5 = A4 ? "start" : "end"), u4.position) {
            case "center":
              c4 = A4 ? S3 + l4 / 2 - p4 : Math.max(h4.width / 2, S3 - l4 / 2) + p4;
              break;
            case "bottom":
              c4 = A4 ? S3 + l4 - d3 - p4 : S3 - l4 + d3 + p4;
              break;
            case "top":
              c4 = A4 ? S3 - d3 - p4 : S3 - d3 + p4;
          }
          if (this.barCtx.lastActiveBarSerieIndex === r4 && f4.enabled) {
            var C4 = new k3(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r4, j: s4 }), g5.fontSize);
            A4 ? (v4 = S3 - d3 - p4 - f4.offsetX, w5 = "end") : v4 = S3 + p4 + f4.offsetX + (this.barCtx.isReversed ? -(l4 + d3) : d3), m4 = y4 - h4.height / 2 + C4.height / 2 + f4.offsetY + d3;
          }
          return e4.config.chart.stacked || ("start" === g5.textAnchor ? c4 - h4.width < 0 ? c4 = A4 ? h4.width + d3 : d3 : c4 + h4.width > e4.globals.gridWidth && (c4 = A4 ? e4.globals.gridWidth - d3 : e4.globals.gridWidth - h4.width - d3) : "middle" === g5.textAnchor ? c4 - h4.width / 2 < 0 ? c4 = h4.width / 2 + d3 : c4 + h4.width / 2 > e4.globals.gridWidth && (c4 = e4.globals.gridWidth - h4.width / 2 - d3) : "end" === g5.textAnchor && (c4 < 1 ? c4 = h4.width + d3 : c4 + 1 > e4.globals.gridWidth && (c4 = e4.globals.gridWidth - h4.width - d3))), { bcx: i4, bcy: o3, dataLabelsX: c4, dataLabelsY: y4, totalDataLabelsX: v4, totalDataLabelsY: m4, totalDataLabelsAnchor: w5 };
        } }, { key: "drawCalculatedDataLabels", value: function(t5) {
          var e4 = t5.x, i4 = t5.y, a4 = t5.val, s4 = t5.i, r4 = t5.j, o3 = t5.textRects, n3 = t5.barHeight, l4 = t5.barWidth, h4 = t5.dataLabelsConfig, c4 = this.w, d3 = "rotate(0)";
          "vertical" === c4.config.plotOptions.bar.dataLabels.orientation && (d3 = "rotate(-90, ".concat(e4, ", ").concat(i4, ")"));
          var u4 = new G3(this.barCtx.ctx), f4 = new k3(this.barCtx.ctx), p4 = h4.formatter, x5 = null, b4 = c4.globals.collapsedSeriesIndices.indexOf(s4) > -1;
          if (h4.enabled && !b4) {
            x5 = f4.group({ class: "apexcharts-data-labels", transform: d3 });
            var v4 = "";
            void 0 !== a4 && (v4 = p4(a4, g4(g4({}, c4), {}, { seriesIndex: s4, dataPointIndex: r4, w: c4 }))), !a4 && c4.config.plotOptions.bar.hideZeroBarsWhenGrouped && (v4 = "");
            var m4 = c4.globals.series[s4][r4] < 0, y4 = c4.config.plotOptions.bar.dataLabels.position;
            if ("vertical" === c4.config.plotOptions.bar.dataLabels.orientation && ("top" === y4 && (h4.textAnchor = m4 ? "end" : "start"), "center" === y4 && (h4.textAnchor = "middle"), "bottom" === y4 && (h4.textAnchor = m4 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) l4 < f4.getTextRects(v4, parseFloat(h4.style.fontSize)).width && (v4 = "");
            c4.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? o3.width / 1.6 > Math.abs(l4) && (v4 = "") : o3.height / 1.6 > Math.abs(n3) && (v4 = ""));
            var w5 = g4({}, h4);
            this.barCtx.isHorizontal && a4 < 0 && ("start" === h4.textAnchor ? w5.textAnchor = "end" : "end" === h4.textAnchor && (w5.textAnchor = "start")), u4.plotDataLabelsText({ x: e4, y: i4, text: v4, i: s4, j: r4, parent: x5, dataLabelsConfig: w5, alwaysDrawDataLabel: true, offsetCorrection: true });
          }
          return x5;
        } }, { key: "drawTotalDataLabels", value: function(t5) {
          var e4 = t5.x, i4 = t5.y, a4 = t5.val, s4 = t5.realIndex, r4 = t5.textAnchor, o3 = t5.barTotalDataLabelsConfig;
          this.w;
          var n3, l4 = new k3(this.barCtx.ctx);
          return o3.enabled && void 0 !== e4 && void 0 !== i4 && this.barCtx.lastActiveBarSerieIndex === s4 && (n3 = l4.drawText({ x: e4, y: i4, foreColor: o3.style.color, text: a4, textAnchor: r4, fontFamily: o3.style.fontFamily, fontSize: o3.style.fontSize, fontWeight: o3.style.fontWeight })), n3;
        } }]), t4;
      })();
      var At = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.barCtx = e4;
        }
        return s3(t4, [{ key: "initVariables", value: function(t5) {
          var e4 = this.w;
          this.barCtx.series = t5, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
          for (var i4 = 0; i4 < t5.length; i4++) if (t5[i4].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t5[i4].length), e4.globals.isXNumeric) for (var a4 = 0; a4 < t5[i4].length; a4++) e4.globals.seriesX[i4][a4] > e4.globals.minX && e4.globals.seriesX[i4][a4] < e4.globals.maxX && this.barCtx.visibleItems++;
          else this.barCtx.visibleItems = e4.globals.dataPoints;
          this.arrBorderRadius = this.createBorderRadiusArr(e4.globals.series), 0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e4.globals.comboCharts || this.checkZeroSeries({ series: t5 });
        } }, { key: "initialPositions", value: function() {
          var t5, e4, i4, a4, s4, r4, o3, n3, l4 = this.w, h4 = l4.globals.dataPoints;
          this.barCtx.isRangeBar && (h4 = l4.globals.labels.length);
          var c4 = this.barCtx.seriesLen;
          if (l4.config.plotOptions.bar.rangeBarGroupRows && (c4 = 1), this.barCtx.isHorizontal) s4 = (i4 = l4.globals.gridHeight / h4) / c4, l4.globals.isXNumeric && (s4 = (i4 = l4.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s4 = s4 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s4 = parseInt(this.barCtx.barOptions.barHeight, 10)), n3 = this.barCtx.baseLineInvertedY + l4.globals.padHorizontal + (this.barCtx.isReversed ? l4.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (n3 = l4.globals.gridWidth / 2), e4 = (i4 - s4 * this.barCtx.seriesLen) / 2;
          else {
            if (a4 = l4.globals.gridWidth / this.barCtx.visibleItems, l4.config.xaxis.convertedCatToNumeric && (a4 = l4.globals.gridWidth / l4.globals.dataPoints), r4 = a4 / c4 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l4.globals.isXNumeric) {
              var d3 = this.barCtx.xRatio;
              l4.globals.minXDiff && 0.5 !== l4.globals.minXDiff && l4.globals.minXDiff / d3 > 0 && (a4 = l4.globals.minXDiff / d3), (r4 = a4 / c4 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r4 = 1);
            }
            -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r4 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o3 = l4.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? l4.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), t5 = l4.globals.padHorizontal + (a4 - r4 * this.barCtx.seriesLen) / 2;
          }
          return l4.globals.barHeight = s4, l4.globals.barWidth = r4, { x: t5, y: e4, yDivision: i4, xDivision: a4, barHeight: s4, barWidth: r4, zeroH: o3, zeroW: n3 };
        } }, { key: "initializeStackedPrevVars", value: function(t5) {
          t5.w.globals.seriesGroups.forEach((function(e4) {
            t5[e4] || (t5[e4] = {}), t5[e4].prevY = [], t5[e4].prevX = [], t5[e4].prevYF = [], t5[e4].prevXF = [], t5[e4].prevYVal = [], t5[e4].prevXVal = [];
          }));
        } }, { key: "initializeStackedXYVars", value: function(t5) {
          t5.w.globals.seriesGroups.forEach((function(e4) {
            t5[e4] || (t5[e4] = {}), t5[e4].xArrj = [], t5[e4].xArrjF = [], t5[e4].xArrjVal = [], t5[e4].yArrj = [], t5[e4].yArrjF = [], t5[e4].yArrjVal = [];
          }));
        } }, { key: "getPathFillColor", value: function(t5, e4, i4, a4) {
          var s4, r4, o3, n3, l4, h4 = this.w, c4 = this.barCtx.ctx.fill, d3 = null, g5 = this.barCtx.barOptions.distributed ? i4 : e4;
          this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((function(a5) {
            t5[e4][i4] >= a5.from && t5[e4][i4] <= a5.to && (d3 = a5.color);
          }));
          return null !== (s4 = h4.config.series[e4].data[i4]) && void 0 !== s4 && s4.fillColor && (d3 = h4.config.series[e4].data[i4].fillColor), c4.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? g5 : a4, dataPointIndex: i4, color: d3, value: t5[e4][i4], fillConfig: null === (r4 = h4.config.series[e4].data[i4]) || void 0 === r4 ? void 0 : r4.fill, fillType: null !== (o3 = h4.config.series[e4].data[i4]) && void 0 !== o3 && null !== (n3 = o3.fill) && void 0 !== n3 && n3.type ? null === (l4 = h4.config.series[e4].data[i4]) || void 0 === l4 ? void 0 : l4.fill.type : Array.isArray(h4.config.fill.type) ? h4.config.fill.type[a4] : h4.config.fill.type });
        } }, { key: "getStrokeWidth", value: function(t5, e4, i4) {
          var a4 = 0, s4 = this.w;
          return this.barCtx.series[t5][e4] ? this.barCtx.isNullValue = false : this.barCtx.isNullValue = true, s4.config.stroke.show && (this.barCtx.isNullValue || (a4 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i4] : this.barCtx.strokeWidth)), a4;
        } }, { key: "createBorderRadiusArr", value: function(t5) {
          var e4 = this.w, i4 = !this.w.config.chart.stacked || "last" !== e4.config.plotOptions.bar.borderRadiusWhenStacked || e4.config.plotOptions.bar.borderRadius <= 0, a4 = t5.length, s4 = t5[0].length, o3 = Array.from({ length: a4 }, (function() {
            return Array(s4).fill(i4 ? "top" : "none");
          }));
          if (i4) return o3;
          for (var n3 = 0; n3 < s4; n3++) {
            for (var l4 = [], h4 = [], c4 = 0, d3 = 0; d3 < a4; d3++) {
              var g5 = t5[d3][n3];
              g5 > 0 ? (l4.push(d3), c4++) : g5 < 0 && (h4.push(d3), c4++);
            }
            if (l4.length > 0 && 0 === h4.length) if (1 === l4.length) o3[l4[0]][n3] = "both";
            else {
              var u4, f4 = l4[0], p4 = l4[l4.length - 1], x5 = r3(l4);
              try {
                for (x5.s(); !(u4 = x5.n()).done; ) {
                  var b4 = u4.value;
                  o3[b4][n3] = b4 === f4 ? "bottom" : b4 === p4 ? "top" : "none";
                }
              } catch (t6) {
                x5.e(t6);
              } finally {
                x5.f();
              }
            }
            else if (h4.length > 0 && 0 === l4.length) if (1 === h4.length) o3[h4[0]][n3] = "both";
            else {
              var v4, m4 = h4[0], y4 = h4[h4.length - 1], w5 = r3(h4);
              try {
                for (w5.s(); !(v4 = w5.n()).done; ) {
                  var k4 = v4.value;
                  o3[k4][n3] = k4 === m4 ? "bottom" : k4 === y4 ? "top" : "none";
                }
              } catch (t6) {
                w5.e(t6);
              } finally {
                w5.f();
              }
            }
            else if (l4.length > 0 && h4.length > 0) {
              var A4, S3 = l4[l4.length - 1], C4 = r3(l4);
              try {
                for (C4.s(); !(A4 = C4.n()).done; ) {
                  var L4 = A4.value;
                  o3[L4][n3] = L4 === S3 ? "top" : "none";
                }
              } catch (t6) {
                C4.e(t6);
              } finally {
                C4.f();
              }
              var P4, M3 = h4[h4.length - 1], I4 = r3(h4);
              try {
                for (I4.s(); !(P4 = I4.n()).done; ) {
                  var T5 = P4.value;
                  o3[T5][n3] = T5 === M3 ? "bottom" : "none";
                }
              } catch (t6) {
                I4.e(t6);
              } finally {
                I4.f();
              }
            } else if (1 === c4) {
              o3[l4[0] || h4[0]][n3] = "both";
            }
          }
          return o3;
        } }, { key: "barBackground", value: function(t5) {
          var e4 = t5.j, i4 = t5.i, a4 = t5.x1, s4 = t5.x2, r4 = t5.y1, o3 = t5.y2, n3 = t5.elSeries, l4 = this.w, h4 = new k3(this.barCtx.ctx), c4 = new V3(this.barCtx.ctx).getActiveConfigSeriesIndex();
          if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c4 === i4) {
            e4 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e4 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
            var d3 = this.barCtx.barOptions.colors.backgroundBarColors[e4], g5 = h4.drawRect(void 0 !== a4 ? a4 : 0, void 0 !== r4 ? r4 : 0, void 0 !== s4 ? s4 : l4.globals.gridWidth, void 0 !== o3 ? o3 : l4.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d3, this.barCtx.barOptions.colors.backgroundBarOpacity);
            n3.add(g5), g5.node.classList.add("apexcharts-backgroundBar");
          }
        } }, { key: "getColumnPaths", value: function(t5) {
          var e4, i4 = t5.barWidth, a4 = t5.barXPosition, s4 = t5.y1, r4 = t5.y2, o3 = t5.strokeWidth, n3 = t5.isReversed, l4 = t5.series, h4 = t5.seriesGroup, c4 = t5.realIndex, d3 = t5.i, g5 = t5.j, u4 = t5.w, f4 = new k3(this.barCtx.ctx);
          (o3 = Array.isArray(o3) ? o3[c4] : o3) || (o3 = 0);
          var p4 = i4, x5 = a4;
          null !== (e4 = u4.config.series[c4].data[g5]) && void 0 !== e4 && e4.columnWidthOffset && (x5 = a4 - u4.config.series[c4].data[g5].columnWidthOffset / 2, p4 = i4 + u4.config.series[c4].data[g5].columnWidthOffset);
          var b4 = o3 / 2, v4 = x5 + b4, m4 = x5 + p4 - b4, y4 = (l4[d3][g5] >= 0 ? 1 : -1) * (n3 ? -1 : 1);
          s4 += 1e-3 - b4 * y4, r4 += 1e-3 + b4 * y4;
          var w5 = f4.move(v4, s4), A4 = f4.move(v4, s4), S3 = f4.line(m4, s4);
          if (u4.globals.previousPaths.length > 0 && (A4 = this.barCtx.getPreviousPath(c4, g5, false)), w5 = w5 + f4.line(v4, r4) + f4.line(m4, r4) + S3 + ("around" === u4.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c4][g5] ? " Z" : " z"), A4 = A4 + f4.line(v4, s4) + S3 + S3 + S3 + S3 + S3 + f4.line(v4, s4) + ("around" === u4.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c4][g5] ? " Z" : " z"), "none" !== this.arrBorderRadius[c4][g5] && (w5 = f4.roundPathCorners(w5, u4.config.plotOptions.bar.borderRadius)), u4.config.chart.stacked) {
            var C4 = this.barCtx;
            (C4 = this.barCtx[h4]).yArrj.push(r4 - b4 * y4), C4.yArrjF.push(Math.abs(s4 - r4 + o3 * y4)), C4.yArrjVal.push(this.barCtx.series[d3][g5]);
          }
          return { pathTo: w5, pathFrom: A4 };
        } }, { key: "getBarpaths", value: function(t5) {
          var e4, i4 = t5.barYPosition, a4 = t5.barHeight, s4 = t5.x1, r4 = t5.x2, o3 = t5.strokeWidth, n3 = t5.isReversed, l4 = t5.series, h4 = t5.seriesGroup, c4 = t5.realIndex, d3 = t5.i, g5 = t5.j, u4 = t5.w, f4 = new k3(this.barCtx.ctx);
          (o3 = Array.isArray(o3) ? o3[c4] : o3) || (o3 = 0);
          var p4 = i4, x5 = a4;
          null !== (e4 = u4.config.series[c4].data[g5]) && void 0 !== e4 && e4.barHeightOffset && (p4 = i4 - u4.config.series[c4].data[g5].barHeightOffset / 2, x5 = a4 + u4.config.series[c4].data[g5].barHeightOffset);
          var b4 = o3 / 2, v4 = p4 + b4, m4 = p4 + x5 - b4, y4 = (l4[d3][g5] >= 0 ? 1 : -1) * (n3 ? -1 : 1);
          s4 += 1e-3 + b4 * y4, r4 += 1e-3 - b4 * y4;
          var w5 = f4.move(s4, v4), A4 = f4.move(s4, v4);
          u4.globals.previousPaths.length > 0 && (A4 = this.barCtx.getPreviousPath(c4, g5, false));
          var S3 = f4.line(s4, m4);
          if (w5 = w5 + f4.line(r4, v4) + f4.line(r4, m4) + S3 + ("around" === u4.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c4][g5] ? " Z" : " z"), A4 = A4 + f4.line(s4, v4) + S3 + S3 + S3 + S3 + S3 + f4.line(s4, v4) + ("around" === u4.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c4][g5] ? " Z" : " z"), "none" !== this.arrBorderRadius[c4][g5] && (w5 = f4.roundPathCorners(w5, u4.config.plotOptions.bar.borderRadius)), u4.config.chart.stacked) {
            var C4 = this.barCtx;
            (C4 = this.barCtx[h4]).xArrj.push(r4 + b4 * y4), C4.xArrjF.push(Math.abs(s4 - r4 - o3 * y4)), C4.xArrjVal.push(this.barCtx.series[d3][g5]);
          }
          return { pathTo: w5, pathFrom: A4 };
        } }, { key: "checkZeroSeries", value: function(t5) {
          for (var e4 = t5.series, i4 = this.w, a4 = 0; a4 < e4.length; a4++) {
            for (var s4 = 0, r4 = 0; r4 < e4[i4.globals.maxValsInArrayIndex].length; r4++) s4 += e4[a4][r4];
            0 === s4 && this.barCtx.zeroSerieses.push(a4);
          }
        } }, { key: "getXForValue", value: function(t5, e4) {
          var i4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e4 : null;
          return null != t5 && (i4 = e4 + t5 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t5 / this.barCtx.invertedYRatio : 0)), i4;
        } }, { key: "getYForValue", value: function(t5, e4, i4) {
          var a4 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3] ? e4 : null;
          return null != t5 && (a4 = e4 - t5 / this.barCtx.yRatio[i4] + 2 * (this.barCtx.isReversed ? t5 / this.barCtx.yRatio[i4] : 0)), a4;
        } }, { key: "getGoalValues", value: function(t5, e4, i4, a4, s4, r4) {
          var o3 = this, l4 = this.w, h4 = [], c4 = function(a5, s5) {
            var l5;
            h4.push((n2(l5 = {}, t5, "x" === t5 ? o3.getXForValue(a5, e4, false) : o3.getYForValue(a5, i4, r4, false)), n2(l5, "attrs", s5), l5));
          };
          if (l4.globals.seriesGoals[a4] && l4.globals.seriesGoals[a4][s4] && Array.isArray(l4.globals.seriesGoals[a4][s4]) && l4.globals.seriesGoals[a4][s4].forEach((function(t6) {
            c4(t6.value, t6);
          })), this.barCtx.barOptions.isDumbbell && l4.globals.seriesRange.length) {
            var d3 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l4.globals.colors, u4 = { strokeHeight: "x" === t5 ? 0 : l4.globals.markers.size[a4], strokeWidth: "x" === t5 ? l4.globals.markers.size[a4] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d3[a4]) ? d3[a4][0] : d3[a4] };
            c4(l4.globals.seriesRangeStart[a4][s4], u4), c4(l4.globals.seriesRangeEnd[a4][s4], g4(g4({}, u4), {}, { strokeColor: Array.isArray(d3[a4]) ? d3[a4][1] : d3[a4] }));
          }
          return h4;
        } }, { key: "drawGoalLine", value: function(t5) {
          var e4 = t5.barXPosition, i4 = t5.barYPosition, a4 = t5.goalX, s4 = t5.goalY, r4 = t5.barWidth, o3 = t5.barHeight, n3 = new k3(this.barCtx.ctx), l4 = n3.group({ className: "apexcharts-bar-goals-groups" });
          l4.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l4.node }), l4.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
          var h4 = null;
          return this.barCtx.isHorizontal ? Array.isArray(a4) && a4.forEach((function(t6) {
            if (t6.x >= -1 && t6.x <= n3.w.globals.gridWidth + 1) {
              var e5 = void 0 !== t6.attrs.strokeHeight ? t6.attrs.strokeHeight : o3 / 2, a5 = i4 + e5 + o3 / 2;
              h4 = n3.drawLine(t6.x, a5 - 2 * e5, t6.x, a5, t6.attrs.strokeColor ? t6.attrs.strokeColor : void 0, t6.attrs.strokeDashArray, t6.attrs.strokeWidth ? t6.attrs.strokeWidth : 2, t6.attrs.strokeLineCap), l4.add(h4);
            }
          })) : Array.isArray(s4) && s4.forEach((function(t6) {
            if (t6.y >= -1 && t6.y <= n3.w.globals.gridHeight + 1) {
              var i5 = void 0 !== t6.attrs.strokeWidth ? t6.attrs.strokeWidth : r4 / 2, a5 = e4 + i5 + r4 / 2;
              h4 = n3.drawLine(a5 - 2 * i5, t6.y, a5, t6.y, t6.attrs.strokeColor ? t6.attrs.strokeColor : void 0, t6.attrs.strokeDashArray, t6.attrs.strokeHeight ? t6.attrs.strokeHeight : 2, t6.attrs.strokeLineCap), l4.add(h4);
            }
          })), l4;
        } }, { key: "drawBarShadow", value: function(t5) {
          var e4 = t5.prevPaths, i4 = t5.currPaths, a4 = t5.color, s4 = this.w, r4 = e4.x, o3 = e4.x1, n3 = e4.barYPosition, l4 = i4.x, h4 = i4.x1, c4 = i4.barYPosition, d3 = n3 + i4.barHeight, g5 = new k3(this.barCtx.ctx), u4 = new m3(), f4 = g5.move(o3, d3) + g5.line(r4, d3) + g5.line(l4, c4) + g5.line(h4, c4) + g5.line(o3, d3) + ("around" === s4.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[realIndex][j] ? " Z" : " z");
          return g5.drawPath({ d: f4, fill: u4.shadeColor(0.5, m3.rgb2hex(a4)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
        } }, { key: "getZeroValueEncounters", value: function(t5) {
          var e4, i4 = t5.i, a4 = t5.j, s4 = this.w, r4 = 0, o3 = 0;
          return (s4.config.plotOptions.bar.horizontal ? s4.globals.series.map((function(t6, e5) {
            return e5;
          })) : (null === (e4 = s4.globals.columnSeries) || void 0 === e4 ? void 0 : e4.i.map((function(t6) {
            return t6;
          }))) || []).forEach((function(t6) {
            var e5 = s4.globals.seriesPercent[t6][a4];
            e5 && r4++, t6 < i4 && 0 === e5 && o3++;
          })), { nonZeroColumns: r4, zeroEncounters: o3 };
        } }, { key: "getGroupIndex", value: function(t5) {
          var e4 = this.w, i4 = e4.globals.seriesGroups.findIndex((function(i5) {
            return i5.indexOf(e4.globals.seriesNames[t5]) > -1;
          })), a4 = this.barCtx.columnGroupIndices, s4 = a4.indexOf(i4);
          return s4 < 0 && (a4.push(i4), s4 = a4.length - 1), { groupIndex: i4, columnGroupIndex: s4 };
        } }]), t4;
      })();
      var St = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
          var s4 = this.w;
          this.barOptions = s4.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s4.config.stroke.width, this.isNullValue = false, this.isRangeBar = s4.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s4.globals.isBarHorizontal && s4.globals.seriesRange.length && s4.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = a4, null !== this.xyRatios && (this.xRatio = a4.xRatio, this.yRatio = a4.yRatio, this.invertedXRatio = a4.invertedXRatio, this.invertedYRatio = a4.invertedYRatio, this.baseLineY = a4.baseLineY, this.baseLineInvertedY = a4.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
          var r4 = new V3(this.ctx);
          this.lastActiveBarSerieIndex = r4.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
          var o3 = r4.getBarSeriesIndices(), n3 = new A3(this.ctx);
          this.stackedSeriesTotals = n3.getStackedSeriesTotals(this.w.config.series.map((function(t5, e5) {
            return -1 === o3.indexOf(e5) ? e5 : -1;
          })).filter((function(t5) {
            return -1 !== t5;
          }))), this.barHelpers = new At(this);
        }
        return s3(t4, [{ key: "draw", value: function(t5, e4) {
          var i4 = this.w, a4 = new k3(this.ctx), s4 = new A3(this.ctx, i4);
          t5 = s4.getLogSeries(t5), this.series = t5, this.yRatio = s4.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t5);
          var r4 = a4.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
          i4.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
          for (var o3 = 0, n3 = 0; o3 < t5.length; o3++, n3++) {
            var l4, h4, c4, d3, u4 = void 0, f4 = void 0, p4 = [], x5 = [], b4 = i4.globals.comboCharts ? e4[o3] : o3, v4 = this.barHelpers.getGroupIndex(b4).columnGroupIndex, y4 = a4.group({ class: "apexcharts-series", rel: o3 + 1, seriesName: m3.escapeString(i4.globals.seriesNames[b4]), "data:realIndex": b4 });
            this.ctx.series.addCollapsedClassToSeries(y4, b4), t5[o3].length > 0 && (this.visibleI = this.visibleI + 1);
            var w5 = 0, S3 = 0;
            this.yRatio.length > 1 && (this.yaxisIndex = i4.globals.seriesYAxisReverseMap[b4], this.translationsIndex = b4);
            var C4 = this.translationsIndex;
            this.isReversed = i4.config.yaxis[this.yaxisIndex] && i4.config.yaxis[this.yaxisIndex].reversed;
            var L4 = this.barHelpers.initialPositions();
            f4 = L4.y, w5 = L4.barHeight, h4 = L4.yDivision, d3 = L4.zeroW, u4 = L4.x, S3 = L4.barWidth, l4 = L4.xDivision, c4 = L4.zeroH, this.horizontal || x5.push(u4 + S3 / 2);
            var P4 = a4.group({ class: "apexcharts-datalabels", "data:realIndex": b4 });
            i4.globals.delayedElements.push({ el: P4.node }), P4.node.classList.add("apexcharts-element-hidden");
            var M3 = a4.group({ class: "apexcharts-bar-goals-markers" }), I4 = a4.group({ class: "apexcharts-bar-shadows" });
            i4.globals.delayedElements.push({ el: I4.node }), I4.node.classList.add("apexcharts-element-hidden");
            for (var T5 = 0; T5 < t5[o3].length; T5++) {
              var z4 = this.barHelpers.getStrokeWidth(o3, T5, b4), X3 = null, E3 = { indexes: { i: o3, j: T5, realIndex: b4, translationsIndex: C4, bc: n3 }, x: u4, y: f4, strokeWidth: z4, elSeries: y4 };
              this.isHorizontal ? (X3 = this.drawBarPaths(g4(g4({}, E3), {}, { barHeight: w5, zeroW: d3, yDivision: h4 })), S3 = this.series[o3][T5] / this.invertedYRatio) : (X3 = this.drawColumnPaths(g4(g4({}, E3), {}, { xDivision: l4, barWidth: S3, zeroH: c4 })), w5 = this.series[o3][T5] / this.yRatio[C4]);
              var Y2 = this.barHelpers.getPathFillColor(t5, o3, T5, b4);
              if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && T5 > 0) {
                var R2 = this.barHelpers.drawBarShadow({ color: "string" == typeof Y2 && -1 === (null == Y2 ? void 0 : Y2.indexOf("url")) ? Y2 : m3.hexToRgba(i4.globals.colors[o3]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: X3 });
                R2 && I4.add(R2);
              }
              this.pathArr.push(X3);
              var F5 = this.barHelpers.drawGoalLine({ barXPosition: X3.barXPosition, barYPosition: X3.barYPosition, goalX: X3.goalX, goalY: X3.goalY, barHeight: w5, barWidth: S3 });
              F5 && M3.add(F5), f4 = X3.y, u4 = X3.x, T5 > 0 && x5.push(u4 + S3 / 2), p4.push(f4), this.renderSeries({ realIndex: b4, pathFill: Y2, j: T5, i: o3, columnGroupIndex: v4, pathFrom: X3.pathFrom, pathTo: X3.pathTo, strokeWidth: z4, elSeries: y4, x: u4, y: f4, series: t5, barHeight: Math.abs(X3.barHeight ? X3.barHeight : w5), barWidth: Math.abs(X3.barWidth ? X3.barWidth : S3), elDataLabelsWrap: P4, elGoalsMarkers: M3, elBarShadows: I4, visibleSeries: this.visibleI, type: "bar" });
            }
            i4.globals.seriesXvalues[b4] = x5, i4.globals.seriesYvalues[b4] = p4, r4.add(y4);
          }
          return r4;
        } }, { key: "renderSeries", value: function(t5) {
          var e4 = t5.realIndex, i4 = t5.pathFill, a4 = t5.lineFill, s4 = t5.j, r4 = t5.i, o3 = t5.columnGroupIndex, n3 = t5.pathFrom, l4 = t5.pathTo, h4 = t5.strokeWidth, c4 = t5.elSeries, d3 = t5.x, g5 = t5.y, u4 = t5.y1, f4 = t5.y2, p4 = t5.series, x5 = t5.barHeight, b4 = t5.barWidth, v4 = t5.barXPosition, m4 = t5.barYPosition, y4 = t5.elDataLabelsWrap, A4 = t5.elGoalsMarkers, S3 = t5.elBarShadows, C4 = t5.visibleSeries, L4 = t5.type, P4 = t5.classes, M3 = this.w, I4 = new k3(this.ctx);
          if (!a4) {
            var T5 = "function" == typeof M3.globals.stroke.colors[e4] ? (function(t6) {
              var e5, i5 = M3.config.stroke.colors;
              return Array.isArray(i5) && i5.length > 0 && ((e5 = i5[t6]) || (e5 = ""), "function" == typeof e5) ? e5({ value: M3.globals.series[t6][s4], dataPointIndex: s4, w: M3 }) : e5;
            })(e4) : M3.globals.stroke.colors[e4];
            a4 = this.barOptions.distributed ? M3.globals.stroke.colors[s4] : T5;
          }
          M3.config.series[r4].data[s4] && M3.config.series[r4].data[s4].strokeColor && (a4 = M3.config.series[r4].data[s4].strokeColor), this.isNullValue && (i4 = "none");
          var z4 = s4 / M3.config.chart.animations.animateGradually.delay * (M3.config.chart.animations.speed / M3.globals.dataPoints) / 2.4, X3 = I4.renderPaths({ i: r4, j: s4, realIndex: e4, pathFrom: n3, pathTo: l4, stroke: a4, strokeWidth: h4, strokeLineCap: M3.config.stroke.lineCap, fill: i4, animationDelay: z4, initialSpeed: M3.config.chart.animations.speed, dataChangeSpeed: M3.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(L4, "-area ").concat(P4), chartType: L4 });
          X3.attr("clip-path", "url(#gridRectBarMask".concat(M3.globals.cuid, ")"));
          var E3 = M3.config.forecastDataPoints;
          E3.count > 0 && s4 >= M3.globals.dataPoints - E3.count && (X3.node.setAttribute("stroke-dasharray", E3.dashArray), X3.node.setAttribute("stroke-width", E3.strokeWidth), X3.node.setAttribute("fill-opacity", E3.fillOpacity)), void 0 !== u4 && void 0 !== f4 && (X3.attr("data-range-y1", u4), X3.attr("data-range-y2", f4)), new w4(this.ctx).setSelectionFilter(X3, e4, s4), c4.add(X3);
          var Y2 = new kt(this).handleBarDataLabels({ x: d3, y: g5, y1: u4, y2: f4, i: r4, j: s4, series: p4, realIndex: e4, columnGroupIndex: o3, barHeight: x5, barWidth: b4, barXPosition: v4, barYPosition: m4, renderedPath: X3, visibleSeries: C4 });
          return null !== Y2.dataLabels && y4.add(Y2.dataLabels), Y2.totalDataLabels && y4.add(Y2.totalDataLabels), c4.add(y4), A4 && c4.add(A4), S3 && c4.add(S3), c4;
        } }, { key: "drawBarPaths", value: function(t5) {
          var e4, i4 = t5.indexes, a4 = t5.barHeight, s4 = t5.strokeWidth, r4 = t5.zeroW, o3 = t5.x, n3 = t5.y, l4 = t5.yDivision, h4 = t5.elSeries, c4 = this.w, d3 = i4.i, g5 = i4.j;
          if (c4.globals.isXNumeric) e4 = (n3 = (c4.globals.seriesX[d3][g5] - c4.globals.minX) / this.invertedXRatio - a4) + a4 * this.visibleI;
          else if (c4.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            var u4 = 0, f4 = 0;
            c4.globals.seriesPercent.forEach((function(t6, e5) {
              t6[g5] && u4++, e5 < d3 && 0 === t6[g5] && f4++;
            })), u4 > 0 && (a4 = this.seriesLen * a4 / u4), e4 = n3 + a4 * this.visibleI, e4 -= a4 * f4;
          } else e4 = n3 + a4 * this.visibleI;
          this.isFunnel && (r4 -= (this.barHelpers.getXForValue(this.series[d3][g5], r4) - r4) / 2), o3 = this.barHelpers.getXForValue(this.series[d3][g5], r4);
          var p4 = this.barHelpers.getBarpaths({ barYPosition: e4, barHeight: a4, x1: r4, x2: o3, strokeWidth: s4, isReversed: this.isReversed, series: this.series, realIndex: i4.realIndex, i: d3, j: g5, w: c4 });
          return c4.globals.isXNumeric || (n3 += l4), this.barHelpers.barBackground({ j: g5, i: d3, y1: e4 - a4 * this.visibleI, y2: a4 * this.seriesLen, elSeries: h4 }), { pathTo: p4.pathTo, pathFrom: p4.pathFrom, x1: r4, x: o3, y: n3, goalX: this.barHelpers.getGoalValues("x", r4, null, d3, g5), barYPosition: e4, barHeight: a4 };
        } }, { key: "drawColumnPaths", value: function(t5) {
          var e4, i4 = t5.indexes, a4 = t5.x, s4 = t5.y, r4 = t5.xDivision, o3 = t5.barWidth, n3 = t5.zeroH, l4 = t5.strokeWidth, h4 = t5.elSeries, c4 = this.w, d3 = i4.realIndex, g5 = i4.translationsIndex, u4 = i4.i, f4 = i4.j, p4 = i4.bc;
          if (c4.globals.isXNumeric) {
            var x5 = this.getBarXForNumericXAxis({ x: a4, j: f4, realIndex: d3, barWidth: o3 });
            a4 = x5.x, e4 = x5.barXPosition;
          } else if (c4.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            var b4 = this.barHelpers.getZeroValueEncounters({ i: u4, j: f4 }), v4 = b4.nonZeroColumns, m4 = b4.zeroEncounters;
            v4 > 0 && (o3 = this.seriesLen * o3 / v4), e4 = a4 + o3 * this.visibleI, e4 -= o3 * m4;
          } else e4 = a4 + o3 * this.visibleI;
          s4 = this.barHelpers.getYForValue(this.series[u4][f4], n3, g5);
          var y4 = this.barHelpers.getColumnPaths({ barXPosition: e4, barWidth: o3, y1: n3, y2: s4, strokeWidth: l4, isReversed: this.isReversed, series: this.series, realIndex: d3, i: u4, j: f4, w: c4 });
          return c4.globals.isXNumeric || (a4 += r4), this.barHelpers.barBackground({ bc: p4, j: f4, i: u4, x1: e4 - l4 / 2 - o3 * this.visibleI, x2: o3 * this.seriesLen + l4 / 2, elSeries: h4 }), { pathTo: y4.pathTo, pathFrom: y4.pathFrom, x: a4, y: s4, goalY: this.barHelpers.getGoalValues("y", null, n3, u4, f4, g5), barXPosition: e4, barWidth: o3 };
        } }, { key: "getBarXForNumericXAxis", value: function(t5) {
          var e4 = t5.x, i4 = t5.barWidth, a4 = t5.realIndex, s4 = t5.j, r4 = this.w, o3 = a4;
          return r4.globals.seriesX[a4].length || (o3 = r4.globals.maxValsInArrayIndex), r4.globals.seriesX[o3][s4] && (e4 = (r4.globals.seriesX[o3][s4] - r4.globals.minX) / this.xRatio - i4 * this.seriesLen / 2), { barXPosition: e4 + i4 * this.visibleI, x: e4 };
        } }, { key: "getPreviousPath", value: function(t5, e4) {
          for (var i4, a4 = this.w, s4 = 0; s4 < a4.globals.previousPaths.length; s4++) {
            var r4 = a4.globals.previousPaths[s4];
            r4.paths && r4.paths.length > 0 && parseInt(r4.realIndex, 10) === parseInt(t5, 10) && void 0 !== a4.globals.previousPaths[s4].paths[e4] && (i4 = a4.globals.previousPaths[s4].paths[e4].d);
          }
          return i4;
        } }]), t4;
      })();
      var Ct = (function(t4) {
        h3(a4, St);
        var e4 = o2(a4);
        function a4() {
          return i3(this, a4), e4.apply(this, arguments);
        }
        return s3(a4, [{ key: "draw", value: function(t5, e5) {
          var i4 = this, a5 = this.w;
          this.graphics = new k3(this.ctx), this.bar = new St(this.ctx, this.xyRatios);
          var s4 = new A3(this.ctx, a5);
          t5 = s4.getLogSeries(t5), this.yRatio = s4.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t5), "100%" === a5.config.chart.stackType && (t5 = a5.globals.comboCharts ? e5.map((function(t6) {
            return a5.globals.seriesPercent[t6];
          })) : a5.globals.seriesPercent.slice()), this.series = t5, this.barHelpers.initializeStackedPrevVars(this);
          for (var r4 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), o3 = 0, n3 = 0, l4 = function(s5, l5) {
            var h5 = void 0, c5 = void 0, d3 = void 0, u4 = void 0, f4 = a5.globals.comboCharts ? e5[s5] : s5, p4 = i4.barHelpers.getGroupIndex(f4), x5 = p4.groupIndex, b4 = p4.columnGroupIndex;
            i4.groupCtx = i4[a5.globals.seriesGroups[x5]];
            var v4 = [], y4 = [], w5 = 0;
            i4.yRatio.length > 1 && (i4.yaxisIndex = a5.globals.seriesYAxisReverseMap[f4][0], w5 = f4), i4.isReversed = a5.config.yaxis[i4.yaxisIndex] && a5.config.yaxis[i4.yaxisIndex].reversed;
            var k4 = i4.graphics.group({ class: "apexcharts-series", seriesName: m3.escapeString(a5.globals.seriesNames[f4]), rel: s5 + 1, "data:realIndex": f4 });
            i4.ctx.series.addCollapsedClassToSeries(k4, f4);
            var A4 = i4.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": f4 }), S3 = i4.graphics.group({ class: "apexcharts-bar-goals-markers" }), C4 = 0, L4 = 0, P4 = i4.initialPositions(o3, n3, h5, c5, d3, u4, w5);
            n3 = P4.y, C4 = P4.barHeight, c5 = P4.yDivision, u4 = P4.zeroW, o3 = P4.x, L4 = P4.barWidth, h5 = P4.xDivision, d3 = P4.zeroH, a5.globals.barHeight = C4, a5.globals.barWidth = L4, i4.barHelpers.initializeStackedXYVars(i4), 1 === i4.groupCtx.prevY.length && i4.groupCtx.prevY[0].every((function(t6) {
              return isNaN(t6);
            })) && (i4.groupCtx.prevY[0] = i4.groupCtx.prevY[0].map((function() {
              return d3;
            })), i4.groupCtx.prevYF[0] = i4.groupCtx.prevYF[0].map((function() {
              return 0;
            })));
            for (var M3 = 0; M3 < a5.globals.dataPoints; M3++) {
              var I4 = i4.barHelpers.getStrokeWidth(s5, M3, f4), T5 = { indexes: { i: s5, j: M3, realIndex: f4, translationsIndex: w5, bc: l5 }, strokeWidth: I4, x: o3, y: n3, elSeries: k4, columnGroupIndex: b4, seriesGroup: a5.globals.seriesGroups[x5] }, z4 = null;
              i4.isHorizontal ? (z4 = i4.drawStackedBarPaths(g4(g4({}, T5), {}, { zeroW: u4, barHeight: C4, yDivision: c5 })), L4 = i4.series[s5][M3] / i4.invertedYRatio) : (z4 = i4.drawStackedColumnPaths(g4(g4({}, T5), {}, { xDivision: h5, barWidth: L4, zeroH: d3 })), C4 = i4.series[s5][M3] / i4.yRatio[w5]);
              var X3 = i4.barHelpers.drawGoalLine({ barXPosition: z4.barXPosition, barYPosition: z4.barYPosition, goalX: z4.goalX, goalY: z4.goalY, barHeight: C4, barWidth: L4 });
              X3 && S3.add(X3), n3 = z4.y, o3 = z4.x, v4.push(o3), y4.push(n3);
              var E3 = i4.barHelpers.getPathFillColor(t5, s5, M3, f4), Y2 = "";
              a5.globals.isBarHorizontal ? "bottom" === i4.barHelpers.arrBorderRadius[f4][M3] && a5.globals.series[f4][M3] > 0 && (Y2 = "apexcharts-flip-x") : "bottom" === i4.barHelpers.arrBorderRadius[f4][M3] && a5.globals.series[f4][M3] > 0 && (Y2 = "apexcharts-flip-y"), k4 = i4.renderSeries({ realIndex: f4, pathFill: E3, j: M3, i: s5, columnGroupIndex: b4, pathFrom: z4.pathFrom, pathTo: z4.pathTo, strokeWidth: I4, elSeries: k4, x: o3, y: n3, series: t5, barHeight: C4, barWidth: L4, elDataLabelsWrap: A4, elGoalsMarkers: S3, type: "bar", visibleSeries: b4, classes: Y2 });
            }
            a5.globals.seriesXvalues[f4] = v4, a5.globals.seriesYvalues[f4] = y4, i4.groupCtx.prevY.push(i4.groupCtx.yArrj), i4.groupCtx.prevYF.push(i4.groupCtx.yArrjF), i4.groupCtx.prevYVal.push(i4.groupCtx.yArrjVal), i4.groupCtx.prevX.push(i4.groupCtx.xArrj), i4.groupCtx.prevXF.push(i4.groupCtx.xArrjF), i4.groupCtx.prevXVal.push(i4.groupCtx.xArrjVal), r4.add(k4);
          }, h4 = 0, c4 = 0; h4 < t5.length; h4++, c4++) l4(h4, c4);
          return r4;
        } }, { key: "initialPositions", value: function(t5, e5, i4, a5, s4, r4, o3) {
          var n3, l4, h4 = this.w;
          if (this.isHorizontal) {
            a5 = h4.globals.gridHeight / h4.globals.dataPoints;
            var c4 = h4.config.plotOptions.bar.barHeight;
            n3 = -1 === String(c4).indexOf("%") ? parseInt(c4, 10) : a5 * parseInt(c4, 10) / 100, r4 = h4.globals.padHorizontal + (this.isReversed ? h4.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e5 = (a5 - n3) / 2;
          } else {
            l4 = i4 = h4.globals.gridWidth / h4.globals.dataPoints;
            var d3 = h4.config.plotOptions.bar.columnWidth;
            h4.globals.isXNumeric && h4.globals.dataPoints > 1 ? l4 = (i4 = h4.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d3).indexOf("%") ? l4 = parseInt(d3, 10) : l4 *= parseInt(d3, 10) / 100, s4 = this.isReversed ? this.baseLineY[o3] : h4.globals.gridHeight - this.baseLineY[o3], t5 = h4.globals.padHorizontal + (i4 - l4) / 2;
          }
          var g5 = h4.globals.barGroups.length || 1;
          return { x: t5, y: e5, yDivision: a5, xDivision: i4, barHeight: n3 / g5, barWidth: l4 / g5, zeroH: s4, zeroW: r4 };
        } }, { key: "drawStackedBarPaths", value: function(t5) {
          for (var e5, i4 = t5.indexes, a5 = t5.barHeight, s4 = t5.strokeWidth, r4 = t5.zeroW, o3 = t5.x, n3 = t5.y, l4 = t5.columnGroupIndex, h4 = t5.seriesGroup, c4 = t5.yDivision, d3 = t5.elSeries, g5 = this.w, u4 = n3 + l4 * a5, f4 = i4.i, p4 = i4.j, x5 = i4.realIndex, b4 = i4.translationsIndex, v4 = 0, m4 = 0; m4 < this.groupCtx.prevXF.length; m4++) v4 += this.groupCtx.prevXF[m4][p4];
          var y4;
          if ((y4 = h4.indexOf(g5.config.series[x5].name)) > 0) {
            var w5 = r4;
            this.groupCtx.prevXVal[y4 - 1][p4] < 0 ? w5 = this.series[f4][p4] >= 0 ? this.groupCtx.prevX[y4 - 1][p4] + v4 - 2 * (this.isReversed ? v4 : 0) : this.groupCtx.prevX[y4 - 1][p4] : this.groupCtx.prevXVal[y4 - 1][p4] >= 0 && (w5 = this.series[f4][p4] >= 0 ? this.groupCtx.prevX[y4 - 1][p4] : this.groupCtx.prevX[y4 - 1][p4] - v4 + 2 * (this.isReversed ? v4 : 0)), e5 = w5;
          } else e5 = r4;
          o3 = null === this.series[f4][p4] ? e5 : e5 + this.series[f4][p4] / this.invertedYRatio - 2 * (this.isReversed ? this.series[f4][p4] / this.invertedYRatio : 0);
          var k4 = this.barHelpers.getBarpaths({ barYPosition: u4, barHeight: a5, x1: e5, x2: o3, strokeWidth: s4, isReversed: this.isReversed, series: this.series, realIndex: i4.realIndex, seriesGroup: h4, i: f4, j: p4, w: g5 });
          return this.barHelpers.barBackground({ j: p4, i: f4, y1: u4, y2: a5, elSeries: d3 }), n3 += c4, { pathTo: k4.pathTo, pathFrom: k4.pathFrom, goalX: this.barHelpers.getGoalValues("x", r4, null, f4, p4, b4), barXPosition: e5, barYPosition: u4, x: o3, y: n3 };
        } }, { key: "drawStackedColumnPaths", value: function(t5) {
          var e5 = t5.indexes, i4 = t5.x, a5 = t5.y, s4 = t5.xDivision, r4 = t5.barWidth, o3 = t5.zeroH, n3 = t5.columnGroupIndex, l4 = t5.seriesGroup, h4 = t5.elSeries, c4 = this.w, d3 = e5.i, g5 = e5.j, u4 = e5.bc, f4 = e5.realIndex, p4 = e5.translationsIndex;
          if (c4.globals.isXNumeric) {
            var x5 = c4.globals.seriesX[f4][g5];
            x5 || (x5 = 0), i4 = (x5 - c4.globals.minX) / this.xRatio - r4 / 2 * c4.globals.barGroups.length;
          }
          for (var b4, v4 = i4 + n3 * r4, m4 = 0, y4 = 0; y4 < this.groupCtx.prevYF.length; y4++) m4 += isNaN(this.groupCtx.prevYF[y4][g5]) ? 0 : this.groupCtx.prevYF[y4][g5];
          var w5 = d3;
          if (l4 && (w5 = l4.indexOf(c4.globals.seriesNames[f4])), w5 > 0 && !c4.globals.isXNumeric || w5 > 0 && c4.globals.isXNumeric && c4.globals.seriesX[f4 - 1][g5] === c4.globals.seriesX[f4][g5]) {
            var k4, A4, S3, C4 = Math.min(this.yRatio.length + 1, f4 + 1);
            if (void 0 !== this.groupCtx.prevY[w5 - 1] && this.groupCtx.prevY[w5 - 1].length) for (var L4 = 1; L4 < C4; L4++) {
              var P4;
              if (!isNaN(null === (P4 = this.groupCtx.prevY[w5 - L4]) || void 0 === P4 ? void 0 : P4[g5])) {
                S3 = this.groupCtx.prevY[w5 - L4][g5];
                break;
              }
            }
            for (var M3 = 1; M3 < C4; M3++) {
              var I4, T5;
              if ((null === (I4 = this.groupCtx.prevYVal[w5 - M3]) || void 0 === I4 ? void 0 : I4[g5]) < 0) {
                A4 = this.series[d3][g5] >= 0 ? S3 - m4 + 2 * (this.isReversed ? m4 : 0) : S3;
                break;
              }
              if ((null === (T5 = this.groupCtx.prevYVal[w5 - M3]) || void 0 === T5 ? void 0 : T5[g5]) >= 0) {
                A4 = this.series[d3][g5] >= 0 ? S3 : S3 + m4 - 2 * (this.isReversed ? m4 : 0);
                break;
              }
            }
            void 0 === A4 && (A4 = c4.globals.gridHeight), b4 = null !== (k4 = this.groupCtx.prevYF[0]) && void 0 !== k4 && k4.every((function(t6) {
              return 0 === t6;
            })) && this.groupCtx.prevYF.slice(1, w5).every((function(t6) {
              return t6.every((function(t7) {
                return isNaN(t7);
              }));
            })) ? o3 : A4;
          } else b4 = o3;
          a5 = this.series[d3][g5] ? b4 - this.series[d3][g5] / this.yRatio[p4] + 2 * (this.isReversed ? this.series[d3][g5] / this.yRatio[p4] : 0) : b4;
          var z4 = this.barHelpers.getColumnPaths({ barXPosition: v4, barWidth: r4, y1: b4, y2: a5, yRatio: this.yRatio[p4], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: l4, realIndex: e5.realIndex, i: d3, j: g5, w: c4 });
          return this.barHelpers.barBackground({ bc: u4, j: g5, i: d3, x1: v4, x2: r4, elSeries: h4 }), { pathTo: z4.pathTo, pathFrom: z4.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, o3, d3, g5), barXPosition: v4, x: c4.globals.isXNumeric ? i4 : i4 + s4, y: a5 };
        } }]), a4;
      })();
      var Lt = (function(t4) {
        h3(a4, St);
        var e4 = o2(a4);
        function a4() {
          return i3(this, a4), e4.apply(this, arguments);
        }
        return s3(a4, [{ key: "draw", value: function(t5, e5, i4) {
          var a5 = this, s4 = this.w, r4 = new k3(this.ctx), o3 = s4.globals.comboCharts ? e5 : s4.config.chart.type, n3 = new N3(this.ctx);
          this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s4.config.plotOptions.bar.horizontal;
          var l4 = new A3(this.ctx, s4);
          t5 = l4.getLogSeries(t5), this.series = t5, this.yRatio = l4.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t5);
          for (var h4 = r4.group({ class: "apexcharts-".concat(o3, "-series apexcharts-plot-series") }), c4 = function(e6) {
            a5.isBoxPlot = "boxPlot" === s4.config.chart.type || "boxPlot" === s4.config.series[e6].type;
            var o4, l5, c5, d4, u4 = void 0, f4 = void 0, p4 = [], x5 = [], b4 = s4.globals.comboCharts ? i4[e6] : e6, v4 = a5.barHelpers.getGroupIndex(b4).columnGroupIndex, y4 = r4.group({ class: "apexcharts-series", seriesName: m3.escapeString(s4.globals.seriesNames[b4]), rel: e6 + 1, "data:realIndex": b4 });
            a5.ctx.series.addCollapsedClassToSeries(y4, b4), t5[e6].length > 0 && (a5.visibleI = a5.visibleI + 1);
            var w5, k4, A4 = 0;
            a5.yRatio.length > 1 && (a5.yaxisIndex = s4.globals.seriesYAxisReverseMap[b4][0], A4 = b4);
            var S3 = a5.barHelpers.initialPositions();
            f4 = S3.y, w5 = S3.barHeight, l5 = S3.yDivision, d4 = S3.zeroW, u4 = S3.x, k4 = S3.barWidth, o4 = S3.xDivision, c5 = S3.zeroH, x5.push(u4 + k4 / 2);
            for (var C4 = r4.group({ class: "apexcharts-datalabels", "data:realIndex": b4 }), L4 = function(i5) {
              var r5 = a5.barHelpers.getStrokeWidth(e6, i5, b4), h5 = null, m4 = { indexes: { i: e6, j: i5, realIndex: b4, translationsIndex: A4 }, x: u4, y: f4, strokeWidth: r5, elSeries: y4 };
              h5 = a5.isHorizontal ? a5.drawHorizontalBoxPaths(g4(g4({}, m4), {}, { yDivision: l5, barHeight: w5, zeroW: d4 })) : a5.drawVerticalBoxPaths(g4(g4({}, m4), {}, { xDivision: o4, barWidth: k4, zeroH: c5 })), f4 = h5.y, u4 = h5.x, i5 > 0 && x5.push(u4 + k4 / 2), p4.push(f4), h5.pathTo.forEach((function(o5, l6) {
                var c6 = !a5.isBoxPlot && a5.candlestickOptions.wick.useFillColor ? h5.color[l6] : s4.globals.stroke.colors[e6], d5 = n3.fillPath({ seriesNumber: b4, dataPointIndex: i5, color: h5.color[l6], value: t5[e6][i5] });
                a5.renderSeries({ realIndex: b4, pathFill: d5, lineFill: c6, j: i5, i: e6, pathFrom: h5.pathFrom, pathTo: o5, strokeWidth: r5, elSeries: y4, x: u4, y: f4, series: t5, columnGroupIndex: v4, barHeight: w5, barWidth: k4, elDataLabelsWrap: C4, visibleSeries: a5.visibleI, type: s4.config.chart.type });
              }));
            }, P4 = 0; P4 < s4.globals.dataPoints; P4++) L4(P4);
            s4.globals.seriesXvalues[b4] = x5, s4.globals.seriesYvalues[b4] = p4, h4.add(y4);
          }, d3 = 0; d3 < t5.length; d3++) c4(d3);
          return h4;
        } }, { key: "drawVerticalBoxPaths", value: function(t5) {
          var e5 = t5.indexes, i4 = t5.x;
          t5.y;
          var a5 = t5.xDivision, s4 = t5.barWidth, r4 = t5.zeroH, o3 = t5.strokeWidth, n3 = this.w, l4 = new k3(this.ctx), h4 = e5.i, c4 = e5.j, d3 = true, g5 = n3.config.plotOptions.candlestick.colors.upward, u4 = n3.config.plotOptions.candlestick.colors.downward, f4 = "";
          this.isBoxPlot && (f4 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
          var p4 = this.yRatio[e5.translationsIndex], x5 = e5.realIndex, b4 = this.getOHLCValue(x5, c4), v4 = r4, m4 = r4;
          b4.o > b4.c && (d3 = false);
          var y4 = Math.min(b4.o, b4.c), w5 = Math.max(b4.o, b4.c), A4 = b4.m;
          n3.globals.isXNumeric && (i4 = (n3.globals.seriesX[x5][c4] - n3.globals.minX) / this.xRatio - s4 / 2);
          var S3 = i4 + s4 * this.visibleI;
          void 0 === this.series[h4][c4] || null === this.series[h4][c4] ? (y4 = r4, w5 = r4) : (y4 = r4 - y4 / p4, w5 = r4 - w5 / p4, v4 = r4 - b4.h / p4, m4 = r4 - b4.l / p4, A4 = r4 - b4.m / p4);
          var C4 = l4.move(S3, r4), L4 = l4.move(S3 + s4 / 2, y4);
          return n3.globals.previousPaths.length > 0 && (L4 = this.getPreviousPath(x5, c4, true)), C4 = this.isBoxPlot ? [l4.move(S3, y4) + l4.line(S3 + s4 / 2, y4) + l4.line(S3 + s4 / 2, v4) + l4.line(S3 + s4 / 4, v4) + l4.line(S3 + s4 - s4 / 4, v4) + l4.line(S3 + s4 / 2, v4) + l4.line(S3 + s4 / 2, y4) + l4.line(S3 + s4, y4) + l4.line(S3 + s4, A4) + l4.line(S3, A4) + l4.line(S3, y4 + o3 / 2), l4.move(S3, A4) + l4.line(S3 + s4, A4) + l4.line(S3 + s4, w5) + l4.line(S3 + s4 / 2, w5) + l4.line(S3 + s4 / 2, m4) + l4.line(S3 + s4 - s4 / 4, m4) + l4.line(S3 + s4 / 4, m4) + l4.line(S3 + s4 / 2, m4) + l4.line(S3 + s4 / 2, w5) + l4.line(S3, w5) + l4.line(S3, A4) + "z"] : [l4.move(S3, w5) + l4.line(S3 + s4 / 2, w5) + l4.line(S3 + s4 / 2, v4) + l4.line(S3 + s4 / 2, w5) + l4.line(S3 + s4, w5) + l4.line(S3 + s4, y4) + l4.line(S3 + s4 / 2, y4) + l4.line(S3 + s4 / 2, m4) + l4.line(S3 + s4 / 2, y4) + l4.line(S3, y4) + l4.line(S3, w5 - o3 / 2)], L4 += l4.move(S3, y4), n3.globals.isXNumeric || (i4 += a5), { pathTo: C4, pathFrom: L4, x: i4, y: w5, barXPosition: S3, color: this.isBoxPlot ? f4 : d3 ? [g5] : [u4] };
        } }, { key: "drawHorizontalBoxPaths", value: function(t5) {
          var e5 = t5.indexes;
          t5.x;
          var i4 = t5.y, a5 = t5.yDivision, s4 = t5.barHeight, r4 = t5.zeroW, o3 = t5.strokeWidth, n3 = this.w, l4 = new k3(this.ctx), h4 = e5.i, c4 = e5.j, d3 = this.boxOptions.colors.lower;
          this.isBoxPlot && (d3 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
          var g5 = this.invertedYRatio, u4 = e5.realIndex, f4 = this.getOHLCValue(u4, c4), p4 = r4, x5 = r4, b4 = Math.min(f4.o, f4.c), v4 = Math.max(f4.o, f4.c), m4 = f4.m;
          n3.globals.isXNumeric && (i4 = (n3.globals.seriesX[u4][c4] - n3.globals.minX) / this.invertedXRatio - s4 / 2);
          var y4 = i4 + s4 * this.visibleI;
          void 0 === this.series[h4][c4] || null === this.series[h4][c4] ? (b4 = r4, v4 = r4) : (b4 = r4 + b4 / g5, v4 = r4 + v4 / g5, p4 = r4 + f4.h / g5, x5 = r4 + f4.l / g5, m4 = r4 + f4.m / g5);
          var w5 = l4.move(r4, y4), A4 = l4.move(b4, y4 + s4 / 2);
          return n3.globals.previousPaths.length > 0 && (A4 = this.getPreviousPath(u4, c4, true)), w5 = [l4.move(b4, y4) + l4.line(b4, y4 + s4 / 2) + l4.line(p4, y4 + s4 / 2) + l4.line(p4, y4 + s4 / 2 - s4 / 4) + l4.line(p4, y4 + s4 / 2 + s4 / 4) + l4.line(p4, y4 + s4 / 2) + l4.line(b4, y4 + s4 / 2) + l4.line(b4, y4 + s4) + l4.line(m4, y4 + s4) + l4.line(m4, y4) + l4.line(b4 + o3 / 2, y4), l4.move(m4, y4) + l4.line(m4, y4 + s4) + l4.line(v4, y4 + s4) + l4.line(v4, y4 + s4 / 2) + l4.line(x5, y4 + s4 / 2) + l4.line(x5, y4 + s4 - s4 / 4) + l4.line(x5, y4 + s4 / 4) + l4.line(x5, y4 + s4 / 2) + l4.line(v4, y4 + s4 / 2) + l4.line(v4, y4) + l4.line(m4, y4) + "z"], A4 += l4.move(b4, y4), n3.globals.isXNumeric || (i4 += a5), { pathTo: w5, pathFrom: A4, x: v4, y: i4, barYPosition: y4, color: d3 };
        } }, { key: "getOHLCValue", value: function(t5, e5) {
          var i4 = this.w;
          return { o: this.isBoxPlot ? i4.globals.seriesCandleH[t5][e5] : i4.globals.seriesCandleO[t5][e5], h: this.isBoxPlot ? i4.globals.seriesCandleO[t5][e5] : i4.globals.seriesCandleH[t5][e5], m: i4.globals.seriesCandleM[t5][e5], l: this.isBoxPlot ? i4.globals.seriesCandleC[t5][e5] : i4.globals.seriesCandleL[t5][e5], c: this.isBoxPlot ? i4.globals.seriesCandleL[t5][e5] : i4.globals.seriesCandleC[t5][e5] };
        } }]), a4;
      })();
      var Pt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "checkColorRange", value: function() {
          var t5 = this.w, e4 = false, i4 = t5.config.plotOptions[t5.config.chart.type];
          return i4.colorScale.ranges.length > 0 && i4.colorScale.ranges.map((function(t6, i5) {
            t6.from <= 0 && (e4 = true);
          })), e4;
        } }, { key: "getShadeColor", value: function(t5, e4, i4, a4) {
          var s4 = this.w, r4 = 1, o3 = s4.config.plotOptions[t5].shadeIntensity, n3 = this.determineColor(t5, e4, i4);
          s4.globals.hasNegs || a4 ? r4 = s4.config.plotOptions[t5].reverseNegativeShade ? n3.percent < 0 ? n3.percent / 100 * (1.25 * o3) : (1 - n3.percent / 100) * (1.25 * o3) : n3.percent <= 0 ? 1 - (1 + n3.percent / 100) * o3 : (1 - n3.percent / 100) * o3 : (r4 = 1 - n3.percent / 100, "treemap" === t5 && (r4 = (1 - n3.percent / 100) * (1.25 * o3)));
          var l4 = n3.color, h4 = new m3();
          if (s4.config.plotOptions[t5].enableShades) if ("dark" === this.w.config.theme.mode) {
            var c4 = h4.shadeColor(-1 * r4, n3.color);
            l4 = m3.hexToRgba(m3.isColorHex(c4) ? c4 : m3.rgb2hex(c4), s4.config.fill.opacity);
          } else {
            var d3 = h4.shadeColor(r4, n3.color);
            l4 = m3.hexToRgba(m3.isColorHex(d3) ? d3 : m3.rgb2hex(d3), s4.config.fill.opacity);
          }
          return { color: l4, colorProps: n3 };
        } }, { key: "determineColor", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = a4.globals.series[e4][i4], r4 = a4.config.plotOptions[t5], o3 = r4.colorScale.inverse ? i4 : e4;
          r4.distributed && "treemap" === a4.config.chart.type && (o3 = i4);
          var n3 = a4.globals.colors[o3], l4 = null, h4 = Math.min.apply(Math, p3(a4.globals.series[e4])), c4 = Math.max.apply(Math, p3(a4.globals.series[e4]));
          r4.distributed || "heatmap" !== t5 || (h4 = a4.globals.minY, c4 = a4.globals.maxY), void 0 !== r4.colorScale.min && (h4 = r4.colorScale.min < a4.globals.minY ? r4.colorScale.min : a4.globals.minY, c4 = r4.colorScale.max > a4.globals.maxY ? r4.colorScale.max : a4.globals.maxY);
          var d3 = Math.abs(c4) + Math.abs(h4), g5 = 100 * s4 / (0 === d3 ? d3 - 1e-6 : d3);
          r4.colorScale.ranges.length > 0 && r4.colorScale.ranges.map((function(t6, e5) {
            if (s4 >= t6.from && s4 <= t6.to) {
              n3 = t6.color, l4 = t6.foreColor ? t6.foreColor : null, h4 = t6.from, c4 = t6.to;
              var i5 = Math.abs(c4) + Math.abs(h4);
              g5 = 100 * s4 / (0 === i5 ? i5 - 1e-6 : i5);
            }
          }));
          return { color: n3, foreColor: l4, percent: g5 };
        } }, { key: "calculateDataLabels", value: function(t5) {
          var e4 = t5.text, i4 = t5.x, a4 = t5.y, s4 = t5.i, r4 = t5.j, o3 = t5.colorProps, n3 = t5.fontSize, l4 = this.w.config.dataLabels, h4 = new k3(this.ctx), c4 = new G3(this.ctx), d3 = null;
          if (l4.enabled) {
            d3 = h4.group({ class: "apexcharts-data-labels" });
            var g5 = l4.offsetX, u4 = l4.offsetY, f4 = i4 + g5, p4 = a4 + parseFloat(l4.style.fontSize) / 3 + u4;
            c4.plotDataLabelsText({ x: f4, y: p4, text: e4, i: s4, j: r4, color: o3.foreColor, parent: d3, fontSize: n3, dataLabelsConfig: l4 });
          }
          return d3;
        } }, { key: "addListeners", value: function(t5) {
          var e4 = new k3(this.ctx);
          t5.node.addEventListener("mouseenter", e4.pathMouseEnter.bind(this, t5)), t5.node.addEventListener("mouseleave", e4.pathMouseLeave.bind(this, t5)), t5.node.addEventListener("mousedown", e4.pathMouseDown.bind(this, t5));
        } }]), t4;
      })();
      var Mt = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.xRatio = a4.xRatio, this.yRatio = a4.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Pt(e4), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
        }
        return s3(t4, [{ key: "draw", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a4 = i4.group({ class: "apexcharts-heatmap" });
          a4.attr("clip-path", "url(#gridRectMask".concat(e4.globals.cuid, ")"));
          var s4 = e4.globals.gridWidth / e4.globals.dataPoints, r4 = e4.globals.gridHeight / e4.globals.series.length, o3 = 0, n3 = false;
          this.negRange = this.helpers.checkColorRange();
          var l4 = t5.slice();
          e4.config.yaxis[0].reversed && (n3 = true, l4.reverse());
          for (var h4 = n3 ? 0 : l4.length - 1; n3 ? h4 < l4.length : h4 >= 0; n3 ? h4++ : h4--) {
            var c4 = i4.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: m3.escapeString(e4.globals.seriesNames[h4]), rel: h4 + 1, "data:realIndex": h4 });
            if (this.ctx.series.addCollapsedClassToSeries(c4, h4), e4.config.chart.dropShadow.enabled) {
              var d3 = e4.config.chart.dropShadow;
              new w4(this.ctx).dropShadow(c4, d3, h4);
            }
            for (var g5 = 0, u4 = e4.config.plotOptions.heatmap.shadeIntensity, f4 = 0; f4 < l4[h4].length; f4++) {
              var p4 = this.helpers.getShadeColor(e4.config.chart.type, h4, f4, this.negRange), x5 = p4.color, b4 = p4.colorProps;
              if ("image" === e4.config.fill.type) x5 = new N3(this.ctx).fillPath({ seriesNumber: h4, dataPointIndex: f4, opacity: e4.globals.hasNegs ? b4.percent < 0 ? 1 - (1 + b4.percent / 100) : u4 + b4.percent / 100 : b4.percent / 100, patternID: m3.randomId(), width: e4.config.fill.image.width ? e4.config.fill.image.width : s4, height: e4.config.fill.image.height ? e4.config.fill.image.height : r4 });
              var v4 = this.rectRadius, y4 = i4.drawRect(g5, o3, s4, r4, v4);
              if (y4.attr({ cx: g5, cy: o3 }), y4.node.classList.add("apexcharts-heatmap-rect"), c4.add(y4), y4.attr({ fill: x5, i: h4, index: h4, j: f4, val: t5[h4][f4], "stroke-width": this.strokeWidth, stroke: e4.config.plotOptions.heatmap.useFillColorAsStroke ? x5 : e4.globals.stroke.colors[0], color: x5 }), this.helpers.addListeners(y4), e4.config.chart.animations.enabled && !e4.globals.dataChanged) {
                var A4 = 1;
                e4.globals.resized || (A4 = e4.config.chart.animations.speed), this.animateHeatMap(y4, g5, o3, s4, r4, A4);
              }
              if (e4.globals.dataChanged) {
                var S3 = 1;
                if (this.dynamicAnim.enabled && e4.globals.shouldAnimate) {
                  S3 = this.dynamicAnim.speed;
                  var C4 = e4.globals.previousPaths[h4] && e4.globals.previousPaths[h4][f4] && e4.globals.previousPaths[h4][f4].color;
                  C4 || (C4 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(y4, m3.isColorHex(C4) ? C4 : m3.rgb2hex(C4), m3.isColorHex(x5) ? x5 : m3.rgb2hex(x5), S3);
                }
              }
              var L4 = (0, e4.config.dataLabels.formatter)(e4.globals.series[h4][f4], { value: e4.globals.series[h4][f4], seriesIndex: h4, dataPointIndex: f4, w: e4 }), P4 = this.helpers.calculateDataLabels({ text: L4, x: g5 + s4 / 2, y: o3 + r4 / 2, i: h4, j: f4, colorProps: b4, series: l4 });
              null !== P4 && c4.add(P4), g5 += s4;
            }
            o3 += r4, a4.add(c4);
          }
          var M3 = e4.globals.yAxisScale[0].result.slice();
          return e4.config.yaxis[0].reversed ? M3.unshift("") : M3.push(""), e4.globals.yAxisScale[0].result = M3, a4;
        } }, { key: "animateHeatMap", value: function(t5, e4, i4, a4, s4, r4) {
          var o3 = new y3(this.ctx);
          o3.animateRect(t5, { x: e4 + a4 / 2, y: i4 + s4 / 2, width: 0, height: 0 }, { x: e4, y: i4, width: a4, height: s4 }, r4, (function() {
            o3.animationCompleted(t5);
          }));
        } }, { key: "animateHeatColor", value: function(t5, e4, i4, a4) {
          t5.attr({ fill: e4 }).animate(a4).attr({ fill: i4 });
        } }]), t4;
      })();
      var It = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "drawYAxisTexts", value: function(t5, e4, i4, a4) {
          var s4 = this.w, r4 = s4.config.yaxis[0], o3 = s4.globals.yLabelFormatters[0];
          return new k3(this.ctx).drawText({ x: t5 + r4.labels.offsetX, y: e4 + r4.labels.offsetY, text: o3(a4, i4), textAnchor: "middle", fontSize: r4.labels.style.fontSize, fontFamily: r4.labels.style.fontFamily, foreColor: Array.isArray(r4.labels.style.colors) ? r4.labels.style.colors[i4] : r4.labels.style.colors });
        } }]), t4;
      })();
      var Tt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
          var a4 = this.w;
          this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a4.globals.stroke.colors ? a4.globals.stroke.colors : a4.globals.colors, this.defaultSize = Math.min(a4.globals.gridWidth, a4.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a4.globals.gridWidth / 2, "radialBar" === a4.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a4.config.plotOptions.pie.endAngle - a4.config.plotOptions.pie.startAngle), this.initialAngle = a4.config.plotOptions.pie.startAngle % this.fullAngle, a4.globals.radialSize = this.defaultSize / 2.05 - a4.config.stroke.width - (a4.config.chart.sparkline.enabled ? 0 : a4.config.chart.dropShadow.blur), this.donutSize = a4.globals.radialSize * parseInt(a4.config.plotOptions.pie.donut.size, 10) / 100;
          var s4 = a4.config.plotOptions.pie.customScale, r4 = a4.globals.gridWidth / 2, o3 = a4.globals.gridHeight / 2;
          this.translateX = r4 - r4 * s4, this.translateY = o3 - o3 * s4, this.dataLabelsGroup = new k3(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s4, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
        }
        return s3(t4, [{ key: "draw", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = new k3(this.ctx), s4 = a4.group({ class: "apexcharts-pie" });
          if (i4.globals.noData) return s4;
          for (var r4 = 0, o3 = 0; o3 < t5.length; o3++) r4 += m3.negToZero(t5[o3]);
          var n3 = [], l4 = a4.group();
          0 === r4 && (r4 = 1e-5), t5.forEach((function(t6) {
            e4.maxY = Math.max(e4.maxY, t6);
          })), i4.config.yaxis[0].max && (this.maxY = i4.config.yaxis[0].max), "back" === i4.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s4);
          for (var h4 = 0; h4 < t5.length; h4++) {
            var c4 = this.fullAngle * m3.negToZero(t5[h4]) / r4;
            n3.push(c4), "polarArea" === this.chartType ? (n3[h4] = this.fullAngle / t5.length, this.sliceSizes.push(i4.globals.radialSize * t5[h4] / this.maxY)) : this.sliceSizes.push(i4.globals.radialSize);
          }
          if (i4.globals.dataChanged) {
            for (var d3, g5 = 0, u4 = 0; u4 < i4.globals.previousPaths.length; u4++) g5 += m3.negToZero(i4.globals.previousPaths[u4]);
            for (var f4 = 0; f4 < i4.globals.previousPaths.length; f4++) d3 = this.fullAngle * m3.negToZero(i4.globals.previousPaths[f4]) / g5, this.prevSectorAngleArr.push(d3);
          }
          if (this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType) {
            var p4 = a4.drawCircle(this.donutSize);
            p4.attr({ cx: this.centerX, cy: this.centerY, fill: i4.config.plotOptions.pie.donut.background ? i4.config.plotOptions.pie.donut.background : "transparent" }), l4.add(p4);
          }
          var x5 = this.drawArcs(n3, t5);
          if (this.sliceLabels.forEach((function(t6) {
            x5.add(t6);
          })), l4.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i4.config.plotOptions.pie.customScale, ")") }), l4.add(x5), s4.add(l4), this.donutDataLabels.show) {
            var b4 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
            s4.add(b4);
          }
          return "front" === i4.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s4), s4;
        } }, { key: "drawArcs", value: function(t5, e4) {
          var i4 = this.w, a4 = new w4(this.ctx), s4 = new k3(this.ctx), r4 = new N3(this.ctx), o3 = s4.group({ class: "apexcharts-slices" }), n3 = this.initialAngle, l4 = this.initialAngle, h4 = this.initialAngle, c4 = this.initialAngle;
          this.strokeWidth = i4.config.stroke.show ? i4.config.stroke.width : 0;
          for (var d3 = 0; d3 < t5.length; d3++) {
            var g5 = s4.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: m3.escapeString(i4.globals.seriesNames[d3]), rel: d3 + 1, "data:realIndex": d3 });
            o3.add(g5), l4 = c4, h4 = (n3 = h4) + t5[d3], c4 = l4 + this.prevSectorAngleArr[d3];
            var u4 = h4 < n3 ? this.fullAngle + h4 - n3 : h4 - n3, f4 = r4.fillPath({ seriesNumber: d3, size: this.sliceSizes[d3], value: e4[d3] }), p4 = this.getChangedPath(l4, c4), x5 = s4.drawPath({ d: p4, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d3] : this.lineColorArr, strokeWidth: 0, fill: f4, fillOpacity: i4.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d3) });
            if (x5.attr({ index: 0, j: d3 }), a4.setSelectionFilter(x5, 0, d3), i4.config.chart.dropShadow.enabled) {
              var b4 = i4.config.chart.dropShadow;
              a4.dropShadow(x5, b4, d3);
            }
            this.addListeners(x5, this.donutDataLabels), k3.setAttrs(x5.node, { "data:angle": u4, "data:startAngle": n3, "data:strokeWidth": this.strokeWidth, "data:value": e4[d3] });
            var v4 = { x: 0, y: 0 };
            "pie" === this.chartType || "polarArea" === this.chartType ? v4 = m3.polarToCartesian(this.centerX, this.centerY, i4.globals.radialSize / 1.25 + i4.config.plotOptions.pie.dataLabels.offset, (n3 + u4 / 2) % this.fullAngle) : "donut" === this.chartType && (v4 = m3.polarToCartesian(this.centerX, this.centerY, (i4.globals.radialSize + this.donutSize) / 2 + i4.config.plotOptions.pie.dataLabels.offset, (n3 + u4 / 2) % this.fullAngle)), g5.add(x5);
            var y4 = 0;
            if (!this.initialAnim || i4.globals.resized || i4.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (y4 = u4 / this.fullAngle * i4.config.chart.animations.speed) && (y4 = 1), this.animDur = y4 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i4.globals.dataChanged ? this.animatePaths(x5, { size: this.sliceSizes[d3], endAngle: h4, startAngle: n3, prevStartAngle: l4, prevEndAngle: c4, animateStartingPos: true, i: d3, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i4.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(x5, { size: this.sliceSizes[d3], endAngle: h4, startAngle: n3, i: d3, totalItems: t5.length - 1, animBeginArr: this.animBeginArr, dur: y4 }), i4.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && x5.node.addEventListener("mouseup", this.pieClicked.bind(this, d3)), void 0 !== i4.globals.selectedDataPoints[0] && i4.globals.selectedDataPoints[0].indexOf(d3) > -1 && this.pieClicked(d3), i4.config.dataLabels.enabled) {
              var A4 = v4.x, S3 = v4.y, C4 = 100 * u4 / this.fullAngle + "%";
              if (0 !== u4 && i4.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t5[d3]) {
                var L4 = i4.config.dataLabels.formatter;
                void 0 !== L4 && (C4 = L4(i4.globals.seriesPercent[d3][0], { seriesIndex: d3, w: i4 }));
                var P4 = i4.globals.dataLabels.style.colors[d3], M3 = s4.group({ class: "apexcharts-datalabels" }), I4 = s4.drawText({ x: A4, y: S3, text: C4, textAnchor: "middle", fontSize: i4.config.dataLabels.style.fontSize, fontFamily: i4.config.dataLabels.style.fontFamily, fontWeight: i4.config.dataLabels.style.fontWeight, foreColor: P4 });
                if (M3.add(I4), i4.config.dataLabels.dropShadow.enabled) {
                  var T5 = i4.config.dataLabels.dropShadow;
                  a4.dropShadow(I4, T5);
                }
                I4.node.classList.add("apexcharts-pie-label"), i4.config.chart.animations.animate && false === i4.globals.resized && (I4.node.classList.add("apexcharts-pie-label-delay"), I4.node.style.animationDelay = i4.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(M3);
              }
            }
          }
          return o3;
        } }, { key: "addListeners", value: function(t5, e4) {
          var i4 = new k3(this.ctx);
          t5.node.addEventListener("mouseenter", i4.pathMouseEnter.bind(this, t5)), t5.node.addEventListener("mouseleave", i4.pathMouseLeave.bind(this, t5)), t5.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t5.node, e4)), t5.node.addEventListener("mousedown", i4.pathMouseDown.bind(this, t5)), this.donutDataLabels.total.showAlways || (t5.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t5.node, e4)), t5.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t5.node, e4)));
        } }, { key: "animatePaths", value: function(t5, e4) {
          var i4 = this.w, a4 = e4.endAngle < e4.startAngle ? this.fullAngle + e4.endAngle - e4.startAngle : e4.endAngle - e4.startAngle, s4 = a4, r4 = e4.startAngle, o3 = e4.startAngle;
          void 0 !== e4.prevStartAngle && void 0 !== e4.prevEndAngle && (r4 = e4.prevEndAngle, s4 = e4.prevEndAngle < e4.prevStartAngle ? this.fullAngle + e4.prevEndAngle - e4.prevStartAngle : e4.prevEndAngle - e4.prevStartAngle), e4.i === i4.config.series.length - 1 && (a4 + o3 > this.fullAngle ? e4.endAngle = e4.endAngle - (a4 + o3) : a4 + o3 < this.fullAngle && (e4.endAngle = e4.endAngle + (this.fullAngle - (a4 + o3)))), a4 === this.fullAngle && (a4 = this.fullAngle - 0.01), this.animateArc(t5, r4, o3, a4, s4, e4);
        } }, { key: "animateArc", value: function(t5, e4, i4, a4, s4, r4) {
          var o3, n3 = this, l4 = this.w, h4 = new y3(this.ctx), c4 = r4.size;
          (isNaN(e4) || isNaN(s4)) && (e4 = i4, s4 = a4, r4.dur = 0);
          var d3 = a4, g5 = i4, u4 = e4 < i4 ? this.fullAngle + e4 - i4 : e4 - i4;
          l4.globals.dataChanged && r4.shouldSetPrevPaths && r4.prevEndAngle && (o3 = n3.getPiePath({ me: n3, startAngle: r4.prevStartAngle, angle: r4.prevEndAngle < r4.prevStartAngle ? this.fullAngle + r4.prevEndAngle - r4.prevStartAngle : r4.prevEndAngle - r4.prevStartAngle, size: c4 }), t5.attr({ d: o3 })), 0 !== r4.dur ? t5.animate(r4.dur, l4.globals.easing, r4.animBeginArr[r4.i]).afterAll((function() {
            "pie" !== n3.chartType && "donut" !== n3.chartType && "polarArea" !== n3.chartType || this.animate(l4.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": n3.strokeWidth }), r4.i === l4.config.series.length - 1 && h4.animationCompleted(t5);
          })).during((function(l5) {
            d3 = u4 + (a4 - u4) * l5, r4.animateStartingPos && (d3 = s4 + (a4 - s4) * l5, g5 = e4 - s4 + (i4 - (e4 - s4)) * l5), o3 = n3.getPiePath({ me: n3, startAngle: g5, angle: d3, size: c4 }), t5.node.setAttribute("data:pathOrig", o3), t5.attr({ d: o3 });
          })) : (o3 = n3.getPiePath({ me: n3, startAngle: g5, angle: a4, size: c4 }), r4.isTrack || (l4.globals.animationEnded = true), t5.node.setAttribute("data:pathOrig", o3), t5.attr({ d: o3, "stroke-width": n3.strokeWidth }));
        } }, { key: "pieClicked", value: function(t5) {
          var e4, i4 = this.w, a4 = this, s4 = a4.sliceSizes[t5] + (i4.config.plotOptions.pie.expandOnClick ? 4 : 0), r4 = i4.globals.dom.Paper.select(".apexcharts-".concat(a4.chartType.toLowerCase(), "-slice-").concat(t5)).members[0];
          if ("true" !== r4.attr("data:pieClicked")) {
            var o3 = i4.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
            Array.prototype.forEach.call(o3, (function(t6) {
              t6.setAttribute("data:pieClicked", "false");
              var e5 = t6.getAttribute("data:pathOrig");
              e5 && t6.setAttribute("d", e5);
            })), i4.globals.capturedDataPointIndex = t5, r4.attr("data:pieClicked", "true");
            var n3 = parseInt(r4.attr("data:startAngle"), 10), l4 = parseInt(r4.attr("data:angle"), 10);
            e4 = a4.getPiePath({ me: a4, startAngle: n3, angle: l4, size: s4 }), 360 !== l4 && r4.plot(e4);
          } else {
            r4.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r4.node, this.donutDataLabels);
            var h4 = r4.attr("data:pathOrig");
            r4.attr({ d: h4 });
          }
        } }, { key: "getChangedPath", value: function(t5, e4) {
          var i4 = "";
          return this.dynamicAnim && this.w.globals.dataChanged && (i4 = this.getPiePath({ me: this, startAngle: t5, angle: e4 - t5, size: this.size })), i4;
        } }, { key: "getPiePath", value: function(t5) {
          var e4, i4 = t5.me, a4 = t5.startAngle, s4 = t5.angle, r4 = t5.size, o3 = new k3(this.ctx), n3 = a4, l4 = Math.PI * (n3 - 90) / 180, h4 = s4 + a4;
          Math.ceil(h4) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h4 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h4) > this.fullAngle && (h4 -= this.fullAngle);
          var c4 = Math.PI * (h4 - 90) / 180, d3 = i4.centerX + r4 * Math.cos(l4), g5 = i4.centerY + r4 * Math.sin(l4), u4 = i4.centerX + r4 * Math.cos(c4), f4 = i4.centerY + r4 * Math.sin(c4), p4 = m3.polarToCartesian(i4.centerX, i4.centerY, i4.donutSize, h4), x5 = m3.polarToCartesian(i4.centerX, i4.centerY, i4.donutSize, n3), b4 = s4 > 180 ? 1 : 0, v4 = ["M", d3, g5, "A", r4, r4, 0, b4, 1, u4, f4];
          return e4 = "donut" === i4.chartType ? [].concat(v4, ["L", p4.x, p4.y, "A", i4.donutSize, i4.donutSize, 0, b4, 0, x5.x, x5.y, "L", d3, g5, "z"]).join(" ") : "pie" === i4.chartType || "polarArea" === i4.chartType ? [].concat(v4, ["L", i4.centerX, i4.centerY, "L", d3, g5]).join(" ") : [].concat(v4).join(" "), o3.roundPathCorners(e4, 2 * this.strokeWidth);
        } }, { key: "drawPolarElements", value: function(t5) {
          var e4 = this.w, i4 = new $3(this.ctx), a4 = new k3(this.ctx), s4 = new It(this.ctx), r4 = a4.group(), o3 = a4.group(), n3 = i4.niceScale(0, Math.ceil(this.maxY), 0), l4 = n3.result.reverse(), h4 = n3.result.length;
          this.maxY = n3.niceMax;
          for (var c4 = e4.globals.radialSize, d3 = c4 / (h4 - 1), g5 = 0; g5 < h4 - 1; g5++) {
            var u4 = a4.drawCircle(c4);
            if (u4.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e4.config.plotOptions.polarArea.rings.strokeWidth, stroke: e4.config.plotOptions.polarArea.rings.strokeColor }), e4.config.yaxis[0].show) {
              var f4 = s4.drawYAxisTexts(this.centerX, this.centerY - c4 + parseInt(e4.config.yaxis[0].labels.style.fontSize, 10) / 2, g5, l4[g5]);
              o3.add(f4);
            }
            r4.add(u4), c4 -= d3;
          }
          this.drawSpokes(t5), t5.add(r4), t5.add(o3);
        } }, { key: "renderInnerDataLabels", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = new k3(this.ctx), r4 = e4.total.show;
          t5.node.innerHTML = "", t5.node.style.opacity = i4.opacity;
          var o3, n3, l4 = i4.centerX, h4 = this.donutDataLabels.total.label ? i4.centerY : i4.centerY - i4.centerY / 6;
          o3 = void 0 === e4.name.color ? a4.globals.colors[0] : e4.name.color;
          var c4 = e4.name.fontSize, d3 = e4.name.fontFamily, g5 = e4.name.fontWeight;
          n3 = void 0 === e4.value.color ? a4.config.chart.foreColor : e4.value.color;
          var u4 = e4.value.formatter, f4 = "", p4 = "";
          if (r4 ? (o3 = e4.total.color, c4 = e4.total.fontSize, d3 = e4.total.fontFamily, g5 = e4.total.fontWeight, p4 = this.donutDataLabels.total.label ? e4.total.label : "", f4 = e4.total.formatter(a4)) : 1 === a4.globals.series.length && (f4 = u4(a4.globals.series[0], a4), p4 = a4.globals.seriesNames[0]), p4 && (p4 = e4.name.formatter(p4, e4.total.show, a4)), e4.name.show) {
            var x5 = s4.drawText({ x: l4, y: h4 + parseFloat(e4.name.offsetY), text: p4, textAnchor: "middle", foreColor: o3, fontSize: c4, fontWeight: g5, fontFamily: d3 });
            x5.node.classList.add("apexcharts-datalabel-label"), t5.add(x5);
          }
          if (e4.value.show) {
            var b4 = e4.name.show ? parseFloat(e4.value.offsetY) + 16 : e4.value.offsetY, v4 = s4.drawText({ x: l4, y: h4 + b4, text: f4, textAnchor: "middle", foreColor: n3, fontWeight: e4.value.fontWeight, fontSize: e4.value.fontSize, fontFamily: e4.value.fontFamily });
            v4.node.classList.add("apexcharts-datalabel-value"), t5.add(v4);
          }
          return t5;
        } }, { key: "printInnerLabels", value: function(t5, e4, i4, a4) {
          var s4, r4 = this.w;
          a4 ? s4 = void 0 === t5.name.color ? r4.globals.colors[parseInt(a4.parentNode.getAttribute("rel"), 10) - 1] : t5.name.color : r4.globals.series.length > 1 && t5.total.show && (s4 = t5.total.color);
          var o3 = r4.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n3 = r4.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
          i4 = (0, t5.value.formatter)(i4, r4), a4 || "function" != typeof t5.total.formatter || (i4 = t5.total.formatter(r4));
          var l4 = e4 === t5.total.label;
          e4 = this.donutDataLabels.total.label ? t5.name.formatter(e4, l4, r4) : "", null !== o3 && (o3.textContent = e4), null !== n3 && (n3.textContent = i4), null !== o3 && (o3.style.fill = s4);
        } }, { key: "printDataLabelsInner", value: function(t5, e4) {
          var i4 = this.w, a4 = t5.getAttribute("data:value"), s4 = i4.globals.seriesNames[parseInt(t5.parentNode.getAttribute("rel"), 10) - 1];
          i4.globals.series.length > 1 && this.printInnerLabels(e4, s4, a4, t5);
          var r4 = i4.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
          null !== r4 && (r4.style.opacity = 1);
        } }, { key: "drawSpokes", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = new k3(this.ctx), s4 = i4.config.plotOptions.polarArea.spokes;
          if (0 !== s4.strokeWidth) {
            for (var r4 = [], o3 = 360 / i4.globals.series.length, n3 = 0; n3 < i4.globals.series.length; n3++) r4.push(m3.polarToCartesian(this.centerX, this.centerY, i4.globals.radialSize, i4.config.plotOptions.pie.startAngle + o3 * n3));
            r4.forEach((function(i5, r5) {
              var o4 = a4.drawLine(i5.x, i5.y, e4.centerX, e4.centerY, Array.isArray(s4.connectorColors) ? s4.connectorColors[r5] : s4.connectorColors);
              t5.add(o4);
            }));
          }
        } }, { key: "revertDataLabelsInner", value: function() {
          var t5 = this.w;
          if (this.donutDataLabels.show) {
            var e4 = t5.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0], i4 = this.renderInnerDataLabels(e4, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
            t5.globals.dom.Paper.select(".apexcharts-radialbar, .apexcharts-pie").members[0].add(i4);
          }
        } }]), t4;
      })();
      var zt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
          var a4 = this.w;
          this.graphics = new k3(this.ctx), this.lineColorArr = void 0 !== a4.globals.stroke.colors ? a4.globals.stroke.colors : a4.globals.colors, this.defaultSize = a4.globals.svgHeight < a4.globals.svgWidth ? a4.globals.gridHeight : a4.globals.gridWidth, this.isLog = a4.config.yaxis[0].logarithmic, this.logBase = a4.config.yaxis[0].logBase, this.coreUtils = new A3(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, a4.globals.maxY, 0) : a4.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : a4.globals.minY, this.polygons = a4.config.plotOptions.radar.polygons, this.strokeWidth = a4.config.stroke.show ? a4.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a4.config.chart.dropShadow.blur, a4.config.xaxis.labels.show && (this.size = this.size - a4.globals.xAxisLabelsWidth / 1.75), void 0 !== a4.config.plotOptions.radar.size && (this.size = a4.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
        }
        return s3(t4, [{ key: "draw", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = new N3(this.ctx), s4 = [], r4 = new G3(this.ctx);
          t5.length && (this.dataPointsLen = t5[i4.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
          var o3 = i4.globals.gridWidth / 2, n3 = i4.globals.gridHeight / 2, l4 = o3 + i4.config.plotOptions.radar.offsetX, h4 = n3 + i4.config.plotOptions.radar.offsetY, c4 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(l4 || 0, ", ").concat(h4 || 0, ")") }), d3 = [], u4 = null, f4 = null;
          if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t5.forEach((function(t6, o4) {
            var n4 = t6.length === i4.globals.dataPoints, l5 = e4.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": n4, seriesName: m3.escapeString(i4.globals.seriesNames[o4]), rel: o4 + 1, "data:realIndex": o4 });
            e4.dataRadiusOfPercent[o4] = [], e4.dataRadius[o4] = [], e4.angleArr[o4] = [], t6.forEach((function(t7, i5) {
              var a5 = Math.abs(e4.maxValue - e4.minValue);
              t7 -= e4.minValue, e4.isLog && (t7 = e4.coreUtils.getLogVal(e4.logBase, t7, 0)), e4.dataRadiusOfPercent[o4][i5] = t7 / a5, e4.dataRadius[o4][i5] = e4.dataRadiusOfPercent[o4][i5] * e4.size, e4.angleArr[o4][i5] = i5 * e4.disAngle;
            })), d3 = e4.getDataPointsPos(e4.dataRadius[o4], e4.angleArr[o4]);
            var h5 = e4.createPaths(d3, { x: 0, y: 0 });
            u4 = e4.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), f4 = e4.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": o4 }), i4.globals.delayedElements.push({ el: u4.node, index: o4 });
            var c5 = { i: o4, realIndex: o4, animationDelay: o4, initialSpeed: i4.config.chart.animations.speed, dataChangeSpeed: i4.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i4.globals.stroke.colors[o4], strokeLineCap: i4.config.stroke.lineCap }, p5 = null;
            i4.globals.previousPaths.length > 0 && (p5 = e4.getPreviousPath(o4));
            for (var x5 = 0; x5 < h5.linePathsTo.length; x5++) {
              var b4 = e4.graphics.renderPaths(g4(g4({}, c5), {}, { pathFrom: null === p5 ? h5.linePathsFrom[x5] : p5, pathTo: h5.linePathsTo[x5], strokeWidth: Array.isArray(e4.strokeWidth) ? e4.strokeWidth[o4] : e4.strokeWidth, fill: "none", drawShadow: false }));
              l5.add(b4);
              var v4 = a4.fillPath({ seriesNumber: o4 }), y4 = e4.graphics.renderPaths(g4(g4({}, c5), {}, { pathFrom: null === p5 ? h5.areaPathsFrom[x5] : p5, pathTo: h5.areaPathsTo[x5], strokeWidth: 0, fill: v4, drawShadow: false }));
              if (i4.config.chart.dropShadow.enabled) {
                var k4 = new w4(e4.ctx), A4 = i4.config.chart.dropShadow;
                k4.dropShadow(y4, Object.assign({}, A4, { noUserSpaceOnUse: true }), o4);
              }
              l5.add(y4);
            }
            t6.forEach((function(t7, a5) {
              var s5 = new W2(e4.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: o4, dataPointIndex: a5 }), n5 = e4.graphics.drawMarker(d3[a5].x, d3[a5].y, s5);
              n5.attr("rel", a5), n5.attr("j", a5), n5.attr("index", o4), n5.node.setAttribute("default-marker-size", s5.pSize);
              var h6 = e4.graphics.group({ class: "apexcharts-series-markers" });
              h6 && h6.add(n5), u4.add(h6), l5.add(u4);
              var c6 = i4.config.dataLabels;
              if (c6.enabled) {
                var p6 = c6.formatter(i4.globals.series[o4][a5], { seriesIndex: o4, dataPointIndex: a5, w: i4 });
                r4.plotDataLabelsText({ x: d3[a5].x, y: d3[a5].y, text: p6, textAnchor: "middle", i: o4, j: o4, parent: f4, offsetCorrection: false, dataLabelsConfig: g4({}, c6) });
              }
              l5.add(f4);
            })), s4.push(l5);
          })), this.drawPolygons({ parent: c4 }), i4.config.xaxis.labels.show) {
            var p4 = this.drawXAxisTexts();
            c4.add(p4);
          }
          return s4.forEach((function(t6) {
            c4.add(t6);
          })), c4.add(this.yaxisLabels), c4;
        } }, { key: "drawPolygons", value: function(t5) {
          for (var e4 = this, i4 = this.w, a4 = t5.parent, s4 = new It(this.ctx), r4 = i4.globals.yAxisScale[0].result.reverse(), o3 = r4.length, n3 = [], l4 = this.size / (o3 - 1), h4 = 0; h4 < o3; h4++) n3[h4] = l4 * h4;
          n3.reverse();
          var c4 = [], d3 = [];
          n3.forEach((function(t6, i5) {
            var a5 = m3.getPolygonPos(t6, e4.dataPointsLen), s5 = "";
            a5.forEach((function(t7, a6) {
              if (0 === i5) {
                var r5 = e4.graphics.drawLine(t7.x, t7.y, 0, 0, Array.isArray(e4.polygons.connectorColors) ? e4.polygons.connectorColors[a6] : e4.polygons.connectorColors);
                d3.push(r5);
              }
              0 === a6 && e4.yaxisLabelsTextsPos.push({ x: t7.x, y: t7.y }), s5 += t7.x + "," + t7.y + " ";
            })), c4.push(s5);
          })), c4.forEach((function(t6, s5) {
            var r5 = e4.polygons.strokeColors, o4 = e4.polygons.strokeWidth, n4 = e4.graphics.drawPolygon(t6, Array.isArray(r5) ? r5[s5] : r5, Array.isArray(o4) ? o4[s5] : o4, i4.globals.radarPolygons.fill.colors[s5]);
            a4.add(n4);
          })), d3.forEach((function(t6) {
            a4.add(t6);
          })), i4.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((function(t6, i5) {
            var a5 = s4.drawYAxisTexts(t6.x, t6.y, i5, r4[i5]);
            e4.yaxisLabels.add(a5);
          }));
        } }, { key: "drawXAxisTexts", value: function() {
          var t5 = this, e4 = this.w, i4 = e4.config.xaxis.labels, a4 = this.graphics.group({ class: "apexcharts-xaxis" }), s4 = m3.getPolygonPos(this.size, this.dataPointsLen);
          return e4.globals.labels.forEach((function(r4, o3) {
            var n3 = e4.config.xaxis.labels.formatter, l4 = new G3(t5.ctx);
            if (s4[o3]) {
              var h4 = t5.getTextPos(s4[o3], t5.size), c4 = n3(r4, { seriesIndex: -1, dataPointIndex: o3, w: e4 });
              l4.plotDataLabelsText({ x: h4.newX, y: h4.newY, text: c4, textAnchor: h4.textAnchor, i: o3, j: o3, parent: a4, className: "apexcharts-xaxis-label", color: Array.isArray(i4.style.colors) && i4.style.colors[o3] ? i4.style.colors[o3] : "#a8a8a8", dataLabelsConfig: g4({ textAnchor: h4.textAnchor, dropShadow: { enabled: false } }, i4), offsetCorrection: false }).on("click", (function(i5) {
                if ("function" == typeof e4.config.chart.events.xAxisLabelClick) {
                  var a5 = Object.assign({}, e4, { labelIndex: o3 });
                  e4.config.chart.events.xAxisLabelClick(i5, t5.ctx, a5);
                }
              }));
            }
          })), a4;
        } }, { key: "createPaths", value: function(t5, e4) {
          var i4 = this, a4 = [], s4 = [], r4 = [], o3 = [];
          if (t5.length) {
            s4 = [this.graphics.move(e4.x, e4.y)], o3 = [this.graphics.move(e4.x, e4.y)];
            var n3 = this.graphics.move(t5[0].x, t5[0].y), l4 = this.graphics.move(t5[0].x, t5[0].y);
            t5.forEach((function(e5, a5) {
              n3 += i4.graphics.line(e5.x, e5.y), l4 += i4.graphics.line(e5.x, e5.y), a5 === t5.length - 1 && (n3 += "Z", l4 += "Z");
            })), a4.push(n3), r4.push(l4);
          }
          return { linePathsFrom: s4, linePathsTo: a4, areaPathsFrom: o3, areaPathsTo: r4 };
        } }, { key: "getTextPos", value: function(t5, e4) {
          var i4 = "middle", a4 = t5.x, s4 = t5.y;
          return Math.abs(t5.x) >= 10 ? t5.x > 0 ? (i4 = "start", a4 += 10) : t5.x < 0 && (i4 = "end", a4 -= 10) : i4 = "middle", Math.abs(t5.y) >= e4 - 10 && (t5.y < 0 ? s4 -= 10 : t5.y > 0 && (s4 += 10)), { textAnchor: i4, newX: a4, newY: s4 };
        } }, { key: "getPreviousPath", value: function(t5) {
          for (var e4 = this.w, i4 = null, a4 = 0; a4 < e4.globals.previousPaths.length; a4++) {
            var s4 = e4.globals.previousPaths[a4];
            s4.paths.length > 0 && parseInt(s4.realIndex, 10) === parseInt(t5, 10) && void 0 !== e4.globals.previousPaths[a4].paths[0] && (i4 = e4.globals.previousPaths[a4].paths[0].d);
          }
          return i4;
        } }, { key: "getDataPointsPos", value: function(t5, e4) {
          var i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
          t5 = t5 || [], e4 = e4 || [];
          for (var a4 = [], s4 = 0; s4 < i4; s4++) {
            var r4 = {};
            r4.x = t5[s4] * Math.sin(e4[s4]), r4.y = -t5[s4] * Math.cos(e4[s4]), a4.push(r4);
          }
          return a4;
        } }]), t4;
      })();
      var Xt = (function(t4) {
        h3(r4, Tt);
        var a4 = o2(r4);
        function r4(t5) {
          var s4;
          i3(this, r4), (s4 = a4.call(this, t5)).ctx = t5, s4.w = t5.w, s4.animBeginArr = [0], s4.animDur = 0;
          var o3 = s4.w;
          return s4.startAngle = o3.config.plotOptions.radialBar.startAngle, s4.endAngle = o3.config.plotOptions.radialBar.endAngle, s4.totalAngle = Math.abs(o3.config.plotOptions.radialBar.endAngle - o3.config.plotOptions.radialBar.startAngle), s4.trackStartAngle = o3.config.plotOptions.radialBar.track.startAngle, s4.trackEndAngle = o3.config.plotOptions.radialBar.track.endAngle, s4.barLabels = s4.w.config.plotOptions.radialBar.barLabels, s4.donutDataLabels = s4.w.config.plotOptions.radialBar.dataLabels, s4.radialDataLabels = s4.donutDataLabels, s4.trackStartAngle || (s4.trackStartAngle = s4.startAngle), s4.trackEndAngle || (s4.trackEndAngle = s4.endAngle), 360 === s4.endAngle && (s4.endAngle = 359.99), s4.margin = parseInt(o3.config.plotOptions.radialBar.track.margin, 10), s4.onBarLabelClick = s4.onBarLabelClick.bind(e3(s4)), s4;
        }
        return s3(r4, [{ key: "draw", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a5 = i4.group({ class: "apexcharts-radialbar" });
          if (e4.globals.noData) return a5;
          var s4 = i4.group(), r5 = this.defaultSize / 2, o3 = e4.globals.gridWidth / 2, n3 = this.defaultSize / 2.05;
          e4.config.chart.sparkline.enabled || (n3 = n3 - e4.config.stroke.width - e4.config.chart.dropShadow.blur);
          var l4 = e4.globals.fill.colors;
          if (e4.config.plotOptions.radialBar.track.show) {
            var h4 = this.drawTracks({ size: n3, centerX: o3, centerY: r5, colorArr: l4, series: t5 });
            s4.add(h4);
          }
          var c4 = this.drawArcs({ size: n3, centerX: o3, centerY: r5, colorArr: l4, series: t5 }), d3 = 360;
          e4.config.plotOptions.radialBar.startAngle < 0 && (d3 = this.totalAngle);
          var g5 = (360 - d3) / 360;
          if (e4.globals.radialSize = n3 - n3 * g5, this.radialDataLabels.value.show) {
            var u4 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
            e4.globals.radialSize += u4 * g5;
          }
          return s4.add(c4.g), "front" === e4.config.plotOptions.radialBar.hollow.position && (c4.g.add(c4.elHollow), c4.dataLabels && c4.g.add(c4.dataLabels)), a5.add(s4), a5;
        } }, { key: "drawTracks", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a5 = i4.group({ class: "apexcharts-tracks" }), s4 = new w4(this.ctx), r5 = new N3(this.ctx), o3 = this.getStrokeWidth(t5);
          t5.size = t5.size - o3 / 2;
          for (var n3 = 0; n3 < t5.series.length; n3++) {
            var l4 = i4.group({ class: "apexcharts-radialbar-track apexcharts-track" });
            a5.add(l4), l4.attr({ rel: n3 + 1 }), t5.size = t5.size - o3 - this.margin;
            var h4 = e4.config.plotOptions.radialBar.track, c4 = r5.fillPath({ seriesNumber: 0, size: t5.size, fillColors: Array.isArray(h4.background) ? h4.background[n3] : h4.background, solid: true }), d3 = this.trackStartAngle, g5 = this.trackEndAngle;
            Math.abs(g5) + Math.abs(d3) >= 360 && (g5 = 360 - Math.abs(this.startAngle) - 0.1);
            var u4 = i4.drawPath({ d: "", stroke: c4, strokeWidth: o3 * parseInt(h4.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h4.opacity, classes: "apexcharts-radialbar-area" });
            if (h4.dropShadow.enabled) {
              var f4 = h4.dropShadow;
              s4.dropShadow(u4, f4);
            }
            l4.add(u4), u4.attr("id", "apexcharts-radialbarTrack-" + n3), this.animatePaths(u4, { centerX: t5.centerX, centerY: t5.centerY, endAngle: g5, startAngle: d3, size: t5.size, i: n3, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e4.globals.easing });
          }
          return a5;
        } }, { key: "drawArcs", value: function(t5) {
          var e4 = this.w, i4 = new k3(this.ctx), a5 = new N3(this.ctx), s4 = new w4(this.ctx), r5 = i4.group(), o3 = this.getStrokeWidth(t5);
          t5.size = t5.size - o3 / 2;
          var n3 = e4.config.plotOptions.radialBar.hollow.background, l4 = t5.size - o3 * t5.series.length - this.margin * t5.series.length - o3 * parseInt(e4.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h4 = l4 - e4.config.plotOptions.radialBar.hollow.margin;
          void 0 !== e4.config.plotOptions.radialBar.hollow.image && (n3 = this.drawHollowImage(t5, r5, l4, n3));
          var c4 = this.drawHollow({ size: h4, centerX: t5.centerX, centerY: t5.centerY, fill: n3 || "transparent" });
          if (e4.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
            var d3 = e4.config.plotOptions.radialBar.hollow.dropShadow;
            s4.dropShadow(c4, d3);
          }
          var g5 = 1;
          !this.radialDataLabels.total.show && e4.globals.series.length > 1 && (g5 = 0);
          var u4 = null;
          if (this.radialDataLabels.show) {
            var f4 = e4.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0];
            u4 = this.renderInnerDataLabels(f4, this.radialDataLabels, { hollowSize: l4, centerX: t5.centerX, centerY: t5.centerY, opacity: g5 });
          }
          "back" === e4.config.plotOptions.radialBar.hollow.position && (r5.add(c4), u4 && r5.add(u4));
          var p4 = false;
          e4.config.plotOptions.radialBar.inverseOrder && (p4 = true);
          for (var x5 = p4 ? t5.series.length - 1 : 0; p4 ? x5 >= 0 : x5 < t5.series.length; p4 ? x5-- : x5++) {
            var b4 = i4.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: m3.escapeString(e4.globals.seriesNames[x5]) });
            r5.add(b4), b4.attr({ rel: x5 + 1, "data:realIndex": x5 }), this.ctx.series.addCollapsedClassToSeries(b4, x5), t5.size = t5.size - o3 - this.margin;
            var v4 = a5.fillPath({ seriesNumber: x5, size: t5.size, value: t5.series[x5] }), y4 = this.startAngle, A4 = void 0, S3 = m3.negToZero(t5.series[x5] > 100 ? 100 : t5.series[x5]) / 100, C4 = Math.round(this.totalAngle * S3) + this.startAngle, L4 = void 0;
            e4.globals.dataChanged && (A4 = this.startAngle, L4 = Math.round(this.totalAngle * m3.negToZero(e4.globals.previousPaths[x5]) / 100) + A4), Math.abs(C4) + Math.abs(y4) > 360 && (C4 -= 0.01), Math.abs(L4) + Math.abs(A4) > 360 && (L4 -= 0.01);
            var P4 = C4 - y4, M3 = Array.isArray(e4.config.stroke.dashArray) ? e4.config.stroke.dashArray[x5] : e4.config.stroke.dashArray, I4 = i4.drawPath({ d: "", stroke: v4, strokeWidth: o3, fill: "none", fillOpacity: e4.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + x5, strokeDashArray: M3 });
            if (k3.setAttrs(I4.node, { "data:angle": P4, "data:value": t5.series[x5] }), e4.config.chart.dropShadow.enabled) {
              var T5 = e4.config.chart.dropShadow;
              s4.dropShadow(I4, T5, x5);
            }
            if (s4.setSelectionFilter(I4, 0, x5), this.addListeners(I4, this.radialDataLabels), b4.add(I4), I4.attr({ index: 0, j: x5 }), this.barLabels.enabled) {
              var z4 = m3.polarToCartesian(t5.centerX, t5.centerY, t5.size, y4), X3 = this.barLabels.formatter(e4.globals.seriesNames[x5], { seriesIndex: x5, w: e4 }), E3 = ["apexcharts-radialbar-label"];
              this.barLabels.onClick || E3.push("apexcharts-no-click");
              var Y2 = this.barLabels.useSeriesColors ? e4.globals.colors[x5] : e4.config.chart.foreColor;
              Y2 || (Y2 = e4.config.chart.foreColor);
              var R2 = z4.x + this.barLabels.offsetX, F5 = z4.y + this.barLabels.offsetY, D4 = i4.drawText({ x: R2, y: F5, text: X3, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: Y2, cssClass: E3.join(" ") });
              D4.on("click", this.onBarLabelClick), D4.attr({ rel: x5 + 1 }), 0 !== y4 && D4.attr({ "transform-origin": "".concat(R2, " ").concat(F5), transform: "rotate(".concat(y4, " 0 0)") }), b4.add(D4);
            }
            var H4 = 0;
            !this.initialAnim || e4.globals.resized || e4.globals.dataChanged || (H4 = e4.config.chart.animations.speed), e4.globals.dataChanged && (H4 = e4.config.chart.animations.dynamicAnimation.speed), this.animDur = H4 / (1.2 * t5.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(I4, { centerX: t5.centerX, centerY: t5.centerY, endAngle: C4, startAngle: y4, prevEndAngle: L4, prevStartAngle: A4, size: t5.size, i: x5, totalItems: 2, animBeginArr: this.animBeginArr, dur: H4, shouldSetPrevPaths: true, easing: e4.globals.easing });
          }
          return { g: r5, elHollow: c4, dataLabels: u4 };
        } }, { key: "drawHollow", value: function(t5) {
          var e4 = new k3(this.ctx).drawCircle(2 * t5.size);
          return e4.attr({ class: "apexcharts-radialbar-hollow", cx: t5.centerX, cy: t5.centerY, r: t5.size, fill: t5.fill }), e4;
        } }, { key: "drawHollowImage", value: function(t5, e4, i4, a5) {
          var s4 = this.w, r5 = new N3(this.ctx), o3 = m3.randomId(), n3 = s4.config.plotOptions.radialBar.hollow.image;
          if (s4.config.plotOptions.radialBar.hollow.imageClipped) r5.clippedImgArea({ width: i4, height: i4, image: n3, patternID: "pattern".concat(s4.globals.cuid).concat(o3) }), a5 = "url(#pattern".concat(s4.globals.cuid).concat(o3, ")");
          else {
            var l4 = s4.config.plotOptions.radialBar.hollow.imageWidth, h4 = s4.config.plotOptions.radialBar.hollow.imageHeight;
            if (void 0 === l4 && void 0 === h4) {
              var c4 = s4.globals.dom.Paper.image(n3).loaded((function(e5) {
                this.move(t5.centerX - e5.width / 2 + s4.config.plotOptions.radialBar.hollow.imageOffsetX, t5.centerY - e5.height / 2 + s4.config.plotOptions.radialBar.hollow.imageOffsetY);
              }));
              e4.add(c4);
            } else {
              var d3 = s4.globals.dom.Paper.image(n3).loaded((function(e5) {
                this.move(t5.centerX - l4 / 2 + s4.config.plotOptions.radialBar.hollow.imageOffsetX, t5.centerY - h4 / 2 + s4.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l4, h4);
              }));
              e4.add(d3);
            }
          }
          return a5;
        } }, { key: "getStrokeWidth", value: function(t5) {
          var e4 = this.w;
          return t5.size * (100 - parseInt(e4.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t5.series.length + 1) - this.margin;
        } }, { key: "onBarLabelClick", value: function(t5) {
          var e4 = parseInt(t5.target.getAttribute("rel"), 10) - 1, i4 = this.barLabels.onClick, a5 = this.w;
          i4 && i4(a5.globals.seriesNames[e4], { w: a5, seriesIndex: e4 });
        } }]), r4;
      })();
      var Et = (function(t4) {
        h3(a4, St);
        var e4 = o2(a4);
        function a4() {
          return i3(this, a4), e4.apply(this, arguments);
        }
        return s3(a4, [{ key: "draw", value: function(t5, e5) {
          var i4 = this.w, a5 = new k3(this.ctx);
          this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t5, this.seriesRangeStart = i4.globals.seriesRangeStart, this.seriesRangeEnd = i4.globals.seriesRangeEnd, this.barHelpers.initVariables(t5);
          for (var s4 = a5.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), r4 = 0; r4 < t5.length; r4++) {
            var o3, n3, l4, h4, c4 = void 0, d3 = void 0, u4 = i4.globals.comboCharts ? e5[r4] : r4, f4 = this.barHelpers.getGroupIndex(u4).columnGroupIndex, p4 = a5.group({ class: "apexcharts-series", seriesName: m3.escapeString(i4.globals.seriesNames[u4]), rel: r4 + 1, "data:realIndex": u4 });
            this.ctx.series.addCollapsedClassToSeries(p4, u4), t5[r4].length > 0 && (this.visibleI = this.visibleI + 1);
            var x5 = 0, b4 = 0, v4 = 0;
            this.yRatio.length > 1 && (this.yaxisIndex = i4.globals.seriesYAxisReverseMap[u4][0], v4 = u4);
            var y4 = this.barHelpers.initialPositions();
            d3 = y4.y, h4 = y4.zeroW, c4 = y4.x, b4 = y4.barWidth, x5 = y4.barHeight, o3 = y4.xDivision, n3 = y4.yDivision, l4 = y4.zeroH;
            for (var w5 = a5.group({ class: "apexcharts-datalabels", "data:realIndex": u4 }), A4 = a5.group({ class: "apexcharts-rangebar-goals-markers" }), S3 = 0; S3 < i4.globals.dataPoints; S3++) {
              var C4 = this.barHelpers.getStrokeWidth(r4, S3, u4), L4 = this.seriesRangeStart[r4][S3], P4 = this.seriesRangeEnd[r4][S3], M3 = null, I4 = null, T5 = null, z4 = { x: c4, y: d3, strokeWidth: C4, elSeries: p4 }, X3 = this.seriesLen;
              if (i4.config.plotOptions.bar.rangeBarGroupRows && (X3 = 1), void 0 === i4.config.series[r4].data[S3]) break;
              if (this.isHorizontal) {
                T5 = d3 + x5 * this.visibleI;
                var E3 = (n3 - x5 * X3) / 2;
                if (i4.config.series[r4].data[S3].x) {
                  var Y2 = this.detectOverlappingBars({ i: r4, j: S3, barYPosition: T5, srty: E3, barHeight: x5, yDivision: n3, initPositions: y4 });
                  x5 = Y2.barHeight, T5 = Y2.barYPosition;
                }
                b4 = (M3 = this.drawRangeBarPaths(g4({ indexes: { i: r4, j: S3, realIndex: u4 }, barHeight: x5, barYPosition: T5, zeroW: h4, yDivision: n3, y1: L4, y2: P4 }, z4))).barWidth;
              } else {
                i4.globals.isXNumeric && (c4 = (i4.globals.seriesX[r4][S3] - i4.globals.minX) / this.xRatio - b4 / 2), I4 = c4 + b4 * this.visibleI;
                var R2 = (o3 - b4 * X3) / 2;
                if (i4.config.series[r4].data[S3].x) {
                  var F5 = this.detectOverlappingBars({ i: r4, j: S3, barXPosition: I4, srtx: R2, barWidth: b4, xDivision: o3, initPositions: y4 });
                  b4 = F5.barWidth, I4 = F5.barXPosition;
                }
                x5 = (M3 = this.drawRangeColumnPaths(g4({ indexes: { i: r4, j: S3, realIndex: u4, translationsIndex: v4 }, barWidth: b4, barXPosition: I4, zeroH: l4, xDivision: o3 }, z4))).barHeight;
              }
              var D4 = this.barHelpers.drawGoalLine({ barXPosition: M3.barXPosition, barYPosition: T5, goalX: M3.goalX, goalY: M3.goalY, barHeight: x5, barWidth: b4 });
              D4 && A4.add(D4), d3 = M3.y, c4 = M3.x;
              var H4 = this.barHelpers.getPathFillColor(t5, r4, S3, u4), O3 = i4.globals.stroke.colors[u4];
              this.renderSeries({ realIndex: u4, pathFill: H4, lineFill: O3, j: S3, i: r4, x: c4, y: d3, y1: L4, y2: P4, pathFrom: M3.pathFrom, pathTo: M3.pathTo, strokeWidth: C4, elSeries: p4, series: t5, barHeight: x5, barWidth: b4, barXPosition: I4, barYPosition: T5, columnGroupIndex: f4, elDataLabelsWrap: w5, elGoalsMarkers: A4, visibleSeries: this.visibleI, type: "rangebar" });
            }
            s4.add(p4);
          }
          return s4;
        } }, { key: "detectOverlappingBars", value: function(t5) {
          var e5 = t5.i, i4 = t5.j, a5 = t5.barYPosition, s4 = t5.barXPosition, r4 = t5.srty, o3 = t5.srtx, n3 = t5.barHeight, l4 = t5.barWidth, h4 = t5.yDivision, c4 = t5.xDivision, d3 = t5.initPositions, g5 = this.w, u4 = [], f4 = g5.config.series[e5].data[i4].rangeName, p4 = g5.config.series[e5].data[i4].x, x5 = Array.isArray(p4) ? p4.join(" ") : p4, b4 = g5.globals.labels.map((function(t6) {
            return Array.isArray(t6) ? t6.join(" ") : t6;
          })).indexOf(x5), v4 = g5.globals.seriesRange[e5].findIndex((function(t6) {
            return t6.x === x5 && t6.overlaps.length > 0;
          }));
          return this.isHorizontal ? (a5 = g5.config.plotOptions.bar.rangeBarGroupRows ? r4 + h4 * b4 : r4 + n3 * this.visibleI + h4 * b4, v4 > -1 && !g5.config.plotOptions.bar.rangeBarOverlap && (u4 = g5.globals.seriesRange[e5][v4].overlaps).indexOf(f4) > -1 && (a5 = (n3 = d3.barHeight / u4.length) * this.visibleI + h4 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + n3 * (this.visibleI + u4.indexOf(f4)) + h4 * b4)) : (b4 > -1 && !g5.globals.timescaleLabels.length && (s4 = g5.config.plotOptions.bar.rangeBarGroupRows ? o3 + c4 * b4 : o3 + l4 * this.visibleI + c4 * b4), v4 > -1 && !g5.config.plotOptions.bar.rangeBarOverlap && (u4 = g5.globals.seriesRange[e5][v4].overlaps).indexOf(f4) > -1 && (s4 = (l4 = d3.barWidth / u4.length) * this.visibleI + c4 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l4 * (this.visibleI + u4.indexOf(f4)) + c4 * b4)), { barYPosition: a5, barXPosition: s4, barHeight: n3, barWidth: l4 };
        } }, { key: "drawRangeColumnPaths", value: function(t5) {
          var e5 = t5.indexes, i4 = t5.x, a5 = t5.xDivision, s4 = t5.barWidth, r4 = t5.barXPosition, o3 = t5.zeroH, n3 = this.w, l4 = e5.i, h4 = e5.j, c4 = e5.realIndex, d3 = e5.translationsIndex, g5 = this.yRatio[d3], u4 = this.getRangeValue(c4, h4), f4 = Math.min(u4.start, u4.end), p4 = Math.max(u4.start, u4.end);
          void 0 === this.series[l4][h4] || null === this.series[l4][h4] ? f4 = o3 : (f4 = o3 - f4 / g5, p4 = o3 - p4 / g5);
          var x5 = Math.abs(p4 - f4), b4 = this.barHelpers.getColumnPaths({ barXPosition: r4, barWidth: s4, y1: f4, y2: p4, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c4, i: c4, j: h4, w: n3 });
          if (n3.globals.isXNumeric) {
            var v4 = this.getBarXForNumericXAxis({ x: i4, j: h4, realIndex: c4, barWidth: s4 });
            i4 = v4.x, r4 = v4.barXPosition;
          } else i4 += a5;
          return { pathTo: b4.pathTo, pathFrom: b4.pathFrom, barHeight: x5, x: i4, y: u4.start < 0 && u4.end < 0 ? f4 : p4, goalY: this.barHelpers.getGoalValues("y", null, o3, l4, h4, d3), barXPosition: r4 };
        } }, { key: "preventBarOverflow", value: function(t5) {
          var e5 = this.w;
          return t5 < 0 && (t5 = 0), t5 > e5.globals.gridWidth && (t5 = e5.globals.gridWidth), t5;
        } }, { key: "drawRangeBarPaths", value: function(t5) {
          var e5 = t5.indexes, i4 = t5.y, a5 = t5.y1, s4 = t5.y2, r4 = t5.yDivision, o3 = t5.barHeight, n3 = t5.barYPosition, l4 = t5.zeroW, h4 = this.w, c4 = e5.realIndex, d3 = e5.j, g5 = this.preventBarOverflow(l4 + a5 / this.invertedYRatio), u4 = this.preventBarOverflow(l4 + s4 / this.invertedYRatio), f4 = this.getRangeValue(c4, d3), p4 = Math.abs(u4 - g5), x5 = this.barHelpers.getBarpaths({ barYPosition: n3, barHeight: o3, x1: g5, x2: u4, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c4, realIndex: c4, j: d3, w: h4 });
          return h4.globals.isXNumeric || (i4 += r4), { pathTo: x5.pathTo, pathFrom: x5.pathFrom, barWidth: p4, x: f4.start < 0 && f4.end < 0 ? g5 : u4, goalX: this.barHelpers.getGoalValues("x", l4, null, c4, d3), y: i4 };
        } }, { key: "getRangeValue", value: function(t5, e5) {
          var i4 = this.w;
          return { start: i4.globals.seriesRangeStart[t5][e5], end: i4.globals.seriesRangeEnd[t5][e5] };
        } }]), a4;
      })();
      var Yt = (function() {
        function t4(e4) {
          i3(this, t4), this.w = e4.w, this.lineCtx = e4;
        }
        return s3(t4, [{ key: "sameValueSeriesFix", value: function(t5, e4) {
          var i4 = this.w;
          if (("gradient" === i4.config.fill.type || "gradient" === i4.config.fill.type[t5]) && new A3(this.lineCtx.ctx, i4).seriesHaveSameValues(t5)) {
            var a4 = e4[t5].slice();
            a4[a4.length - 1] = a4[a4.length - 1] + 1e-6, e4[t5] = a4;
          }
          return e4;
        } }, { key: "calculatePoints", value: function(t5) {
          var e4 = t5.series, i4 = t5.realIndex, a4 = t5.x, s4 = t5.y, r4 = t5.i, o3 = t5.j, n3 = t5.prevY, l4 = this.w, h4 = [], c4 = [];
          if (0 === o3) {
            var d3 = this.lineCtx.categoryAxisCorrection + l4.config.markers.offsetX;
            l4.globals.isXNumeric && (d3 = (l4.globals.seriesX[i4][0] - l4.globals.minX) / this.lineCtx.xRatio + l4.config.markers.offsetX), h4.push(d3), c4.push(m3.isNumber(e4[r4][0]) ? n3 + l4.config.markers.offsetY : null), h4.push(a4 + l4.config.markers.offsetX), c4.push(m3.isNumber(e4[r4][o3 + 1]) ? s4 + l4.config.markers.offsetY : null);
          } else h4.push(a4 + l4.config.markers.offsetX), c4.push(m3.isNumber(e4[r4][o3 + 1]) ? s4 + l4.config.markers.offsetY : null);
          return { x: h4, y: c4 };
        } }, { key: "checkPreviousPaths", value: function(t5) {
          for (var e4 = t5.pathFromLine, i4 = t5.pathFromArea, a4 = t5.realIndex, s4 = this.w, r4 = 0; r4 < s4.globals.previousPaths.length; r4++) {
            var o3 = s4.globals.previousPaths[r4];
            ("line" === o3.type || "area" === o3.type) && o3.paths.length > 0 && parseInt(o3.realIndex, 10) === parseInt(a4, 10) && ("line" === o3.type ? (this.lineCtx.appendPathFrom = false, e4 = s4.globals.previousPaths[r4].paths[0].d) : "area" === o3.type && (this.lineCtx.appendPathFrom = false, i4 = s4.globals.previousPaths[r4].paths[0].d, s4.config.stroke.show && s4.globals.previousPaths[r4].paths[1] && (e4 = s4.globals.previousPaths[r4].paths[1].d)));
          }
          return { pathFromLine: e4, pathFromArea: i4 };
        } }, { key: "determineFirstPrevY", value: function(t5) {
          var e4, i4, a4, s4 = t5.i, r4 = t5.realIndex, o3 = t5.series, n3 = t5.prevY, l4 = t5.lineYPosition, h4 = t5.translationsIndex, c4 = this.w, d3 = c4.config.chart.stacked && !c4.globals.comboCharts || c4.config.chart.stacked && c4.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e4 = this.w.config.series[r4]) || void 0 === e4 ? void 0 : e4.type) || "column" === (null === (i4 = this.w.config.series[r4]) || void 0 === i4 ? void 0 : i4.type));
          if (void 0 !== (null === (a4 = o3[s4]) || void 0 === a4 ? void 0 : a4[0])) n3 = (l4 = d3 && s4 > 0 ? this.lineCtx.prevSeriesY[s4 - 1][0] : this.lineCtx.zeroY) - o3[s4][0] / this.lineCtx.yRatio[h4] + 2 * (this.lineCtx.isReversed ? o3[s4][0] / this.lineCtx.yRatio[h4] : 0);
          else if (d3 && s4 > 0 && void 0 === o3[s4][0]) {
            for (var g5 = s4 - 1; g5 >= 0; g5--) if (null !== o3[g5][0] && void 0 !== o3[g5][0]) {
              n3 = l4 = this.lineCtx.prevSeriesY[g5][0];
              break;
            }
          }
          return { prevY: n3, lineYPosition: l4 };
        } }]), t4;
      })();
      var Rt = function(t4) {
        for (var e4, i4, a4, s4, r4 = (function(t5) {
          for (var e5 = [], i5 = t5[0], a5 = t5[1], s5 = e5[0] = Ht(i5, a5), r5 = 1, o4 = t5.length - 1; r5 < o4; r5++) i5 = a5, a5 = t5[r5 + 1], e5[r5] = 0.5 * (s5 + (s5 = Ht(i5, a5)));
          return e5[r5] = s5, e5;
        })(t4), o3 = t4.length - 1, n3 = [], l4 = 0; l4 < o3; l4++) a4 = Ht(t4[l4], t4[l4 + 1]), Math.abs(a4) < 1e-6 ? r4[l4] = r4[l4 + 1] = 0 : (s4 = (e4 = r4[l4] / a4) * e4 + (i4 = r4[l4 + 1] / a4) * i4) > 9 && (s4 = 3 * a4 / Math.sqrt(s4), r4[l4] = s4 * e4, r4[l4 + 1] = s4 * i4);
        for (var h4 = 0; h4 <= o3; h4++) s4 = (t4[Math.min(o3, h4 + 1)][0] - t4[Math.max(0, h4 - 1)][0]) / (6 * (1 + r4[h4] * r4[h4])), n3.push([s4 || 0, r4[h4] * s4 || 0]);
        return n3;
      };
      var Ft = function(t4) {
        var e4 = Rt(t4), i4 = t4[1], a4 = t4[0], s4 = [], r4 = e4[1], o3 = e4[0];
        s4.push(a4, [a4[0] + o3[0], a4[1] + o3[1], i4[0] - r4[0], i4[1] - r4[1], i4[0], i4[1]]);
        for (var n3 = 2, l4 = e4.length; n3 < l4; n3++) {
          var h4 = t4[n3], c4 = e4[n3];
          s4.push([h4[0] - c4[0], h4[1] - c4[1], h4[0], h4[1]]);
        }
        return s4;
      };
      var Dt = function(t4, e4, i4) {
        var a4 = t4.slice(e4, i4);
        if (e4) {
          if (i4 - e4 > 1 && a4[1].length < 6) {
            var s4 = a4[0].length;
            a4[1] = [2 * a4[0][s4 - 2] - a4[0][s4 - 4], 2 * a4[0][s4 - 1] - a4[0][s4 - 3]].concat(a4[1]);
          }
          a4[0] = a4[0].slice(-2);
        }
        return a4;
      };
      function Ht(t4, e4) {
        return (e4[1] - t4[1]) / (e4[0] - t4[0]);
      }
      var Ot = (function() {
        function t4(e4, a4, s4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.xyRatios = a4, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s4, this.scatter = new B3(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Yt(this), this.markers = new W2(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
        }
        return s3(t4, [{ key: "draw", value: function(t5, e4, i4, a4) {
          var s4, r4 = this.w, o3 = new k3(this.ctx), n3 = r4.globals.comboCharts ? e4 : r4.config.chart.type, l4 = o3.group({ class: "apexcharts-".concat(n3, "-series apexcharts-plot-series") }), h4 = new A3(this.ctx, r4);
          this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t5 = h4.getLogSeries(t5), this.yRatio = h4.getLogYRatios(this.yRatio), this.prevSeriesY = [];
          for (var c4 = [], d3 = 0; d3 < t5.length; d3++) {
            t5 = this.lineHelpers.sameValueSeriesFix(d3, t5);
            var u4 = r4.globals.comboCharts ? i4[d3] : d3, f4 = this.yRatio.length > 1 ? u4 : 0;
            this._initSerieVariables(t5, d3, u4);
            var p4 = [], x5 = [], b4 = [], v4 = r4.globals.padHorizontal + this.categoryAxisCorrection;
            this.ctx.series.addCollapsedClassToSeries(this.elSeries, u4), r4.globals.isXNumeric && r4.globals.seriesX.length > 0 && (v4 = (r4.globals.seriesX[u4][0] - r4.globals.minX) / this.xRatio), b4.push(v4);
            var m4, y4 = v4, w5 = void 0, S3 = y4, C4 = this.zeroY, L4 = this.zeroY;
            C4 = this.lineHelpers.determineFirstPrevY({ i: d3, realIndex: u4, series: t5, prevY: C4, lineYPosition: 0, translationsIndex: f4 }).prevY, "monotoneCubic" === r4.config.stroke.curve && null === t5[d3][0] ? p4.push(null) : p4.push(C4), m4 = C4;
            "rangeArea" === n3 && (w5 = L4 = this.lineHelpers.determineFirstPrevY({ i: d3, realIndex: u4, series: a4, prevY: L4, lineYPosition: 0, translationsIndex: f4 }).prevY, x5.push(null !== p4[0] ? L4 : null));
            var P4 = this._calculatePathsFrom({ type: n3, series: t5, i: d3, realIndex: u4, translationsIndex: f4, prevX: S3, prevY: C4, prevY2: L4 }), M3 = [p4[0]], I4 = [x5[0]], T5 = { type: n3, series: t5, realIndex: u4, translationsIndex: f4, i: d3, x: v4, y: 1, pX: y4, pY: m4, pathsFrom: P4, linePaths: [], areaPaths: [], seriesIndex: i4, lineYPosition: 0, xArrj: b4, yArrj: p4, y2Arrj: x5, seriesRangeEnd: a4 }, z4 = this._iterateOverDataPoints(g4(g4({}, T5), {}, { iterations: "rangeArea" === n3 ? t5[d3].length - 1 : void 0, isRangeStart: true }));
            if ("rangeArea" === n3) {
              for (var X3 = this._calculatePathsFrom({ series: a4, i: d3, realIndex: u4, prevX: S3, prevY: L4 }), E3 = this._iterateOverDataPoints(g4(g4({}, T5), {}, { series: a4, xArrj: [v4], yArrj: M3, y2Arrj: I4, pY: w5, areaPaths: z4.areaPaths, pathsFrom: X3, iterations: a4[d3].length - 1, isRangeStart: false })), Y2 = z4.linePaths.length / 2, R2 = 0; R2 < Y2; R2++) z4.linePaths[R2] = E3.linePaths[R2 + Y2] + z4.linePaths[R2];
              z4.linePaths.splice(Y2), z4.pathFromLine = E3.pathFromLine + z4.pathFromLine;
            } else z4.pathFromArea += "z";
            this._handlePaths({ type: n3, realIndex: u4, i: d3, paths: z4 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c4.push(this.elSeries);
          }
          if (void 0 !== (null === (s4 = r4.config.series[0]) || void 0 === s4 ? void 0 : s4.zIndex) && c4.sort((function(t6, e5) {
            return Number(t6.node.getAttribute("zIndex")) - Number(e5.node.getAttribute("zIndex"));
          })), r4.config.chart.stacked) for (var F5 = c4.length - 1; F5 >= 0; F5--) l4.add(c4[F5]);
          else for (var D4 = 0; D4 < c4.length; D4++) l4.add(c4[D4]);
          return l4;
        } }, { key: "_initSerieVariables", value: function(t5, e4, i4) {
          var a4 = this.w, s4 = new k3(this.ctx);
          this.xDivision = a4.globals.gridWidth / (a4.globals.dataPoints - ("on" === a4.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a4.config.stroke.width) ? a4.config.stroke.width[i4] : a4.config.stroke.width;
          var r4 = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = a4.globals.seriesYAxisReverseMap[i4], r4 = i4), this.isReversed = a4.config.yaxis[this.yaxisIndex] && a4.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a4.globals.gridHeight - this.baseLineY[r4] - (this.isReversed ? a4.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r4] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a4.globals.gridHeight || "end" === a4.config.plotOptions.area.fillTo) && (this.areaBottomY = a4.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s4.group({ class: "apexcharts-series", zIndex: void 0 !== a4.config.series[i4].zIndex ? a4.config.series[i4].zIndex : i4, seriesName: m3.escapeString(a4.globals.seriesNames[i4]) }), this.elPointsMain = s4.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i4 }), this.elDataLabelsWrap = s4.group({ class: "apexcharts-datalabels", "data:realIndex": i4 });
          var o3 = t5[e4].length === a4.globals.dataPoints;
          this.elSeries.attr({ "data:longestSeries": o3, rel: e4 + 1, "data:realIndex": i4 }), this.appendPathFrom = true;
        } }, { key: "_calculatePathsFrom", value: function(t5) {
          var e4, i4, a4, s4, r4 = t5.type, o3 = t5.series, n3 = t5.i, l4 = t5.realIndex, h4 = t5.translationsIndex, c4 = t5.prevX, d3 = t5.prevY, g5 = t5.prevY2, u4 = this.w, f4 = new k3(this.ctx);
          if (null === o3[n3][0]) {
            for (var p4 = 0; p4 < o3[n3].length; p4++) if (null !== o3[n3][p4]) {
              c4 = this.xDivision * p4, d3 = this.zeroY - o3[n3][p4] / this.yRatio[h4], e4 = f4.move(c4, d3), i4 = f4.move(c4, this.areaBottomY);
              break;
            }
          } else e4 = f4.move(c4, d3), "rangeArea" === r4 && (e4 = f4.move(c4, g5) + f4.line(c4, d3)), i4 = f4.move(c4, this.areaBottomY) + f4.line(c4, d3);
          if (a4 = f4.move(0, this.zeroY) + f4.line(0, this.zeroY), s4 = f4.move(0, this.zeroY) + f4.line(0, this.zeroY), u4.globals.previousPaths.length > 0) {
            var x5 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a4, pathFromArea: s4, realIndex: l4 });
            a4 = x5.pathFromLine, s4 = x5.pathFromArea;
          }
          return { prevX: c4, prevY: d3, linePath: e4, areaPath: i4, pathFromLine: a4, pathFromArea: s4 };
        } }, { key: "_handlePaths", value: function(t5) {
          var e4 = t5.type, i4 = t5.realIndex, a4 = t5.i, s4 = t5.paths, r4 = this.w, o3 = new k3(this.ctx), n3 = new N3(this.ctx);
          this.prevSeriesY.push(s4.yArrj), r4.globals.seriesXvalues[i4] = s4.xArrj, r4.globals.seriesYvalues[i4] = s4.yArrj;
          var l4 = r4.config.forecastDataPoints;
          if (l4.count > 0 && "rangeArea" !== e4) {
            var h4 = r4.globals.seriesXvalues[i4][r4.globals.seriesXvalues[i4].length - l4.count - 1], c4 = o3.drawRect(h4, 0, r4.globals.gridWidth, r4.globals.gridHeight, 0);
            r4.globals.dom.elForecastMask.appendChild(c4.node);
            var d3 = o3.drawRect(0, 0, h4, r4.globals.gridHeight, 0);
            r4.globals.dom.elNonForecastMask.appendChild(d3.node);
          }
          this.pointsChart || r4.globals.delayedElements.push({ el: this.elPointsMain.node, index: i4 });
          var u4 = { i: a4, realIndex: i4, animationDelay: a4, initialSpeed: r4.config.chart.animations.speed, dataChangeSpeed: r4.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(e4) };
          if ("area" === e4) for (var f4 = n3.fillPath({ seriesNumber: i4 }), p4 = 0; p4 < s4.areaPaths.length; p4++) {
            var x5 = o3.renderPaths(g4(g4({}, u4), {}, { pathFrom: s4.pathFromArea, pathTo: s4.areaPaths[p4], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: f4 }));
            this.elSeries.add(x5);
          }
          if (r4.config.stroke.show && !this.pointsChart) {
            var b4 = null;
            if ("line" === e4) b4 = n3.fillPath({ seriesNumber: i4, i: a4 });
            else if ("solid" === r4.config.stroke.fill.type) b4 = r4.globals.stroke.colors[i4];
            else {
              var v4 = r4.config.fill;
              r4.config.fill = r4.config.stroke.fill, b4 = n3.fillPath({ seriesNumber: i4, i: a4 }), r4.config.fill = v4;
            }
            for (var m4 = 0; m4 < s4.linePaths.length; m4++) {
              var y4 = b4;
              "rangeArea" === e4 && (y4 = n3.fillPath({ seriesNumber: i4 }));
              var w5 = g4(g4({}, u4), {}, { pathFrom: s4.pathFromLine, pathTo: s4.linePaths[m4], stroke: b4, strokeWidth: this.strokeWidth, strokeLineCap: r4.config.stroke.lineCap, fill: "rangeArea" === e4 ? y4 : "none" }), A4 = o3.renderPaths(w5);
              if (this.elSeries.add(A4), A4.attr("fill-rule", "evenodd"), l4.count > 0 && "rangeArea" !== e4) {
                var S3 = o3.renderPaths(w5);
                S3.node.setAttribute("stroke-dasharray", l4.dashArray), l4.strokeWidth && S3.node.setAttribute("stroke-width", l4.strokeWidth), this.elSeries.add(S3), S3.attr("clip-path", "url(#forecastMask".concat(r4.globals.cuid, ")")), A4.attr("clip-path", "url(#nonForecastMask".concat(r4.globals.cuid, ")"));
              }
            }
          }
        } }, { key: "_iterateOverDataPoints", value: function(t5) {
          var e4, i4, a4 = this, s4 = t5.type, r4 = t5.series, o3 = t5.iterations, n3 = t5.realIndex, l4 = t5.translationsIndex, h4 = t5.i, c4 = t5.x, d3 = t5.y, g5 = t5.pX, u4 = t5.pY, f4 = t5.pathsFrom, p4 = t5.linePaths, x5 = t5.areaPaths, b4 = t5.seriesIndex, v4 = t5.lineYPosition, y4 = t5.xArrj, w5 = t5.yArrj, A4 = t5.y2Arrj, S3 = t5.isRangeStart, C4 = t5.seriesRangeEnd, L4 = this.w, P4 = new k3(this.ctx), M3 = this.yRatio, I4 = f4.prevY, T5 = f4.linePath, z4 = f4.areaPath, X3 = f4.pathFromLine, E3 = f4.pathFromArea, Y2 = m3.isNumber(L4.globals.minYArr[n3]) ? L4.globals.minYArr[n3] : L4.globals.minY;
          o3 || (o3 = L4.globals.dataPoints > 1 ? L4.globals.dataPoints - 1 : L4.globals.dataPoints);
          var R2 = function(t6, e5) {
            return e5 - t6 / M3[l4] + 2 * (a4.isReversed ? t6 / M3[l4] : 0);
          }, F5 = d3, D4 = L4.config.chart.stacked && !L4.globals.comboCharts || L4.config.chart.stacked && L4.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e4 = this.w.config.series[n3]) || void 0 === e4 ? void 0 : e4.type) || "column" === (null === (i4 = this.w.config.series[n3]) || void 0 === i4 ? void 0 : i4.type)), H4 = L4.config.stroke.curve;
          Array.isArray(H4) && (H4 = Array.isArray(b4) ? H4[b4[h4]] : H4[h4]);
          for (var O3, N4 = 0, W3 = 0; W3 < o3; W3++) {
            var B4 = void 0 === r4[h4][W3 + 1] || null === r4[h4][W3 + 1];
            if (L4.globals.isXNumeric) {
              var G4 = L4.globals.seriesX[n3][W3 + 1];
              void 0 === L4.globals.seriesX[n3][W3 + 1] && (G4 = L4.globals.seriesX[n3][o3 - 1]), c4 = (G4 - L4.globals.minX) / this.xRatio;
            } else c4 += this.xDivision;
            if (D4) if (h4 > 0 && L4.globals.collapsedSeries.length < L4.config.series.length - 1) {
              v4 = this.prevSeriesY[(function(t6) {
                for (var e5 = t6; e5 > 0; e5--) {
                  if (!(L4.globals.collapsedSeriesIndices.indexOf((null == b4 ? void 0 : b4[e5]) || e5) > -1)) return e5;
                  e5--;
                }
                return 0;
              })(h4 - 1)][W3 + 1];
            } else v4 = this.zeroY;
            else v4 = this.zeroY;
            B4 ? d3 = R2(Y2, v4) : (d3 = R2(r4[h4][W3 + 1], v4), "rangeArea" === s4 && (F5 = R2(C4[h4][W3 + 1], v4))), y4.push(c4), !B4 || "smooth" !== L4.config.stroke.curve && "monotoneCubic" !== L4.config.stroke.curve ? (w5.push(d3), A4.push(F5)) : (w5.push(null), A4.push(null));
            var V4 = this.lineHelpers.calculatePoints({ series: r4, x: c4, y: d3, realIndex: n3, i: h4, j: W3, prevY: I4 }), j5 = this._createPaths({ type: s4, series: r4, i: h4, realIndex: n3, j: W3, x: c4, y: d3, y2: F5, xArrj: y4, yArrj: w5, y2Arrj: A4, pX: g5, pY: u4, pathState: N4, segmentStartX: O3, linePath: T5, areaPath: z4, linePaths: p4, areaPaths: x5, curve: H4, isRangeStart: S3 });
            x5 = j5.areaPaths, p4 = j5.linePaths, g5 = j5.pX, u4 = j5.pY, N4 = j5.pathState, O3 = j5.segmentStartX, z4 = j5.areaPath, T5 = j5.linePath, !this.appendPathFrom || "monotoneCubic" === H4 && "rangeArea" === s4 || (X3 += P4.line(c4, this.zeroY), E3 += P4.line(c4, this.zeroY)), this.handleNullDataPoints(r4, V4, h4, W3, n3), this._handleMarkersAndLabels({ type: s4, pointsPos: V4, i: h4, j: W3, realIndex: n3, isRangeStart: S3 });
          }
          return { yArrj: w5, xArrj: y4, pathFromArea: E3, areaPaths: x5, pathFromLine: X3, linePaths: p4, linePath: T5, areaPath: z4 };
        } }, { key: "_handleMarkersAndLabels", value: function(t5) {
          var e4 = t5.type, i4 = t5.pointsPos, a4 = t5.isRangeStart, s4 = t5.i, r4 = t5.j, o3 = t5.realIndex, n3 = this.w, l4 = new G3(this.ctx);
          if (this.pointsChart) this.scatter.draw(this.elSeries, r4, { realIndex: o3, pointsPos: i4, zRatio: this.zRatio, elParent: this.elPointsMain });
          else {
            n3.globals.series[s4].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
            var h4 = this.markers.plotChartMarkers(i4, o3, r4 + 1);
            null !== h4 && this.elPointsMain.add(h4);
          }
          var c4 = l4.drawDataLabel({ type: e4, isRangeStart: a4, pos: i4, i: o3, j: r4 + 1 });
          null !== c4 && this.elDataLabelsWrap.add(c4);
        } }, { key: "_createPaths", value: function(t5) {
          var e4 = t5.type, i4 = t5.series, a4 = t5.i;
          t5.realIndex;
          var s4, r4 = t5.j, o3 = t5.x, n3 = t5.y, l4 = t5.xArrj, h4 = t5.yArrj, c4 = t5.y2, d3 = t5.y2Arrj, g5 = t5.pX, u4 = t5.pY, f4 = t5.pathState, p4 = t5.segmentStartX, x5 = t5.linePath, b4 = t5.areaPath, v4 = t5.linePaths, m4 = t5.areaPaths, y4 = t5.curve, w5 = t5.isRangeStart, A4 = new k3(this.ctx), S3 = this.areaBottomY, C4 = "rangeArea" === e4, L4 = "rangeArea" === e4 && w5;
          switch (y4) {
            case "monotoneCubic":
              var P4 = w5 ? h4 : d3;
              switch (f4) {
                case 0:
                  if (null === P4[r4 + 1]) break;
                  f4 = 1;
                case 1:
                  if (!(C4 ? l4.length === i4[a4].length : r4 === i4[a4].length - 2)) break;
                case 2:
                  var M3 = w5 ? l4 : l4.slice().reverse(), I4 = w5 ? P4 : P4.slice().reverse(), T5 = (s4 = I4, M3.map((function(t6, e5) {
                    return [t6, s4[e5]];
                  })).filter((function(t6) {
                    return null !== t6[1];
                  }))), z4 = T5.length > 1 ? Ft(T5) : T5, X3 = [];
                  C4 && (L4 ? m4 = T5 : X3 = m4.reverse());
                  var E3 = 0, Y2 = 0;
                  if ((function(t6, e5) {
                    for (var i5 = (function(t7) {
                      var e6 = [], i6 = 0;
                      return t7.forEach((function(t8) {
                        null !== t8 ? i6++ : i6 > 0 && (e6.push(i6), i6 = 0);
                      })), i6 > 0 && e6.push(i6), e6;
                    })(t6), a5 = [], s5 = 0, r5 = 0; s5 < i5.length; r5 += i5[s5++]) a5[s5] = Dt(e5, r5, r5 + i5[s5]);
                    return a5;
                  })(I4, z4).forEach((function(t6) {
                    E3++;
                    var e5 = (function(t7) {
                      for (var e6 = "", i6 = 0; i6 < t7.length; i6++) {
                        var a6 = t7[i6], s5 = a6.length;
                        s5 > 4 ? (e6 += "C".concat(a6[0], ", ").concat(a6[1]), e6 += ", ".concat(a6[2], ", ").concat(a6[3]), e6 += ", ".concat(a6[4], ", ").concat(a6[5])) : s5 > 2 && (e6 += "S".concat(a6[0], ", ").concat(a6[1]), e6 += ", ".concat(a6[2], ", ").concat(a6[3]));
                      }
                      return e6;
                    })(t6), i5 = Y2, a5 = (Y2 += t6.length) - 1;
                    L4 ? x5 = A4.move(T5[i5][0], T5[i5][1]) + e5 : C4 ? x5 = A4.move(X3[i5][0], X3[i5][1]) + A4.line(T5[i5][0], T5[i5][1]) + e5 + A4.line(X3[a5][0], X3[a5][1]) : (x5 = A4.move(T5[i5][0], T5[i5][1]) + e5, b4 = x5 + A4.line(T5[a5][0], S3) + A4.line(T5[i5][0], S3) + "z", m4.push(b4)), v4.push(x5);
                  })), C4 && E3 > 1 && !L4) {
                    var R2 = v4.slice(E3).reverse();
                    v4.splice(E3), R2.forEach((function(t6) {
                      return v4.push(t6);
                    }));
                  }
                  f4 = 0;
              }
              break;
            case "smooth":
              var F5 = 0.35 * (o3 - g5);
              if (null === i4[a4][r4]) f4 = 0;
              else switch (f4) {
                case 0:
                  if (p4 = g5, x5 = L4 ? A4.move(g5, d3[r4]) + A4.line(g5, u4) : A4.move(g5, u4), b4 = A4.move(g5, u4), null === i4[a4][r4 + 1]) {
                    v4.push(x5), m4.push(b4);
                    break;
                  }
                  if (f4 = 1, r4 < i4[a4].length - 2) {
                    var D4 = A4.curve(g5 + F5, u4, o3 - F5, n3, o3, n3);
                    x5 += D4, b4 += D4;
                    break;
                  }
                case 1:
                  if (null === i4[a4][r4 + 1]) x5 += L4 ? A4.line(g5, c4) : A4.move(g5, u4), b4 += A4.line(g5, S3) + A4.line(p4, S3) + "z", v4.push(x5), m4.push(b4), f4 = -1;
                  else {
                    var H4 = A4.curve(g5 + F5, u4, o3 - F5, n3, o3, n3);
                    x5 += H4, b4 += H4, r4 >= i4[a4].length - 2 && (L4 && (x5 += A4.curve(o3, n3, o3, n3, o3, c4) + A4.move(o3, c4)), b4 += A4.curve(o3, n3, o3, n3, o3, S3) + A4.line(p4, S3) + "z", v4.push(x5), m4.push(b4), f4 = -1);
                  }
              }
              g5 = o3, u4 = n3;
              break;
            default:
              var O3 = function(t6, e5, i5) {
                var a5 = [];
                switch (t6) {
                  case "stepline":
                    a5 = A4.line(e5, null, "H") + A4.line(null, i5, "V");
                    break;
                  case "linestep":
                    a5 = A4.line(null, i5, "V") + A4.line(e5, null, "H");
                    break;
                  case "straight":
                    a5 = A4.line(e5, i5);
                }
                return a5;
              };
              if (null === i4[a4][r4]) f4 = 0;
              else switch (f4) {
                case 0:
                  if (p4 = g5, x5 = L4 ? A4.move(g5, d3[r4]) + A4.line(g5, u4) : A4.move(g5, u4), b4 = A4.move(g5, u4), null === i4[a4][r4 + 1]) {
                    v4.push(x5), m4.push(b4);
                    break;
                  }
                  if (f4 = 1, r4 < i4[a4].length - 2) {
                    var N4 = O3(y4, o3, n3);
                    x5 += N4, b4 += N4;
                    break;
                  }
                case 1:
                  if (null === i4[a4][r4 + 1]) x5 += L4 ? A4.line(g5, c4) : A4.move(g5, u4), b4 += A4.line(g5, S3) + A4.line(p4, S3) + "z", v4.push(x5), m4.push(b4), f4 = -1;
                  else {
                    var W3 = O3(y4, o3, n3);
                    x5 += W3, b4 += W3, r4 >= i4[a4].length - 2 && (L4 && (x5 += A4.line(o3, c4)), b4 += A4.line(o3, S3) + A4.line(p4, S3) + "z", v4.push(x5), m4.push(b4), f4 = -1);
                  }
              }
              g5 = o3, u4 = n3;
          }
          return { linePaths: v4, areaPaths: m4, pX: g5, pY: u4, pathState: f4, segmentStartX: p4, linePath: x5, areaPath: b4 };
        } }, { key: "handleNullDataPoints", value: function(t5, e4, i4, a4, s4) {
          var r4 = this.w;
          if (null === t5[i4][a4] && r4.config.markers.showNullDataPoints || 1 === t5[i4].length) {
            var o3 = this.strokeWidth - r4.config.markers.strokeWidth / 2;
            o3 > 0 || (o3 = 0);
            var n3 = this.markers.plotChartMarkers(e4, s4, a4 + 1, o3, true);
            null !== n3 && this.elPointsMain.add(n3);
          }
        } }]), t4;
      })();
      window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ (function() {
        function t4(e5, i5, a5, s5) {
          this.xoffset = e5, this.yoffset = i5, this.height = s5, this.width = a5, this.shortestEdge = function() {
            return Math.min(this.height, this.width);
          }, this.getCoordinates = function(t5) {
            var e6, i6 = [], a6 = this.xoffset, s6 = this.yoffset, o4 = r4(t5) / this.height, n3 = r4(t5) / this.width;
            if (this.width >= this.height) for (e6 = 0; e6 < t5.length; e6++) i6.push([a6, s6, a6 + o4, s6 + t5[e6] / o4]), s6 += t5[e6] / o4;
            else for (e6 = 0; e6 < t5.length; e6++) i6.push([a6, s6, a6 + t5[e6] / n3, s6 + n3]), a6 += t5[e6] / n3;
            return i6;
          }, this.cutArea = function(e6) {
            var i6;
            if (this.width >= this.height) {
              var a6 = e6 / this.height, s6 = this.width - a6;
              i6 = new t4(this.xoffset + a6, this.yoffset, s6, this.height);
            } else {
              var r5 = e6 / this.width, o4 = this.height - r5;
              i6 = new t4(this.xoffset, this.yoffset + r5, this.width, o4);
            }
            return i6;
          };
        }
        function e4(e5, a5, s5, o4, n3) {
          o4 = void 0 === o4 ? 0 : o4, n3 = void 0 === n3 ? 0 : n3;
          var l4 = i4((function(t5, e6) {
            var i5, a6 = [], s6 = e6 / r4(t5);
            for (i5 = 0; i5 < t5.length; i5++) a6[i5] = t5[i5] * s6;
            return a6;
          })(e5, a5 * s5), [], new t4(o4, n3, a5, s5), []);
          return (function(t5) {
            var e6, i5, a6 = [];
            for (e6 = 0; e6 < t5.length; e6++) for (i5 = 0; i5 < t5[e6].length; i5++) a6.push(t5[e6][i5]);
            return a6;
          })(l4);
        }
        function i4(t5, e5, s5, o4) {
          var n3, l4, h4;
          if (0 !== t5.length) return n3 = s5.shortestEdge(), (function(t6, e6, i5) {
            var s6;
            if (0 === t6.length) return true;
            (s6 = t6.slice()).push(e6);
            var r5 = a4(t6, i5), o5 = a4(s6, i5);
            return r5 >= o5;
          })(e5, l4 = t5[0], n3) ? (e5.push(l4), i4(t5.slice(1), e5, s5, o4)) : (h4 = s5.cutArea(r4(e5), o4), o4.push(s5.getCoordinates(e5)), i4(t5, [], h4, o4)), o4;
          o4.push(s5.getCoordinates(e5));
        }
        function a4(t5, e5) {
          var i5 = Math.min.apply(Math, t5), a5 = Math.max.apply(Math, t5), s5 = r4(t5);
          return Math.max(Math.pow(e5, 2) * a5 / Math.pow(s5, 2), Math.pow(s5, 2) / (Math.pow(e5, 2) * i5));
        }
        function s4(t5) {
          return t5 && t5.constructor === Array;
        }
        function r4(t5) {
          var e5, i5 = 0;
          for (e5 = 0; e5 < t5.length; e5++) i5 += t5[e5];
          return i5;
        }
        function o3(t5) {
          var e5, i5 = 0;
          if (s4(t5[0])) for (e5 = 0; e5 < t5.length; e5++) i5 += o3(t5[e5]);
          else i5 = r4(t5);
          return i5;
        }
        return function t5(i5, a5, r5, n3, l4) {
          n3 = void 0 === n3 ? 0 : n3, l4 = void 0 === l4 ? 0 : l4;
          var h4, c4, d3 = [], g5 = [];
          if (s4(i5[0])) {
            for (c4 = 0; c4 < i5.length; c4++) d3[c4] = o3(i5[c4]);
            for (h4 = e4(d3, a5, r5, n3, l4), c4 = 0; c4 < i5.length; c4++) g5.push(t5(i5[c4], h4[c4][2] - h4[c4][0], h4[c4][3] - h4[c4][1], h4[c4][0], h4[c4][1]));
          } else g5 = e4(i5, a5, r5, n3, l4);
          return g5;
        };
      })();
      var Nt;
      var Wt;
      var Bt = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Pt(e4), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
        }
        return s3(t4, [{ key: "draw", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = new k3(this.ctx), s4 = new N3(this.ctx), r4 = a4.group({ class: "apexcharts-treemap" });
          if (i4.globals.noData) return r4;
          var o3 = [];
          return t5.forEach((function(t6) {
            var e5 = t6.map((function(t7) {
              return Math.abs(t7);
            }));
            o3.push(e5);
          })), this.negRange = this.helpers.checkColorRange(), i4.config.series.forEach((function(t6, i5) {
            t6.data.forEach((function(t7) {
              Array.isArray(e4.labels[i5]) || (e4.labels[i5] = []), e4.labels[i5].push(t7.x);
            }));
          })), window.TreemapSquared.generate(o3, i4.globals.gridWidth, i4.globals.gridHeight).forEach((function(o4, n3) {
            var l4 = a4.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: m3.escapeString(i4.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
            if (i4.config.chart.dropShadow.enabled) {
              var h4 = i4.config.chart.dropShadow;
              new w4(e4.ctx).dropShadow(r4, h4, n3);
            }
            var c4 = a4.group({ class: "apexcharts-data-labels" });
            o4.forEach((function(r5, o5) {
              var h5 = r5[0], c5 = r5[1], d3 = r5[2], g5 = r5[3], u4 = a4.drawRect(h5, c5, d3 - h5, g5 - c5, i4.config.plotOptions.treemap.borderRadius, "#fff", 1, e4.strokeWidth, i4.config.plotOptions.treemap.useFillColorAsStroke ? p4 : i4.globals.stroke.colors[n3]);
              u4.attr({ cx: h5, cy: c5, index: n3, i: n3, j: o5, width: d3 - h5, height: g5 - c5 });
              var f4 = e4.helpers.getShadeColor(i4.config.chart.type, n3, o5, e4.negRange), p4 = f4.color;
              void 0 !== i4.config.series[n3].data[o5] && i4.config.series[n3].data[o5].fillColor && (p4 = i4.config.series[n3].data[o5].fillColor);
              var x5 = s4.fillPath({ color: p4, seriesNumber: n3, dataPointIndex: o5 });
              u4.node.classList.add("apexcharts-treemap-rect"), u4.attr({ fill: x5 }), e4.helpers.addListeners(u4);
              var b4 = { x: h5 + (d3 - h5) / 2, y: c5 + (g5 - c5) / 2, width: 0, height: 0 }, v4 = { x: h5, y: c5, width: d3 - h5, height: g5 - c5 };
              if (i4.config.chart.animations.enabled && !i4.globals.dataChanged) {
                var m4 = 1;
                i4.globals.resized || (m4 = i4.config.chart.animations.speed), e4.animateTreemap(u4, b4, v4, m4);
              }
              if (i4.globals.dataChanged) {
                var y4 = 1;
                e4.dynamicAnim.enabled && i4.globals.shouldAnimate && (y4 = e4.dynamicAnim.speed, i4.globals.previousPaths[n3] && i4.globals.previousPaths[n3][o5] && i4.globals.previousPaths[n3][o5].rect && (b4 = i4.globals.previousPaths[n3][o5].rect), e4.animateTreemap(u4, b4, v4, y4));
              }
              var w5 = e4.getFontSize(r5), k4 = i4.config.dataLabels.formatter(e4.labels[n3][o5], { value: i4.globals.series[n3][o5], seriesIndex: n3, dataPointIndex: o5, w: i4 });
              "truncate" === i4.config.plotOptions.treemap.dataLabels.format && (w5 = parseInt(i4.config.dataLabels.style.fontSize, 10), k4 = e4.truncateLabels(k4, w5, h5, c5, d3, g5));
              var A4 = null;
              i4.globals.series[n3][o5] && (A4 = e4.helpers.calculateDataLabels({ text: k4, x: (h5 + d3) / 2, y: (c5 + g5) / 2 + e4.strokeWidth / 2 + w5 / 3, i: n3, j: o5, colorProps: f4, fontSize: w5, series: t5 })), i4.config.dataLabels.enabled && A4 && e4.rotateToFitLabel(A4, w5, k4, h5, c5, d3, g5), l4.add(u4), null !== A4 && l4.add(A4);
            })), l4.add(c4), r4.add(l4);
          })), r4;
        } }, { key: "getFontSize", value: function(t5) {
          var e4 = this.w;
          var i4, a4, s4, r4, o3 = (function t6(e5) {
            var i5, a5 = 0;
            if (Array.isArray(e5[0])) for (i5 = 0; i5 < e5.length; i5++) a5 += t6(e5[i5]);
            else for (i5 = 0; i5 < e5.length; i5++) a5 += e5[i5].length;
            return a5;
          })(this.labels) / (function t6(e5) {
            var i5, a5 = 0;
            if (Array.isArray(e5[0])) for (i5 = 0; i5 < e5.length; i5++) a5 += t6(e5[i5]);
            else for (i5 = 0; i5 < e5.length; i5++) a5 += 1;
            return a5;
          })(this.labels);
          return i4 = t5[2] - t5[0], a4 = t5[3] - t5[1], s4 = i4 * a4, r4 = Math.pow(s4, 0.5), Math.min(r4 / o3, parseInt(e4.config.dataLabels.style.fontSize, 10));
        } }, { key: "rotateToFitLabel", value: function(t5, e4, i4, a4, s4, r4, o3) {
          var n3 = new k3(this.ctx), l4 = n3.getTextRects(i4, e4);
          if (l4.width + this.w.config.stroke.width + 5 > r4 - a4 && l4.width <= o3 - s4) {
            var h4 = n3.rotateAroundCenter(t5.node);
            t5.node.setAttribute("transform", "rotate(-90 ".concat(h4.x, " ").concat(h4.y, ") translate(").concat(l4.height / 3, ")"));
          }
        } }, { key: "truncateLabels", value: function(t5, e4, i4, a4, s4, r4) {
          var o3 = new k3(this.ctx), n3 = o3.getTextRects(t5, e4).width + this.w.config.stroke.width + 5 > s4 - i4 && r4 - a4 > s4 - i4 ? r4 - a4 : s4 - i4, l4 = o3.getTextBasedOnMaxWidth({ text: t5, maxWidth: n3, fontSize: e4 });
          return t5.length !== l4.length && n3 / e4 < 5 ? "" : l4;
        } }, { key: "animateTreemap", value: function(t5, e4, i4, a4) {
          var s4 = new y3(this.ctx);
          s4.animateRect(t5, { x: e4.x, y: e4.y, width: e4.width, height: e4.height }, { x: i4.x, y: i4.y, width: i4.width, height: i4.height }, a4, (function() {
            s4.animationCompleted(t5);
          }));
        } }]), t4;
      })();
      var Gt = 86400;
      var Vt = 10 / Gt;
      var jt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
        }
        return s3(t4, [{ key: "calculateTimeScaleTicks", value: function(t5, e4) {
          var i4 = this, a4 = this.w;
          if (a4.globals.allSeriesCollapsed) return a4.globals.labels = [], a4.globals.timescaleLabels = [], [];
          var s4 = new L3(this.ctx), r4 = (e4 - t5) / 864e5;
          this.determineInterval(r4), a4.globals.disableZoomIn = false, a4.globals.disableZoomOut = false, r4 < Vt ? a4.globals.disableZoomIn = true : r4 > 5e4 && (a4.globals.disableZoomOut = true);
          var o3 = s4.getTimeUnitsfromTimestamp(t5, e4, this.utc), n3 = a4.globals.gridWidth / r4, l4 = n3 / 24, h4 = l4 / 60, c4 = h4 / 60, d3 = Math.floor(24 * r4), u4 = Math.floor(1440 * r4), f4 = Math.floor(r4 * Gt), p4 = Math.floor(r4), x5 = Math.floor(r4 / 30), b4 = Math.floor(r4 / 365), v4 = { minMillisecond: o3.minMillisecond, minSecond: o3.minSecond, minMinute: o3.minMinute, minHour: o3.minHour, minDate: o3.minDate, minMonth: o3.minMonth, minYear: o3.minYear }, m4 = { firstVal: v4, currentMillisecond: v4.minMillisecond, currentSecond: v4.minSecond, currentMinute: v4.minMinute, currentHour: v4.minHour, currentMonthDate: v4.minDate, currentDate: v4.minDate, currentMonth: v4.minMonth, currentYear: v4.minYear, daysWidthOnXAxis: n3, hoursWidthOnXAxis: l4, minutesWidthOnXAxis: h4, secondsWidthOnXAxis: c4, numberOfSeconds: f4, numberOfMinutes: u4, numberOfHours: d3, numberOfDays: p4, numberOfMonths: x5, numberOfYears: b4 };
          switch (this.tickInterval) {
            case "years":
              this.generateYearScale(m4);
              break;
            case "months":
            case "half_year":
              this.generateMonthScale(m4);
              break;
            case "months_days":
            case "months_fortnight":
            case "days":
            case "week_days":
              this.generateDayScale(m4);
              break;
            case "hours":
              this.generateHourScale(m4);
              break;
            case "minutes_fives":
            case "minutes":
              this.generateMinuteScale(m4);
              break;
            case "seconds_tens":
            case "seconds_fives":
            case "seconds":
              this.generateSecondScale(m4);
          }
          var y4 = this.timeScaleArray.map((function(t6) {
            var e5 = { position: t6.position, unit: t6.unit, year: t6.year, day: t6.day ? t6.day : 1, hour: t6.hour ? t6.hour : 0, month: t6.month + 1 };
            return "month" === t6.unit ? g4(g4({}, e5), {}, { day: 1, value: t6.value + 1 }) : "day" === t6.unit || "hour" === t6.unit ? g4(g4({}, e5), {}, { value: t6.value }) : "minute" === t6.unit ? g4(g4({}, e5), {}, { value: t6.value, minute: t6.value }) : "second" === t6.unit ? g4(g4({}, e5), {}, { value: t6.value, minute: t6.minute, second: t6.second }) : t6;
          }));
          return y4.filter((function(t6) {
            var e5 = 1, s5 = Math.ceil(a4.globals.gridWidth / 120), r5 = t6.value;
            void 0 !== a4.config.xaxis.tickAmount && (s5 = a4.config.xaxis.tickAmount), y4.length > s5 && (e5 = Math.floor(y4.length / s5));
            var o4 = false, n4 = false;
            switch (i4.tickInterval) {
              case "years":
                "year" === t6.unit && (o4 = true);
                break;
              case "half_year":
                e5 = 7, "year" === t6.unit && (o4 = true);
                break;
              case "months":
                e5 = 1, "year" === t6.unit && (o4 = true);
                break;
              case "months_fortnight":
                e5 = 15, "year" !== t6.unit && "month" !== t6.unit || (o4 = true), 30 === r5 && (n4 = true);
                break;
              case "months_days":
                e5 = 10, "month" === t6.unit && (o4 = true), 30 === r5 && (n4 = true);
                break;
              case "week_days":
                e5 = 8, "month" === t6.unit && (o4 = true);
                break;
              case "days":
                e5 = 1, "month" === t6.unit && (o4 = true);
                break;
              case "hours":
                "day" === t6.unit && (o4 = true);
                break;
              case "minutes_fives":
              case "seconds_fives":
                r5 % 5 != 0 && (n4 = true);
                break;
              case "seconds_tens":
                r5 % 10 != 0 && (n4 = true);
            }
            if ("hours" === i4.tickInterval || "minutes_fives" === i4.tickInterval || "seconds_tens" === i4.tickInterval || "seconds_fives" === i4.tickInterval) {
              if (!n4) return true;
            } else if ((r5 % e5 == 0 || o4) && !n4) return true;
          }));
        } }, { key: "recalcDimensionsBasedOnFormat", value: function(t5, e4) {
          var i4 = this.w, a4 = this.formatDates(t5), s4 = this.removeOverlappingTS(a4);
          i4.globals.timescaleLabels = s4.slice(), new ct(this.ctx).plotCoords();
        } }, { key: "determineInterval", value: function(t5) {
          var e4 = 24 * t5, i4 = 60 * e4;
          switch (true) {
            case t5 / 365 > 5:
              this.tickInterval = "years";
              break;
            case t5 > 800:
              this.tickInterval = "half_year";
              break;
            case t5 > 180:
              this.tickInterval = "months";
              break;
            case t5 > 90:
              this.tickInterval = "months_fortnight";
              break;
            case t5 > 60:
              this.tickInterval = "months_days";
              break;
            case t5 > 30:
              this.tickInterval = "week_days";
              break;
            case t5 > 2:
              this.tickInterval = "days";
              break;
            case e4 > 2.4:
              this.tickInterval = "hours";
              break;
            case i4 > 15:
              this.tickInterval = "minutes_fives";
              break;
            case i4 > 5:
              this.tickInterval = "minutes";
              break;
            case i4 > 1:
              this.tickInterval = "seconds_tens";
              break;
            case 60 * i4 > 20:
              this.tickInterval = "seconds_fives";
              break;
            default:
              this.tickInterval = "seconds";
          }
        } }, { key: "generateYearScale", value: function(t5) {
          var e4 = t5.firstVal, i4 = t5.currentMonth, a4 = t5.currentYear, s4 = t5.daysWidthOnXAxis, r4 = t5.numberOfYears, o3 = e4.minYear, n3 = 0, l4 = new L3(this.ctx), h4 = "year";
          if (e4.minDate > 1 || e4.minMonth > 0) {
            var c4 = l4.determineRemainingDaysOfYear(e4.minYear, e4.minMonth, e4.minDate);
            n3 = (l4.determineDaysOfYear(e4.minYear) - c4 + 1) * s4, o3 = e4.minYear + 1, this.timeScaleArray.push({ position: n3, value: o3, unit: h4, year: o3, month: m3.monthMod(i4 + 1) });
          } else 1 === e4.minDate && 0 === e4.minMonth && this.timeScaleArray.push({ position: n3, value: o3, unit: h4, year: a4, month: m3.monthMod(i4 + 1) });
          for (var d3 = o3, g5 = n3, u4 = 0; u4 < r4; u4++) d3++, g5 = l4.determineDaysOfYear(d3 - 1) * s4 + g5, this.timeScaleArray.push({ position: g5, value: d3, unit: h4, year: d3, month: 1 });
        } }, { key: "generateMonthScale", value: function(t5) {
          var e4 = t5.firstVal, i4 = t5.currentMonthDate, a4 = t5.currentMonth, s4 = t5.currentYear, r4 = t5.daysWidthOnXAxis, o3 = t5.numberOfMonths, n3 = a4, l4 = 0, h4 = new L3(this.ctx), c4 = "month", d3 = 0;
          if (e4.minDate > 1) {
            l4 = (h4.determineDaysOfMonths(a4 + 1, e4.minYear) - i4 + 1) * r4, n3 = m3.monthMod(a4 + 1);
            var g5 = s4 + d3, u4 = m3.monthMod(n3), f4 = n3;
            0 === n3 && (c4 = "year", f4 = g5, u4 = 1, g5 += d3 += 1), this.timeScaleArray.push({ position: l4, value: f4, unit: c4, year: g5, month: u4 });
          } else this.timeScaleArray.push({ position: l4, value: n3, unit: c4, year: s4, month: m3.monthMod(a4) });
          for (var p4 = n3 + 1, x5 = l4, b4 = 0, v4 = 1; b4 < o3; b4++, v4++) {
            0 === (p4 = m3.monthMod(p4)) ? (c4 = "year", d3 += 1) : c4 = "month";
            var y4 = this._getYear(s4, p4, d3);
            x5 = h4.determineDaysOfMonths(p4, y4) * r4 + x5;
            var w5 = 0 === p4 ? y4 : p4;
            this.timeScaleArray.push({ position: x5, value: w5, unit: c4, year: y4, month: 0 === p4 ? 1 : p4 }), p4++;
          }
        } }, { key: "generateDayScale", value: function(t5) {
          var e4 = t5.firstVal, i4 = t5.currentMonth, a4 = t5.currentYear, s4 = t5.hoursWidthOnXAxis, r4 = t5.numberOfDays, o3 = new L3(this.ctx), n3 = "day", l4 = e4.minDate + 1, h4 = l4, c4 = function(t6, e5, i5) {
            return t6 > o3.determineDaysOfMonths(e5 + 1, i5) ? (h4 = 1, n3 = "month", g5 = e5 += 1, e5) : e5;
          }, d3 = (24 - e4.minHour) * s4, g5 = l4, u4 = c4(h4, i4, a4);
          0 === e4.minHour && 1 === e4.minDate ? (d3 = 0, g5 = m3.monthMod(e4.minMonth), n3 = "month", h4 = e4.minDate) : 1 !== e4.minDate && 0 === e4.minHour && 0 === e4.minMinute && (d3 = 0, l4 = e4.minDate, g5 = l4, u4 = c4(h4 = l4, i4, a4)), this.timeScaleArray.push({ position: d3, value: g5, unit: n3, year: this._getYear(a4, u4, 0), month: m3.monthMod(u4), day: h4 });
          for (var f4 = d3, p4 = 0; p4 < r4; p4++) {
            n3 = "day", u4 = c4(h4 += 1, u4, this._getYear(a4, u4, 0));
            var x5 = this._getYear(a4, u4, 0);
            f4 = 24 * s4 + f4;
            var b4 = 1 === h4 ? m3.monthMod(u4) : h4;
            this.timeScaleArray.push({ position: f4, value: b4, unit: n3, year: x5, month: m3.monthMod(u4), day: b4 });
          }
        } }, { key: "generateHourScale", value: function(t5) {
          var e4 = t5.firstVal, i4 = t5.currentDate, a4 = t5.currentMonth, s4 = t5.currentYear, r4 = t5.minutesWidthOnXAxis, o3 = t5.numberOfHours, n3 = new L3(this.ctx), l4 = "hour", h4 = function(t6, e5) {
            return t6 > n3.determineDaysOfMonths(e5 + 1, s4) && (p4 = 1, e5 += 1), { month: e5, date: p4 };
          }, c4 = function(t6, e5) {
            return t6 > n3.determineDaysOfMonths(e5 + 1, s4) ? e5 += 1 : e5;
          }, d3 = 60 - (e4.minMinute + e4.minSecond / 60), g5 = d3 * r4, u4 = e4.minHour + 1, f4 = u4;
          60 === d3 && (g5 = 0, f4 = u4 = e4.minHour);
          var p4 = i4;
          f4 >= 24 && (f4 = 0, p4 += 1, l4 = "day");
          var x5 = h4(p4, a4).month;
          x5 = c4(p4, x5), this.timeScaleArray.push({ position: g5, value: u4, unit: l4, day: p4, hour: f4, year: s4, month: m3.monthMod(x5) }), f4++;
          for (var b4 = g5, v4 = 0; v4 < o3; v4++) {
            if (l4 = "hour", f4 >= 24) f4 = 0, l4 = "day", x5 = h4(p4 += 1, x5).month, x5 = c4(p4, x5);
            var y4 = this._getYear(s4, x5, 0);
            b4 = 60 * r4 + b4;
            var w5 = 0 === f4 ? p4 : f4;
            this.timeScaleArray.push({ position: b4, value: w5, unit: l4, hour: f4, day: p4, year: y4, month: m3.monthMod(x5) }), f4++;
          }
        } }, { key: "generateMinuteScale", value: function(t5) {
          for (var e4 = t5.currentMillisecond, i4 = t5.currentSecond, a4 = t5.currentMinute, s4 = t5.currentHour, r4 = t5.currentDate, o3 = t5.currentMonth, n3 = t5.currentYear, l4 = t5.minutesWidthOnXAxis, h4 = t5.secondsWidthOnXAxis, c4 = t5.numberOfMinutes, d3 = a4 + 1, g5 = r4, u4 = o3, f4 = n3, p4 = s4, x5 = (60 - i4 - e4 / 1e3) * h4, b4 = 0; b4 < c4; b4++) d3 >= 60 && (d3 = 0, 24 === (p4 += 1) && (p4 = 0)), this.timeScaleArray.push({ position: x5, value: d3, unit: "minute", hour: p4, minute: d3, day: g5, year: this._getYear(f4, u4, 0), month: m3.monthMod(u4) }), x5 += l4, d3++;
        } }, { key: "generateSecondScale", value: function(t5) {
          for (var e4 = t5.currentMillisecond, i4 = t5.currentSecond, a4 = t5.currentMinute, s4 = t5.currentHour, r4 = t5.currentDate, o3 = t5.currentMonth, n3 = t5.currentYear, l4 = t5.secondsWidthOnXAxis, h4 = t5.numberOfSeconds, c4 = i4 + 1, d3 = a4, g5 = r4, u4 = o3, f4 = n3, p4 = s4, x5 = (1e3 - e4) / 1e3 * l4, b4 = 0; b4 < h4; b4++) c4 >= 60 && (c4 = 0, ++d3 >= 60 && (d3 = 0, 24 === ++p4 && (p4 = 0))), this.timeScaleArray.push({ position: x5, value: c4, unit: "second", hour: p4, minute: d3, second: c4, day: g5, year: this._getYear(f4, u4, 0), month: m3.monthMod(u4) }), x5 += l4, c4++;
        } }, { key: "createRawDateString", value: function(t5, e4) {
          var i4 = t5.year;
          return 0 === t5.month && (t5.month = 1), i4 += "-" + ("0" + t5.month.toString()).slice(-2), "day" === t5.unit ? i4 += "day" === t5.unit ? "-" + ("0" + e4).slice(-2) : "-01" : i4 += "-" + ("0" + (t5.day ? t5.day : "1")).slice(-2), "hour" === t5.unit ? i4 += "hour" === t5.unit ? "T" + ("0" + e4).slice(-2) : "T00" : i4 += "T" + ("0" + (t5.hour ? t5.hour : "0")).slice(-2), "minute" === t5.unit ? i4 += ":" + ("0" + e4).slice(-2) : i4 += ":" + (t5.minute ? ("0" + t5.minute).slice(-2) : "00"), "second" === t5.unit ? i4 += ":" + ("0" + e4).slice(-2) : i4 += ":00", this.utc && (i4 += ".000Z"), i4;
        } }, { key: "formatDates", value: function(t5) {
          var e4 = this, i4 = this.w;
          return t5.map((function(t6) {
            var a4 = t6.value.toString(), s4 = new L3(e4.ctx), r4 = e4.createRawDateString(t6, a4), o3 = s4.getDate(s4.parseDate(r4));
            if (e4.utc || (o3 = s4.getDate(s4.parseDateWithTimezone(r4))), void 0 === i4.config.xaxis.labels.format) {
              var n3 = "dd MMM", l4 = i4.config.xaxis.labels.datetimeFormatter;
              "year" === t6.unit && (n3 = l4.year), "month" === t6.unit && (n3 = l4.month), "day" === t6.unit && (n3 = l4.day), "hour" === t6.unit && (n3 = l4.hour), "minute" === t6.unit && (n3 = l4.minute), "second" === t6.unit && (n3 = l4.second), a4 = s4.formatDate(o3, n3);
            } else a4 = s4.formatDate(o3, i4.config.xaxis.labels.format);
            return { dateString: r4, position: t6.position, value: a4, unit: t6.unit, year: t6.year, month: t6.month };
          }));
        } }, { key: "removeOverlappingTS", value: function(t5) {
          var e4, i4 = this, a4 = new k3(this.ctx), s4 = false;
          t5.length > 0 && t5[0].value && t5.every((function(e5) {
            return e5.value.length === t5[0].value.length;
          })) && (s4 = true, e4 = a4.getTextRects(t5[0].value).width);
          var r4 = 0, o3 = t5.map((function(o4, n3) {
            if (n3 > 0 && i4.w.config.xaxis.labels.hideOverlappingLabels) {
              var l4 = s4 ? e4 : a4.getTextRects(t5[r4].value).width, h4 = t5[r4].position;
              return o4.position > h4 + l4 + 10 ? (r4 = n3, o4) : null;
            }
            return o4;
          }));
          return o3 = o3.filter((function(t6) {
            return null !== t6;
          }));
        } }, { key: "_getYear", value: function(t5, e4, i4) {
          return t5 + Math.floor(e4 / 12) + i4;
        } }]), t4;
      })();
      var _t = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.ctx = a4, this.w = a4.w, this.el = e4;
        }
        return s3(t4, [{ key: "setupElements", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = t5.config, a4 = i4.chart.type;
          e4.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(a4), e4.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(a4), e4.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(a4) && i4.plotOptions.bar.horizontal, e4.chartClass = ".apexcharts".concat(e4.chartID), e4.dom.baseEl = this.el, e4.dom.elWrap = document.createElement("div"), k3.setAttrs(e4.dom.elWrap, { id: e4.chartClass.substring(1), class: "apexcharts-canvas ".concat(e4.chartClass.substring(1)) }), this.el.appendChild(e4.dom.elWrap), e4.dom.Paper = new window.SVG.Doc(e4.dom.elWrap), e4.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i4.chart.offsetX, ", ").concat(i4.chart.offsetY, ")") }), e4.dom.Paper.node.style.background = "dark" !== i4.theme.mode || i4.chart.background ? "light" !== i4.theme.mode || i4.chart.background ? i4.chart.background : "#fff" : "#424242", this.setSVGDimensions(), e4.dom.elLegendForeign = document.createElementNS(e4.SVGNS, "foreignObject"), k3.setAttrs(e4.dom.elLegendForeign, { x: 0, y: 0, width: e4.svgWidth, height: e4.svgHeight }), e4.dom.elLegendWrap = document.createElement("div"), e4.dom.elLegendWrap.classList.add("apexcharts-legend"), e4.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e4.dom.elLegendForeign.appendChild(e4.dom.elLegendWrap), e4.dom.Paper.node.appendChild(e4.dom.elLegendForeign), e4.dom.elGraphical = e4.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), e4.dom.elDefs = e4.dom.Paper.defs(), e4.dom.Paper.add(e4.dom.elGraphical), e4.dom.elGraphical.add(e4.dom.elDefs);
        } }, { key: "plotChartType", value: function(t5, e4) {
          var i4 = this.w, a4 = this.ctx, s4 = i4.config, r4 = i4.globals, o3 = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, column: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, n3 = s4.chart.type || "line", l4 = null, h4 = 0;
          r4.series.forEach((function(e5, a5) {
            var s5 = t5[a5].type || n3;
            o3[s5] ? ("rangeArea" === s5 ? (o3[s5].series.push(r4.seriesRangeStart[a5]), o3[s5].seriesRangeEnd.push(r4.seriesRangeEnd[a5])) : o3[s5].series.push(e5), o3[s5].i.push(a5), "column" !== s5 && "bar" !== s5 || (i4.globals.columnSeries = o3.column)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(s5) ? l4 = s5 : "bar" === s5 ? (o3.column.series.push(e5), o3.column.i.push(a5)) : console.warn("You have specified an unrecognized series type (".concat(s5, ").")), n3 !== s5 && "scatter" !== s5 && h4++;
          })), h4 > 0 && (l4 && console.warn("Chart or series type ".concat(l4, " cannot appear with other chart or series types.")), o3.column.series.length > 0 && s4.plotOptions.bar.horizontal && (h4 -= o3.column.series.length, o3.column = { series: [], i: [] }, i4.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), r4.comboCharts || (r4.comboCharts = h4 > 0);
          var c4 = new Ot(a4, e4), d3 = new Lt(a4, e4);
          a4.pie = new Tt(a4);
          var g5 = new Xt(a4);
          a4.rangeBar = new Et(a4, e4);
          var u4 = new zt(a4), f4 = [];
          if (r4.comboCharts) {
            var x5, b4, v4 = new A3(a4);
            if (o3.area.series.length > 0) (x5 = f4).push.apply(x5, p3(v4.drawSeriesByGroup(o3.area, r4.areaGroups, "area", c4)));
            if (o3.column.series.length > 0) if (s4.chart.stacked) {
              var m4 = new Ct(a4, e4);
              f4.push(m4.draw(o3.column.series, o3.column.i));
            } else a4.bar = new St(a4, e4), f4.push(a4.bar.draw(o3.column.series, o3.column.i));
            if (o3.rangeArea.series.length > 0 && f4.push(c4.draw(o3.rangeArea.series, "rangeArea", o3.rangeArea.i, o3.rangeArea.seriesRangeEnd)), o3.line.series.length > 0) (b4 = f4).push.apply(b4, p3(v4.drawSeriesByGroup(o3.line, r4.lineGroups, "line", c4)));
            if (o3.candlestick.series.length > 0 && f4.push(d3.draw(o3.candlestick.series, "candlestick", o3.candlestick.i)), o3.boxPlot.series.length > 0 && f4.push(d3.draw(o3.boxPlot.series, "boxPlot", o3.boxPlot.i)), o3.rangeBar.series.length > 0 && f4.push(a4.rangeBar.draw(o3.rangeBar.series, o3.rangeBar.i)), o3.scatter.series.length > 0) {
              var y4 = new Ot(a4, e4, true);
              f4.push(y4.draw(o3.scatter.series, "scatter", o3.scatter.i));
            }
            if (o3.bubble.series.length > 0) {
              var w5 = new Ot(a4, e4, true);
              f4.push(w5.draw(o3.bubble.series, "bubble", o3.bubble.i));
            }
          } else switch (s4.chart.type) {
            case "line":
              f4 = c4.draw(r4.series, "line");
              break;
            case "area":
              f4 = c4.draw(r4.series, "area");
              break;
            case "bar":
              if (s4.chart.stacked) f4 = new Ct(a4, e4).draw(r4.series);
              else a4.bar = new St(a4, e4), f4 = a4.bar.draw(r4.series);
              break;
            case "candlestick":
              f4 = new Lt(a4, e4).draw(r4.series, "candlestick");
              break;
            case "boxPlot":
              f4 = new Lt(a4, e4).draw(r4.series, s4.chart.type);
              break;
            case "rangeBar":
              f4 = a4.rangeBar.draw(r4.series);
              break;
            case "rangeArea":
              f4 = c4.draw(r4.seriesRangeStart, "rangeArea", void 0, r4.seriesRangeEnd);
              break;
            case "heatmap":
              f4 = new Mt(a4, e4).draw(r4.series);
              break;
            case "treemap":
              f4 = new Bt(a4, e4).draw(r4.series);
              break;
            case "pie":
            case "donut":
            case "polarArea":
              f4 = a4.pie.draw(r4.series);
              break;
            case "radialBar":
              f4 = g5.draw(r4.series);
              break;
            case "radar":
              f4 = u4.draw(r4.series);
              break;
            default:
              f4 = c4.draw(r4.series);
          }
          return f4;
        } }, { key: "setSVGDimensions", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = t5.config;
          i4.chart.width = i4.chart.width || "100%", i4.chart.height = i4.chart.height || "auto", e4.svgWidth = i4.chart.width, e4.svgHeight = i4.chart.height;
          var a4 = m3.getDimensions(this.el), s4 = i4.chart.width.toString().split(/[0-9]+/g).pop();
          "%" === s4 ? m3.isNumber(a4[0]) && (0 === a4[0].width && (a4 = m3.getDimensions(this.el.parentNode)), e4.svgWidth = a4[0] * parseInt(i4.chart.width, 10) / 100) : "px" !== s4 && "" !== s4 || (e4.svgWidth = parseInt(i4.chart.width, 10));
          var r4 = String(i4.chart.height).toString().split(/[0-9]+/g).pop();
          if ("auto" !== e4.svgHeight && "" !== e4.svgHeight) if ("%" === r4) {
            var o3 = m3.getDimensions(this.el.parentNode);
            e4.svgHeight = o3[1] * parseInt(i4.chart.height, 10) / 100;
          } else e4.svgHeight = parseInt(i4.chart.height, 10);
          else e4.svgHeight = e4.axisCharts ? e4.svgWidth / 1.61 : e4.svgWidth / 1.2;
          if (e4.svgWidth = Math.max(e4.svgWidth, 0), e4.svgHeight = Math.max(e4.svgHeight, 0), k3.setAttrs(e4.dom.Paper.node, { width: e4.svgWidth, height: e4.svgHeight }), "%" !== r4) {
            var n3 = i4.chart.sparkline.enabled ? 0 : e4.axisCharts ? i4.chart.parentHeightOffset : 0;
            e4.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(e4.svgHeight + n3, "px");
          }
          e4.dom.elWrap.style.width = "".concat(e4.svgWidth, "px"), e4.dom.elWrap.style.height = "".concat(e4.svgHeight, "px");
        } }, { key: "shiftGraphPosition", value: function() {
          var t5 = this.w.globals, e4 = t5.translateY, i4 = t5.translateX;
          k3.setAttrs(t5.dom.elGraphical.node, { transform: "translate(".concat(i4, ", ").concat(e4, ")") });
        } }, { key: "resizeNonAxisCharts", value: function() {
          var t5 = this.w, e4 = t5.globals, i4 = 0, a4 = t5.config.chart.sparkline.enabled ? 1 : 15;
          a4 += t5.config.grid.padding.bottom, ["top", "bottom"].includes(t5.config.legend.position) && t5.config.legend.show && !t5.config.legend.floating && (i4 = new gt(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
          var s4 = t5.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r4 = 2.05 * t5.globals.radialSize;
          if (s4 && !t5.config.chart.sparkline.enabled && 0 !== t5.config.plotOptions.radialBar.startAngle) {
            var o3 = m3.getBoundingClientRect(s4);
            r4 = o3.bottom;
            var n3 = o3.bottom - o3.top;
            r4 = Math.max(2.05 * t5.globals.radialSize, n3);
          }
          var l4 = Math.ceil(r4 + e4.translateY + i4 + a4);
          e4.dom.elLegendForeign && e4.dom.elLegendForeign.setAttribute("height", l4), t5.config.chart.height && String(t5.config.chart.height).includes("%") || (e4.dom.elWrap.style.height = "".concat(l4, "px"), k3.setAttrs(e4.dom.Paper.node, { height: l4 }), e4.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(l4, "px"));
        } }, { key: "coreCalculations", value: function() {
          new J2(this.ctx).init();
        } }, { key: "resetGlobals", value: function() {
          var t5 = this, e4 = function() {
            return t5.w.config.series.map((function() {
              return [];
            }));
          }, i4 = new H3(), a4 = this.w.globals;
          i4.initGlobalVars(a4), a4.seriesXvalues = e4(), a4.seriesYvalues = e4();
        } }, { key: "isMultipleY", value: function() {
          return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = true, true);
        } }, { key: "xySettings", value: function() {
          var t5 = this.w, e4 = null;
          if (t5.globals.axisCharts) {
            if ("back" === t5.config.xaxis.crosshairs.position && new it(this.ctx).drawXCrosshairs(), "back" === t5.config.yaxis[0].crosshairs.position && new it(this.ctx).drawYCrosshairs(), "datetime" === t5.config.xaxis.type && void 0 === t5.config.xaxis.labels.formatter) {
              this.ctx.timeScale = new jt(this.ctx);
              var i4 = [];
              isFinite(t5.globals.minX) && isFinite(t5.globals.maxX) && !t5.globals.isBarHorizontal ? i4 = this.ctx.timeScale.calculateTimeScaleTicks(t5.globals.minX, t5.globals.maxX) : t5.globals.isBarHorizontal && (i4 = this.ctx.timeScale.calculateTimeScaleTicks(t5.globals.minY, t5.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i4);
            }
            e4 = new A3(this.ctx).getCalculatedRatios();
          }
          return e4;
        } }, { key: "updateSourceChart", value: function(t5) {
          this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t5.w.globals.minX, max: t5.w.globals.maxX } } } }, false, false);
        } }, { key: "setupBrushHandler", value: function() {
          var t5 = this, e4 = this.w;
          if (e4.config.chart.brush.enabled && "function" != typeof e4.config.chart.events.selection) {
            var i4 = Array.isArray(e4.config.chart.brush.targets) ? e4.config.chart.brush.targets : [e4.config.chart.brush.target];
            i4.forEach((function(e5) {
              var i5 = ApexCharts.getChartByID(e5);
              i5.w.globals.brushSource = t5.ctx, "function" != typeof i5.w.config.chart.events.zoomed && (i5.w.config.chart.events.zoomed = function() {
                return t5.updateSourceChart(i5);
              }), "function" != typeof i5.w.config.chart.events.scrolled && (i5.w.config.chart.events.scrolled = function() {
                return t5.updateSourceChart(i5);
              });
            })), e4.config.chart.events.selection = function(t6, e5) {
              i4.forEach((function(t7) {
                ApexCharts.getChartByID(t7).ctx.updateHelpers._updateOptions({ xaxis: { min: e5.xaxis.min, max: e5.xaxis.max } }, false, false, false, false);
              }));
            };
          }
        } }]), t4;
      })();
      var Ut = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "_updateOptions", value: function(t5) {
          var e4 = this, i4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s4 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r4 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          return new Promise((function(o3) {
            var n3 = [e4.ctx];
            s4 && (n3 = e4.ctx.getSyncedCharts()), e4.ctx.w.globals.isExecCalled && (n3 = [e4.ctx], e4.ctx.w.globals.isExecCalled = false), n3.forEach((function(s5, l4) {
              var h4 = s5.w;
              if (h4.globals.shouldAnimate = a4, i4 || (h4.globals.resized = true, h4.globals.dataChanged = true, a4 && s5.series.getPreviousPaths()), t5 && "object" === b3(t5) && (s5.config = new D3(t5), t5 = A3.extendArrayProps(s5.config, t5, h4), s5.w.globals.chartID !== e4.ctx.w.globals.chartID && delete t5.series, h4.config = m3.extend(h4.config, t5), r4 && (h4.globals.lastXAxis = t5.xaxis ? m3.clone(t5.xaxis) : [], h4.globals.lastYAxis = t5.yaxis ? m3.clone(t5.yaxis) : [], h4.globals.initialConfig = m3.extend({}, h4.config), h4.globals.initialSeries = m3.clone(h4.config.series), t5.series))) {
                for (var c4 = 0; c4 < h4.globals.collapsedSeriesIndices.length; c4++) {
                  var d3 = h4.config.series[h4.globals.collapsedSeriesIndices[c4]];
                  h4.globals.collapsedSeries[c4].data = h4.globals.axisCharts ? d3.data.slice() : d3;
                }
                for (var g5 = 0; g5 < h4.globals.ancillaryCollapsedSeriesIndices.length; g5++) {
                  var u4 = h4.config.series[h4.globals.ancillaryCollapsedSeriesIndices[g5]];
                  h4.globals.ancillaryCollapsedSeries[g5].data = h4.globals.axisCharts ? u4.data.slice() : u4;
                }
                s5.series.emptyCollapsedSeries(h4.config.series);
              }
              return s5.update(t5).then((function() {
                l4 === n3.length - 1 && o3(s5);
              }));
            }));
          }));
        } }, { key: "_updateSeries", value: function(t5, e4) {
          var i4 = this, a4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          return new Promise((function(s4) {
            var r4, o3 = i4.w;
            return o3.globals.shouldAnimate = e4, o3.globals.dataChanged = true, e4 && i4.ctx.series.getPreviousPaths(), o3.globals.axisCharts ? (0 === (r4 = t5.map((function(t6, e5) {
              return i4._extendSeries(t6, e5);
            }))).length && (r4 = [{ data: [] }]), o3.config.series = r4) : o3.config.series = t5.slice(), a4 && (o3.globals.initialConfig.series = m3.clone(o3.config.series), o3.globals.initialSeries = m3.clone(o3.config.series)), i4.ctx.update().then((function() {
              s4(i4.ctx);
            }));
          }));
        } }, { key: "_extendSeries", value: function(t5, e4) {
          var i4 = this.w, a4 = i4.config.series[e4];
          return g4(g4({}, i4.config.series[e4]), {}, { name: t5.name ? t5.name : null == a4 ? void 0 : a4.name, color: t5.color ? t5.color : null == a4 ? void 0 : a4.color, type: t5.type ? t5.type : null == a4 ? void 0 : a4.type, group: t5.group ? t5.group : null == a4 ? void 0 : a4.group, hidden: void 0 !== t5.hidden ? t5.hidden : null == a4 ? void 0 : a4.hidden, data: t5.data ? t5.data : null == a4 ? void 0 : a4.data, zIndex: void 0 !== t5.zIndex ? t5.zIndex : e4 });
        } }, { key: "toggleDataPointSelection", value: function(t5, e4) {
          var i4 = this.w, a4 = null, s4 = ".apexcharts-series[data\\:realIndex='".concat(t5, "']");
          return i4.globals.axisCharts ? a4 = i4.globals.dom.Paper.select("".concat(s4, " path[j='").concat(e4, "'], ").concat(s4, " circle[j='").concat(e4, "'], ").concat(s4, " rect[j='").concat(e4, "']")).members[0] : void 0 === e4 && (a4 = i4.globals.dom.Paper.select("".concat(s4, " path[j='").concat(t5, "']")).members[0], "pie" !== i4.config.chart.type && "polarArea" !== i4.config.chart.type && "donut" !== i4.config.chart.type || this.ctx.pie.pieClicked(t5)), a4 ? (new k3(this.ctx).pathMouseDown(a4, null), a4.node ? a4.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
        } }, { key: "forceXAxisUpdate", value: function(t5) {
          var e4 = this.w;
          if (["min", "max"].forEach((function(i5) {
            void 0 !== t5.xaxis[i5] && (e4.config.xaxis[i5] = t5.xaxis[i5], e4.globals.lastXAxis[i5] = t5.xaxis[i5]);
          })), t5.xaxis.categories && t5.xaxis.categories.length && (e4.config.xaxis.categories = t5.xaxis.categories), e4.config.xaxis.convertedCatToNumeric) {
            var i4 = new F4(t5);
            t5 = i4.convertCatToNumericXaxis(t5, this.ctx);
          }
          return t5;
        } }, { key: "forceYAxisUpdate", value: function(t5) {
          return t5.chart && t5.chart.stacked && "100%" === t5.chart.stackType && (Array.isArray(t5.yaxis) ? t5.yaxis.forEach((function(e4, i4) {
            t5.yaxis[i4].min = 0, t5.yaxis[i4].max = 100;
          })) : (t5.yaxis.min = 0, t5.yaxis.max = 100)), t5;
        } }, { key: "revertDefaultAxisMinMax", value: function(t5) {
          var e4 = this, i4 = this.w, a4 = i4.globals.lastXAxis, s4 = i4.globals.lastYAxis;
          t5 && t5.xaxis && (a4 = t5.xaxis), t5 && t5.yaxis && (s4 = t5.yaxis), i4.config.xaxis.min = a4.min, i4.config.xaxis.max = a4.max;
          var r4 = function(t6) {
            void 0 !== s4[t6] && (i4.config.yaxis[t6].min = s4[t6].min, i4.config.yaxis[t6].max = s4[t6].max);
          };
          i4.config.yaxis.map((function(t6, a5) {
            i4.globals.zoomed || void 0 !== s4[a5] ? r4(a5) : void 0 !== e4.ctx.opts.yaxis[a5] && (t6.min = e4.ctx.opts.yaxis[a5].min, t6.max = e4.ctx.opts.yaxis[a5].max);
          }));
        } }]), t4;
      })();
      Nt = "undefined" != typeof window ? window : void 0, Wt = function(t4, e4) {
        var i4 = (void 0 !== this ? this : t4).SVG = function(t5) {
          if (i4.supported) return t5 = new i4.Doc(t5), i4.parser.draw || i4.prepare(), t5;
        };
        if (i4.ns = "http://www.w3.org/2000/svg", i4.xmlns = "http://www.w3.org/2000/xmlns/", i4.xlink = "http://www.w3.org/1999/xlink", i4.svgjs = "http://svgjs.dev", i4.supported = true, !i4.supported) return false;
        i4.did = 1e3, i4.eid = function(t5) {
          return "Svgjs" + c4(t5) + i4.did++;
        }, i4.create = function(t5) {
          var i5 = e4.createElementNS(this.ns, t5);
          return i5.setAttribute("id", this.eid(t5)), i5;
        }, i4.extend = function() {
          var t5, e5;
          e5 = (t5 = [].slice.call(arguments)).pop();
          for (var a5 = t5.length - 1; a5 >= 0; a5--) if (t5[a5]) for (var s5 in e5) t5[a5].prototype[s5] = e5[s5];
          i4.Set && i4.Set.inherit && i4.Set.inherit();
        }, i4.invent = function(t5) {
          var e5 = "function" == typeof t5.create ? t5.create : function() {
            this.constructor.call(this, i4.create(t5.create));
          };
          return t5.inherit && (e5.prototype = new t5.inherit()), t5.extend && i4.extend(e5, t5.extend), t5.construct && i4.extend(t5.parent || i4.Container, t5.construct), e5;
        }, i4.adopt = function(e5) {
          return e5 ? e5.instance ? e5.instance : ((a5 = "svg" == e5.nodeName ? e5.parentNode instanceof t4.SVGElement ? new i4.Nested() : new i4.Doc() : "linearGradient" == e5.nodeName ? new i4.Gradient("linear") : "radialGradient" == e5.nodeName ? new i4.Gradient("radial") : i4[c4(e5.nodeName)] ? new i4[c4(e5.nodeName)]() : new i4.Element(e5)).type = e5.nodeName, a5.node = e5, e5.instance = a5, a5 instanceof i4.Doc && a5.namespace().defs(), a5.setData(JSON.parse(e5.getAttribute("svgjs:data")) || {}), a5) : null;
          var a5;
        }, i4.prepare = function() {
          var t5 = e4.getElementsByTagName("body")[0], a5 = (t5 ? new i4.Doc(t5) : i4.adopt(e4.documentElement).nested()).size(2, 0);
          i4.parser = { body: t5 || e4.documentElement, draw: a5.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: a5.polyline().node, path: a5.path().node, native: i4.create("svg") };
        }, i4.parser = { native: i4.create("svg") }, e4.addEventListener("DOMContentLoaded", (function() {
          i4.parser.draw || i4.prepare();
        }), false), i4.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, i4.utils = { map: function(t5, e5) {
          for (var i5 = t5.length, a5 = [], s5 = 0; s5 < i5; s5++) a5.push(e5(t5[s5]));
          return a5;
        }, filter: function(t5, e5) {
          for (var i5 = t5.length, a5 = [], s5 = 0; s5 < i5; s5++) e5(t5[s5]) && a5.push(t5[s5]);
          return a5;
        }, filterSVGElements: function(e5) {
          return this.filter(e5, (function(e6) {
            return e6 instanceof t4.SVGElement;
          }));
        } }, i4.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, i4.Color = function(t5) {
          var e5, a5;
          this.r = 0, this.g = 0, this.b = 0, t5 && ("string" == typeof t5 ? i4.regex.isRgb.test(t5) ? (e5 = i4.regex.rgb.exec(t5.replace(i4.regex.whitespace, "")), this.r = parseInt(e5[1]), this.g = parseInt(e5[2]), this.b = parseInt(e5[3])) : i4.regex.isHex.test(t5) && (e5 = i4.regex.hex.exec(4 == (a5 = t5).length ? ["#", a5.substring(1, 2), a5.substring(1, 2), a5.substring(2, 3), a5.substring(2, 3), a5.substring(3, 4), a5.substring(3, 4)].join("") : a5), this.r = parseInt(e5[1], 16), this.g = parseInt(e5[2], 16), this.b = parseInt(e5[3], 16)) : "object" === b3(t5) && (this.r = t5.r, this.g = t5.g, this.b = t5.b));
        }, i4.extend(i4.Color, { toString: function() {
          return this.toHex();
        }, toHex: function() {
          return "#" + d3(this.r) + d3(this.g) + d3(this.b);
        }, toRgb: function() {
          return "rgb(" + [this.r, this.g, this.b].join() + ")";
        }, brightness: function() {
          return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
        }, morph: function(t5) {
          return this.destination = new i4.Color(t5), this;
        }, at: function(t5) {
          return this.destination ? (t5 = t5 < 0 ? 0 : t5 > 1 ? 1 : t5, new i4.Color({ r: ~~(this.r + (this.destination.r - this.r) * t5), g: ~~(this.g + (this.destination.g - this.g) * t5), b: ~~(this.b + (this.destination.b - this.b) * t5) })) : this;
        } }), i4.Color.test = function(t5) {
          return t5 += "", i4.regex.isHex.test(t5) || i4.regex.isRgb.test(t5);
        }, i4.Color.isRgb = function(t5) {
          return t5 && "number" == typeof t5.r && "number" == typeof t5.g && "number" == typeof t5.b;
        }, i4.Color.isColor = function(t5) {
          return i4.Color.isRgb(t5) || i4.Color.test(t5);
        }, i4.Array = function(t5, e5) {
          0 == (t5 = (t5 || []).valueOf()).length && e5 && (t5 = e5.valueOf()), this.value = this.parse(t5);
        }, i4.extend(i4.Array, { toString: function() {
          return this.value.join(" ");
        }, valueOf: function() {
          return this.value;
        }, parse: function(t5) {
          return t5 = t5.valueOf(), Array.isArray(t5) ? t5 : this.split(t5);
        } }), i4.PointArray = function(t5, e5) {
          i4.Array.call(this, t5, e5 || [[0, 0]]);
        }, i4.PointArray.prototype = new i4.Array(), i4.PointArray.prototype.constructor = i4.PointArray;
        for (var a4 = { M: function(t5, e5, i5) {
          return e5.x = i5.x = t5[0], e5.y = i5.y = t5[1], ["M", e5.x, e5.y];
        }, L: function(t5, e5) {
          return e5.x = t5[0], e5.y = t5[1], ["L", t5[0], t5[1]];
        }, H: function(t5, e5) {
          return e5.x = t5[0], ["H", t5[0]];
        }, V: function(t5, e5) {
          return e5.y = t5[0], ["V", t5[0]];
        }, C: function(t5, e5) {
          return e5.x = t5[4], e5.y = t5[5], ["C", t5[0], t5[1], t5[2], t5[3], t5[4], t5[5]];
        }, Q: function(t5, e5) {
          return e5.x = t5[2], e5.y = t5[3], ["Q", t5[0], t5[1], t5[2], t5[3]];
        }, S: function(t5, e5) {
          return e5.x = t5[2], e5.y = t5[3], ["S", t5[0], t5[1], t5[2], t5[3]];
        }, Z: function(t5, e5, i5) {
          return e5.x = i5.x, e5.y = i5.y, ["Z"];
        } }, s4 = "mlhvqtcsaz".split(""), r4 = 0, o3 = s4.length; r4 < o3; ++r4) a4[s4[r4]] = /* @__PURE__ */ (function(t5) {
          return function(e5, i5, s5) {
            if ("H" == t5) e5[0] = e5[0] + i5.x;
            else if ("V" == t5) e5[0] = e5[0] + i5.y;
            else if ("A" == t5) e5[5] = e5[5] + i5.x, e5[6] = e5[6] + i5.y;
            else for (var r5 = 0, o4 = e5.length; r5 < o4; ++r5) e5[r5] = e5[r5] + (r5 % 2 ? i5.y : i5.x);
            if (a4 && "function" == typeof a4[t5]) return a4[t5](e5, i5, s5);
          };
        })(s4[r4].toUpperCase());
        i4.PathArray = function(t5, e5) {
          i4.Array.call(this, t5, e5 || [["M", 0, 0]]);
        }, i4.PathArray.prototype = new i4.Array(), i4.PathArray.prototype.constructor = i4.PathArray, i4.extend(i4.PathArray, { toString: function() {
          return (function(t5) {
            for (var e5 = 0, i5 = t5.length, a5 = ""; e5 < i5; e5++) a5 += t5[e5][0], null != t5[e5][1] && (a5 += t5[e5][1], null != t5[e5][2] && (a5 += " ", a5 += t5[e5][2], null != t5[e5][3] && (a5 += " ", a5 += t5[e5][3], a5 += " ", a5 += t5[e5][4], null != t5[e5][5] && (a5 += " ", a5 += t5[e5][5], a5 += " ", a5 += t5[e5][6], null != t5[e5][7] && (a5 += " ", a5 += t5[e5][7])))));
            return a5 + " ";
          })(this.value);
        }, move: function(t5, e5) {
          var i5 = this.bbox();
          return i5.x, i5.y, this;
        }, at: function(t5) {
          if (!this.destination) return this;
          for (var e5 = this.value, a5 = this.destination.value, s5 = [], r5 = new i4.PathArray(), o4 = 0, n4 = e5.length; o4 < n4; o4++) {
            s5[o4] = [e5[o4][0]];
            for (var l5 = 1, h5 = e5[o4].length; l5 < h5; l5++) s5[o4][l5] = e5[o4][l5] + (a5[o4][l5] - e5[o4][l5]) * t5;
            "A" === s5[o4][0] && (s5[o4][4] = +(0 != s5[o4][4]), s5[o4][5] = +(0 != s5[o4][5]));
          }
          return r5.value = s5, r5;
        }, parse: function(t5) {
          if (t5 instanceof i4.PathArray) return t5.valueOf();
          var e5, s5 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
          t5 = "string" == typeof t5 ? t5.replace(i4.regex.numbersWithDots, l4).replace(i4.regex.pathLetters, " $& ").replace(i4.regex.hyphen, "$1 -").trim().split(i4.regex.delimiter) : t5.reduce((function(t6, e6) {
            return [].concat.call(t6, e6);
          }), []);
          var r5 = [], o4 = new i4.Point(), n4 = new i4.Point(), h5 = 0, c5 = t5.length;
          do {
            i4.regex.isPathLetter.test(t5[h5]) ? (e5 = t5[h5], ++h5) : "M" == e5 ? e5 = "L" : "m" == e5 && (e5 = "l"), r5.push(a4[e5].call(null, t5.slice(h5, h5 += s5[e5.toUpperCase()]).map(parseFloat), o4, n4));
          } while (c5 > h5);
          return r5;
        }, bbox: function() {
          return i4.parser.draw || i4.prepare(), i4.parser.path.setAttribute("d", this.toString()), i4.parser.path.getBBox();
        } }), i4.Number = i4.invent({ create: function(t5, e5) {
          this.value = 0, this.unit = e5 || "", "number" == typeof t5 ? this.value = isNaN(t5) ? 0 : isFinite(t5) ? t5 : t5 < 0 ? -34e37 : 34e37 : "string" == typeof t5 ? (e5 = t5.match(i4.regex.numberAndUnit)) && (this.value = parseFloat(e5[1]), "%" == e5[5] ? this.value /= 100 : "s" == e5[5] && (this.value *= 1e3), this.unit = e5[5]) : t5 instanceof i4.Number && (this.value = t5.valueOf(), this.unit = t5.unit);
        }, extend: { toString: function() {
          return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
        }, toJSON: function() {
          return this.toString();
        }, valueOf: function() {
          return this.value;
        }, plus: function(t5) {
          return t5 = new i4.Number(t5), new i4.Number(this + t5, this.unit || t5.unit);
        }, minus: function(t5) {
          return t5 = new i4.Number(t5), new i4.Number(this - t5, this.unit || t5.unit);
        }, times: function(t5) {
          return t5 = new i4.Number(t5), new i4.Number(this * t5, this.unit || t5.unit);
        }, divide: function(t5) {
          return t5 = new i4.Number(t5), new i4.Number(this / t5, this.unit || t5.unit);
        }, to: function(t5) {
          var e5 = new i4.Number(this);
          return "string" == typeof t5 && (e5.unit = t5), e5;
        }, morph: function(t5) {
          return this.destination = new i4.Number(t5), t5.relative && (this.destination.value += this.value), this;
        }, at: function(t5) {
          return this.destination ? new i4.Number(this.destination).minus(this).times(t5).plus(this) : this;
        } } }), i4.Element = i4.invent({ create: function(t5) {
          this._stroke = i4.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t5) && (this.type = t5.nodeName, this.node.instance = this, this._stroke = t5.getAttribute("stroke") || this._stroke);
        }, extend: { x: function(t5) {
          return this.attr("x", t5);
        }, y: function(t5) {
          return this.attr("y", t5);
        }, cx: function(t5) {
          return null == t5 ? this.x() + this.width() / 2 : this.x(t5 - this.width() / 2);
        }, cy: function(t5) {
          return null == t5 ? this.y() + this.height() / 2 : this.y(t5 - this.height() / 2);
        }, move: function(t5, e5) {
          return this.x(t5).y(e5);
        }, center: function(t5, e5) {
          return this.cx(t5).cy(e5);
        }, width: function(t5) {
          return this.attr("width", t5);
        }, height: function(t5) {
          return this.attr("height", t5);
        }, size: function(t5, e5) {
          var a5 = g5(this, t5, e5);
          return this.width(new i4.Number(a5.width)).height(new i4.Number(a5.height));
        }, clone: function(t5) {
          this.writeDataToDom();
          var e5 = p4(this.node.cloneNode(true));
          return t5 ? t5.add(e5) : this.after(e5), e5;
        }, remove: function() {
          return this.parent() && this.parent().removeElement(this), this;
        }, replace: function(t5) {
          return this.after(t5).remove(), t5;
        }, addTo: function(t5) {
          return t5.put(this);
        }, putIn: function(t5) {
          return t5.add(this);
        }, id: function(t5) {
          return this.attr("id", t5);
        }, show: function() {
          return this.style("display", "");
        }, hide: function() {
          return this.style("display", "none");
        }, visible: function() {
          return "none" != this.style("display");
        }, toString: function() {
          return this.attr("id");
        }, classes: function() {
          var t5 = this.attr("class");
          return null == t5 ? [] : t5.trim().split(i4.regex.delimiter);
        }, hasClass: function(t5) {
          return -1 != this.classes().indexOf(t5);
        }, addClass: function(t5) {
          if (!this.hasClass(t5)) {
            var e5 = this.classes();
            e5.push(t5), this.attr("class", e5.join(" "));
          }
          return this;
        }, removeClass: function(t5) {
          return this.hasClass(t5) && this.attr("class", this.classes().filter((function(e5) {
            return e5 != t5;
          })).join(" ")), this;
        }, toggleClass: function(t5) {
          return this.hasClass(t5) ? this.removeClass(t5) : this.addClass(t5);
        }, reference: function(t5) {
          return i4.get(this.attr(t5));
        }, parent: function(e5) {
          var a5 = this;
          if (!a5.node.parentNode) return null;
          if (a5 = i4.adopt(a5.node.parentNode), !e5) return a5;
          for (; a5 && a5.node instanceof t4.SVGElement; ) {
            if ("string" == typeof e5 ? a5.matches(e5) : a5 instanceof e5) return a5;
            if (!a5.node.parentNode || "#document" == a5.node.parentNode.nodeName) return null;
            a5 = i4.adopt(a5.node.parentNode);
          }
        }, doc: function() {
          return this instanceof i4.Doc ? this : this.parent(i4.Doc);
        }, parents: function(t5) {
          var e5 = [], i5 = this;
          do {
            if (!(i5 = i5.parent(t5)) || !i5.node) break;
            e5.push(i5);
          } while (i5.parent);
          return e5;
        }, matches: function(t5) {
          return (function(t6, e5) {
            return (t6.matches || t6.matchesSelector || t6.msMatchesSelector || t6.mozMatchesSelector || t6.webkitMatchesSelector || t6.oMatchesSelector).call(t6, e5);
          })(this.node, t5);
        }, native: function() {
          return this.node;
        }, svg: function(t5) {
          var a5 = e4.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (!(t5 && this instanceof i4.Parent)) return a5.appendChild(t5 = e4.createElementNS("http://www.w3.org/2000/svg", "svg")), this.writeDataToDom(), t5.appendChild(this.node.cloneNode(true)), a5.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
          a5.innerHTML = "<svg>" + t5.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
          for (var s5 = 0, r5 = a5.firstChild.childNodes.length; s5 < r5; s5++) this.node.appendChild(a5.firstChild.firstChild);
          return this;
        }, writeDataToDom: function() {
          return (this.each || this.lines) && (this.each ? this : this.lines()).each((function() {
            this.writeDataToDom();
          })), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
        }, setData: function(t5) {
          return this.dom = t5, this;
        }, is: function(t5) {
          return (function(t6, e5) {
            return t6 instanceof e5;
          })(this, t5);
        } } }), i4.easing = { "-": function(t5) {
          return t5;
        }, "<>": function(t5) {
          return -Math.cos(t5 * Math.PI) / 2 + 0.5;
        }, ">": function(t5) {
          return Math.sin(t5 * Math.PI / 2);
        }, "<": function(t5) {
          return 1 - Math.cos(t5 * Math.PI / 2);
        } }, i4.morph = function(t5) {
          return function(e5, a5) {
            return new i4.MorphObj(e5, a5).at(t5);
          };
        }, i4.Situation = i4.invent({ create: function(t5) {
          this.init = false, this.reversed = false, this.reversing = false, this.duration = new i4.Number(t5.duration).valueOf(), this.delay = new i4.Number(t5.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t5.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
        } }), i4.FX = i4.invent({ create: function(t5) {
          this._target = t5, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
        }, extend: { animate: function(t5, e5, a5) {
          "object" === b3(t5) && (e5 = t5.ease, a5 = t5.delay, t5 = t5.duration);
          var s5 = new i4.Situation({ duration: t5 || 1e3, delay: a5 || 0, ease: i4.easing[e5 || "-"] || e5 });
          return this.queue(s5), this;
        }, target: function(t5) {
          return t5 && t5 instanceof i4.Element ? (this._target = t5, this) : this._target;
        }, timeToAbsPos: function(t5) {
          return (t5 - this.situation.start) / (this.situation.duration / this._speed);
        }, absPosToTime: function(t5) {
          return this.situation.duration / this._speed * t5 + this.situation.start;
        }, startAnimFrame: function() {
          this.stopAnimFrame(), this.animationFrame = t4.requestAnimationFrame(function() {
            this.step();
          }.bind(this));
        }, stopAnimFrame: function() {
          t4.cancelAnimationFrame(this.animationFrame);
        }, start: function() {
          return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
        }, startCurrent: function() {
          return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
        }, queue: function(t5) {
          return ("function" == typeof t5 || t5 instanceof i4.Situation) && this.situations.push(t5), this.situation || (this.situation = this.situations.shift()), this;
        }, dequeue: function() {
          return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof i4.Situation ? this.start() : this.situation.call(this)), this;
        }, initAnimations: function() {
          var t5, e5 = this.situation;
          if (e5.init) return this;
          for (var a5 in e5.animations) {
            t5 = this.target()[a5](), Array.isArray(t5) || (t5 = [t5]), Array.isArray(e5.animations[a5]) || (e5.animations[a5] = [e5.animations[a5]]);
            for (var s5 = t5.length; s5--; ) e5.animations[a5][s5] instanceof i4.Number && (t5[s5] = new i4.Number(t5[s5])), e5.animations[a5][s5] = t5[s5].morph(e5.animations[a5][s5]);
          }
          for (var a5 in e5.attrs) e5.attrs[a5] = new i4.MorphObj(this.target().attr(a5), e5.attrs[a5]);
          for (var a5 in e5.styles) e5.styles[a5] = new i4.MorphObj(this.target().style(a5), e5.styles[a5]);
          return e5.initialTransformation = this.target().matrixify(), e5.init = true, this;
        }, clearQueue: function() {
          return this.situations = [], this;
        }, clearCurrent: function() {
          return this.situation = null, this;
        }, stop: function(t5, e5) {
          var i5 = this.active;
          return this.active = false, e5 && this.clearQueue(), t5 && this.situation && (!i5 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
        }, after: function(t5) {
          var e5 = this.last();
          return this.target().on("finished.fx", (function i5(a5) {
            a5.detail.situation == e5 && (t5.call(this, e5), this.off("finished.fx", i5));
          })), this._callStart();
        }, during: function(t5) {
          var e5 = this.last(), a5 = function(a6) {
            a6.detail.situation == e5 && t5.call(this, a6.detail.pos, i4.morph(a6.detail.pos), a6.detail.eased, e5);
          };
          return this.target().off("during.fx", a5).on("during.fx", a5), this.after((function() {
            this.off("during.fx", a5);
          })), this._callStart();
        }, afterAll: function(t5) {
          var e5 = function e6(i5) {
            t5.call(this), this.off("allfinished.fx", e6);
          };
          return this.target().off("allfinished.fx", e5).on("allfinished.fx", e5), this._callStart();
        }, last: function() {
          return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
        }, add: function(t5, e5, i5) {
          return this.last()[i5 || "animations"][t5] = e5, this._callStart();
        }, step: function(t5) {
          var e5, i5, a5;
          t5 || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), false !== this.situation.loops ? (e5 = Math.max(this.absPos, 0), i5 = Math.floor(e5), true === this.situation.loops || i5 < this.situation.loops ? (this.pos = e5 - i5, a5 = this.situation.loop, this.situation.loop = i5) : (this.absPos = this.situation.loops, this.pos = 1, a5 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a5) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
          var s5 = this.situation.ease(this.pos);
          for (var r5 in this.situation.once) r5 > this.lastPos && r5 <= s5 && (this.situation.once[r5].call(this.target(), this.pos, s5), delete this.situation.once[r5]);
          return this.active && this.target().fire("during", { pos: this.pos, eased: s5, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s5, this) : this;
        }, eachAt: function() {
          var t5, e5 = this, a5 = this.target(), s5 = this.situation;
          for (var r5 in s5.animations) t5 = [].concat(s5.animations[r5]).map((function(t6) {
            return "string" != typeof t6 && t6.at ? t6.at(s5.ease(e5.pos), e5.pos) : t6;
          })), a5[r5].apply(a5, t5);
          for (var r5 in s5.attrs) t5 = [r5].concat(s5.attrs[r5]).map((function(t6) {
            return "string" != typeof t6 && t6.at ? t6.at(s5.ease(e5.pos), e5.pos) : t6;
          })), a5.attr.apply(a5, t5);
          for (var r5 in s5.styles) t5 = [r5].concat(s5.styles[r5]).map((function(t6) {
            return "string" != typeof t6 && t6.at ? t6.at(s5.ease(e5.pos), e5.pos) : t6;
          })), a5.style.apply(a5, t5);
          if (s5.transforms.length) {
            t5 = s5.initialTransformation, r5 = 0;
            for (var o4 = s5.transforms.length; r5 < o4; r5++) {
              var n4 = s5.transforms[r5];
              n4 instanceof i4.Matrix ? t5 = n4.relative ? t5.multiply(new i4.Matrix().morph(n4).at(s5.ease(this.pos))) : t5.morph(n4).at(s5.ease(this.pos)) : (n4.relative || n4.undo(t5.extract()), t5 = t5.multiply(n4.at(s5.ease(this.pos))));
            }
            a5.matrix(t5);
          }
          return this;
        }, once: function(t5, e5, i5) {
          var a5 = this.last();
          return i5 || (t5 = a5.ease(t5)), a5.once[t5] = e5, this;
        }, _callStart: function() {
          return setTimeout(function() {
            this.start();
          }.bind(this), 0), this;
        } }, parent: i4.Element, construct: { animate: function(t5, e5, a5) {
          return (this.fx || (this.fx = new i4.FX(this))).animate(t5, e5, a5);
        }, delay: function(t5) {
          return (this.fx || (this.fx = new i4.FX(this))).delay(t5);
        }, stop: function(t5, e5) {
          return this.fx && this.fx.stop(t5, e5), this;
        }, finish: function() {
          return this.fx && this.fx.finish(), this;
        } } }), i4.MorphObj = i4.invent({ create: function(t5, e5) {
          return i4.Color.isColor(e5) ? new i4.Color(t5).morph(e5) : i4.regex.delimiter.test(t5) ? i4.regex.pathLetters.test(t5) ? new i4.PathArray(t5).morph(e5) : new i4.Array(t5).morph(e5) : i4.regex.numberAndUnit.test(e5) ? new i4.Number(t5).morph(e5) : (this.value = t5, void (this.destination = e5));
        }, extend: { at: function(t5, e5) {
          return e5 < 1 ? this.value : this.destination;
        }, valueOf: function() {
          return this.value;
        } } }), i4.extend(i4.FX, { attr: function(t5, e5, i5) {
          if ("object" === b3(t5)) for (var a5 in t5) this.attr(a5, t5[a5]);
          else this.add(t5, e5, "attrs");
          return this;
        }, plot: function(t5, e5, i5, a5) {
          return 4 == arguments.length ? this.plot([t5, e5, i5, a5]) : this.add("plot", new (this.target()).morphArray(t5));
        } }), i4.Box = i4.invent({ create: function(t5, e5, a5, s5) {
          if (!("object" !== b3(t5) || t5 instanceof i4.Element)) return i4.Box.call(this, null != t5.left ? t5.left : t5.x, null != t5.top ? t5.top : t5.y, t5.width, t5.height);
          var r5;
          4 == arguments.length && (this.x = t5, this.y = e5, this.width = a5, this.height = s5), null == (r5 = this).x && (r5.x = 0, r5.y = 0, r5.width = 0, r5.height = 0), r5.w = r5.width, r5.h = r5.height, r5.x2 = r5.x + r5.width, r5.y2 = r5.y + r5.height, r5.cx = r5.x + r5.width / 2, r5.cy = r5.y + r5.height / 2;
        } }), i4.BBox = i4.invent({ create: function(t5) {
          if (i4.Box.apply(this, [].slice.call(arguments)), t5 instanceof i4.Element) {
            var a5;
            try {
              if (!e4.documentElement.contains) {
                for (var s5 = t5.node; s5.parentNode; ) s5 = s5.parentNode;
                if (s5 != e4) throw new Error("Element not in the dom");
              }
              a5 = t5.node.getBBox();
            } catch (e5) {
              if (t5 instanceof i4.Shape) {
                i4.parser.draw || i4.prepare();
                var r5 = t5.clone(i4.parser.draw.instance).show();
                r5 && r5.node && "function" == typeof r5.node.getBBox && (a5 = r5.node.getBBox()), r5 && "function" == typeof r5.remove && r5.remove();
              } else a5 = { x: t5.node.clientLeft, y: t5.node.clientTop, width: t5.node.clientWidth, height: t5.node.clientHeight };
            }
            i4.Box.call(this, a5);
          }
        }, inherit: i4.Box, parent: i4.Element, construct: { bbox: function() {
          return new i4.BBox(this);
        } } }), i4.BBox.prototype.constructor = i4.BBox, i4.Matrix = i4.invent({ create: function(t5) {
          var e5 = f4([1, 0, 0, 1, 0, 0]);
          t5 = null === t5 ? e5 : t5 instanceof i4.Element ? t5.matrixify() : "string" == typeof t5 ? f4(t5.split(i4.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f4([].slice.call(arguments)) : Array.isArray(t5) ? f4(t5) : t5 && "object" === b3(t5) ? t5 : e5;
          for (var a5 = v4.length - 1; a5 >= 0; --a5) this[v4[a5]] = null != t5[v4[a5]] ? t5[v4[a5]] : e5[v4[a5]];
        }, extend: { extract: function() {
          var t5 = u4(this, 0, 1);
          u4(this, 1, 0);
          var e5 = 180 / Math.PI * Math.atan2(t5.y, t5.x) - 90;
          return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(e5 * Math.PI / 180) + this.f * Math.sin(e5 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e5 * Math.PI / 180) + this.e * Math.sin(-e5 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e5, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new i4.Matrix(this) };
        }, clone: function() {
          return new i4.Matrix(this);
        }, morph: function(t5) {
          return this.destination = new i4.Matrix(t5), this;
        }, multiply: function(t5) {
          return new i4.Matrix(this.native().multiply((function(t6) {
            return t6 instanceof i4.Matrix || (t6 = new i4.Matrix(t6)), t6;
          })(t5).native()));
        }, inverse: function() {
          return new i4.Matrix(this.native().inverse());
        }, translate: function(t5, e5) {
          return new i4.Matrix(this.native().translate(t5 || 0, e5 || 0));
        }, native: function() {
          for (var t5 = i4.parser.native.createSVGMatrix(), e5 = v4.length - 1; e5 >= 0; e5--) t5[v4[e5]] = this[v4[e5]];
          return t5;
        }, toString: function() {
          return "matrix(" + x5(this.a) + "," + x5(this.b) + "," + x5(this.c) + "," + x5(this.d) + "," + x5(this.e) + "," + x5(this.f) + ")";
        } }, parent: i4.Element, construct: { ctm: function() {
          return new i4.Matrix(this.node.getCTM());
        }, screenCTM: function() {
          if (this instanceof i4.Nested) {
            var t5 = this.rect(1, 1), e5 = t5.node.getScreenCTM();
            return t5.remove(), new i4.Matrix(e5);
          }
          return new i4.Matrix(this.node.getScreenCTM());
        } } }), i4.Point = i4.invent({ create: function(t5, e5) {
          var i5;
          i5 = Array.isArray(t5) ? { x: t5[0], y: t5[1] } : "object" === b3(t5) ? { x: t5.x, y: t5.y } : null != t5 ? { x: t5, y: null != e5 ? e5 : t5 } : { x: 0, y: 0 }, this.x = i5.x, this.y = i5.y;
        }, extend: { clone: function() {
          return new i4.Point(this);
        }, morph: function(t5, e5) {
          return this.destination = new i4.Point(t5, e5), this;
        } } }), i4.extend(i4.Element, { point: function(t5, e5) {
          return new i4.Point(t5, e5).transform(this.screenCTM().inverse());
        } }), i4.extend(i4.Element, { attr: function(t5, e5, a5) {
          if (null == t5) {
            for (t5 = {}, a5 = (e5 = this.node.attributes).length - 1; a5 >= 0; a5--) t5[e5[a5].nodeName] = i4.regex.isNumber.test(e5[a5].nodeValue) ? parseFloat(e5[a5].nodeValue) : e5[a5].nodeValue;
            return t5;
          }
          if ("object" === b3(t5)) for (var s5 in t5) this.attr(s5, t5[s5]);
          else if (null === e5) this.node.removeAttribute(t5);
          else {
            if (null == e5) return null == (e5 = this.node.getAttribute(t5)) ? i4.defaults.attrs[t5] : i4.regex.isNumber.test(e5) ? parseFloat(e5) : e5;
            "stroke-width" == t5 ? this.attr("stroke", parseFloat(e5) > 0 ? this._stroke : null) : "stroke" == t5 && (this._stroke = e5), "fill" != t5 && "stroke" != t5 || (i4.regex.isImage.test(e5) && (e5 = this.doc().defs().image(e5, 0, 0)), e5 instanceof i4.Image && (e5 = this.doc().defs().pattern(0, 0, (function() {
              this.add(e5);
            })))), "number" == typeof e5 ? e5 = new i4.Number(e5) : i4.Color.isColor(e5) ? e5 = new i4.Color(e5) : Array.isArray(e5) && (e5 = new i4.Array(e5)), "leading" == t5 ? this.leading && this.leading(e5) : "string" == typeof a5 ? this.node.setAttributeNS(a5, t5, e5.toString()) : this.node.setAttribute(t5, e5.toString()), !this.rebuild || "font-size" != t5 && "x" != t5 || this.rebuild(t5, e5);
          }
          return this;
        } }), i4.extend(i4.Element, { transform: function(t5, e5) {
          var a5;
          return "object" !== b3(t5) ? (a5 = new i4.Matrix(this).extract(), "string" == typeof t5 ? a5[t5] : a5) : (a5 = new i4.Matrix(this), e5 = !!e5 || !!t5.relative, null != t5.a && (a5 = e5 ? a5.multiply(new i4.Matrix(t5)) : new i4.Matrix(t5)), this.attr("transform", a5));
        } }), i4.extend(i4.Element, { untransform: function() {
          return this.attr("transform", null);
        }, matrixify: function() {
          return (this.attr("transform") || "").split(i4.regex.transforms).slice(0, -1).map((function(t5) {
            var e5 = t5.trim().split("(");
            return [e5[0], e5[1].split(i4.regex.delimiter).map((function(t6) {
              return parseFloat(t6);
            }))];
          })).reduce((function(t5, e5) {
            return "matrix" == e5[0] ? t5.multiply(f4(e5[1])) : t5[e5[0]].apply(t5, e5[1]);
          }), new i4.Matrix());
        }, toParent: function(t5) {
          if (this == t5) return this;
          var e5 = this.screenCTM(), i5 = t5.screenCTM().inverse();
          return this.addTo(t5).untransform().transform(i5.multiply(e5)), this;
        }, toDoc: function() {
          return this.toParent(this.doc());
        } }), i4.Transformation = i4.invent({ create: function(t5, e5) {
          if (arguments.length > 1 && "boolean" != typeof e5) return this.constructor.call(this, [].slice.call(arguments));
          if (Array.isArray(t5)) for (var i5 = 0, a5 = this.arguments.length; i5 < a5; ++i5) this[this.arguments[i5]] = t5[i5];
          else if (t5 && "object" === b3(t5)) for (i5 = 0, a5 = this.arguments.length; i5 < a5; ++i5) this[this.arguments[i5]] = t5[this.arguments[i5]];
          this.inversed = false, true === e5 && (this.inversed = true);
        } }), i4.Translate = i4.invent({ parent: i4.Matrix, inherit: i4.Transformation, create: function(t5, e5) {
          this.constructor.apply(this, [].slice.call(arguments));
        }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), i4.extend(i4.Element, { style: function(t5, e5) {
          if (0 == arguments.length) return this.node.style.cssText || "";
          if (arguments.length < 2) if ("object" === b3(t5)) for (var a5 in t5) this.style(a5, t5[a5]);
          else {
            if (!i4.regex.isCss.test(t5)) return this.node.style[h4(t5)];
            for (t5 = t5.split(/\s*;\s*/).filter((function(t6) {
              return !!t6;
            })).map((function(t6) {
              return t6.split(/\s*:\s*/);
            })); e5 = t5.pop(); ) this.style(e5[0], e5[1]);
          }
          else this.node.style[h4(t5)] = null === e5 || i4.regex.isBlank.test(e5) ? "" : e5;
          return this;
        } }), i4.Parent = i4.invent({ create: function(t5) {
          this.constructor.call(this, t5);
        }, inherit: i4.Element, extend: { children: function() {
          return i4.utils.map(i4.utils.filterSVGElements(this.node.childNodes), (function(t5) {
            return i4.adopt(t5);
          }));
        }, add: function(t5, e5) {
          return null == e5 ? this.node.appendChild(t5.node) : t5.node != this.node.childNodes[e5] && this.node.insertBefore(t5.node, this.node.childNodes[e5]), this;
        }, put: function(t5, e5) {
          return this.add(t5, e5), t5;
        }, has: function(t5) {
          return this.index(t5) >= 0;
        }, index: function(t5) {
          return [].slice.call(this.node.childNodes).indexOf(t5.node);
        }, get: function(t5) {
          return i4.adopt(this.node.childNodes[t5]);
        }, first: function() {
          return this.get(0);
        }, last: function() {
          return this.get(this.node.childNodes.length - 1);
        }, each: function(t5, e5) {
          for (var a5 = this.children(), s5 = 0, r5 = a5.length; s5 < r5; s5++) a5[s5] instanceof i4.Element && t5.apply(a5[s5], [s5, a5]), e5 && a5[s5] instanceof i4.Container && a5[s5].each(t5, e5);
          return this;
        }, removeElement: function(t5) {
          return this.node.removeChild(t5.node), this;
        }, clear: function() {
          for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
          return delete this._defs, this;
        }, defs: function() {
          return this.doc().defs();
        } } }), i4.extend(i4.Parent, { ungroup: function(t5, e5) {
          return 0 === e5 || this instanceof i4.Defs || this.node == i4.parser.draw || (t5 = t5 || (this instanceof i4.Doc ? this : this.parent(i4.Parent)), e5 = e5 || 1 / 0, this.each((function() {
            return this instanceof i4.Defs ? this : this instanceof i4.Parent ? this.ungroup(t5, e5 - 1) : this.toParent(t5);
          })), this.node.firstChild || this.remove()), this;
        }, flatten: function(t5, e5) {
          return this.ungroup(t5, e5);
        } }), i4.Container = i4.invent({ create: function(t5) {
          this.constructor.call(this, t5);
        }, inherit: i4.Parent }), i4.ViewBox = i4.invent({ parent: i4.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach((function(t5) {
          i4.Element.prototype[t5] = function(e5) {
            return i4.on(this.node, t5, e5), this;
          };
        })), i4.listeners = [], i4.handlerMap = [], i4.listenerId = 0, i4.on = function(t5, e5, a5, s5, r5) {
          var o4 = a5.bind(s5 || t5.instance || t5), n4 = (i4.handlerMap.indexOf(t5) + 1 || i4.handlerMap.push(t5)) - 1, l5 = e5.split(".")[0], h5 = e5.split(".")[1] || "*";
          i4.listeners[n4] = i4.listeners[n4] || {}, i4.listeners[n4][l5] = i4.listeners[n4][l5] || {}, i4.listeners[n4][l5][h5] = i4.listeners[n4][l5][h5] || {}, a5._svgjsListenerId || (a5._svgjsListenerId = ++i4.listenerId), i4.listeners[n4][l5][h5][a5._svgjsListenerId] = o4, t5.addEventListener(l5, o4, r5 || { passive: false });
        }, i4.off = function(t5, e5, a5) {
          var s5 = i4.handlerMap.indexOf(t5), r5 = e5 && e5.split(".")[0], o4 = e5 && e5.split(".")[1], n4 = "";
          if (-1 != s5) if (a5) {
            if ("function" == typeof a5 && (a5 = a5._svgjsListenerId), !a5) return;
            i4.listeners[s5][r5] && i4.listeners[s5][r5][o4 || "*"] && (t5.removeEventListener(r5, i4.listeners[s5][r5][o4 || "*"][a5], false), delete i4.listeners[s5][r5][o4 || "*"][a5]);
          } else if (o4 && r5) {
            if (i4.listeners[s5][r5] && i4.listeners[s5][r5][o4]) {
              for (var l5 in i4.listeners[s5][r5][o4]) i4.off(t5, [r5, o4].join("."), l5);
              delete i4.listeners[s5][r5][o4];
            }
          } else if (o4) for (var h5 in i4.listeners[s5]) for (var n4 in i4.listeners[s5][h5]) o4 === n4 && i4.off(t5, [h5, o4].join("."));
          else if (r5) {
            if (i4.listeners[s5][r5]) {
              for (var n4 in i4.listeners[s5][r5]) i4.off(t5, [r5, n4].join("."));
              delete i4.listeners[s5][r5];
            }
          } else {
            for (var h5 in i4.listeners[s5]) i4.off(t5, h5);
            delete i4.listeners[s5], delete i4.handlerMap[s5];
          }
        }, i4.extend(i4.Element, { on: function(t5, e5, a5, s5) {
          return i4.on(this.node, t5, e5, a5, s5), this;
        }, off: function(t5, e5) {
          return i4.off(this.node, t5, e5), this;
        }, fire: function(e5, a5) {
          return e5 instanceof t4.Event ? this.node.dispatchEvent(e5) : this.node.dispatchEvent(e5 = new i4.CustomEvent(e5, { detail: a5, cancelable: true })), this._event = e5, this;
        }, event: function() {
          return this._event;
        } }), i4.Defs = i4.invent({ create: "defs", inherit: i4.Container }), i4.G = i4.invent({ create: "g", inherit: i4.Container, extend: { x: function(t5) {
          return null == t5 ? this.transform("x") : this.transform({ x: t5 - this.x() }, true);
        } }, construct: { group: function() {
          return this.put(new i4.G());
        } } }), i4.Doc = i4.invent({ create: function(t5) {
          t5 && ("svg" == (t5 = "string" == typeof t5 ? e4.getElementById(t5) : t5).nodeName ? this.constructor.call(this, t5) : (this.constructor.call(this, i4.create("svg")), t5.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
        }, inherit: i4.Container, extend: { namespace: function() {
          return this.attr({ xmlns: i4.ns, version: "1.1" }).attr("xmlns:xlink", i4.xlink, i4.xmlns).attr("xmlns:svgjs", i4.svgjs, i4.xmlns);
        }, defs: function() {
          var t5;
          return this._defs || ((t5 = this.node.getElementsByTagName("defs")[0]) ? this._defs = i4.adopt(t5) : this._defs = new i4.Defs(), this.node.appendChild(this._defs.node)), this._defs;
        }, parent: function() {
          return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
        }, remove: function() {
          return this.parent() && this.parent().removeChild(this.node), this;
        }, clear: function() {
          for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
          return delete this._defs, i4.parser.draw && !i4.parser.draw.parentNode && this.node.appendChild(i4.parser.draw), this;
        }, clone: function(t5) {
          this.writeDataToDom();
          var e5 = this.node, i5 = p4(e5.cloneNode(true));
          return t5 ? (t5.node || t5).appendChild(i5.node) : e5.parentNode.insertBefore(i5.node, e5.nextSibling), i5;
        } } }), i4.extend(i4.Element, {}), i4.Gradient = i4.invent({ create: function(t5) {
          this.constructor.call(this, i4.create(t5 + "Gradient")), this.type = t5;
        }, inherit: i4.Container, extend: { at: function(t5, e5, a5) {
          return this.put(new i4.Stop()).update(t5, e5, a5);
        }, update: function(t5) {
          return this.clear(), "function" == typeof t5 && t5.call(this, this), this;
        }, fill: function() {
          return "url(#" + this.id() + ")";
        }, toString: function() {
          return this.fill();
        }, attr: function(t5, e5, a5) {
          return "transform" == t5 && (t5 = "gradientTransform"), i4.Container.prototype.attr.call(this, t5, e5, a5);
        } }, construct: { gradient: function(t5, e5) {
          return this.defs().gradient(t5, e5);
        } } }), i4.extend(i4.Gradient, i4.FX, { from: function(t5, e5) {
          return "radial" == (this._target || this).type ? this.attr({ fx: new i4.Number(t5), fy: new i4.Number(e5) }) : this.attr({ x1: new i4.Number(t5), y1: new i4.Number(e5) });
        }, to: function(t5, e5) {
          return "radial" == (this._target || this).type ? this.attr({ cx: new i4.Number(t5), cy: new i4.Number(e5) }) : this.attr({ x2: new i4.Number(t5), y2: new i4.Number(e5) });
        } }), i4.extend(i4.Defs, { gradient: function(t5, e5) {
          return this.put(new i4.Gradient(t5)).update(e5);
        } }), i4.Stop = i4.invent({ create: "stop", inherit: i4.Element, extend: { update: function(t5) {
          return ("number" == typeof t5 || t5 instanceof i4.Number) && (t5 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t5.opacity && this.attr("stop-opacity", t5.opacity), null != t5.color && this.attr("stop-color", t5.color), null != t5.offset && this.attr("offset", new i4.Number(t5.offset)), this;
        } } }), i4.Pattern = i4.invent({ create: "pattern", inherit: i4.Container, extend: { fill: function() {
          return "url(#" + this.id() + ")";
        }, update: function(t5) {
          return this.clear(), "function" == typeof t5 && t5.call(this, this), this;
        }, toString: function() {
          return this.fill();
        }, attr: function(t5, e5, a5) {
          return "transform" == t5 && (t5 = "patternTransform"), i4.Container.prototype.attr.call(this, t5, e5, a5);
        } }, construct: { pattern: function(t5, e5, i5) {
          return this.defs().pattern(t5, e5, i5);
        } } }), i4.extend(i4.Defs, { pattern: function(t5, e5, a5) {
          return this.put(new i4.Pattern()).update(a5).attr({ x: 0, y: 0, width: t5, height: e5, patternUnits: "userSpaceOnUse" });
        } }), i4.Shape = i4.invent({ create: function(t5) {
          this.constructor.call(this, t5);
        }, inherit: i4.Element }), i4.Symbol = i4.invent({ create: "symbol", inherit: i4.Container, construct: { symbol: function() {
          return this.put(new i4.Symbol());
        } } }), i4.Use = i4.invent({ create: "use", inherit: i4.Shape, extend: { element: function(t5, e5) {
          return this.attr("href", (e5 || "") + "#" + t5, i4.xlink);
        } }, construct: { use: function(t5, e5) {
          return this.put(new i4.Use()).element(t5, e5);
        } } }), i4.Rect = i4.invent({ create: "rect", inherit: i4.Shape, construct: { rect: function(t5, e5) {
          return this.put(new i4.Rect()).size(t5, e5);
        } } }), i4.Circle = i4.invent({ create: "circle", inherit: i4.Shape, construct: { circle: function(t5) {
          return this.put(new i4.Circle()).rx(new i4.Number(t5).divide(2)).move(0, 0);
        } } }), i4.extend(i4.Circle, i4.FX, { rx: function(t5) {
          return this.attr("r", t5);
        }, ry: function(t5) {
          return this.rx(t5);
        } }), i4.Ellipse = i4.invent({ create: "ellipse", inherit: i4.Shape, construct: { ellipse: function(t5, e5) {
          return this.put(new i4.Ellipse()).size(t5, e5).move(0, 0);
        } } }), i4.extend(i4.Ellipse, i4.Rect, i4.FX, { rx: function(t5) {
          return this.attr("rx", t5);
        }, ry: function(t5) {
          return this.attr("ry", t5);
        } }), i4.extend(i4.Circle, i4.Ellipse, { x: function(t5) {
          return null == t5 ? this.cx() - this.rx() : this.cx(t5 + this.rx());
        }, y: function(t5) {
          return null == t5 ? this.cy() - this.ry() : this.cy(t5 + this.ry());
        }, cx: function(t5) {
          return null == t5 ? this.attr("cx") : this.attr("cx", t5);
        }, cy: function(t5) {
          return null == t5 ? this.attr("cy") : this.attr("cy", t5);
        }, width: function(t5) {
          return null == t5 ? 2 * this.rx() : this.rx(new i4.Number(t5).divide(2));
        }, height: function(t5) {
          return null == t5 ? 2 * this.ry() : this.ry(new i4.Number(t5).divide(2));
        }, size: function(t5, e5) {
          var a5 = g5(this, t5, e5);
          return this.rx(new i4.Number(a5.width).divide(2)).ry(new i4.Number(a5.height).divide(2));
        } }), i4.Line = i4.invent({ create: "line", inherit: i4.Shape, extend: { array: function() {
          return new i4.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
        }, plot: function(t5, e5, a5, s5) {
          return null == t5 ? this.array() : (t5 = void 0 !== e5 ? { x1: t5, y1: e5, x2: a5, y2: s5 } : new i4.PointArray(t5).toLine(), this.attr(t5));
        }, move: function(t5, e5) {
          return this.attr(this.array().move(t5, e5).toLine());
        }, size: function(t5, e5) {
          var i5 = g5(this, t5, e5);
          return this.attr(this.array().size(i5.width, i5.height).toLine());
        } }, construct: { line: function(t5, e5, a5, s5) {
          return i4.Line.prototype.plot.apply(this.put(new i4.Line()), null != t5 ? [t5, e5, a5, s5] : [0, 0, 0, 0]);
        } } }), i4.Polyline = i4.invent({ create: "polyline", inherit: i4.Shape, construct: { polyline: function(t5) {
          return this.put(new i4.Polyline()).plot(t5 || new i4.PointArray());
        } } }), i4.Polygon = i4.invent({ create: "polygon", inherit: i4.Shape, construct: { polygon: function(t5) {
          return this.put(new i4.Polygon()).plot(t5 || new i4.PointArray());
        } } }), i4.extend(i4.Polyline, i4.Polygon, { array: function() {
          return this._array || (this._array = new i4.PointArray(this.attr("points")));
        }, plot: function(t5) {
          return null == t5 ? this.array() : this.clear().attr("points", "string" == typeof t5 ? t5 : this._array = new i4.PointArray(t5));
        }, clear: function() {
          return delete this._array, this;
        }, move: function(t5, e5) {
          return this.attr("points", this.array().move(t5, e5));
        }, size: function(t5, e5) {
          var i5 = g5(this, t5, e5);
          return this.attr("points", this.array().size(i5.width, i5.height));
        } }), i4.extend(i4.Line, i4.Polyline, i4.Polygon, { morphArray: i4.PointArray, x: function(t5) {
          return null == t5 ? this.bbox().x : this.move(t5, this.bbox().y);
        }, y: function(t5) {
          return null == t5 ? this.bbox().y : this.move(this.bbox().x, t5);
        }, width: function(t5) {
          var e5 = this.bbox();
          return null == t5 ? e5.width : this.size(t5, e5.height);
        }, height: function(t5) {
          var e5 = this.bbox();
          return null == t5 ? e5.height : this.size(e5.width, t5);
        } }), i4.Path = i4.invent({ create: "path", inherit: i4.Shape, extend: { morphArray: i4.PathArray, array: function() {
          return this._array || (this._array = new i4.PathArray(this.attr("d")));
        }, plot: function(t5) {
          return null == t5 ? this.array() : this.clear().attr("d", "string" == typeof t5 ? t5 : this._array = new i4.PathArray(t5));
        }, clear: function() {
          return delete this._array, this;
        } }, construct: { path: function(t5) {
          return this.put(new i4.Path()).plot(t5 || new i4.PathArray());
        } } }), i4.Image = i4.invent({ create: "image", inherit: i4.Shape, extend: { load: function(e5) {
          if (!e5) return this;
          var a5 = this, s5 = new t4.Image();
          return i4.on(s5, "load", (function() {
            i4.off(s5);
            var t5 = a5.parent(i4.Pattern);
            null !== t5 && (0 == a5.width() && 0 == a5.height() && a5.size(s5.width, s5.height), t5 && 0 == t5.width() && 0 == t5.height() && t5.size(a5.width(), a5.height()), "function" == typeof a5._loaded && a5._loaded.call(a5, { width: s5.width, height: s5.height, ratio: s5.width / s5.height, url: e5 }));
          })), i4.on(s5, "error", (function(t5) {
            i4.off(s5), "function" == typeof a5._error && a5._error.call(a5, t5);
          })), this.attr("href", s5.src = this.src = e5, i4.xlink);
        }, loaded: function(t5) {
          return this._loaded = t5, this;
        }, error: function(t5) {
          return this._error = t5, this;
        } }, construct: { image: function(t5, e5, a5) {
          return this.put(new i4.Image()).load(t5).size(e5 || 0, a5 || e5 || 0);
        } } }), i4.Text = i4.invent({ create: function() {
          this.constructor.call(this, i4.create("text")), this.dom.leading = new i4.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", i4.defaults.attrs["font-family"]);
        }, inherit: i4.Shape, extend: { x: function(t5) {
          return null == t5 ? this.attr("x") : this.attr("x", t5);
        }, text: function(t5) {
          if (void 0 === t5) {
            t5 = "";
            for (var e5 = this.node.childNodes, a5 = 0, s5 = e5.length; a5 < s5; ++a5) 0 != a5 && 3 != e5[a5].nodeType && 1 == i4.adopt(e5[a5]).dom.newLined && (t5 += "\n"), t5 += e5[a5].textContent;
            return t5;
          }
          if (this.clear().build(true), "function" == typeof t5) t5.call(this, this);
          else {
            a5 = 0;
            for (var r5 = (t5 = t5.split("\n")).length; a5 < r5; a5++) this.tspan(t5[a5]).newLine();
          }
          return this.build(false).rebuild();
        }, size: function(t5) {
          return this.attr("font-size", t5).rebuild();
        }, leading: function(t5) {
          return null == t5 ? this.dom.leading : (this.dom.leading = new i4.Number(t5), this.rebuild());
        }, lines: function() {
          var t5 = (this.textPath && this.textPath() || this).node, e5 = i4.utils.map(i4.utils.filterSVGElements(t5.childNodes), (function(t6) {
            return i4.adopt(t6);
          }));
          return new i4.Set(e5);
        }, rebuild: function(t5) {
          if ("boolean" == typeof t5 && (this._rebuild = t5), this._rebuild) {
            var e5 = this, a5 = 0, s5 = this.dom.leading * new i4.Number(this.attr("font-size"));
            this.lines().each((function() {
              this.dom.newLined && (e5.textPath() || this.attr("x", e5.attr("x")), "\n" == this.text() ? a5 += s5 : (this.attr("dy", s5 + a5), a5 = 0));
            })), this.fire("rebuild");
          }
          return this;
        }, build: function(t5) {
          return this._build = !!t5, this;
        }, setData: function(t5) {
          return this.dom = t5, this.dom.leading = new i4.Number(t5.leading || 1.3), this;
        } }, construct: { text: function(t5) {
          return this.put(new i4.Text()).text(t5);
        }, plain: function(t5) {
          return this.put(new i4.Text()).plain(t5);
        } } }), i4.Tspan = i4.invent({ create: "tspan", inherit: i4.Shape, extend: { text: function(t5) {
          return null == t5 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t5 ? t5.call(this, this) : this.plain(t5), this);
        }, dx: function(t5) {
          return this.attr("dx", t5);
        }, dy: function(t5) {
          return this.attr("dy", t5);
        }, newLine: function() {
          var t5 = this.parent(i4.Text);
          return this.dom.newLined = true, this.dy(t5.dom.leading * t5.attr("font-size")).attr("x", t5.x());
        } } }), i4.extend(i4.Text, i4.Tspan, { plain: function(t5) {
          return false === this._build && this.clear(), this.node.appendChild(e4.createTextNode(t5)), this;
        }, tspan: function(t5) {
          var e5 = (this.textPath && this.textPath() || this).node, a5 = new i4.Tspan();
          return false === this._build && this.clear(), e5.appendChild(a5.node), a5.text(t5);
        }, clear: function() {
          for (var t5 = (this.textPath && this.textPath() || this).node; t5.hasChildNodes(); ) t5.removeChild(t5.lastChild);
          return this;
        }, length: function() {
          return this.node.getComputedTextLength();
        } }), i4.TextPath = i4.invent({ create: "textPath", inherit: i4.Parent, parent: i4.Text, construct: { morphArray: i4.PathArray, array: function() {
          var t5 = this.track();
          return t5 ? t5.array() : null;
        }, plot: function(t5) {
          var e5 = this.track(), i5 = null;
          return e5 && (i5 = e5.plot(t5)), null == t5 ? i5 : this;
        }, track: function() {
          var t5 = this.textPath();
          if (t5) return t5.reference("href");
        }, textPath: function() {
          if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return i4.adopt(this.node.firstChild);
        } } }), i4.Nested = i4.invent({ create: function() {
          this.constructor.call(this, i4.create("svg")), this.style("overflow", "visible");
        }, inherit: i4.Container, construct: { nested: function() {
          return this.put(new i4.Nested());
        } } });
        var n3 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t5, e5) {
          return "color" == e5 ? t5 : t5 + "-" + e5;
        } };
        function l4(t5, e5, a5, s5) {
          return a5 + s5.replace(i4.regex.dots, " .");
        }
        function h4(t5) {
          return t5.toLowerCase().replace(/-(.)/g, (function(t6, e5) {
            return e5.toUpperCase();
          }));
        }
        function c4(t5) {
          return t5.charAt(0).toUpperCase() + t5.slice(1);
        }
        function d3(t5) {
          var e5 = t5.toString(16);
          return 1 == e5.length ? "0" + e5 : e5;
        }
        function g5(t5, e5, i5) {
          if (null == e5 || null == i5) {
            var a5 = t5.bbox();
            null == e5 ? e5 = a5.width / a5.height * i5 : null == i5 && (i5 = a5.height / a5.width * e5);
          }
          return { width: e5, height: i5 };
        }
        function u4(t5, e5, i5) {
          return { x: e5 * t5.a + i5 * t5.c + 0, y: e5 * t5.b + i5 * t5.d + 0 };
        }
        function f4(t5) {
          return { a: t5[0], b: t5[1], c: t5[2], d: t5[3], e: t5[4], f: t5[5] };
        }
        function p4(e5) {
          for (var a5 = e5.childNodes.length - 1; a5 >= 0; a5--) e5.childNodes[a5] instanceof t4.SVGElement && p4(e5.childNodes[a5]);
          return i4.adopt(e5).id(i4.eid(e5.nodeName));
        }
        function x5(t5) {
          return Math.abs(t5) > 1e-37 ? t5 : 0;
        }
        ["fill", "stroke"].forEach((function(t5) {
          var e5 = {};
          e5[t5] = function(e6) {
            if (void 0 === e6) return this;
            if ("string" == typeof e6 || i4.Color.isRgb(e6) || e6 && "function" == typeof e6.fill) this.attr(t5, e6);
            else for (var a5 = n3[t5].length - 1; a5 >= 0; a5--) null != e6[n3[t5][a5]] && this.attr(n3.prefix(t5, n3[t5][a5]), e6[n3[t5][a5]]);
            return this;
          }, i4.extend(i4.Element, i4.FX, e5);
        })), i4.extend(i4.Element, i4.FX, { translate: function(t5, e5) {
          return this.transform({ x: t5, y: e5 });
        }, matrix: function(t5) {
          return this.attr("transform", new i4.Matrix(6 == arguments.length ? [].slice.call(arguments) : t5));
        }, opacity: function(t5) {
          return this.attr("opacity", t5);
        }, dx: function(t5) {
          return this.x(new i4.Number(t5).plus(this instanceof i4.FX ? 0 : this.x()), true);
        }, dy: function(t5) {
          return this.y(new i4.Number(t5).plus(this instanceof i4.FX ? 0 : this.y()), true);
        } }), i4.extend(i4.Path, { length: function() {
          return this.node.getTotalLength();
        }, pointAt: function(t5) {
          return this.node.getPointAtLength(t5);
        } }), i4.Set = i4.invent({ create: function(t5) {
          Array.isArray(t5) ? this.members = t5 : this.clear();
        }, extend: { add: function() {
          for (var t5 = [].slice.call(arguments), e5 = 0, i5 = t5.length; e5 < i5; e5++) this.members.push(t5[e5]);
          return this;
        }, remove: function(t5) {
          var e5 = this.index(t5);
          return e5 > -1 && this.members.splice(e5, 1), this;
        }, each: function(t5) {
          for (var e5 = 0, i5 = this.members.length; e5 < i5; e5++) t5.apply(this.members[e5], [e5, this.members]);
          return this;
        }, clear: function() {
          return this.members = [], this;
        }, length: function() {
          return this.members.length;
        }, has: function(t5) {
          return this.index(t5) >= 0;
        }, index: function(t5) {
          return this.members.indexOf(t5);
        }, get: function(t5) {
          return this.members[t5];
        }, first: function() {
          return this.get(0);
        }, last: function() {
          return this.get(this.members.length - 1);
        }, valueOf: function() {
          return this.members;
        } }, construct: { set: function(t5) {
          return new i4.Set(t5);
        } } }), i4.FX.Set = i4.invent({ create: function(t5) {
          this.set = t5;
        } }), i4.Set.inherit = function() {
          var t5 = [];
          for (var e5 in i4.Shape.prototype) "function" == typeof i4.Shape.prototype[e5] && "function" != typeof i4.Set.prototype[e5] && t5.push(e5);
          for (var e5 in t5.forEach((function(t6) {
            i4.Set.prototype[t6] = function() {
              for (var e6 = 0, a5 = this.members.length; e6 < a5; e6++) this.members[e6] && "function" == typeof this.members[e6][t6] && this.members[e6][t6].apply(this.members[e6], arguments);
              return "animate" == t6 ? this.fx || (this.fx = new i4.FX.Set(this)) : this;
            };
          })), t5 = [], i4.FX.prototype) "function" == typeof i4.FX.prototype[e5] && "function" != typeof i4.FX.Set.prototype[e5] && t5.push(e5);
          t5.forEach((function(t6) {
            i4.FX.Set.prototype[t6] = function() {
              for (var e6 = 0, i5 = this.set.members.length; e6 < i5; e6++) this.set.members[e6].fx[t6].apply(this.set.members[e6].fx, arguments);
              return this;
            };
          }));
        }, i4.extend(i4.Element, {}), i4.extend(i4.Element, { remember: function(t5, e5) {
          if ("object" === b3(arguments[0])) for (var i5 in t5) this.remember(i5, t5[i5]);
          else {
            if (1 == arguments.length) return this.memory()[t5];
            this.memory()[t5] = e5;
          }
          return this;
        }, forget: function() {
          if (0 == arguments.length) this._memory = {};
          else for (var t5 = arguments.length - 1; t5 >= 0; t5--) delete this.memory()[arguments[t5]];
          return this;
        }, memory: function() {
          return this._memory || (this._memory = {});
        } }), i4.get = function(t5) {
          var a5 = e4.getElementById((function(t6) {
            var e5 = (t6 || "").toString().match(i4.regex.reference);
            if (e5) return e5[1];
          })(t5) || t5);
          return i4.adopt(a5);
        }, i4.select = function(t5, a5) {
          return new i4.Set(i4.utils.map((a5 || e4).querySelectorAll(t5), (function(t6) {
            return i4.adopt(t6);
          })));
        }, i4.extend(i4.Parent, { select: function(t5) {
          return i4.select(t5, this.node);
        } });
        var v4 = "abcdef".split("");
        if ("function" != typeof t4.CustomEvent) {
          var m4 = function(t5, i5) {
            i5 = i5 || { bubbles: false, cancelable: false, detail: void 0 };
            var a5 = e4.createEvent("CustomEvent");
            return a5.initCustomEvent(t5, i5.bubbles, i5.cancelable, i5.detail), a5;
          };
          m4.prototype = t4.Event.prototype, i4.CustomEvent = m4;
        } else i4.CustomEvent = t4.CustomEvent;
        return i4;
      }, "function" == typeof define && define.amd ? define((function() {
        return Wt(Nt, Nt.document);
      })) : "object" === ("undefined" == typeof exports ? "undefined" : b3(exports)) && "undefined" != typeof module ? module.exports = Nt.document ? Wt(Nt, Nt.document) : function(t4) {
        return Wt(t4, t4.document);
      } : Nt.SVG = Wt(Nt, Nt.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
      * https://github.com/wout/svg.filter.js
      * Copyright (c) 2016 Wout Fierens; Licensed MIT */
      function() {
        SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t5, e5) {
          return this.add(t5, e5), !t5.attr("in") && this.autoSetIn && t5.attr("in", this.source), t5.attr("result") || t5.attr("result", t5), t5;
        }, blend: function(t5, e5, i5) {
          return this.put(new SVG.BlendEffect(t5, e5, i5));
        }, colorMatrix: function(t5, e5) {
          return this.put(new SVG.ColorMatrixEffect(t5, e5));
        }, convolveMatrix: function(t5) {
          return this.put(new SVG.ConvolveMatrixEffect(t5));
        }, componentTransfer: function(t5) {
          return this.put(new SVG.ComponentTransferEffect(t5));
        }, composite: function(t5, e5, i5) {
          return this.put(new SVG.CompositeEffect(t5, e5, i5));
        }, flood: function(t5, e5) {
          return this.put(new SVG.FloodEffect(t5, e5));
        }, offset: function(t5, e5) {
          return this.put(new SVG.OffsetEffect(t5, e5));
        }, image: function(t5) {
          return this.put(new SVG.ImageEffect(t5));
        }, merge: function() {
          var t5 = [void 0];
          for (var e5 in arguments) t5.push(arguments[e5]);
          return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t5))());
        }, gaussianBlur: function(t5, e5) {
          return this.put(new SVG.GaussianBlurEffect(t5, e5));
        }, morphology: function(t5, e5) {
          return this.put(new SVG.MorphologyEffect(t5, e5));
        }, diffuseLighting: function(t5, e5, i5) {
          return this.put(new SVG.DiffuseLightingEffect(t5, e5, i5));
        }, displacementMap: function(t5, e5, i5, a5, s5) {
          return this.put(new SVG.DisplacementMapEffect(t5, e5, i5, a5, s5));
        }, specularLighting: function(t5, e5, i5, a5) {
          return this.put(new SVG.SpecularLightingEffect(t5, e5, i5, a5));
        }, tile: function() {
          return this.put(new SVG.TileEffect());
        }, turbulence: function(t5, e5, i5, a5, s5) {
          return this.put(new SVG.TurbulenceEffect(t5, e5, i5, a5, s5));
        }, toString: function() {
          return "url(#" + this.attr("id") + ")";
        } } }), SVG.extend(SVG.Defs, { filter: function(t5) {
          var e5 = this.put(new SVG.Filter());
          return "function" == typeof t5 && t5.call(e5, e5), e5;
        } }), SVG.extend(SVG.Container, { filter: function(t5) {
          return this.defs().filter(t5);
        } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t5) {
          return this.filterer = t5 instanceof SVG.Element ? t5 : this.doc().filter(t5), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
        }, unfilter: function(t5) {
          return this.filterer && true === t5 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
        } }), SVG.Effect = SVG.invent({ create: function() {
          this.constructor.call(this);
        }, inherit: SVG.Element, extend: { in: function(t5) {
          return null == t5 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t5);
        }, result: function(t5) {
          return null == t5 ? this.attr("result") : this.attr("result", t5);
        }, toString: function() {
          return this.result();
        } } }), SVG.ParentEffect = SVG.invent({ create: function() {
          this.constructor.call(this);
        }, inherit: SVG.Parent, extend: { in: function(t5) {
          return null == t5 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t5);
        }, result: function(t5) {
          return null == t5 ? this.attr("result") : this.attr("result", t5);
        }, toString: function() {
          return this.result();
        } } });
        var t4 = { blend: function(t5, e5) {
          return this.parent() && this.parent().blend(this, t5, e5);
        }, colorMatrix: function(t5, e5) {
          return this.parent() && this.parent().colorMatrix(t5, e5).in(this);
        }, convolveMatrix: function(t5) {
          return this.parent() && this.parent().convolveMatrix(t5).in(this);
        }, componentTransfer: function(t5) {
          return this.parent() && this.parent().componentTransfer(t5).in(this);
        }, composite: function(t5, e5) {
          return this.parent() && this.parent().composite(this, t5, e5);
        }, flood: function(t5, e5) {
          return this.parent() && this.parent().flood(t5, e5);
        }, offset: function(t5, e5) {
          return this.parent() && this.parent().offset(t5, e5).in(this);
        }, image: function(t5) {
          return this.parent() && this.parent().image(t5);
        }, merge: function() {
          return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
        }, gaussianBlur: function(t5, e5) {
          return this.parent() && this.parent().gaussianBlur(t5, e5).in(this);
        }, morphology: function(t5, e5) {
          return this.parent() && this.parent().morphology(t5, e5).in(this);
        }, diffuseLighting: function(t5, e5, i5) {
          return this.parent() && this.parent().diffuseLighting(t5, e5, i5).in(this);
        }, displacementMap: function(t5, e5, i5, a5) {
          return this.parent() && this.parent().displacementMap(this, t5, e5, i5, a5);
        }, specularLighting: function(t5, e5, i5, a5) {
          return this.parent() && this.parent().specularLighting(t5, e5, i5, a5).in(this);
        }, tile: function() {
          return this.parent() && this.parent().tile().in(this);
        }, turbulence: function(t5, e5, i5, a5, s5) {
          return this.parent() && this.parent().turbulence(t5, e5, i5, a5, s5).in(this);
        } };
        SVG.extend(SVG.Effect, t4), SVG.extend(SVG.ParentEffect, t4), SVG.ChildEffect = SVG.invent({ create: function() {
          this.constructor.call(this);
        }, inherit: SVG.Element, extend: { in: function(t5) {
          this.attr("in", t5);
        } } });
        var e4 = { blend: function(t5, e5, i5) {
          this.attr({ in: t5, in2: e5, mode: i5 || "normal" });
        }, colorMatrix: function(t5, e5) {
          "matrix" == t5 && (e5 = s4(e5)), this.attr({ type: t5, values: void 0 === e5 ? null : e5 });
        }, convolveMatrix: function(t5) {
          t5 = s4(t5), this.attr({ order: Math.sqrt(t5.split(" ").length), kernelMatrix: t5 });
        }, composite: function(t5, e5, i5) {
          this.attr({ in: t5, in2: e5, operator: i5 });
        }, flood: function(t5, e5) {
          this.attr("flood-color", t5), null != e5 && this.attr("flood-opacity", e5);
        }, offset: function(t5, e5) {
          this.attr({ dx: t5, dy: e5 });
        }, image: function(t5) {
          this.attr("href", t5, SVG.xlink);
        }, displacementMap: function(t5, e5, i5, a5, s5) {
          this.attr({ in: t5, in2: e5, scale: i5, xChannelSelector: a5, yChannelSelector: s5 });
        }, gaussianBlur: function(t5, e5) {
          null != t5 || null != e5 ? this.attr("stdDeviation", (function(t6) {
            if (!Array.isArray(t6)) return t6;
            for (var e6 = 0, i5 = t6.length, a5 = []; e6 < i5; e6++) a5.push(t6[e6]);
            return a5.join(" ");
          })(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
        }, morphology: function(t5, e5) {
          this.attr({ operator: t5, radius: e5 });
        }, tile: function() {
        }, turbulence: function(t5, e5, i5, a5, s5) {
          this.attr({ numOctaves: e5, seed: i5, stitchTiles: a5, baseFrequency: t5, type: s5 });
        } }, i4 = { merge: function() {
          var t5;
          if (arguments[0] instanceof SVG.Set) {
            var e5 = this;
            arguments[0].each((function(t6) {
              this instanceof SVG.MergeNode ? e5.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e5.put(new SVG.MergeNode(this));
            }));
          } else {
            t5 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
            for (var i5 = 0; i5 < t5.length; i5++) t5[i5] instanceof SVG.MergeNode ? this.put(t5[i5]) : this.put(new SVG.MergeNode(t5[i5]));
          }
        }, componentTransfer: function(t5) {
          if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach(function(t6) {
            this[t6] = new SVG["Func" + t6.toUpperCase()]("identity"), this.rgb.add(this[t6]), this.node.appendChild(this[t6].node);
          }.bind(this)), t5) for (var e5 in t5.rgb && (["r", "g", "b"].forEach(function(e6) {
            this[e6].attr(t5.rgb);
          }.bind(this)), delete t5.rgb), t5) this[e5].attr(t5[e5]);
        }, diffuseLighting: function(t5, e5, i5) {
          this.attr({ surfaceScale: t5, diffuseConstant: e5, kernelUnitLength: i5 });
        }, specularLighting: function(t5, e5, i5, a5) {
          this.attr({ surfaceScale: t5, diffuseConstant: e5, specularExponent: i5, kernelUnitLength: a5 });
        } }, a4 = { distantLight: function(t5, e5) {
          this.attr({ azimuth: t5, elevation: e5 });
        }, pointLight: function(t5, e5, i5) {
          this.attr({ x: t5, y: e5, z: i5 });
        }, spotLight: function(t5, e5, i5, a5, s5, r5) {
          this.attr({ x: t5, y: e5, z: i5, pointsAtX: a5, pointsAtY: s5, pointsAtZ: r5 });
        }, mergeNode: function(t5) {
          this.attr("in", t5);
        } };
        function s4(t5) {
          return Array.isArray(t5) && (t5 = new SVG.Array(t5)), t5.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
        }
        function r4() {
          var t5 = function() {
          };
          for (var e5 in "function" == typeof arguments[arguments.length - 1] && (t5 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (var i5 in arguments[e5]) t5(arguments[e5][i5], i5, arguments[e5]);
        }
        ["r", "g", "b", "a"].forEach((function(t5) {
          a4["Func" + t5.toUpperCase()] = function(t6) {
            switch (this.attr("type", t6), t6) {
              case "table":
                this.attr("tableValues", arguments[1]);
                break;
              case "linear":
                this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                break;
              case "gamma":
                this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
            }
          };
        })), r4(e4, (function(t5, e5) {
          var i5 = e5.charAt(0).toUpperCase() + e5.slice(1);
          SVG[i5 + "Effect"] = SVG.invent({ create: function() {
            this.constructor.call(this, SVG.create("fe" + i5)), t5.apply(this, arguments), this.result(this.attr("id") + "Out");
          }, inherit: SVG.Effect, extend: {} });
        })), r4(i4, (function(t5, e5) {
          var i5 = e5.charAt(0).toUpperCase() + e5.slice(1);
          SVG[i5 + "Effect"] = SVG.invent({ create: function() {
            this.constructor.call(this, SVG.create("fe" + i5)), t5.apply(this, arguments), this.result(this.attr("id") + "Out");
          }, inherit: SVG.ParentEffect, extend: {} });
        })), r4(a4, (function(t5, e5) {
          var i5 = e5.charAt(0).toUpperCase() + e5.slice(1);
          SVG[i5] = SVG.invent({ create: function() {
            this.constructor.call(this, SVG.create("fe" + i5)), t5.apply(this, arguments);
          }, inherit: SVG.ChildEffect, extend: {} });
        })), SVG.extend(SVG.MergeEffect, { in: function(t5) {
          return t5 instanceof SVG.MergeNode ? this.add(t5, 0) : this.add(new SVG.MergeNode(t5), 0), this;
        } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t5) {
          return null == t5 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t5);
        } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
      }.call(void 0), (function() {
        function t4(t5, s5, r4, o3, n3, l4, h4) {
          for (var c4 = t5.slice(s5, r4 || h4), d3 = o3.slice(n3, l4 || h4), g5 = 0, u4 = { pos: [0, 0], start: [0, 0] }, f4 = { pos: [0, 0], start: [0, 0] }; ; ) {
            if (c4[g5] = e4.call(u4, c4[g5]), d3[g5] = e4.call(f4, d3[g5]), c4[g5][0] != d3[g5][0] || "M" == c4[g5][0] || "A" == c4[g5][0] && (c4[g5][4] != d3[g5][4] || c4[g5][5] != d3[g5][5]) ? (Array.prototype.splice.apply(c4, [g5, 1].concat(a4.call(u4, c4[g5]))), Array.prototype.splice.apply(d3, [g5, 1].concat(a4.call(f4, d3[g5])))) : (c4[g5] = i4.call(u4, c4[g5]), d3[g5] = i4.call(f4, d3[g5])), ++g5 == c4.length && g5 == d3.length) break;
            g5 == c4.length && c4.push(["C", u4.pos[0], u4.pos[1], u4.pos[0], u4.pos[1], u4.pos[0], u4.pos[1]]), g5 == d3.length && d3.push(["C", f4.pos[0], f4.pos[1], f4.pos[0], f4.pos[1], f4.pos[0], f4.pos[1]]);
          }
          return { start: c4, dest: d3 };
        }
        function e4(t5) {
          switch (t5[0]) {
            case "z":
            case "Z":
              t5[0] = "L", t5[1] = this.start[0], t5[2] = this.start[1];
              break;
            case "H":
              t5[0] = "L", t5[2] = this.pos[1];
              break;
            case "V":
              t5[0] = "L", t5[2] = t5[1], t5[1] = this.pos[0];
              break;
            case "T":
              t5[0] = "Q", t5[3] = t5[1], t5[4] = t5[2], t5[1] = this.reflection[1], t5[2] = this.reflection[0];
              break;
            case "S":
              t5[0] = "C", t5[6] = t5[4], t5[5] = t5[3], t5[4] = t5[2], t5[3] = t5[1], t5[2] = this.reflection[1], t5[1] = this.reflection[0];
          }
          return t5;
        }
        function i4(t5) {
          var e5 = t5.length;
          return this.pos = [t5[e5 - 2], t5[e5 - 1]], -1 != "SCQT".indexOf(t5[0]) && (this.reflection = [2 * this.pos[0] - t5[e5 - 4], 2 * this.pos[1] - t5[e5 - 3]]), t5;
        }
        function a4(t5) {
          var e5 = [t5];
          switch (t5[0]) {
            case "M":
              return this.pos = this.start = [t5[1], t5[2]], e5;
            case "L":
              t5[5] = t5[3] = t5[1], t5[6] = t5[4] = t5[2], t5[1] = this.pos[0], t5[2] = this.pos[1];
              break;
            case "Q":
              t5[6] = t5[4], t5[5] = t5[3], t5[4] = 1 * t5[4] / 3 + 2 * t5[2] / 3, t5[3] = 1 * t5[3] / 3 + 2 * t5[1] / 3, t5[2] = 1 * this.pos[1] / 3 + 2 * t5[2] / 3, t5[1] = 1 * this.pos[0] / 3 + 2 * t5[1] / 3;
              break;
            case "A":
              e5 = (function(t6, e6) {
                var i5, a5, s5, r4, o3, n3, l4, h4, c4, d3, g5, u4, f4, p4, x5, b4, v4, m4, y4, w5, k4, A4, S3, C4, L4, P4, M3 = Math.abs(e6[1]), I4 = Math.abs(e6[2]), T5 = e6[3] % 360, z4 = e6[4], X3 = e6[5], E3 = e6[6], Y2 = e6[7], R2 = new SVG.Point(t6), F5 = new SVG.Point(E3, Y2), D4 = [];
                if (0 === M3 || 0 === I4 || R2.x === F5.x && R2.y === F5.y) return [["C", R2.x, R2.y, F5.x, F5.y, F5.x, F5.y]];
                i5 = new SVG.Point((R2.x - F5.x) / 2, (R2.y - F5.y) / 2).transform(new SVG.Matrix().rotate(T5)), (a5 = i5.x * i5.x / (M3 * M3) + i5.y * i5.y / (I4 * I4)) > 1 && (M3 *= a5 = Math.sqrt(a5), I4 *= a5);
                s5 = new SVG.Matrix().rotate(T5).scale(1 / M3, 1 / I4).rotate(-T5), R2 = R2.transform(s5), F5 = F5.transform(s5), r4 = [F5.x - R2.x, F5.y - R2.y], n3 = r4[0] * r4[0] + r4[1] * r4[1], o3 = Math.sqrt(n3), r4[0] /= o3, r4[1] /= o3, l4 = n3 < 4 ? Math.sqrt(1 - n3 / 4) : 0, z4 === X3 && (l4 *= -1);
                h4 = new SVG.Point((F5.x + R2.x) / 2 + l4 * -r4[1], (F5.y + R2.y) / 2 + l4 * r4[0]), c4 = new SVG.Point(R2.x - h4.x, R2.y - h4.y), d3 = new SVG.Point(F5.x - h4.x, F5.y - h4.y), g5 = Math.acos(c4.x / Math.sqrt(c4.x * c4.x + c4.y * c4.y)), c4.y < 0 && (g5 *= -1);
                u4 = Math.acos(d3.x / Math.sqrt(d3.x * d3.x + d3.y * d3.y)), d3.y < 0 && (u4 *= -1);
                X3 && g5 > u4 && (u4 += 2 * Math.PI);
                !X3 && g5 < u4 && (u4 -= 2 * Math.PI);
                for (p4 = Math.ceil(2 * Math.abs(g5 - u4) / Math.PI), b4 = [], v4 = g5, f4 = (u4 - g5) / p4, x5 = 4 * Math.tan(f4 / 4) / 3, k4 = 0; k4 <= p4; k4++) y4 = Math.cos(v4), m4 = Math.sin(v4), w5 = new SVG.Point(h4.x + y4, h4.y + m4), b4[k4] = [new SVG.Point(w5.x + x5 * m4, w5.y - x5 * y4), w5, new SVG.Point(w5.x - x5 * m4, w5.y + x5 * y4)], v4 += f4;
                for (b4[0][0] = b4[0][1].clone(), b4[b4.length - 1][2] = b4[b4.length - 1][1].clone(), s5 = new SVG.Matrix().rotate(T5).scale(M3, I4).rotate(-T5), k4 = 0, A4 = b4.length; k4 < A4; k4++) b4[k4][0] = b4[k4][0].transform(s5), b4[k4][1] = b4[k4][1].transform(s5), b4[k4][2] = b4[k4][2].transform(s5);
                for (k4 = 1, A4 = b4.length; k4 < A4; k4++) S3 = (w5 = b4[k4 - 1][2]).x, C4 = w5.y, L4 = (w5 = b4[k4][0]).x, P4 = w5.y, E3 = (w5 = b4[k4][1]).x, Y2 = w5.y, D4.push(["C", S3, C4, L4, P4, E3, Y2]);
                return D4;
              })(this.pos, t5), t5 = e5[0];
          }
          return t5[0] = "C", this.pos = [t5[5], t5[6]], this.reflection = [2 * t5[5] - t5[3], 2 * t5[6] - t5[4]], e5;
        }
        function s4(t5, e5) {
          if (false === e5) return false;
          for (var i5 = e5, a5 = t5.length; i5 < a5; ++i5) if ("M" == t5[i5][0]) return i5;
          return false;
        }
        SVG.extend(SVG.PathArray, { morph: function(e5) {
          for (var i5 = this.value, a5 = this.parse(e5), r4 = 0, o3 = 0, n3 = false, l4 = false; false !== r4 || false !== o3; ) {
            var h4;
            n3 = s4(i5, false !== r4 && r4 + 1), l4 = s4(a5, false !== o3 && o3 + 1), false === r4 && (r4 = 0 == (h4 = new SVG.PathArray(c4.start).bbox()).height || 0 == h4.width ? i5.push(i5[0]) - 1 : i5.push(["M", h4.x + h4.width / 2, h4.y + h4.height / 2]) - 1), false === o3 && (o3 = 0 == (h4 = new SVG.PathArray(c4.dest).bbox()).height || 0 == h4.width ? a5.push(a5[0]) - 1 : a5.push(["M", h4.x + h4.width / 2, h4.y + h4.height / 2]) - 1);
            var c4 = t4(i5, r4, n3, a5, o3, l4);
            i5 = i5.slice(0, r4).concat(c4.start, false === n3 ? [] : i5.slice(n3)), a5 = a5.slice(0, o3).concat(c4.dest, false === l4 ? [] : a5.slice(l4)), r4 = false !== n3 && r4 + c4.start.length, o3 = false !== l4 && o3 + c4.dest.length;
          }
          return this.value = i5, this.destination = new SVG.PathArray(), this.destination.value = a5, this;
        } });
      })(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
      * https://github.com/svgdotjs/svg.draggable.js
      * Copyright (c) 2019 Wout Fierens; Licensed MIT */
      function() {
        function t4(t5) {
          t5.remember("_draggable", this), this.el = t5;
        }
        t4.prototype.init = function(t5, e4) {
          var i4 = this;
          this.constraint = t5, this.value = e4, this.el.on("mousedown.drag", (function(t6) {
            i4.start(t6);
          })), this.el.on("touchstart.drag", (function(t6) {
            i4.start(t6);
          }));
        }, t4.prototype.transformPoint = function(t5, e4) {
          var i4 = (t5 = t5 || window.event).changedTouches && t5.changedTouches[0] || t5;
          return this.p.x = i4.clientX - (e4 || 0), this.p.y = i4.clientY, this.p.matrixTransform(this.m);
        }, t4.prototype.getBBox = function() {
          var t5 = this.el.bbox();
          return this.el instanceof SVG.Nested && (t5 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t5.x = this.el.x(), t5.y = this.el.y()), t5;
        }, t4.prototype.start = function(t5) {
          if ("click" != t5.type && "mousedown" != t5.type && "mousemove" != t5.type || 1 == (t5.which || t5.buttons)) {
            var e4 = this;
            if (this.el.fire("beforedrag", { event: t5, handler: this }), !this.el.event().defaultPrevented) {
              t5.preventDefault(), t5.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
              var i4, a4 = this.getBBox();
              if (this.el instanceof SVG.Text) switch (i4 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                case "middle":
                  i4 /= 2;
                  break;
                case "start":
                  i4 = 0;
              }
              this.startPoints = { point: this.transformPoint(t5, i4), box: a4, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", (function(t6) {
                e4.drag(t6);
              })), SVG.on(window, "touchmove.drag", (function(t6) {
                e4.drag(t6);
              })), SVG.on(window, "mouseup.drag", (function(t6) {
                e4.end(t6);
              })), SVG.on(window, "touchend.drag", (function(t6) {
                e4.end(t6);
              })), this.el.fire("dragstart", { event: t5, p: this.startPoints.point, m: this.m, handler: this });
            }
          }
        }, t4.prototype.drag = function(t5) {
          var e4 = this.getBBox(), i4 = this.transformPoint(t5), a4 = this.startPoints.box.x + i4.x - this.startPoints.point.x, s4 = this.startPoints.box.y + i4.y - this.startPoints.point.y, r4 = this.constraint, o3 = i4.x - this.startPoints.point.x, n3 = i4.y - this.startPoints.point.y;
          if (this.el.fire("dragmove", { event: t5, p: i4, m: this.m, handler: this }), this.el.event().defaultPrevented) return i4;
          if ("function" == typeof r4) {
            var l4 = r4.call(this.el, a4, s4, this.m);
            "boolean" == typeof l4 && (l4 = { x: l4, y: l4 }), true === l4.x ? this.el.x(a4) : false !== l4.x && this.el.x(l4.x), true === l4.y ? this.el.y(s4) : false !== l4.y && this.el.y(l4.y);
          } else "object" == typeof r4 && (null != r4.minX && a4 < r4.minX ? o3 = (a4 = r4.minX) - this.startPoints.box.x : null != r4.maxX && a4 > r4.maxX - e4.width && (o3 = (a4 = r4.maxX - e4.width) - this.startPoints.box.x), null != r4.minY && s4 < r4.minY ? n3 = (s4 = r4.minY) - this.startPoints.box.y : null != r4.maxY && s4 > r4.maxY - e4.height && (n3 = (s4 = r4.maxY - e4.height) - this.startPoints.box.y), null != r4.snapToGrid && (a4 -= a4 % r4.snapToGrid, s4 -= s4 % r4.snapToGrid, o3 -= o3 % r4.snapToGrid, n3 -= n3 % r4.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: o3, y: n3 }, true) : this.el.move(a4, s4));
          return i4;
        }, t4.prototype.end = function(t5) {
          var e4 = this.drag(t5);
          this.el.fire("dragend", { event: t5, p: e4, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
        }, SVG.extend(SVG.Element, { draggable: function(e4, i4) {
          "function" != typeof e4 && "object" != typeof e4 || (i4 = e4, e4 = true);
          var a4 = this.remember("_draggable") || new t4(this);
          return (e4 = void 0 === e4 || e4) ? a4.init(i4 || {}, e4) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
        } });
      }.call(void 0), (function() {
        function t4(t5) {
          this.el = t5, t5.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t6, e4, i4) {
            var a4 = "string" != typeof t6 ? t6 : e4[t6];
            return i4 ? a4 / 2 : a4;
          }, this.pointCoords = function(t6, e4) {
            var i4 = this.pointsList[t6];
            return { x: this.pointCoord(i4[0], e4, "t" === t6 || "b" === t6), y: this.pointCoord(i4[1], e4, "r" === t6 || "l" === t6) };
          };
        }
        t4.prototype.init = function(t5, e4) {
          var i4 = this.el.bbox();
          this.options = {};
          var a4 = this.el.selectize.defaults.points;
          for (var s4 in this.el.selectize.defaults) this.options[s4] = this.el.selectize.defaults[s4], void 0 !== e4[s4] && (this.options[s4] = e4[s4]);
          var r4 = ["points", "pointsExclude"];
          for (var s4 in r4) {
            var o3 = this.options[r4[s4]];
            "string" == typeof o3 ? o3 = o3.length > 0 ? o3.split(/\s*,\s*/i) : [] : "boolean" == typeof o3 && "points" === r4[s4] && (o3 = o3 ? a4 : []), this.options[r4[s4]] = o3;
          }
          this.options.points = [a4, this.options.points].reduce((function(t6, e5) {
            return t6.filter((function(t7) {
              return e5.indexOf(t7) > -1;
            }));
          })), this.options.points = [this.options.points, this.options.pointsExclude].reduce((function(t6, e5) {
            return t6.filter((function(t7) {
              return e5.indexOf(t7) < 0;
            }));
          })), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i4.x, i4.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t5) : this.selectRect(t5), this.observe(), this.cleanup();
        }, t4.prototype.selectPoints = function(t5) {
          return this.pointSelection.isSelected = t5, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
        }, t4.prototype.getPointArray = function() {
          var t5 = this.el.bbox();
          return this.el.array().valueOf().map((function(e4) {
            return [e4[0] - t5.x, e4[1] - t5.y];
          }));
        }, t4.prototype.drawPoints = function() {
          for (var t5 = this, e4 = this.getPointArray(), i4 = 0, a4 = e4.length; i4 < a4; ++i4) {
            var s4 = /* @__PURE__ */ (function(e5) {
              return function(i5) {
                (i5 = i5 || window.event).preventDefault ? i5.preventDefault() : i5.returnValue = false, i5.stopPropagation();
                var a5 = i5.pageX || i5.touches[0].pageX, s5 = i5.pageY || i5.touches[0].pageY;
                t5.el.fire("point", { x: a5, y: s5, i: e5, event: i5 });
              };
            })(i4), r4 = this.drawPoint(e4[i4][0], e4[i4][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s4).on("mousedown", s4);
            this.pointSelection.set.add(r4);
          }
        }, t4.prototype.drawPoint = function(t5, e4) {
          var i4 = this.options.pointType;
          switch (i4) {
            case "circle":
              return this.drawCircle(t5, e4);
            case "rect":
              return this.drawRect(t5, e4);
            default:
              if ("function" == typeof i4) return i4.call(this, t5, e4);
              throw new Error("Unknown " + i4 + " point type!");
          }
        }, t4.prototype.drawCircle = function(t5, e4) {
          return this.nested.circle(this.options.pointSize).center(t5, e4);
        }, t4.prototype.drawRect = function(t5, e4) {
          return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t5, e4);
        }, t4.prototype.updatePointSelection = function() {
          var t5 = this.getPointArray();
          this.pointSelection.set.each((function(e4) {
            this.cx() === t5[e4][0] && this.cy() === t5[e4][1] || this.center(t5[e4][0], t5[e4][1]);
          }));
        }, t4.prototype.updateRectSelection = function() {
          var t5 = this, e4 = this.el.bbox();
          if (this.rectSelection.set.get(0).attr({ width: e4.width, height: e4.height }), this.options.points.length && this.options.points.map((function(i5, a4) {
            var s4 = t5.pointCoords(i5, e4);
            t5.rectSelection.set.get(a4 + 1).center(s4.x, s4.y);
          })), this.options.rotationPoint) {
            var i4 = this.rectSelection.set.length();
            this.rectSelection.set.get(i4 - 1).center(e4.width / 2, 20);
          }
        }, t4.prototype.selectRect = function(t5) {
          var e4 = this, i4 = this.el.bbox();
          function a4(t6) {
            return function(i5) {
              (i5 = i5 || window.event).preventDefault ? i5.preventDefault() : i5.returnValue = false, i5.stopPropagation();
              var a5 = i5.pageX || i5.touches[0].pageX, s5 = i5.pageY || i5.touches[0].pageY;
              e4.el.fire(t6, { x: a5, y: s5, event: i5 });
            };
          }
          if (this.rectSelection.isSelected = t5, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i4.width, i4.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
            this.options.points.map((function(t6, s5) {
              var r5 = e4.pointCoords(t6, i4), o3 = e4.drawPoint(r5.x, r5.y).attr("class", e4.options.classPoints + "_" + t6).on("mousedown", a4(t6)).on("touchstart", a4(t6));
              e4.rectSelection.set.add(o3);
            })), this.rectSelection.set.each((function() {
              this.addClass(e4.options.classPoints);
            }));
          }
          if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
            var s4 = function(t6) {
              (t6 = t6 || window.event).preventDefault ? t6.preventDefault() : t6.returnValue = false, t6.stopPropagation();
              var i5 = t6.pageX || t6.touches[0].pageX, a5 = t6.pageY || t6.touches[0].pageY;
              e4.el.fire("rot", { x: i5, y: a5, event: t6 });
            }, r4 = this.drawPoint(i4.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s4).on("mousedown", s4);
            this.rectSelection.set.add(r4);
          }
        }, t4.prototype.handler = function() {
          var t5 = this.el.bbox();
          this.nested.matrix(new SVG.Matrix(this.el).translate(t5.x, t5.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
        }, t4.prototype.observe = function() {
          var t5 = this;
          if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver((function() {
            t5.handler();
          })), this.observerInst.observe(this.el.node, { attributes: true });
          else try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch (t6) {
          }
          else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", (function() {
            t5.handler();
          }));
        }, t4.prototype.cleanup = function() {
          !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each((function() {
            this.remove();
          })), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each((function() {
            this.remove();
          })), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
        }, SVG.extend(SVG.Element, { selectize: function(e4, i4) {
          return "object" == typeof e4 && (i4 = e4, e4 = true), (this.remember("_selectHandler") || new t4(this)).init(void 0 === e4 || e4, i4 || {}), this;
        } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
      })(), (function() {
        (function() {
          function t4(t5) {
            t5.remember("_resizeHandler", this), this.el = t5, this.parameters = {}, this.lastUpdateCall = null, this.p = t5.doc().node.createSVGPoint();
          }
          t4.prototype.transformPoint = function(t5, e4, i4) {
            return this.p.x = t5 - (this.offset.x - window.pageXOffset), this.p.y = e4 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i4 || this.m);
          }, t4.prototype._extractPosition = function(t5) {
            return { x: null != t5.clientX ? t5.clientX : t5.touches[0].clientX, y: null != t5.clientY ? t5.clientY : t5.touches[0].clientY };
          }, t4.prototype.init = function(t5) {
            var e4 = this;
            if (this.stop(), "stop" !== t5) {
              for (var i4 in this.options = {}, this.el.resize.defaults) this.options[i4] = this.el.resize.defaults[i4], void 0 !== t5[i4] && (this.options[i4] = t5[i4]);
              this.el.on("lt.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("rt.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("rb.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("lb.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("t.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("r.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("b.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("l.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("rot.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.el.on("point.resize", (function(t6) {
                e4.resize(t6 || window.event);
              })), this.update();
            }
          }, t4.prototype.stop = function() {
            return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
          }, t4.prototype.resize = function(t5) {
            var e4 = this;
            this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
            var i4 = this._extractPosition(t5.detail.event);
            if (this.parameters = { type: this.el.type, p: this.transformPoint(i4.x, i4.y), x: t5.detail.x, y: t5.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t5.detail.i) {
              var a4 = this.el.array().valueOf();
              this.parameters.i = t5.detail.i, this.parameters.pointCoords = [a4[t5.detail.i][0], a4[t5.detail.i][1]];
            }
            switch (t5.type) {
              case "lt":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5);
                  if (this.parameters.box.width - i5[0] > 0 && this.parameters.box.height - i5[1] > 0) {
                    if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i5[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i5[0]);
                    i5 = this.checkAspectRatio(i5), this.el.move(this.parameters.box.x + i5[0], this.parameters.box.y + i5[1]).size(this.parameters.box.width - i5[0], this.parameters.box.height - i5[1]);
                  }
                };
                break;
              case "rt":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 2);
                  if (this.parameters.box.width + i5[0] > 0 && this.parameters.box.height - i5[1] > 0) {
                    if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i5[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i5[0]);
                    i5 = this.checkAspectRatio(i5, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i5[1]).size(this.parameters.box.width + i5[0], this.parameters.box.height - i5[1]);
                  }
                };
                break;
              case "rb":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 0);
                  if (this.parameters.box.width + i5[0] > 0 && this.parameters.box.height + i5[1] > 0) {
                    if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i5[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i5[0]);
                    i5 = this.checkAspectRatio(i5), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i5[0], this.parameters.box.height + i5[1]);
                  }
                };
                break;
              case "lb":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 1);
                  if (this.parameters.box.width - i5[0] > 0 && this.parameters.box.height + i5[1] > 0) {
                    if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i5[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i5[0]);
                    i5 = this.checkAspectRatio(i5, true), this.el.move(this.parameters.box.x + i5[0], this.parameters.box.y).size(this.parameters.box.width - i5[0], this.parameters.box.height + i5[1]);
                  }
                };
                break;
              case "t":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 2);
                  if (this.parameters.box.height - i5[1] > 0) {
                    if ("text" === this.parameters.type) return;
                    this.el.move(this.parameters.box.x, this.parameters.box.y + i5[1]).height(this.parameters.box.height - i5[1]);
                  }
                };
                break;
              case "r":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 0);
                  if (this.parameters.box.width + i5[0] > 0) {
                    if ("text" === this.parameters.type) return;
                    this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i5[0]);
                  }
                };
                break;
              case "b":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 0);
                  if (this.parameters.box.height + i5[1] > 0) {
                    if ("text" === this.parameters.type) return;
                    this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i5[1]);
                  }
                };
                break;
              case "l":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, 1);
                  if (this.parameters.box.width - i5[0] > 0) {
                    if ("text" === this.parameters.type) return;
                    this.el.move(this.parameters.box.x + i5[0], this.parameters.box.y).width(this.parameters.box.width - i5[0]);
                  }
                };
                break;
              case "rot":
                this.calc = function(t6, e5) {
                  var i5 = t6 + this.parameters.p.x, a5 = e5 + this.parameters.p.y, s4 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r4 = Math.atan2(a5 - this.parameters.box.y - this.parameters.box.height / 2, i5 - this.parameters.box.x - this.parameters.box.width / 2), o3 = this.parameters.rotation + 180 * (r4 - s4) / Math.PI + this.options.snapToAngle / 2;
                  this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o3 - o3 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
                };
                break;
              case "point":
                this.calc = function(t6, e5) {
                  var i5 = this.snapToGrid(t6, e5, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a5 = this.el.array().valueOf();
                  a5[this.parameters.i][0] = this.parameters.pointCoords[0] + i5[0], a5[this.parameters.i][1] = this.parameters.pointCoords[1] + i5[1], this.el.plot(a5);
                };
            }
            this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t5 }), SVG.on(window, "touchmove.resize", (function(t6) {
              e4.update(t6 || window.event);
            })), SVG.on(window, "touchend.resize", (function() {
              e4.done();
            })), SVG.on(window, "mousemove.resize", (function(t6) {
              e4.update(t6 || window.event);
            })), SVG.on(window, "mouseup.resize", (function() {
              e4.done();
            }));
          }, t4.prototype.update = function(t5) {
            if (t5) {
              var e4 = this._extractPosition(t5), i4 = this.transformPoint(e4.x, e4.y), a4 = i4.x - this.parameters.p.x, s4 = i4.y - this.parameters.p.y;
              this.lastUpdateCall = [a4, s4], this.calc(a4, s4), this.el.fire("resizing", { dx: a4, dy: s4, event: t5 });
            } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
          }, t4.prototype.done = function() {
            this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
          }, t4.prototype.snapToGrid = function(t5, e4, i4, a4) {
            var s4;
            return void 0 !== a4 ? s4 = [(i4 + t5) % this.options.snapToGrid, (a4 + e4) % this.options.snapToGrid] : (i4 = null == i4 ? 3 : i4, s4 = [(this.parameters.box.x + t5 + (1 & i4 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e4 + (2 & i4 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t5 < 0 && (s4[0] -= this.options.snapToGrid), e4 < 0 && (s4[1] -= this.options.snapToGrid), t5 -= Math.abs(s4[0]) < this.options.snapToGrid / 2 ? s4[0] : s4[0] - (t5 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e4 -= Math.abs(s4[1]) < this.options.snapToGrid / 2 ? s4[1] : s4[1] - (e4 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t5, e4, i4, a4);
          }, t4.prototype.constraintToBox = function(t5, e4, i4, a4) {
            var s4, r4, o3 = this.options.constraint || {};
            return void 0 !== a4 ? (s4 = i4, r4 = a4) : (s4 = this.parameters.box.x + (1 & i4 ? 0 : this.parameters.box.width), r4 = this.parameters.box.y + (2 & i4 ? 0 : this.parameters.box.height)), void 0 !== o3.minX && s4 + t5 < o3.minX && (t5 = o3.minX - s4), void 0 !== o3.maxX && s4 + t5 > o3.maxX && (t5 = o3.maxX - s4), void 0 !== o3.minY && r4 + e4 < o3.minY && (e4 = o3.minY - r4), void 0 !== o3.maxY && r4 + e4 > o3.maxY && (e4 = o3.maxY - r4), [t5, e4];
          }, t4.prototype.checkAspectRatio = function(t5, e4) {
            if (!this.options.saveAspectRatio) return t5;
            var i4 = t5.slice(), a4 = this.parameters.box.width / this.parameters.box.height, s4 = this.parameters.box.width + t5[0], r4 = this.parameters.box.height - t5[1], o3 = s4 / r4;
            return o3 < a4 ? (i4[1] = s4 / a4 - this.parameters.box.height, e4 && (i4[1] = -i4[1])) : o3 > a4 && (i4[0] = this.parameters.box.width - r4 * a4, e4 && (i4[0] = -i4[0])), i4;
          }, SVG.extend(SVG.Element, { resize: function(e4) {
            return (this.remember("_resizeHandler") || new t4(this)).init(e4 || {}), this;
          } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
        }).call(this);
      })(), void 0 === window.Apex && (window.Apex = {});
      var qt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "initModules", value: function() {
          this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new y3(this.ctx), this.ctx.axes = new et(this.ctx), this.ctx.core = new _t(this.ctx.el, this.ctx), this.ctx.config = new D3({}), this.ctx.data = new _3(this.ctx), this.ctx.grid = new Z2(this.ctx), this.ctx.graphics = new k3(this.ctx), this.ctx.coreUtils = new A3(this.ctx), this.ctx.crosshairs = new it(this.ctx), this.ctx.events = new K2(this.ctx), this.ctx.exports = new U2(this.ctx), this.ctx.fill = new N3(this.ctx), this.ctx.localization = new tt(this.ctx), this.ctx.options = new X2(), this.ctx.responsive = new at(this.ctx), this.ctx.series = new V3(this.ctx), this.ctx.theme = new st(this.ctx), this.ctx.formatters = new P3(this.ctx), this.ctx.titleSubtitle = new rt(this.ctx), this.ctx.legend = new gt(this.ctx), this.ctx.toolbar = new ut(this.ctx), this.ctx.tooltip = new wt(this.ctx), this.ctx.dimensions = new ct(this.ctx), this.ctx.updateHelpers = new Ut(this.ctx), this.ctx.zoomPanSelection = new ft(this.ctx), this.ctx.w.globals.tooltip = new wt(this.ctx);
        } }]), t4;
      })();
      var Zt = (function() {
        function t4(e4) {
          i3(this, t4), this.ctx = e4, this.w = e4.w;
        }
        return s3(t4, [{ key: "clear", value: function(t5) {
          var e4 = t5.isUpdating;
          this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e4 });
        } }, { key: "killSVG", value: function(t5) {
          t5.each((function() {
            this.removeClass("*"), this.off(), this.stop();
          }), true), t5.ungroup(), t5.clear();
        } }, { key: "clearDomElements", value: function(t5) {
          var e4 = this, i4 = t5.isUpdating, a4 = this.w.globals.dom.Paper.node;
          a4.parentNode && a4.parentNode.parentNode && !i4 && (a4.parentNode.parentNode.style.minHeight = "unset");
          var s4 = this.w.globals.dom.baseEl;
          s4 && this.ctx.eventList.forEach((function(t6) {
            s4.removeEventListener(t6, e4.ctx.events.documentEvent);
          }));
          var r4 = this.w.globals.dom;
          if (null !== this.ctx.el) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
          this.killSVG(r4.Paper), r4.Paper.remove(), r4.elWrap = null, r4.elGraphical = null, r4.elLegendWrap = null, r4.elLegendForeign = null, r4.baseEl = null, r4.elGridRect = null, r4.elGridRectMask = null, r4.elGridRectBarMask = null, r4.elGridRectMarkerMask = null, r4.elForecastMask = null, r4.elNonForecastMask = null, r4.elDefs = null;
        } }]), t4;
      })();
      var $t = /* @__PURE__ */ new WeakMap();
      var Jt = (function() {
        function t4(e4, a4) {
          i3(this, t4), this.opts = a4, this.ctx = this, this.w = new O2(a4).init(), this.el = e4, this.w.globals.cuid = m3.randomId(), this.w.globals.chartID = this.w.config.chart.id ? m3.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new qt(this).initModules(), this.create = m3.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
        }
        return s3(t4, [{ key: "render", value: function() {
          var t5 = this;
          return new Promise((function(e4, i4) {
            if (null !== t5.el) {
              void 0 === Apex._chartInstances && (Apex._chartInstances = []), t5.w.config.chart.id && Apex._chartInstances.push({ id: t5.w.globals.chartID, group: t5.w.config.chart.group, chart: t5 }), t5.setLocale(t5.w.config.chart.defaultLocale);
              var a4 = t5.w.config.chart.events.beforeMount;
              "function" == typeof a4 && a4(t5, t5.w), t5.events.fireEvent("beforeMount", [t5, t5.w]), window.addEventListener("resize", t5.windowResizeHandler), (function(t6, e5) {
                var i5 = false;
                if (t6.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                  var a5 = t6.getBoundingClientRect();
                  "none" !== t6.style.display && 0 !== a5.width || (i5 = true);
                }
                var s5 = new ResizeObserver((function(a6) {
                  i5 && e5.call(t6, a6), i5 = true;
                }));
                t6.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t6.children).forEach((function(t7) {
                  return s5.observe(t7);
                })) : s5.observe(t6), $t.set(e5, s5);
              })(t5.el.parentNode, t5.parentResizeHandler);
              var s4 = t5.el.getRootNode && t5.el.getRootNode(), r4 = m3.is("ShadowRoot", s4), o3 = t5.el.ownerDocument, n3 = r4 ? s4.getElementById("apexcharts-css") : o3.getElementById("apexcharts-css");
              if (!n3) {
                var l4;
                (n3 = document.createElement("style")).id = "apexcharts-css", n3.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,\n.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,\n.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,\n.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}\n';
                var h4 = (null === (l4 = t5.opts.chart) || void 0 === l4 ? void 0 : l4.nonce) || t5.w.config.chart.nonce;
                h4 && n3.setAttribute("nonce", h4), r4 ? s4.prepend(n3) : o3.head.appendChild(n3);
              }
              var c4 = t5.create(t5.w.config.series, {});
              if (!c4) return e4(t5);
              t5.mount(c4).then((function() {
                "function" == typeof t5.w.config.chart.events.mounted && t5.w.config.chart.events.mounted(t5, t5.w), t5.events.fireEvent("mounted", [t5, t5.w]), e4(c4);
              })).catch((function(t6) {
                i4(t6);
              }));
            } else i4(new Error("Element not found"));
          }));
        } }, { key: "create", value: function(t5, e4) {
          var i4 = this, a4 = this.w;
          new qt(this).initModules();
          var s4 = this.w.globals;
          (s4.noData = false, s4.animationEnded = false, this.responsive.checkResponsiveConfig(e4), a4.config.xaxis.convertedCatToNumeric) && new F4(a4.config).convertCatToNumericXaxis(a4.config, this.ctx);
          if (null === this.el) return s4.animationEnded = true, null;
          if (this.core.setupElements(), "treemap" === a4.config.chart.type && (a4.config.grid.show = false, a4.config.yaxis[0].show = false), 0 === s4.svgWidth) return s4.animationEnded = true, null;
          var r4 = t5;
          t5.forEach((function(t6, e5) {
            t6.hidden && (r4 = i4.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: e5 }));
          }));
          var o3 = A3.checkComboSeries(r4, a4.config.chart.type);
          s4.comboCharts = o3.comboCharts, s4.comboBarCount = o3.comboBarCount;
          var n3 = r4.every((function(t6) {
            return t6.data && 0 === t6.data.length;
          }));
          (0 === r4.length || n3 && s4.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r4), this.theme.init(), new W2(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), s4.noData && s4.collapsedSeries.length !== s4.series.length && !a4.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), s4.axisCharts && (this.core.coreCalculations(), "category" !== a4.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a4.globals.minX, this.ctx.toolbar.maxX = a4.globals.maxX), this.formatters.heatmapLabelFormatters(), new A3(this).getLargestMarkerSize(), this.dimensions.plotCoords();
          var l4 = this.core.xySettings();
          this.grid.createGridMask();
          var h4 = this.core.plotChartType(r4, l4), c4 = new G3(this);
          return c4.bringForward(), a4.config.dataLabels.background.enabled && c4.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: h4, xyRatios: l4, dimensions: { plot: { left: a4.globals.translateX, top: a4.globals.translateY, width: a4.globals.gridWidth, height: a4.globals.gridHeight } } };
        } }, { key: "mount", value: function() {
          var t5 = this, e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i4 = this, a4 = i4.w;
          return new Promise((function(s4, r4) {
            if (null === i4.el) return r4(new Error("Not enough data to display or target element not found"));
            (null === e4 || a4.globals.allSeriesCollapsed) && i4.series.handleNoData(), i4.grid = new Z2(i4);
            var o3, n3, l4 = i4.grid.drawGrid();
            (i4.annotations = new E2(i4), i4.annotations.drawImageAnnos(), i4.annotations.drawTextAnnos(), "back" === a4.config.grid.position) && (l4 && a4.globals.dom.elGraphical.add(l4.el), null != l4 && null !== (o3 = l4.elGridBorders) && void 0 !== o3 && o3.node && a4.globals.dom.elGraphical.add(l4.elGridBorders));
            if (Array.isArray(e4.elGraph)) for (var h4 = 0; h4 < e4.elGraph.length; h4++) a4.globals.dom.elGraphical.add(e4.elGraph[h4]);
            else a4.globals.dom.elGraphical.add(e4.elGraph);
            "front" === a4.config.grid.position && (l4 && a4.globals.dom.elGraphical.add(l4.el), null != l4 && null !== (n3 = l4.elGridBorders) && void 0 !== n3 && n3.node && a4.globals.dom.elGraphical.add(l4.elGridBorders));
            "front" === a4.config.xaxis.crosshairs.position && i4.crosshairs.drawXCrosshairs(), "front" === a4.config.yaxis[0].crosshairs.position && i4.crosshairs.drawYCrosshairs(), "treemap" !== a4.config.chart.type && i4.axes.drawAxis(a4.config.chart.type, l4);
            var c4 = new q3(t5.ctx, l4), d3 = new Q2(t5.ctx, l4);
            if (null !== l4 && (c4.xAxisLabelCorrections(l4.xAxisTickWidth), d3.setYAxisTextAlignments(), a4.config.yaxis.map((function(t6, e5) {
              -1 === a4.globals.ignoreYAxisIndexes.indexOf(e5) && d3.yAxisTitleRotate(e5, t6.opposite);
            }))), i4.annotations.drawAxesAnnotations(), !a4.globals.noData) {
              if (a4.config.tooltip.enabled && !a4.globals.noData && i4.w.globals.tooltip.drawTooltip(e4.xyRatios), a4.globals.axisCharts && (a4.globals.isXNumeric || a4.config.xaxis.convertedCatToNumeric || a4.globals.isRangeBar)) (a4.config.chart.zoom.enabled || a4.config.chart.selection && a4.config.chart.selection.enabled || a4.config.chart.pan && a4.config.chart.pan.enabled) && i4.zoomPanSelection.init({ xyRatios: e4.xyRatios });
              else {
                var g5 = a4.config.chart.toolbar.tools;
                ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach((function(t6) {
                  g5[t6] = false;
                }));
              }
              a4.config.chart.toolbar.show && !a4.globals.allSeriesCollapsed && i4.toolbar.createToolbar();
            }
            a4.globals.memory.methodsToExec.length > 0 && a4.globals.memory.methodsToExec.forEach((function(t6) {
              t6.method(t6.params, false, t6.context);
            })), a4.globals.axisCharts || a4.globals.noData || i4.core.resizeNonAxisCharts(), s4(i4);
          }));
        } }, { key: "destroy", value: function() {
          var t5, e4;
          window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t5 = this.parentResizeHandler, (e4 = $t.get(t5)) && (e4.disconnect(), $t.delete(t5));
          var i4 = this.w.config.chart.id;
          i4 && Apex._chartInstances.forEach((function(t6, e5) {
            t6.id === m3.escapeString(i4) && Apex._chartInstances.splice(e5, 1);
          })), new Zt(this.ctx).clear({ isUpdating: false });
        } }, { key: "updateOptions", value: function(t5) {
          var e4 = this, i4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s4 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r4 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o3 = this.w;
          return o3.globals.selection = void 0, t5.series && (this.series.resetSeries(false, true, false), t5.series.length && t5.series[0].data && (t5.series = t5.series.map((function(t6, i5) {
            return e4.updateHelpers._extendSeries(t6, i5);
          }))), this.updateHelpers.revertDefaultAxisMinMax()), t5.xaxis && (t5 = this.updateHelpers.forceXAxisUpdate(t5)), t5.yaxis && (t5 = this.updateHelpers.forceYAxisUpdate(t5)), o3.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t5.theme && (t5 = this.theme.updateThemeOptions(t5)), this.updateHelpers._updateOptions(t5, i4, a4, s4, r4);
        } }, { key: "updateSeries", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t5, e4, i4);
        } }, { key: "appendSeries", value: function(t5) {
          var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a4 = this.w.config.series.slice();
          return a4.push(t5), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a4, e4, i4);
        } }, { key: "appendData", value: function(t5) {
          var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = this;
          i4.w.globals.dataChanged = true, i4.series.getPreviousPaths();
          for (var a4 = i4.w.config.series.slice(), s4 = 0; s4 < a4.length; s4++) if (null !== t5[s4] && void 0 !== t5[s4]) for (var r4 = 0; r4 < t5[s4].data.length; r4++) a4[s4].data.push(t5[s4].data[r4]);
          return i4.w.config.series = a4, e4 && (i4.w.globals.initialSeries = m3.clone(i4.w.config.series)), this.update();
        } }, { key: "update", value: function(t5) {
          var e4 = this;
          return new Promise((function(i4, a4) {
            new Zt(e4.ctx).clear({ isUpdating: true });
            var s4 = e4.create(e4.w.config.series, t5);
            if (!s4) return i4(e4);
            e4.mount(s4).then((function() {
              "function" == typeof e4.w.config.chart.events.updated && e4.w.config.chart.events.updated(e4, e4.w), e4.events.fireEvent("updated", [e4, e4.w]), e4.w.globals.isDirty = true, i4(e4);
            })).catch((function(t6) {
              a4(t6);
            }));
          }));
        } }, { key: "getSyncedCharts", value: function() {
          var t5 = this.getGroupedCharts(), e4 = [this];
          return t5.length && (e4 = [], t5.forEach((function(t6) {
            e4.push(t6);
          }))), e4;
        } }, { key: "getGroupedCharts", value: function() {
          var t5 = this;
          return Apex._chartInstances.filter((function(t6) {
            if (t6.group) return true;
          })).map((function(e4) {
            return t5.w.config.chart.group === e4.group ? e4.chart : t5;
          }));
        } }, { key: "toggleSeries", value: function(t5) {
          return this.series.toggleSeries(t5);
        } }, { key: "highlightSeriesOnLegendHover", value: function(t5, e4) {
          return this.series.toggleSeriesOnHover(t5, e4);
        } }, { key: "showSeries", value: function(t5) {
          this.series.showSeries(t5);
        } }, { key: "hideSeries", value: function(t5) {
          this.series.hideSeries(t5);
        } }, { key: "highlightSeries", value: function(t5) {
          this.series.highlightSeries(t5);
        } }, { key: "isSeriesHidden", value: function(t5) {
          this.series.isSeriesHidden(t5);
        } }, { key: "resetSeries", value: function() {
          var t5 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          this.series.resetSeries(t5, e4);
        } }, { key: "addEventListener", value: function(t5, e4) {
          this.events.addEventListener(t5, e4);
        } }, { key: "removeEventListener", value: function(t5, e4) {
          this.events.removeEventListener(t5, e4);
        } }, { key: "addXaxisAnnotation", value: function(t5) {
          var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a4 = this;
          i4 && (a4 = i4), a4.annotations.addXaxisAnnotationExternal(t5, e4, a4);
        } }, { key: "addYaxisAnnotation", value: function(t5) {
          var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a4 = this;
          i4 && (a4 = i4), a4.annotations.addYaxisAnnotationExternal(t5, e4, a4);
        } }, { key: "addPointAnnotation", value: function(t5) {
          var e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a4 = this;
          i4 && (a4 = i4), a4.annotations.addPointAnnotationExternal(t5, e4, a4);
        } }, { key: "clearAnnotations", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e4 = this;
          t5 && (e4 = t5), e4.annotations.clearAnnotations(e4);
        } }, { key: "removeAnnotation", value: function(t5) {
          var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i4 = this;
          e4 && (i4 = e4), i4.annotations.removeAnnotation(i4, t5);
        } }, { key: "getChartArea", value: function() {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
        } }, { key: "getSeriesTotalXRange", value: function(t5, e4) {
          return this.coreUtils.getSeriesTotalsXRange(t5, e4);
        } }, { key: "getHighestValueInSeries", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          return new J2(this.ctx).getMinYMaxY(t5).highestY;
        } }, { key: "getLowestValueInSeries", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          return new J2(this.ctx).getMinYMaxY(t5).lowestY;
        } }, { key: "getSeriesTotal", value: function() {
          return this.w.globals.seriesTotals;
        } }, { key: "toggleDataPointSelection", value: function(t5, e4) {
          return this.updateHelpers.toggleDataPointSelection(t5, e4);
        } }, { key: "zoomX", value: function(t5, e4) {
          this.ctx.toolbar.zoomUpdateOptions(t5, e4);
        } }, { key: "setLocale", value: function(t5) {
          this.localization.setCurrentLocaleValues(t5);
        } }, { key: "dataURI", value: function(t5) {
          return new U2(this.ctx).dataURI(t5);
        } }, { key: "exportToCSV", value: function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return new U2(this.ctx).exportToCSV(t5);
        } }, { key: "paper", value: function() {
          return this.w.globals.dom.Paper;
        } }, { key: "_parentResizeCallback", value: function() {
          this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
        } }, { key: "_windowResize", value: function() {
          var t5 = this;
          clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((function() {
            t5.w.globals.resized = true, t5.w.globals.dataChanged = false, t5.ctx.update();
          }), 150);
        } }, { key: "_windowResizeHandler", value: function() {
          var t5 = this.w.config.chart.redrawOnWindowResize;
          "function" == typeof t5 && (t5 = t5()), t5 && this._windowResize();
        } }], [{ key: "getChartByID", value: function(t5) {
          var e4 = m3.escapeString(t5);
          if (Apex._chartInstances) {
            var i4 = Apex._chartInstances.filter((function(t6) {
              return t6.id === e4;
            }))[0];
            return i4 && i4.chart;
          }
        } }, { key: "initOnLoad", value: function() {
          for (var e4 = document.querySelectorAll("[data-apexcharts]"), i4 = 0; i4 < e4.length; i4++) {
            new t4(e4[i4], JSON.parse(e4[i4].getAttribute("data-options"))).render();
          }
        } }, { key: "exec", value: function(t5, e4) {
          var i4 = this.getChartByID(t5);
          if (i4) {
            i4.w.globals.isExecCalled = true;
            var a4 = null;
            if (-1 !== i4.publicMethods.indexOf(e4)) {
              for (var s4 = arguments.length, r4 = new Array(s4 > 2 ? s4 - 2 : 0), o3 = 2; o3 < s4; o3++) r4[o3 - 2] = arguments[o3];
              a4 = i4[e4].apply(i4, r4);
            }
            return a4;
          }
        } }, { key: "merge", value: function(t5, e4) {
          return m3.extend(t5, e4);
        } }]), t4;
      })();
      module.exports = Jt;
    }
  });

  // node_modules/alpinejs/dist/module.esm.js
  var flushPending = false;
  var flushing = false;
  var queue = [];
  var lastFlushedIndex = -1;
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index6 = queue.indexOf(job);
    if (index6 !== -1 && index6 > lastFlushedIndex)
      queue.splice(index6, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i3 = 0; i3 < queue.length; i3++) {
      queue[i3]();
      lastFlushedIndex = i3;
    }
    queue.length = 0;
    lastFlushedIndex = -1;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i3) => i3());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  function watch(getter, callback) {
    let firstTime = true;
    let oldValue;
    let effectReference = effect(() => {
      let value = getter();
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    });
    return () => release(effectReference);
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i3) => i3());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  function cleanupElement(el) {
    el._x_effects?.forEach(dequeueJob);
    while (el._x_cleanups?.length)
      el._x_cleanups.pop()();
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var queuedMutations = [];
  function flushObserver() {
    let records = observer.takeRecords();
    queuedMutations.push(() => records.length > 0 && onMutate(records));
    let queueLengthWhenTriggered = queuedMutations.length;
    queueMicrotask(() => {
      if (queuedMutations.length === queueLengthWhenTriggered) {
        while (queuedMutations.length > 0)
          queuedMutations.shift()();
      }
    });
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = /* @__PURE__ */ new Set();
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < mutations.length; i3++) {
      if (mutations[i3].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i3].type === "childList") {
        mutations[i3].removedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (!node._x_marker)
            return;
          removedNodes.add(node);
        });
        mutations[i3].addedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (removedNodes.has(node)) {
            removedNodes.delete(node);
            return;
          }
          if (node._x_marker)
            return;
          addedNodes.push(node);
        });
      }
      if (mutations[i3].type === "attributes") {
        let el = mutations[i3].target;
        let name = mutations[i3].attributeName;
        let oldValue = mutations[i3].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove2 = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove2();
          add2();
        } else {
          remove2();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i3) => i3(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.some((i3) => i3.contains(node)))
        continue;
      onElRemoveds.forEach((i3) => i3(node));
    }
    for (let node of addedNodes) {
      if (!node.isConnected)
        continue;
      onElAddeds.forEach((i3) => i3(node));
    }
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i3) => i3 !== data2);
    };
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({ objects }, mergeProxyTrap);
  }
  var mergeProxyTrap = {
    ownKeys({ objects }) {
      return Array.from(
        new Set(objects.flatMap((i3) => Object.keys(i3)))
      );
    },
    has({ objects }, name) {
      if (name == Symbol.unscopables)
        return false;
      return objects.some(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
      );
    },
    get({ objects }, name, thisProxy) {
      if (name == "toJSON")
        return collapseProxies;
      return Reflect.get(
        objects.find(
          (obj) => Reflect.has(obj, name)
        ) || {},
        name,
        thisProxy
      );
    },
    set({ objects }, name, value, thisProxy) {
      const target = objects.find(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      ) || objects[objects.length - 1];
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      if (descriptor?.set && descriptor?.get)
        return descriptor.set.call(thisProxy, value) || true;
      return Reflect.set(target, name, value);
    }
  };
  function collapseProxies() {
    let keys = Reflect.ownKeys(this);
    return keys.reduce((acc, key) => {
      acc[key] = Reflect.get(this, key);
      return acc;
    }, {});
  }
  function initInterceptors(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        if (typeof value === "object" && value !== null && value.__v_skip)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    let memoizedUtilities = getUtilities(el);
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback(el, memoizedUtilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function getUtilities(el) {
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    let utils = { interceptor, ...utilities };
    onElRemoved(el, cleanup2);
    return utils;
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e3) {
      handleError(e3, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    error2 = Object.assign(
      error2 ?? { message: "No error message given." },
      { el, expression }
    );
    console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    let result = callback();
    shouldAutoEvaluateFunctions = cache;
    return result;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [], context } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        let func2 = new AsyncFunction(
          ["__self", "scope"],
          `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
        );
        Object.defineProperty(func2, "name", {
          value: `[Alpine] ${expression}`
        });
        return func2;
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [], context } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func.call(context, func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i3) => runIfTypeOfFunction(receiver, i3, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else if (typeof value === "object" && value instanceof Promise) {
      value.then((i3) => receiver(i3));
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
    return {
      before(directive2) {
        if (!directiveHandlers[directive2]) {
          console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
          return;
        }
        const pos = directiveOrder.indexOf(directive2);
        directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
      }
    };
  }
  function directiveExists(name) {
    return Object.keys(directiveHandlers).includes(name);
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i3) => i3());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler4 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler4.inline && handler4.inline(el, directive2, utilities);
      handler4 = handler4.bind(handler4, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i3) => i3;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i3) => i3.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "anchor",
    "bind",
    "init",
    "for",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a3, b3) {
    let typeA = directiveOrder.indexOf(a3.type) === -1 ? DEFAULT : a3.type;
    let typeB = directiveOrder.indexOf(b3.type) === -1 ? DEFAULT : b3.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        // Allows events to pass the shadow DOM barrier.
        composed: true,
        cancelable: true
      })
    );
  }
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback, false);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  var started = false;
  function start() {
    if (started)
      warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
    started = true;
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
    setTimeout(() => {
      warnAboutMissingPlugins();
    });
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  var initInterceptors2 = [];
  function interceptInit(callback) {
    initInterceptors2.push(callback);
  }
  var markerDispenser = 1;
  function initTree(el, walker = walk, intercept = () => {
  }) {
    if (findClosest(el, (i3) => i3._x_ignore))
      return;
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        if (el2._x_marker)
          return;
        intercept(el2, skip);
        initInterceptors2.forEach((i3) => i3(el2, skip));
        directives(el2, el2.attributes).forEach((handle) => handle());
        if (!el2._x_ignore)
          el2._x_marker = markerDispenser++;
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root, walker = walk) {
    walker(root, (el) => {
      cleanupElement(el);
      cleanupAttributes(el);
      delete el._x_marker;
    });
  }
  function warnAboutMissingPlugins() {
    let pluginDirectives = [
      ["ui", "dialog", ["[x-dialog], [x-popover]"]],
      ["anchor", "anchor", ["[x-anchor]"]],
      ["sort", "sort", ["[x-sort]"]]
    ];
    pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
      if (directiveExists(directive2))
        return;
      selectors.some((selector) => {
        if (document.querySelector(selector)) {
          warn(`found "${selector}", but missing ${plugin2} plugin`);
          return true;
        }
      });
    });
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let split = (classString2) => classString2.split(" ").filter(Boolean);
    let missingClasses = (classString2) => classString2.split(" ").filter((i3) => !el.classList.contains(i3)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i3) => {
      if (el.classList.contains(i3)) {
        el.classList.remove(i3);
        removed.push(i3);
      }
    });
    forAdd.forEach((i3) => {
      if (!el.classList.contains(i3)) {
        el.classList.add(i3);
        added.push(i3);
      }
    });
    return () => {
      removed.forEach((i3) => el.classList.add(i3));
      added.forEach((i3) => el.classList.remove(i3));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (expression === false)
      return;
    if (!expression || typeof expression === "boolean") {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      "enter": (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      "leave": (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i3, index6) => index6 < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i3, index6) => index6 > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0) / 1e3;
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: `${delay}s`,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: `${delay}s`,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i3]) => i3?.());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e3) => {
            if (!e3.isFromCancelledTransition)
              throw e3;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        ;
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration2 = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration2 === 0)
        duration2 = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration2 + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration" || key === "delay") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function onlyDuringClone(callback) {
    return (...args) => isCloning && callback(...args);
  }
  var interceptors = [];
  function interceptClone(callback) {
    interceptors.push(callback);
  }
  function cloneNode(from, to) {
    interceptors.forEach((i3) => i3(from, to));
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      initTree(to, (el, callback) => {
        callback(el, () => {
        });
      });
    });
    isCloning = false;
  }
  var isCloningLegacy = false;
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    isCloningLegacy = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
    isCloningLegacy = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      case "selected":
      case "checked":
        bindAttributeAndProperty(el, name, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (isRadio(el)) {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        if (typeof value === "boolean") {
          el.checked = safeParseBoolean(el.value) === value;
        } else {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      }
    } else if (isCheckbox(el)) {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value === void 0 ? "" : value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttributeAndProperty(el, name, value) {
    bindAttribute(el, name, value);
    setPropertyIfChanged(el, name, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function setPropertyIfChanged(el, propName, value) {
    if (el[propName] !== value) {
      el[propName] = value;
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function safeParseBoolean(rawValue) {
    if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
      return true;
    }
    if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
      return false;
    }
    return rawValue ? Boolean(rawValue) : null;
  }
  var booleanAttributes = /* @__PURE__ */ new Set([
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "inert",
    "ismap",
    "itemscope",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected",
    "shadowrootclonable",
    "shadowrootdelegatesfocus",
    "shadowrootserializable"
  ]);
  function isBooleanAttr(attrName) {
    return booleanAttributes.has(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    return getAttributeBinding(el, name, fallback);
  }
  function extractProp(el, name, fallback, extract = true) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
      let binding = el._x_inlineBindings[name];
      binding.extract = extract;
      return dontAutoEvaluateFunctions(() => {
        return evaluate(el, binding.expression);
      });
    }
    return getAttributeBinding(el, name, fallback);
  }
  function getAttributeBinding(el, name, fallback) {
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  function isCheckbox(el) {
    return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
  }
  function isRadio(el) {
    return el.type === "radio" || el.localName === "ui-radio";
  }
  function debounce(func, wait) {
    let timeout;
    return function() {
      const context = this, args = arguments;
      const later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
    let firstRun = true;
    let outerHash;
    let innerHash;
    let reference = effect(() => {
      let outer = outerGet();
      let inner = innerGet();
      if (firstRun) {
        innerSet(cloneIfObject(outer));
        firstRun = false;
      } else {
        let outerHashLatest = JSON.stringify(outer);
        let innerHashLatest = JSON.stringify(inner);
        if (outerHashLatest !== outerHash) {
          innerSet(cloneIfObject(outer));
        } else if (outerHashLatest !== innerHashLatest) {
          outerSet(cloneIfObject(inner));
        } else {
        }
      }
      outerHash = JSON.stringify(outerGet());
      innerHash = JSON.stringify(innerGet());
    });
    return () => {
      release(reference);
    };
  }
  function cloneIfObject(value) {
    return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
  }
  function plugin(callback) {
    let callbacks = Array.isArray(callback) ? callback : [callback];
    callbacks.forEach((i3) => i3(alpine_default));
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    initInterceptors(stores[name]);
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      return applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
    return () => {
    };
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
    return () => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
    };
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.15.0",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    startObservingMutations,
    stopObservingMutations,
    setReactivityEngine,
    onAttributeRemoved,
    onAttributesAdded,
    closestDataStack,
    skipDuringClone,
    onlyDuringClone,
    addRootSelector,
    addInitSelector,
    interceptClone,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    interceptInit,
    setEvaluator,
    mergeProxies,
    extractProp,
    findClosest,
    onElRemoved,
    closestRoot,
    destroyTree,
    interceptor,
    // INTERNAL: not public API and is subject to change without major release.
    transition,
    // INTERNAL
    setStyles,
    // INTERNAL
    mutateDom,
    directive,
    entangle,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    // INTERNAL
    cloneNode,
    // INTERNAL
    bound: getBinding,
    $data: scope,
    watch,
    walk,
    data,
    bind: bind2
  };
  var alpine_default = Alpine;
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i3 = 0; i3 < list.length; i3++) {
      map[list[i3]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_3, c3) => c3 ? c3.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i3 = 0; i3 < deps.length; i3++) {
        deps[i3].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i3 = 0, l3 = this.length; i3 < l3; i3++) {
          track(arr, "get", i3 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (true) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (true) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v3) => Reflect.getPrototypeOf(v3);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value[
      "__v_skip"
      /* SKIP */
    ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target[
      "__v_isReadonly"
      /* IS_READONLY */
    ]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target[
      "__v_raw"
      /* RAW */
    ] && !(isReadonly && target[
      "__v_isReactive"
      /* IS_REACTIVE */
    ])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed[
      "__v_raw"
      /* RAW */
    ]) || observed;
  }
  function isRef(r3) {
    return Boolean(r3 && r3.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let getter = () => {
      let value;
      evaluate2((i3) => value = i3);
      return value;
    };
    let unwatch = watch(getter, callback);
    cleanup2(unwatch);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    findClosest(el, (i3) => {
      if (i3._x_refs)
        refObjects.push(i3._x_refs);
    });
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
    let cacheKey = `${name}${key ? `-${key}` : ""}`;
    return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
      let root = closestIdRoot(el, name);
      let id = root ? root._x_ids[name] : findAndIncrementId(name);
      return key ? `${name}-${id}-${key}` : `${name}-${id}`;
    });
  });
  interceptClone((from, to) => {
    if (from._x_id) {
      to._x_id = from._x_id;
    }
  });
  function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
    if (!el._x_id)
      el._x_id = {};
    if (el._x_id[cacheKey])
      return el._x_id[cacheKey];
    let output = callback();
    el._x_id[cacheKey] = output;
    cleanup2(() => {
      delete el._x_id[cacheKey];
    });
    return output;
  }
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i3) => result = i3);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { "__placeholder": val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      let releaseEntanglement = entangle(
        {
          get() {
            return outerGet();
          },
          set(value) {
            outerSet(value);
          }
        },
        {
          get() {
            return innerGet();
          },
          set(value) {
            innerSet(value);
          }
        }
      );
      cleanup2(releaseEntanglement);
    });
  });
  directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = getTarget(expression);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    el.setAttribute("data-teleport-template", true);
    clone2.setAttribute("data-teleport-target", true);
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e3) => {
          e3.stopPropagation();
          el.dispatchEvent(new e3.constructor(e3.type, e3));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    let placeInDom = (clone3, target2, modifiers2) => {
      if (modifiers2.includes("prepend")) {
        target2.parentNode.insertBefore(clone3, target2);
      } else if (modifiers2.includes("append")) {
        target2.parentNode.insertBefore(clone3, target2.nextSibling);
      } else {
        target2.appendChild(clone3);
      }
    };
    mutateDom(() => {
      placeInDom(clone2, target, modifiers);
      skipDuringClone(() => {
        initTree(clone2);
      })();
    });
    el._x_teleportPutBack = () => {
      let target2 = getTarget(expression);
      mutateDom(() => {
        placeInDom(el._x_teleport, target2, modifiers);
      });
    };
    cleanup2(
      () => mutateDom(() => {
        clone2.remove();
        destroyTree(clone2);
      })
    );
  });
  var teleportContainerDuringClone = document.createElement("div");
  function getTarget(expression) {
    let target = skipDuringClone(() => {
      return document.querySelector(expression);
    }, () => {
      return teleportContainerDuringClone;
    })();
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    return target;
  }
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
    effect3(evaluateLater(el, expression));
  }));
  function on(el, event, modifiers, callback) {
    let listenerTarget = el;
    let handler4 = (e3) => callback(e3);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e3) => wrapper(callback2, e3);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = debounce(handler4, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = throttle(handler4, wait);
    }
    if (modifiers.includes("prevent"))
      handler4 = wrapHandler(handler4, (next, e3) => {
        e3.preventDefault();
        next(e3);
      });
    if (modifiers.includes("stop"))
      handler4 = wrapHandler(handler4, (next, e3) => {
        e3.stopPropagation();
        next(e3);
      });
    if (modifiers.includes("once")) {
      handler4 = wrapHandler(handler4, (next, e3) => {
        next(e3);
        listenerTarget.removeEventListener(event, handler4, options);
      });
    }
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler4 = wrapHandler(handler4, (next, e3) => {
        if (el.contains(e3.target))
          return;
        if (e3.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e3);
      });
    }
    if (modifiers.includes("self"))
      handler4 = wrapHandler(handler4, (next, e3) => {
        e3.target === el && next(e3);
      });
    if (isKeyEvent(event) || isClickEvent(event)) {
      handler4 = wrapHandler(handler4, (next, e3) => {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e3, modifiers)) {
          return;
        }
        next(e3);
      });
    }
    listenerTarget.addEventListener(event, handler4, options);
    return () => {
      listenerTarget.removeEventListener(event, handler4, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    if ([" ", "_"].includes(
      subject
    ))
      return subject;
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isClickEvent(event) {
    return ["contextmenu", "click", "mouse"].some((i3) => event.includes(i3));
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e3, modifiers) {
    let keyModifiers = modifiers.filter((i3) => {
      return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(i3);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.includes("throttle")) {
      let debounceIndex = keyModifiers.indexOf("throttle");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e3.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i3) => !selectedSystemKeyModifiers.includes(i3));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e3[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (isClickEvent(e3.type))
          return false;
        if (keyToModifiers(e3.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      "ctrl": "control",
      "slash": "/",
      "space": " ",
      "spacebar": " ",
      "cmd": "meta",
      "esc": "escape",
      "up": "arrow-up",
      "down": "arrow-down",
      "left": "arrow-left",
      "right": "arrow-right",
      "period": ".",
      "comma": ",",
      "equal": "=",
      "minus": "-",
      "underscore": "_"
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let scopeTarget = el;
    if (modifiers.includes("parent")) {
      scopeTarget = el.parentNode;
    }
    let evaluateGet = evaluateLater(scopeTarget, expression);
    let evaluateSet;
    if (typeof expression === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
    } else if (typeof expression === "function" && typeof expression() === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
    } else {
      evaluateSet = () => {
      };
    }
    let getValue = () => {
      let result;
      evaluateGet((value) => result = value);
      return isGetterSetter(result) ? result.get() : result;
    };
    let setValue = (value) => {
      let result;
      evaluateGet((value2) => result = value2);
      if (isGetterSetter(result)) {
        result.set(value);
      } else {
        evaluateSet(() => {
        }, {
          scope: { "__placeholder": value }
        });
      }
    };
    if (typeof expression === "string" && el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    let event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let removeListener = isCloning ? () => {
    } : on(el, event, modifiers, (e3) => {
      setValue(getInputValue(el, modifiers, e3, getValue()));
    });
    if (modifiers.includes("fill")) {
      if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
        setValue(
          getInputValue(el, modifiers, { target: el }, getValue())
        );
      }
    }
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    if (el.form) {
      let removeResetListener = on(el.form, "reset", [], (e3) => {
        nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
      });
      cleanup2(() => removeResetListener());
    }
    el._x_model = {
      get() {
        return getValue();
      },
      set(value) {
        setValue(value);
      }
    };
    el._x_forceModelUpdate = (value) => {
      if (value === void 0 && typeof expression === "string" && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    };
    effect3(() => {
      let value = getValue();
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate(value);
    });
  });
  function getInputValue(el, modifiers, event, currentValue) {
    return mutateDom(() => {
      if (event instanceof CustomEvent && event.detail !== void 0)
        return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;
      else if (isCheckbox(el)) {
        if (Array.isArray(currentValue)) {
          let newValue = null;
          if (modifiers.includes("number")) {
            newValue = safeParseNumber(event.target.value);
          } else if (modifiers.includes("boolean")) {
            newValue = safeParseBoolean(event.target.value);
          } else {
            newValue = event.target.value;
          }
          return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        if (modifiers.includes("number")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          });
        } else if (modifiers.includes("boolean")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseBoolean(rawValue);
          });
        }
        return Array.from(event.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        let newValue;
        if (isRadio(el)) {
          if (event.target.checked) {
            newValue = event.target.value;
          } else {
            newValue = currentValue;
          }
        } else {
          newValue = event.target.value;
        }
        if (modifiers.includes("number")) {
          return safeParseNumber(newValue);
        } else if (modifiers.includes("boolean")) {
          return safeParseBoolean(newValue);
        } else if (modifiers.includes("trim")) {
          return newValue.trim();
        } else {
          return newValue;
        }
      }
    });
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function isGetterSetter(value) {
    return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
      return;
    }
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
    cleanup2(() => {
      el._x_undoAddedClasses && el._x_undoAddedClasses();
      el._x_undoAddedStyles && el._x_undoAddedStyles();
    });
  };
  handler2.inline = (el, { value, modifiers, expression }) => {
    if (!value)
      return;
    if (!el._x_inlineBindings)
      el._x_inlineBindings = {};
    el._x_inlineBindings[value] = { expression, extract: false };
  };
  directive("bind", handler2);
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
    if (shouldSkipRegisteringDataDuringClone(el))
      return;
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    if (data2 === void 0 || data2 === true)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo();
    });
  });
  interceptClone((from, to) => {
    if (from._x_dataStack) {
      to._x_dataStack = from._x_dataStack;
      to.setAttribute("data-has-alpine-state", true);
    }
  });
  function shouldSkipRegisteringDataDuringClone(el) {
    if (!isCloning)
      return false;
    if (isCloningLegacy)
      return true;
    return el.hasAttribute("data-has-alpine-state");
  }
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once(
      (value) => value ? show() : hide(),
      (value) => {
        if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
          el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
        } else {
          value ? clickAwayCompatibleShow() : hide();
        }
      }
    );
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(
      el,
      // the x-bind:key expression is stored for our use instead of evaluated.
      el._x_keyExpression || "index"
    );
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => mutateDom(
        () => {
          destroyTree(el2);
          el2.remove();
        }
      ));
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i3) => typeof i3 === "object" && !Array.isArray(i3);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i3) => i3 + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => {
            if (keys.includes(value2))
              warn("Duplicate key on x-for", el);
            keys.push(value2);
          }, { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i3 = 0; i3 < items.length; i3++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i3], i3, items);
          evaluateKey((value) => {
            if (keys.includes(value))
              warn("Duplicate key on x-for", el);
            keys.push(value);
          }, { scope: { index: i3, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i3 = 0; i3 < prevKeys.length; i3++) {
        let key = prevKeys[i3];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i3 = 0; i3 < keys.length; i3++) {
        let key = keys[i3];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i3, 0, key);
          adds.push([lastKey, i3]);
        } else if (prevIndex !== i3) {
          let keyInSpot = prevKeys.splice(i3, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i3, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i3 = 0; i3 < removes.length; i3++) {
        let key = removes[i3];
        if (!(key in lookup))
          continue;
        mutateDom(() => {
          destroyTree(lookup[key]);
          lookup[key].remove();
        });
        delete lookup[key];
      }
      for (let i3 = 0; i3 < moves.length; i3++) {
        let [keyInSpot, keyForSpot] = moves[i3];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          if (!elForSpot)
            warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i3 = 0; i3 < adds.length; i3++) {
        let [lastKey2, index6] = adds[i3];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index6];
        let key = keys[index6];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        let reactiveScope = reactive(scope2);
        addScopeToNode(clone2, reactiveScope, templateEl);
        clone2._x_refreshXForScope = (newScope) => {
          Object.entries(newScope).forEach(([key2, value]) => {
            reactiveScope[key2] = value;
          });
        };
        mutateDom(() => {
          lastEl.after(clone2);
          skipDuringClone(() => initTree(clone2))();
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i3 = 0; i3 < sames.length; i3++) {
        lookup[sames[i3]]._x_refreshXForScope(scopes[keys.indexOf(sames[i3])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index6, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i3) => i3.trim());
      names.forEach((name, i3) => {
        scopeVariables[name] = item[i3];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i3) => i3.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index6;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler3() {
  }
  handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler3);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-if can only be used on a <template> tag", el);
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        mutateDom(() => {
          destroyTree(clone2);
          clone2.remove();
        });
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  interceptClone((from, to) => {
    if (from._x_ids) {
      to._x_ids = from._x_ids;
    }
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e3) => {
      evaluate2(() => {
      }, { scope: { "$event": e3 }, params: [e3] });
    });
    cleanup2(() => removeListener());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName, slug) {
    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default = alpine_default;
  var module_default = src_default;

  // node_modules/@alpinejs/persist/dist/module.esm.js
  function src_default2(Alpine2) {
    let persist = () => {
      let alias;
      let storage;
      try {
        storage = localStorage;
      } catch (e3) {
        console.error(e3);
        console.warn("Alpine: $persist is using temporary storage since localStorage is unavailable.");
        let dummy = /* @__PURE__ */ new Map();
        storage = {
          getItem: dummy.get.bind(dummy),
          setItem: dummy.set.bind(dummy)
        };
      }
      return Alpine2.interceptor((initialValue, getter, setter, path, key) => {
        let lookup = alias || `_x_${path}`;
        let initial = storageHas(lookup, storage) ? storageGet(lookup, storage) : initialValue;
        setter(initial);
        Alpine2.effect(() => {
          let value = getter();
          storageSet(lookup, value, storage);
          setter(value);
        });
        return initial;
      }, (func) => {
        func.as = (key) => {
          alias = key;
          return func;
        }, func.using = (target) => {
          storage = target;
          return func;
        };
      });
    };
    Object.defineProperty(Alpine2, "$persist", { get: () => persist() });
    Alpine2.magic("persist", persist);
    Alpine2.persist = (key, { get: get3, set: set3 }, storage = localStorage) => {
      let initial = storageHas(key, storage) ? storageGet(key, storage) : get3();
      set3(initial);
      Alpine2.effect(() => {
        let value = get3();
        storageSet(key, value, storage);
        set3(value);
      });
    };
  }
  function storageHas(key, storage) {
    return storage.getItem(key) !== null;
  }
  function storageGet(key, storage) {
    let value = storage.getItem(key);
    if (value === void 0)
      return;
    return JSON.parse(value);
  }
  function storageSet(key, value, storage) {
    storage.setItem(key, JSON.stringify(value));
  }
  var module_default2 = src_default2;

  // node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: /* @__PURE__ */ new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // node_modules/flatpickr/dist/esm/l10n/default.js
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
      var s3 = nth % 100;
      if (s3 > 3 && s3 < 21)
        return "th";
      switch (s3 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default = english;

  // node_modules/flatpickr/dist/esm/utils/index.js
  var pad = function(number, length) {
    if (length === void 0) {
      length = 2;
    }
    return ("000" + number).slice(length * -1);
  };
  var int = function(bool) {
    return bool === true ? 1 : 0;
  };
  function debounce2(fn, wait) {
    var t3;
    return function() {
      var _this = this;
      var args = arguments;
      clearTimeout(t3);
      t3 = setTimeout(function() {
        return fn.apply(_this, args);
      }, wait);
    };
  }
  var arrayify = function(obj) {
    return obj instanceof Array ? obj : [obj];
  };

  // node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  function createElement(tag, className, content) {
    var e3 = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e3.className = className;
    if (content !== void 0)
      e3.textContent = content;
    return e3;
  }
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (var key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error2) {
      return event.target;
    }
  }

  // node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing = function() {
    return void 0;
  };
  var monthToStr = function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  };
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_3, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1e3);
    },
    W: function(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function(dateObj, year2) {
      dateObj.setFullYear(parseFloat(year2));
    },
    Z: function(_3, ISODate) {
      return new Date(ISODate);
    },
    d: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_3, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function(dateObj, year2) {
      dateObj.setFullYear(2e3 + parseFloat(year2));
    }
  };
  var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: function(date) {
      return date.toISOString();
    },
    D: function(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    H: function(date) {
      return pad(date.getHours());
    },
    J: function(date, locale) {
      return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: function(date, locale) {
      return locale.amPM[int(date.getHours() > 11)];
    },
    M: function(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    S: function(date) {
      return pad(date.getSeconds());
    },
    U: function(date) {
      return date.getTime() / 1e3;
    },
    W: function(date, _3, options) {
      return options.getWeek(date);
    },
    Y: function(date) {
      return pad(date.getFullYear(), 4);
    },
    d: function(date) {
      return pad(date.getDate());
    },
    h: function(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    i: function(date) {
      return pad(date.getMinutes());
    },
    j: function(date) {
      return date.getDate();
    },
    l: function(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    m: function(date) {
      return pad(date.getMonth() + 1);
    },
    n: function(date) {
      return date.getMonth() + 1;
    },
    s: function(date) {
      return date.getSeconds();
    },
    u: function(date) {
      return date.getTime();
    },
    w: function(date) {
      return date.getDay();
    },
    y: function(date) {
      return String(date.getFullYear()).substring(2);
    }
  };

  // node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter = function(_a) {
    var _b = _a.config, config2 = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;
      if (config2.formatDate !== void 0 && !isMobile) {
        return config2.formatDate(dateObj, frmt, locale);
      }
      return frmt.split("").map(function(c3, i3, arr) {
        return formats[c3] && arr[i3 - 1] !== "\\" ? formats[c3](dateObj, locale, config2) : c3 !== "\\" ? c3 : "";
      }).join("");
    };
  };
  var createDateParser = function(_a) {
    var _b = _a.config, config2 = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
    return function(date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date)
        return void 0;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date)
        parsedDate = new Date(date.getTime());
      else if (typeof date !== "string" && date.toFixed !== void 0)
        parsedDate = new Date(date);
      else if (typeof date === "string") {
        var format = givenFormat || (config2 || defaults).dateFormat;
        var datestr = String(date).trim();
        if (datestr === "today") {
          parsedDate = /* @__PURE__ */ new Date();
          timeless = true;
        } else if (config2 && config2.parseDate) {
          parsedDate = config2.parseDate(date, format);
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
          parsedDate = new Date(date);
        } else {
          var matched = void 0, ops = [];
          for (var i3 = 0, matchIndex = 0, regexStr = ""; i3 < format.length; i3++) {
            var token = format[i3];
            var isBackSlash = token === "\\";
            var escaped = format[i3 - 1] === "\\" || isBackSlash;
            if (tokenRegex[token] && !escaped) {
              regexStr += tokenRegex[token];
              var match = new RegExp(regexStr).exec(date);
              if (match && (matched = true)) {
                ops[token !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token],
                  val: match[++matchIndex]
                });
              }
            } else if (!isBackSlash)
              regexStr += ".";
          }
          parsedDate = !config2 || !config2.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          ops.forEach(function(_a2) {
            var fn = _a2.fn, val = _a2.val;
            return parsedDate = fn(parsedDate, val, locale) || parsedDate;
          });
          parsedDate = matched ? parsedDate : void 0;
        }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config2.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return void 0;
      }
      if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  };
  function compareDates(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  var isBetween = function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };
  var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
  };
  var parseSeconds = function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
  };
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config2) {
    var hours = config2.defaultHour;
    var minutes = config2.defaultMinute;
    var seconds = config2.defaultSeconds;
    if (config2.minDate !== void 0) {
      var minHour = config2.minDate.getHours();
      var minMinutes = config2.minDate.getMinutes();
      var minSeconds = config2.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config2.minDate.getSeconds();
    }
    if (config2.maxDate !== void 0) {
      var maxHr = config2.maxDate.getHours();
      var maxMinutes = config2.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config2.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }

  // node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      var _loop_1 = function(source2) {
        if (source2) {
          Object.keys(source2).forEach(function(key) {
            return target[key] = source2[key];
          });
        }
      };
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];
        _loop_1(source);
      }
      return target;
    };
  }

  // node_modules/flatpickr/dist/esm/index.js
  var __assign = function() {
    __assign = Object.assign || function(t3) {
      for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
        s3 = arguments[i3];
        for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
          t3[p3] = s3[p3];
      }
      return t3;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArrays = function() {
    for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++) s3 += arguments[i3].length;
    for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
      for (var a3 = arguments[i3], j5 = 0, jl = a3.length; j5 < jl; j5++, k3++)
        r3[k3] = a3[j5];
    return r3;
  };
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    var self = {
      config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
      l10n: default_default
    };
    self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
    self._handlers = [];
    self.pluginElements = [];
    self.loadedPlugins = [];
    self._bind = bind3;
    self._setHoursFromDate = setHoursFromDate;
    self._positionCalendar = positionCalendar;
    self.changeMonth = changeMonth;
    self.changeYear = changeYear;
    self.clear = clear2;
    self.close = close;
    self.onMouseOver = onMouseOver;
    self._createElement = createElement;
    self.createDay = createDay;
    self.destroy = destroy;
    self.isEnabled = isEnabled;
    self.jumpToDate = jumpToDate;
    self.updateValue = updateValue;
    self.open = open;
    self.redraw = redraw;
    self.set = set3;
    self.setDate = setDate;
    self.toggle = toggle;
    function setupHelperFunctions() {
      self.utils = {
        getDaysInMonth: function(month, yr) {
          if (month === void 0) {
            month = self.currentMonth;
          }
          if (yr === void 0) {
            yr = self.currentYear;
          }
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self.l10n.daysInMonth[month];
        }
      };
    }
    function init() {
      self.element = self.input = element;
      self.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self.isMobile)
        build();
      bindEvents();
      if (self.selectedDates.length || self.config.noCalendar) {
        if (self.config.enableTime) {
          setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    function getClosestActiveElement() {
      var _a;
      return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
    }
    function bindToInstance(fn) {
      return fn.bind(self);
    }
    function setCalendarWidth() {
      var config2 = self.config;
      if (config2.weekNumbers === false && config2.showMonths === 1) {
        return;
      } else if (config2.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self.calendarContainer !== void 0) {
            self.calendarContainer.style.visibility = "hidden";
            self.calendarContainer.style.display = "block";
          }
          if (self.daysContainer !== void 0) {
            var daysWidth = (self.days.offsetWidth + 1) * config2.showMonths;
            self.daysContainer.style.width = daysWidth + "px";
            self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== void 0 ? self.weekWrapper.offsetWidth : 0) + "px";
            self.calendarContainer.style.removeProperty("visibility");
            self.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    function updateTime(e3) {
      if (self.selectedDates.length === 0) {
        var defaultDate = self.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self.config.minDate.getTime());
        var defaults2 = getDefaultHours(self.config);
        defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
        self.selectedDates = [defaultDate];
        self.latestSelectedDateObj = defaultDate;
      }
      if (e3 !== void 0 && e3.type !== "blur") {
        timeWrapper(e3);
      }
      var prevValue = self._input.value;
      setHoursFromInputs();
      updateValue();
      if (self._input.value !== prevValue) {
        self._debouncedChange();
      }
    }
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
    }
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    function setHoursFromInputs() {
      if (self.hourElement === void 0 || self.minuteElement === void 0)
        return;
      var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== void 0 ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
      if (self.amPM !== void 0) {
        hours = ampm2military(hours, self.amPM.textContent);
      }
      var limitMinHours = self.config.minTime !== void 0 || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
      var limitMaxHours = self.config.maxTime !== void 0 || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
      if (self.config.maxTime !== void 0 && self.config.minTime !== void 0 && self.config.minTime > self.config.maxTime) {
        var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
        var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
        var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
        if (currentTime > maxBound && currentTime < minBound) {
          var result = parseSeconds(minBound);
          hours = result[0];
          minutes = result[1];
          seconds = result[2];
        }
      } else {
        if (limitMaxHours) {
          var maxTime = self.config.maxTime !== void 0 ? self.config.maxTime : self.config.maxDate;
          hours = Math.min(hours, maxTime.getHours());
          if (hours === maxTime.getHours())
            minutes = Math.min(minutes, maxTime.getMinutes());
          if (minutes === maxTime.getMinutes())
            seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
          var minTime = self.config.minTime !== void 0 ? self.config.minTime : self.config.minDate;
          hours = Math.max(hours, minTime.getHours());
          if (hours === minTime.getHours() && minutes < minTime.getMinutes())
            minutes = minTime.getMinutes();
          if (minutes === minTime.getMinutes())
            seconds = Math.max(seconds, minTime.getSeconds());
        }
      }
      setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
      var date = dateObj || self.latestSelectedDateObj;
      if (date && date instanceof Date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    function setHours(hours, minutes, seconds) {
      if (self.latestSelectedDateObj !== void 0) {
        self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self.hourElement || !self.minuteElement || self.isMobile)
        return;
      self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self.minuteElement.value = pad(minutes);
      if (self.amPM !== void 0)
        self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
      if (self.secondElement !== void 0)
        self.secondElement.value = pad(seconds);
    }
    function onYearInput(event) {
      var eventTarget = getEventTarget(event);
      var year2 = parseInt(eventTarget.value) + (event.delta || 0);
      if (year2 / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year2.toString())) {
        changeYear(year2);
      }
    }
    function bind3(element2, event, handler4, options) {
      if (event instanceof Array)
        return event.forEach(function(ev) {
          return bind3(element2, ev, handler4, options);
        });
      if (element2 instanceof Array)
        return element2.forEach(function(el) {
          return bind3(el, event, handler4, options);
        });
      element2.addEventListener(event, handler4, options);
      self._handlers.push({
        remove: function() {
          return element2.removeEventListener(event, handler4, options);
        }
      });
    }
    function triggerChange() {
      triggerEvent("onChange");
    }
    function bindEvents() {
      if (self.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function(evt) {
          Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function(el) {
            return bind3(el, "click", self[evt]);
          });
        });
      }
      if (self.isMobile) {
        setupMobile();
        return;
      }
      var debouncedResize = debounce2(onResize, 50);
      self._debouncedChange = debounce2(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind3(self.daysContainer, "mouseover", function(e3) {
          if (self.config.mode === "range")
            onMouseOver(getEventTarget(e3));
        });
      bind3(self._input, "keydown", onKeyDown);
      if (self.calendarContainer !== void 0) {
        bind3(self.calendarContainer, "keydown", onKeyDown);
      }
      if (!self.config.inline && !self.config.static)
        bind3(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind3(window.document, "touchstart", documentClick);
      else
        bind3(window.document, "mousedown", documentClick);
      bind3(window.document, "focus", documentClick, { capture: true });
      if (self.config.clickOpens === true) {
        bind3(self._input, "focus", self.open);
        bind3(self._input, "click", self.open);
      }
      if (self.daysContainer !== void 0) {
        bind3(self.monthNav, "click", onMonthNavClick);
        bind3(self.monthNav, ["keyup", "increment"], onYearInput);
        bind3(self.daysContainer, "click", selectDate);
      }
      if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0) {
        var selText = function(e3) {
          return getEventTarget(e3).select();
        };
        bind3(self.timeContainer, ["increment"], updateTime);
        bind3(self.timeContainer, "blur", updateTime, { capture: true });
        bind3(self.timeContainer, "click", timeIncrement);
        bind3([self.hourElement, self.minuteElement], ["focus", "click"], selText);
        if (self.secondElement !== void 0)
          bind3(self.secondElement, "focus", function() {
            return self.secondElement && self.secondElement.select();
          });
        if (self.amPM !== void 0) {
          bind3(self.amPM, "click", function(e3) {
            updateTime(e3);
          });
        }
      }
      if (self.config.allowInput) {
        bind3(self._input, "blur", onBlur);
      }
    }
    function jumpToDate(jumpDate, triggerChange2) {
      var jumpTo = jumpDate !== void 0 ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
      var oldYear = self.currentYear;
      var oldMonth = self.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self.currentYear = jumpTo.getFullYear();
          self.currentMonth = jumpTo.getMonth();
        }
      } catch (e3) {
        e3.message = "Invalid date supplied: " + jumpTo;
        self.config.errorHandler(e3);
      }
      if (triggerChange2 && self.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self.redraw();
    }
    function timeIncrement(e3) {
      var eventTarget = getEventTarget(e3);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e3, delta, inputElem) {
      var target = e3 && getEventTarget(e3);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    function build() {
      var fragment = window.document.createDocumentFragment();
      self.calendarContainer = createElement("div", "flatpickr-calendar");
      self.calendarContainer.tabIndex = -1;
      if (!self.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self.config.weekNumbers) {
          var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
          self.innerContainer.appendChild(weekWrapper);
          self.weekNumbers = weekNumbers;
          self.weekWrapper = weekWrapper;
        }
        self.rContainer = createElement("div", "flatpickr-rContainer");
        self.rContainer.appendChild(buildWeekdays());
        if (!self.daysContainer) {
          self.daysContainer = createElement("div", "flatpickr-days");
          self.daysContainer.tabIndex = -1;
        }
        buildDays();
        self.rContainer.appendChild(self.daysContainer);
        self.innerContainer.appendChild(self.rContainer);
        fragment.appendChild(self.innerContainer);
      }
      if (self.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
      toggleClass(self.calendarContainer, "animate", self.config.animate === true);
      toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
      self.calendarContainer.appendChild(fragment);
      var customAppend = self.config.appendTo !== void 0 && self.config.appendTo.nodeType !== void 0;
      if (self.config.inline || self.config.static) {
        self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
        if (self.config.inline) {
          if (!customAppend && self.element.parentNode)
            self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
          else if (self.config.appendTo !== void 0)
            self.config.appendTo.appendChild(self.calendarContainer);
        }
        if (self.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self.element.parentNode)
            self.element.parentNode.insertBefore(wrapper, self.element);
          wrapper.appendChild(self.element);
          if (self.altInput)
            wrapper.appendChild(self.altInput);
          wrapper.appendChild(self.calendarContainer);
        }
      }
      if (!self.config.static && !self.config.inline)
        (self.config.appendTo !== void 0 ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
    }
    function createDay(className, date, _dayNumber, i3) {
      var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i3;
      dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
        self.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self.selectedDateElem = dayElement;
          if (self.config.mode === "range") {
            toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i3 % 7 === 6) {
        self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self.config.mode === "range")
        onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
      var endMonth = delta > 0 ? self.config.showMonths : -1;
      for (var m3 = startMonth; m3 != endMonth; m3 += delta) {
        var month = self.daysContainer.children[m3];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;
        for (var i3 = startIndex; i3 != endIndex; i3 += delta) {
          var c3 = month.children[i3];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj))
            return c3;
        }
      }
      return void 0;
    }
    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
      var endMonth = delta > 0 ? self.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;
      for (var m3 = givenMonth - self.currentMonth; m3 != endMonth; m3 += loopDelta) {
        var month = self.daysContainer.children[m3];
        var startIndex = givenMonth - self.currentMonth === m3 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;
        for (var i3 = startIndex; i3 >= 0 && i3 < numMonthDays && i3 != (delta > 0 ? numMonthDays : -1); i3 += loopDelta) {
          var c3 = month.children[i3];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj) && Math.abs(current.$i - i3) >= Math.abs(delta))
            return focusOnDayElem(c3);
        }
      }
      self.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    function focusOnDay(current, offset) {
      var activeElement = getClosestActiveElement();
      var dayFocused = isInView(activeElement || document.body);
      var startElem = current !== void 0 ? current : dayFocused ? activeElement : self.selectedDateElem !== void 0 && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== void 0 && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
      if (startElem === void 0) {
        self._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }
    function buildMonthDays(year2, month) {
      var firstOfMonth = (new Date(year2, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year2);
      var daysInMonth = self.utils.getDaysInMonth(month, year2), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year2, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day", new Date(year2, month, dayNumber), dayNumber, dayIndex));
      }
      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year2, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    function buildDays() {
      if (self.daysContainer === void 0) {
        return;
      }
      clearNode(self.daysContainer);
      if (self.weekNumbers)
        clearNode(self.weekNumbers);
      var frag = document.createDocumentFragment();
      for (var i3 = 0; i3 < self.config.showMonths; i3++) {
        var d2 = new Date(self.currentYear, self.currentMonth, 1);
        d2.setMonth(self.currentMonth + i3);
        frag.appendChild(buildMonthDays(d2.getFullYear(), d2.getMonth()));
      }
      self.daysContainer.appendChild(frag);
      self.days = self.daysContainer.firstChild;
      if (self.config.mode === "range" && self.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    function buildMonthSwitch() {
      if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown")
        return;
      var shouldBuildMonth = function(month2) {
        if (self.config.minDate !== void 0 && self.currentYear === self.config.minDate.getFullYear() && month2 < self.config.minDate.getMonth()) {
          return false;
        }
        return !(self.config.maxDate !== void 0 && self.currentYear === self.config.maxDate.getFullYear() && month2 > self.config.maxDate.getMonth());
      };
      self.monthsDropdownContainer.tabIndex = -1;
      self.monthsDropdownContainer.innerHTML = "";
      for (var i3 = 0; i3 < 12; i3++) {
        if (!shouldBuildMonth(i3))
          continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self.currentYear, i3).getMonth().toString();
        month.textContent = monthToStr(i3, self.config.shorthandCurrentMonth, self.l10n);
        month.tabIndex = -1;
        if (self.currentMonth === i3) {
          month.selected = true;
        }
        self.monthsDropdownContainer.appendChild(month);
      }
    }
    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
        bind3(self.monthsDropdownContainer, "change", function(e3) {
          var target = getEventTarget(e3);
          var selectedMonth = parseInt(target.value, 10);
          self.changeMonth(selectedMonth - self.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self.monthsDropdownContainer;
      }
      var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
      if (self.config.minDate) {
        yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
      }
      if (self.config.maxDate) {
        yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
      }
      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    function buildMonths() {
      clearNode(self.monthNav);
      self.monthNav.appendChild(self.prevMonthNav);
      if (self.config.showMonths) {
        self.yearElements = [];
        self.monthElements = [];
      }
      for (var m3 = self.config.showMonths; m3--; ) {
        var month = buildMonth();
        self.yearElements.push(month.yearElement);
        self.monthElements.push(month.monthElement);
        self.monthNav.appendChild(month.container);
      }
      self.monthNav.appendChild(self.nextMonthNav);
    }
    function buildMonthNav() {
      self.monthNav = createElement("div", "flatpickr-months");
      self.yearElements = [];
      self.monthElements = [];
      self.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self.prevMonthNav.innerHTML = self.config.prevArrow;
      self.nextMonthNav = createElement("span", "flatpickr-next-month");
      self.nextMonthNav.innerHTML = self.config.nextArrow;
      buildMonths();
      Object.defineProperty(self, "_hidePrevMonthArrow", {
        get: function() {
          return self.__hidePrevMonthArrow;
        },
        set: function(bool) {
          if (self.__hidePrevMonthArrow !== bool) {
            toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
            self.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self, "_hideNextMonthArrow", {
        get: function() {
          return self.__hideNextMonthArrow;
        },
        set: function(bool) {
          if (self.__hideNextMonthArrow !== bool) {
            toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
            self.__hideNextMonthArrow = bool;
          }
        }
      });
      self.currentYearElement = self.yearElements[0];
      updateNavigationCurrentMonth();
      return self.monthNav;
    }
    function buildTime() {
      self.calendarContainer.classList.add("hasTime");
      if (self.config.noCalendar)
        self.calendarContainer.classList.add("noCalendar");
      var defaults2 = getDefaultHours(self.config);
      self.timeContainer = createElement("div", "flatpickr-time");
      self.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self.l10n.hourAriaLabel
      });
      self.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self.l10n.minuteAriaLabel
      });
      self.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
      self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
      self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults2.minutes);
      self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
      self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
      self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
      self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
      self.hourElement.setAttribute("maxlength", "2");
      self.minuteElement.setAttribute("min", "0");
      self.minuteElement.setAttribute("max", "59");
      self.minuteElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(hourInput);
      self.timeContainer.appendChild(separator);
      self.timeContainer.appendChild(minuteInput);
      if (self.config.time_24hr)
        self.timeContainer.classList.add("time24hr");
      if (self.config.enableSeconds) {
        self.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self.secondElement = secondInput.getElementsByTagName("input")[0];
        self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults2.seconds);
        self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
        self.secondElement.setAttribute("min", "0");
        self.secondElement.setAttribute("max", "59");
        self.secondElement.setAttribute("maxlength", "2");
        self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self.timeContainer.appendChild(secondInput);
      }
      if (!self.config.time_24hr) {
        self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
        self.amPM.title = self.l10n.toggleTitle;
        self.amPM.tabIndex = -1;
        self.timeContainer.appendChild(self.amPM);
      }
      return self.timeContainer;
    }
    function buildWeekdays() {
      if (!self.weekdayContainer)
        self.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self.weekdayContainer);
      for (var i3 = self.config.showMonths; i3--; ) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self.weekdayContainer;
    }
    function updateWeekdays() {
      if (!self.weekdayContainer) {
        return;
      }
      var firstDayOfWeek = self.l10n.firstDayOfWeek;
      var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }
      for (var i3 = self.config.showMonths; i3--; ) {
        self.weekdayContainer.children[i3].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    function buildWeeks() {
      self.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }
      var delta = isOffset ? value : value - self.currentMonth;
      if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true)
        return;
      self.currentMonth += delta;
      if (self.currentMonth < 0 || self.currentMonth > 11) {
        self.currentYear += self.currentMonth > 11 ? 1 : -1;
        self.currentMonth = (self.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    function clear2(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }
      if (toInitial === void 0) {
        toInitial = true;
      }
      self.input.value = "";
      if (self.altInput !== void 0)
        self.altInput.value = "";
      if (self.mobileInput !== void 0)
        self.mobileInput.value = "";
      self.selectedDates = [];
      self.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self.currentYear = self._initialDate.getFullYear();
        self.currentMonth = self._initialDate.getMonth();
      }
      if (self.config.enableTime === true) {
        var _a = getDefaultHours(self.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
        setHours(hours, minutes, seconds);
      }
      self.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    function close() {
      self.isOpen = false;
      if (!self.isMobile) {
        if (self.calendarContainer !== void 0) {
          self.calendarContainer.classList.remove("open");
        }
        if (self._input !== void 0) {
          self._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    function destroy() {
      if (self.config !== void 0)
        triggerEvent("onDestroy");
      for (var i3 = self._handlers.length; i3--; ) {
        self._handlers[i3].remove();
      }
      self._handlers = [];
      if (self.mobileInput) {
        if (self.mobileInput.parentNode)
          self.mobileInput.parentNode.removeChild(self.mobileInput);
        self.mobileInput = void 0;
      } else if (self.calendarContainer && self.calendarContainer.parentNode) {
        if (self.config.static && self.calendarContainer.parentNode) {
          var wrapper = self.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self.calendarContainer.parentNode.removeChild(self.calendarContainer);
      }
      if (self.altInput) {
        self.input.type = "text";
        if (self.altInput.parentNode)
          self.altInput.parentNode.removeChild(self.altInput);
        delete self.altInput;
      }
      if (self.input) {
        self.input.type = self.input._type;
        self.input.classList.remove("flatpickr-input");
        self.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach(function(k3) {
        try {
          delete self[k3];
        } catch (_3) {
        }
      });
    }
    function isCalendarElem(elem) {
      return self.calendarContainer.contains(elem);
    }
    function documentClick(e3) {
      if (self.isOpen && !self.config.inline) {
        var eventTarget_1 = getEventTarget(e3);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e3.path && e3.path.indexOf && (~e3.path.indexOf(self.input) || ~e3.path.indexOf(self.altInput));
        var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
        var isIgnored = !self.config.ignoredFocusElements.some(function(elem) {
          return elem.contains(eventTarget_1);
        });
        if (lostFocus && isIgnored) {
          if (self.config.allowInput) {
            self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
          }
          if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0 && self.input.value !== "" && self.input.value !== void 0) {
            updateTime();
          }
          self.close();
          if (self.config && self.config.mode === "range" && self.selectedDates.length === 1)
            self.clear(false);
        }
      }
    }
    function changeYear(newYear) {
      if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear())
        return;
      var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
      self.currentYear = newYearNum || self.currentYear;
      if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
        self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
      } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
        self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
      }
      if (isNewYear) {
        self.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    function isEnabled(date, timeless) {
      var _a;
      if (timeless === void 0) {
        timeless = true;
      }
      var dateToCheck = self.parseDate(date, void 0, timeless);
      if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== void 0 ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== void 0 ? timeless : !self.maxDateHasTime) > 0)
        return false;
      if (!self.config.enable && self.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      var bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
      for (var i3 = 0, d2 = void 0; i3 < array.length; i3++) {
        d2 = array[i3];
        if (typeof d2 === "function" && d2(dateToCheck))
          return bool;
        else if (d2 instanceof Date && dateToCheck !== void 0 && d2.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d2 === "string") {
          var parsed = self.parseDate(d2, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d2 === "object" && dateToCheck !== void 0 && d2.from && d2.to && dateToCheck.getTime() >= d2.from.getTime() && dateToCheck.getTime() <= d2.to.getTime())
          return bool;
      }
      return !bool;
    }
    function isInView(elem) {
      if (self.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
      return false;
    }
    function onBlur(e3) {
      var isInput = e3.target === self._input;
      var valueChanged = self._input.value.trimEnd() !== getDateStr();
      if (isInput && valueChanged && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
        self.setDate(self._input.value, true, e3.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
      }
    }
    function onKeyDown(e3) {
      var eventTarget = getEventTarget(e3);
      var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
      var allowInput = self.config.allowInput;
      var allowKeydown = self.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self.config.inline && isInput && !allowInput;
      if (e3.keyCode === 13 && isInput) {
        if (allowInput) {
          self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
          self.close();
          return eventTarget.blur();
        } else {
          self.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
        switch (e3.keyCode) {
          case 13:
            if (isTimeObj) {
              e3.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e3);
            break;
          case 27:
            e3.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self.config.allowInput) {
              e3.preventDefault();
              self.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e3.preventDefault();
              var activeElement = getClosestActiveElement();
              if (self.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                var delta_1 = e3.keyCode === 39 ? 1 : -1;
                if (!e3.ctrlKey)
                  focusOnDay(void 0, delta_1);
                else {
                  e3.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self.hourElement)
              self.hourElement.focus();
            break;
          case 38:
          case 40:
            e3.preventDefault();
            var delta = e3.keyCode === 40 ? 1 : -1;
            if (self.daysContainer && eventTarget.$i !== void 0 || eventTarget === self.input || eventTarget === self.altInput) {
              if (e3.ctrlKey) {
                e3.stopPropagation();
                changeYear(self.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self.currentYearElement) {
              changeYear(self.currentYear - delta);
            } else if (self.config.enableTime) {
              if (!isTimeObj && self.hourElement)
                self.hourElement.focus();
              updateTime(e3);
              self._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              var elems = [
                self.hourElement,
                self.minuteElement,
                self.secondElement,
                self.amPM
              ].concat(self.pluginElements).filter(function(x4) {
                return x4;
              });
              var i3 = elems.indexOf(eventTarget);
              if (i3 !== -1) {
                var target = elems[i3 + (e3.shiftKey ? -1 : 1)];
                e3.preventDefault();
                (target || self._input).focus();
              }
            } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e3.shiftKey) {
              e3.preventDefault();
              self._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self.amPM !== void 0 && eventTarget === self.amPM) {
        switch (e3.key) {
          case self.l10n.amPM[0].charAt(0):
          case self.l10n.amPM[0].charAt(0).toLowerCase():
            self.amPM.textContent = self.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self.l10n.amPM[1].charAt(0):
          case self.l10n.amPM[1].charAt(0).toLowerCase():
            self.amPM.textContent = self.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e3);
      }
    }
    function onMouseOver(elem, cellClass) {
      if (cellClass === void 0) {
        cellClass = "flatpickr-day";
      }
      if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
        return;
      var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0, maxRange = 0;
      for (var t3 = rangeStartDate; t3 < rangeEndDate; t3 += duration.DAY) {
        if (!isEnabled(new Date(t3), true)) {
          containsDisabled = containsDisabled || t3 > rangeStartDate && t3 < rangeEndDate;
          if (t3 < initialDate && (!minRange || t3 > minRange))
            minRange = t3;
          else if (t3 > initialDate && (!maxRange || t3 < maxRange))
            maxRange = t3;
        }
      }
      var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
      hoverableCells.forEach(function(dayElem) {
        var date = dayElem.dateObj;
        var timestamp = date.getTime();
        var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach(function(c3) {
            dayElem.classList.remove(c3);
          });
          return;
        } else if (containsDisabled && !outOfRange)
          return;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c3) {
          dayElem.classList.remove(c3);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      });
    }
    function onResize() {
      if (self.isOpen && !self.config.static && !self.config.inline)
        positionCalendar();
    }
    function open(e3, positionElement) {
      if (positionElement === void 0) {
        positionElement = self._positionElement;
      }
      if (self.isMobile === true) {
        if (e3) {
          e3.preventDefault();
          var eventTarget = getEventTarget(e3);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self.mobileInput !== void 0) {
          self.mobileInput.focus();
          self.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self._input.disabled || self.config.inline) {
        return;
      }
      var wasOpen = self.isOpen;
      self.isOpen = true;
      if (!wasOpen) {
        self.calendarContainer.classList.add("open");
        self._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self.config.enableTime === true && self.config.noCalendar === true) {
        if (self.config.allowInput === false && (e3 === void 0 || !self.timeContainer.contains(e3.relatedTarget))) {
          setTimeout(function() {
            return self.hourElement.select();
          }, 50);
        }
      }
    }
    function minMaxDateSetter(type) {
      return function(date) {
        var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
        var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
        if (dateObj !== void 0) {
          self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self.selectedDates) {
          self.selectedDates = self.selectedDates.filter(function(d2) {
            return isEnabled(d2);
          });
          if (!self.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self.currentYearElement.removeAttribute(type);
          self.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    function parseConfig() {
      var boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      var formats2 = {};
      self.config.parseDate = userConfig.parseDate;
      self.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self.config, "enable", {
        get: function() {
          return self.config._enable;
        },
        set: function(dates) {
          self.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self.config, "disable", {
        get: function() {
          return self.config._disable;
        },
        set: function(dates) {
          self.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }
      Object.defineProperty(self.config, "minDate", {
        get: function() {
          return self.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self.config, "maxDate", {
        get: function() {
          return self.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });
      var minMaxTimeSetter = function(type) {
        return function(val) {
          self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
        };
      };
      Object.defineProperty(self.config, "minTime", {
        get: function() {
          return self.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self.config, "maxTime", {
        get: function() {
          return self.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self.config.noCalendar = true;
        self.config.enableTime = true;
      }
      Object.assign(self.config, formats2, userConfig);
      for (var i3 = 0; i3 < boolOpts.length; i3++)
        self.config[boolOpts[i3]] = self.config[boolOpts[i3]] === true || self.config[boolOpts[i3]] === "true";
      HOOKS.filter(function(hook) {
        return self.config[hook] !== void 0;
      }).forEach(function(hook) {
        self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
      });
      self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (var i3 = 0; i3 < self.config.plugins.length; i3++) {
        var pluginConf = self.config.plugins[i3](self) || {};
        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    function getInputElem() {
      return self.config.wrap ? element.querySelector("[data-input]") : element;
    }
    function setupLocale() {
      if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined")
        self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
      self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : void 0);
      tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
      tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
      tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
      tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
      tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
      var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self.config.time_24hr = self.l10n.time_24hr;
      }
      self.formatDate = createDateFormatter(self);
      self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
    }
    function positionCalendar(customPositionElement) {
      if (typeof self.config.position === "function") {
        return void self.config.position(self, customPositionElement);
      }
      if (self.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function(acc, child) {
        return acc + child.offsetHeight;
      }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
      if (self.config.inline)
        return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;
      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self.calendarContainer, "rightMost", rightMost);
      if (self.config.static)
        return;
      self.calendarContainer.style.top = top + "px";
      if (!rightMost) {
        self.calendarContainer.style.left = left + "px";
        self.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self.calendarContainer.style.left = "auto";
        self.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self.calendarContainer, "rightMost", false);
        toggleClass(self.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self.calendarContainer.style.left = centerLeft + "px";
        self.calendarContainer.style.right = "auto";
      }
    }
    function getDocumentStyleSheet() {
      var editableSheet = null;
      for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
        var sheet = document.styleSheets[i3];
        if (!sheet.cssRules)
          continue;
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    function redraw() {
      if (self.config.noCalendar || self.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    function focusAndClose() {
      self._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self.close, 0);
      } else {
        self.close();
      }
    }
    function selectDate(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      var isSelectable = function(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      };
      var t3 = findParent(getEventTarget(e3), isSelectable);
      if (t3 === void 0)
        return;
      var target = t3;
      var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
      self.selectedDateElem = target;
      if (self.config.mode === "single")
        self.selectedDates = [selectedDate];
      else if (self.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self.selectedDates.push(selectedDate);
      } else if (self.config.mode === "range") {
        if (self.selectedDates.length === 2) {
          self.clear(false, false);
        }
        self.latestSelectedDateObj = selectedDate;
        self.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
          self.selectedDates.sort(function(a3, b3) {
            return a3.getTime() - b3.getTime();
          });
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        var isNewYear = self.currentYear !== selectedDate.getFullYear();
        self.currentYear = selectedDate.getFullYear();
        self.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self.selectedDateElem !== void 0 && self.hourElement === void 0) {
        self.selectedDateElem && self.selectedDateElem.focus();
      }
      if (self.hourElement !== void 0)
        self.hourElement !== void 0 && self.hourElement.focus();
      if (self.config.closeOnSelect) {
        var single = self.config.mode === "single" && !self.config.enableTime;
        var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      positionElement: [updatePositionElement],
      clickOpens: [
        function() {
          if (self.config.clickOpens === true) {
            bind3(self._input, "focus", self.open);
            bind3(self._input, "click", self.open);
          } else {
            self._input.removeEventListener("focus", self.open);
            self._input.removeEventListener("click", self.open);
          }
        }
      ]
    };
    function set3(option, value) {
      if (option !== null && typeof option === "object") {
        Object.assign(self.config, option);
        for (var key in option) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach(function(x4) {
              return x4();
            });
        }
      } else {
        self.config[option] = value;
        if (CALLBACKS[option] !== void 0)
          CALLBACKS[option].forEach(function(x4) {
            return x4();
          });
        else if (HOOKS.indexOf(option) > -1)
          self.config[option] = arrayify(value);
      }
      self.redraw();
      updateValue(true);
    }
    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map(function(d2) {
          return self.parseDate(d2, format);
        });
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self.parseDate(inputDate, format)];
      else if (typeof inputDate === "string") {
        switch (self.config.mode) {
          case "single":
          case "time":
            dates = [self.parseDate(inputDate, format)];
            break;
          case "multiple":
            dates = inputDate.split(self.config.conjunction).map(function(date) {
              return self.parseDate(date, format);
            });
            break;
          case "range":
            dates = inputDate.split(self.l10n.rangeSeparator).map(function(date) {
              return self.parseDate(date, format);
            });
            break;
          default:
            break;
        }
      } else
        self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function(d2) {
        return d2 instanceof Date && isEnabled(d2, false);
      });
      if (self.config.mode === "range")
        self.selectedDates.sort(function(a3, b3) {
          return a3.getTime() - b3.getTime();
        });
    }
    function setDate(date, triggerChange2, format) {
      if (triggerChange2 === void 0) {
        triggerChange2 = false;
      }
      if (format === void 0) {
        format = self.config.dateFormat;
      }
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self.clear(triggerChange2);
      setSelectedDate(date, format);
      self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
      self.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self.selectedDates.length === 0) {
        self.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    function parseDateRules(arr) {
      return arr.slice().map(function(rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self.parseDate(rule.from, void 0),
            to: self.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter(function(x4) {
        return x4;
      });
    }
    function setupDates() {
      self.selectedDates = [];
      self.now = self.parseDate(self.config.now) || /* @__PURE__ */ new Date();
      var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self.config.dateFormat);
      self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
      if (self.selectedDates.length > 0)
        self.latestSelectedDateObj = self.selectedDates[0];
      if (self.config.minTime !== void 0)
        self.config.minTime = self.parseDate(self.config.minTime, "H:i");
      if (self.config.maxTime !== void 0)
        self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
      self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
      self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
      self.input = getInputElem();
      if (!self.input) {
        self.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self.input._type = self.input.type;
      self.input.type = "text";
      self.input.classList.add("flatpickr-input");
      self._input = self.input;
      if (self.config.altInput) {
        self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
        self._input = self.altInput;
        self.altInput.placeholder = self.input.placeholder;
        self.altInput.disabled = self.input.disabled;
        self.altInput.required = self.input.required;
        self.altInput.tabIndex = self.input.tabIndex;
        self.altInput.type = "text";
        self.input.setAttribute("type", "hidden");
        if (!self.config.static && self.input.parentNode)
          self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
      }
      if (!self.config.allowInput)
        self._input.setAttribute("readonly", "readonly");
      updatePositionElement();
    }
    function updatePositionElement() {
      self._positionElement = self.config.positionElement || self._input;
    }
    function setupMobile() {
      var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
      self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
      self.mobileInput.tabIndex = 1;
      self.mobileInput.type = inputType;
      self.mobileInput.disabled = self.input.disabled;
      self.mobileInput.required = self.input.required;
      self.mobileInput.placeholder = self.input.placeholder;
      self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self.selectedDates.length > 0) {
        self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
      }
      if (self.config.minDate)
        self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
      if (self.config.maxDate)
        self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
      if (self.input.getAttribute("step"))
        self.mobileInput.step = String(self.input.getAttribute("step"));
      self.input.type = "hidden";
      if (self.altInput !== void 0)
        self.altInput.type = "hidden";
      try {
        if (self.input.parentNode)
          self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
      } catch (_a) {
      }
      bind3(self.mobileInput, "change", function(e3) {
        self.setDate(getEventTarget(e3).value, false, self.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    function toggle(e3) {
      if (self.isOpen === true)
        return self.close();
      self.open(e3);
    }
    function triggerEvent(event, data2) {
      if (self.config === void 0)
        return;
      var hooks = self.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (var i3 = 0; hooks[i3] && i3 < hooks.length; i3++)
          hooks[i3](self.selectedDates, self.input.value, self, data2);
      }
      if (event === "onChange") {
        self.input.dispatchEvent(createEvent("change"));
        self.input.dispatchEvent(createEvent("input"));
      }
    }
    function createEvent(name) {
      var e3 = document.createEvent("Event");
      e3.initEvent(name, true, true);
      return e3;
    }
    function isDateSelected(date) {
      for (var i3 = 0; i3 < self.selectedDates.length; i3++) {
        var selectedDate = self.selectedDates[i3];
        if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
          return "" + i3;
      }
      return false;
    }
    function isDateInRange(date) {
      if (self.config.mode !== "range" || self.selectedDates.length < 2)
        return false;
      return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
    }
    function updateNavigationCurrentMonth() {
      if (self.config.noCalendar || self.isMobile || !self.monthNav)
        return;
      self.yearElements.forEach(function(yearElement, i3) {
        var d2 = new Date(self.currentYear, self.currentMonth, 1);
        d2.setMonth(self.currentMonth + i3);
        if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
          self.monthElements[i3].textContent = monthToStr(d2.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
        } else {
          self.monthsDropdownContainer.value = d2.getMonth().toString();
        }
        yearElement.value = d2.getFullYear().toString();
      });
      self._hidePrevMonthArrow = self.config.minDate !== void 0 && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
      self._hideNextMonthArrow = self.config.maxDate !== void 0 && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
    }
    function getDateStr(specificFormat) {
      var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
      return self.selectedDates.map(function(dObj) {
        return self.formatDate(dObj, format);
      }).filter(function(d2, i3, arr) {
        return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d2) === i3;
      }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
    }
    function updateValue(triggerChange2) {
      if (triggerChange2 === void 0) {
        triggerChange2 = true;
      }
      if (self.mobileInput !== void 0 && self.mobileFormatStr) {
        self.mobileInput.value = self.latestSelectedDateObj !== void 0 ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
      }
      self.input.value = getDateStr(self.config.dateFormat);
      if (self.altInput !== void 0) {
        self.altInput.value = getDateStr(self.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e3) {
      var eventTarget = getEventTarget(e3);
      var isPrevMonth = self.prevMonthNav.contains(eventTarget);
      var isNextMonth = self.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self.changeYear(self.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self.changeYear(self.currentYear - 1);
      }
    }
    function timeWrapper(e3) {
      e3.preventDefault();
      var isKeyDown = e3.type === "keydown", eventTarget = getEventTarget(e3), input = eventTarget;
      if (self.amPM !== void 0 && eventTarget === self.amPM) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown ? e3.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
        if (newValue < min) {
          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self.hourElement);
        } else if (newValue > max) {
          newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self.hourElement);
        }
        if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    init();
    return self;
  }
  function _flatpickr(nodeList, config2) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x4) {
      return x4 instanceof HTMLElement;
    });
    var instances = [];
    for (var i3 = 0; i3 < nodes.length; i3++) {
      var node = nodes[i3];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config2 || {});
        instances.push(node._flatpickr);
      } catch (e3) {
        console.error(e3);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
      return _flatpickr(this, config2);
    };
    HTMLElement.prototype.flatpickr = function(config2) {
      return _flatpickr([this], config2);
    };
  }
  var flatpickr = function(selector, config2) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config2);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config2);
    } else {
      return _flatpickr(selector, config2);
    }
  };
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: __assign({}, default_default),
    default: __assign({}, default_default)
  };
  flatpickr.localize = function(l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = function(config2) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config2);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config2) {
      return _flatpickr(this, config2);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  var esm_default = flatpickr;

  // node_modules/just-extend/index.esm.js
  var objectExtend = extend;
  function extend() {
    var args = [].slice.call(arguments);
    var deep = false;
    if (typeof args[0] == "boolean") {
      deep = args.shift();
    }
    var result = args[0];
    if (isUnextendable(result)) {
      throw new Error("extendee must be an object");
    }
    var extenders = args.slice(1);
    var len = extenders.length;
    for (var i3 = 0; i3 < len; i3++) {
      var extender = extenders[i3];
      for (var key in extender) {
        if (Object.prototype.hasOwnProperty.call(extender, key)) {
          var value = extender[key];
          if (deep && isCloneable(value)) {
            var base = Array.isArray(value) ? [] : {};
            result[key] = extend(
              true,
              Object.prototype.hasOwnProperty.call(result, key) && !isUnextendable(result[key]) ? result[key] : base,
              value
            );
          } else {
            result[key] = value;
          }
        }
      }
    }
    return result;
  }
  function isCloneable(obj) {
    return Array.isArray(obj) || {}.toString.call(obj) == "[object Object]";
  }
  function isUnextendable(val) {
    return !val || typeof val != "object" && typeof val != "function";
  }

  // node_modules/dropzone/dist/dropzone.mjs
  function $parcel$interopDefault(a3) {
    return a3 && a3.__esModule ? a3.default : a3;
  }
  var $4040acfd8584338d$export$2e2bcd8739ae039 = class {
    // Add an event listener for given event
    on(event, fn) {
      this._callbacks = this._callbacks || {};
      if (!this._callbacks[event]) this._callbacks[event] = [];
      this._callbacks[event].push(fn);
      return this;
    }
    emit(event, ...args) {
      this._callbacks = this._callbacks || {};
      let callbacks = this._callbacks[event];
      if (callbacks) for (let callback of callbacks) callback.apply(this, args);
      if (this.element) this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
        args
      }));
      return this;
    }
    makeEvent(eventName, detail) {
      let params = {
        bubbles: true,
        cancelable: true,
        detail
      };
      if (typeof window.CustomEvent === "function") return new CustomEvent(eventName, params);
      else {
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
    }
    // Remove event listener for given event. If fn is not provided, all event
    // listeners for that event will be removed. If neither is provided, all
    // event listeners will be removed.
    off(event, fn) {
      if (!this._callbacks || arguments.length === 0) {
        this._callbacks = {};
        return this;
      }
      let callbacks = this._callbacks[event];
      if (!callbacks) return this;
      if (arguments.length === 1) {
        delete this._callbacks[event];
        return this;
      }
      for (let i3 = 0; i3 < callbacks.length; i3++) {
        let callback = callbacks[i3];
        if (callback === fn) {
          callbacks.splice(i3, 1);
          break;
        }
      }
      return this;
    }
  };
  var $fd6031f88dce2e32$exports = {};
  $fd6031f88dce2e32$exports = '<div class="dz-preview dz-file-preview">\n  <div class="dz-image"><img data-dz-thumbnail=""></div>\n  <div class="dz-details">\n    <div class="dz-size"><span data-dz-size=""></span></div>\n    <div class="dz-filename"><span data-dz-name=""></span></div>\n  </div>\n  <div class="dz-progress">\n    <span class="dz-upload" data-dz-uploadprogress=""></span>\n  </div>\n  <div class="dz-error-message"><span data-dz-errormessage=""></span></div>\n  <div class="dz-success-mark">\n    <svg width="54" height="54" viewBox="0 0 54 54" fill="white" xmlns="http://www.w3.org/2000/svg">\n      <path d="M10.2071 29.7929L14.2929 25.7071C14.6834 25.3166 15.3166 25.3166 15.7071 25.7071L21.2929 31.2929C21.6834 31.6834 22.3166 31.6834 22.7071 31.2929L38.2929 15.7071C38.6834 15.3166 39.3166 15.3166 39.7071 15.7071L43.7929 19.7929C44.1834 20.1834 44.1834 20.8166 43.7929 21.2071L22.7071 42.2929C22.3166 42.6834 21.6834 42.6834 21.2929 42.2929L10.2071 31.2071C9.81658 30.8166 9.81658 30.1834 10.2071 29.7929Z"></path>\n    </svg>\n  </div>\n  <div class="dz-error-mark">\n    <svg width="54" height="54" viewBox="0 0 54 54" fill="white" xmlns="http://www.w3.org/2000/svg">\n      <path d="M26.2929 20.2929L19.2071 13.2071C18.8166 12.8166 18.1834 12.8166 17.7929 13.2071L13.2071 17.7929C12.8166 18.1834 12.8166 18.8166 13.2071 19.2071L20.2929 26.2929C20.6834 26.6834 20.6834 27.3166 20.2929 27.7071L13.2071 34.7929C12.8166 35.1834 12.8166 35.8166 13.2071 36.2071L17.7929 40.7929C18.1834 41.1834 18.8166 41.1834 19.2071 40.7929L26.2929 33.7071C26.6834 33.3166 27.3166 33.3166 27.7071 33.7071L34.7929 40.7929C35.1834 41.1834 35.8166 41.1834 36.2071 40.7929L40.7929 36.2071C41.1834 35.8166 41.1834 35.1834 40.7929 34.7929L33.7071 27.7071C33.3166 27.3166 33.3166 26.6834 33.7071 26.2929L40.7929 19.2071C41.1834 18.8166 41.1834 18.1834 40.7929 17.7929L36.2071 13.2071C35.8166 12.8166 35.1834 12.8166 34.7929 13.2071L27.7071 20.2929C27.3166 20.6834 26.6834 20.6834 26.2929 20.2929Z"></path>\n    </svg>\n  </div>\n</div>\n';
  var $4ca367182776f80b$var$defaultOptions = {
    /**
    * Has to be specified on elements other than form (or when the form doesn't
    * have an `action` attribute).
    *
    * You can also provide a function that will be called with `files` and
    * `dataBlocks`  and must return the url as string.
    */
    url: null,
    /**
    * Can be changed to `"put"` if necessary. You can also provide a function
    * that will be called with `files` and must return the method (since `v3.12.0`).
    */
    method: "post",
    /**
    * Will be set on the XHRequest.
    */
    withCredentials: false,
    /**
    * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
    * If set to null or 0, no timeout is going to be set.
    */
    timeout: null,
    /**
    * How many file uploads to process in parallel (See the
    * Enqueuing file uploads documentation section for more info)
    */
    parallelUploads: 2,
    /**
    * Whether to send multiple files in one request. If
    * this it set to true, then the fallback file input element will
    * have the `multiple` attribute as well. This option will
    * also trigger additional events (like `processingmultiple`). See the events
    * documentation section for more information.
    */
    uploadMultiple: false,
    /**
    * Whether you want files to be uploaded in chunks to your server. This can't be
    * used in combination with `uploadMultiple`.
    *
    * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
    */
    chunking: false,
    /**
    * If `chunking` is enabled, this defines whether **every** file should be chunked,
    * even if the file size is below chunkSize. This means, that the additional chunk
    * form data will be submitted and the `chunksUploaded` callback will be invoked.
    */
    forceChunking: false,
    /**
    * If `chunking` is `true`, then this defines the chunk size in bytes.
    */
    chunkSize: 2097152,
    /**
    * If `true`, the individual chunks of a file are being uploaded simultaneously.
    */
    parallelChunkUploads: false,
    /**
    * Whether a chunk should be retried if it fails.
    */
    retryChunks: false,
    /**
    * If `retryChunks` is true, how many times should it be retried.
    */
    retryChunksLimit: 3,
    /**
    * The maximum filesize (in MiB) that is allowed to be uploaded.
    */
    maxFilesize: 256,
    /**
    * The name of the file param that gets transferred.
    * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
    * Dropzone will append `[]` to the name.
    */
    paramName: "file",
    /**
    * Whether thumbnails for images should be generated
    */
    createImageThumbnails: true,
    /**
    * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
    */
    maxThumbnailFilesize: 10,
    /**
    * If `null`, the ratio of the image will be used to calculate it.
    */
    thumbnailWidth: 120,
    /**
    * The same as `thumbnailWidth`. If both are null, images will not be resized.
    */
    thumbnailHeight: 120,
    /**
    * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
    * Can be either `contain` or `crop`.
    */
    thumbnailMethod: "crop",
    /**
    * If set, images will be resized to these dimensions before being **uploaded**.
    * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
    * ratio of the file will be preserved.
    *
    * The `options.transformFile` function uses these options, so if the `transformFile` function
    * is overridden, these options don't do anything.
    */
    resizeWidth: null,
    /**
    * See `resizeWidth`.
    */
    resizeHeight: null,
    /**
    * The mime type of the resized image (before it gets uploaded to the server).
    * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
    * See `resizeWidth` for more information.
    */
    resizeMimeType: null,
    /**
    * The quality of the resized images. See `resizeWidth`.
    */
    resizeQuality: 0.8,
    /**
    * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
    * Can be either `contain` or `crop`.
    */
    resizeMethod: "contain",
    /**
    * The base that is used to calculate the **displayed** filesize. You can
    * change this to 1024 if you would rather display kibibytes, mebibytes,
    * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
    * not `1 kilobyte`. You can change this to `1024` if you don't care about
    * validity.
    */
    filesizeBase: 1e3,
    /**
    * If not `null` defines how many files this Dropzone handles. If it exceeds,
    * the event `maxfilesexceeded` will be called. The dropzone element gets the
    * class `dz-max-files-reached` accordingly so you can provide visual
    * feedback.
    */
    maxFiles: null,
    /**
    * An optional object to send additional headers to the server. Eg:
    * `{ "My-Awesome-Header": "header value" }`
    */
    headers: null,
    /**
    * Should the default headers be set or not?
    * Accept: application/json <- for requesting json response
    * Cache-Control: no-cache <- Request shouldnt be cached
    * X-Requested-With: XMLHttpRequest <- We sent the request via XMLHttpRequest
    */
    defaultHeaders: true,
    /**
    * If `true`, the dropzone element itself will be clickable, if `false`
    * nothing will be clickable.
    *
    * You can also pass an HTML element, a CSS selector (for multiple elements)
    * or an array of those. In that case, all of those elements will trigger an
    * upload when clicked.
    */
    clickable: true,
    /**
    * Whether hidden files in directories should be ignored.
    */
    ignoreHiddenFiles: true,
    /**
    * The default implementation of `accept` checks the file's mime type or
    * extension against this list. This is a comma separated list of mime
    * types or file extensions.
    *
    * Eg.: `image/*,application/pdf,.psd`
    *
    * If the Dropzone is `clickable` this option will also be used as
    * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
    * parameter on the hidden file input as well.
    */
    acceptedFiles: null,
    /**
    * **Deprecated!**
    * Use acceptedFiles instead.
    */
    acceptedMimeTypes: null,
    /**
    * If false, files will be added to the queue but the queue will not be
    * processed automatically.
    * This can be useful if you need some additional user input before sending
    * files (or if you want want all files sent at once).
    * If you're ready to send the file simply call `myDropzone.processQueue()`.
    *
    * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
    * section for more information.
    */
    autoProcessQueue: true,
    /**
    * If false, files added to the dropzone will not be queued by default.
    * You'll have to call `enqueueFile(file)` manually.
    */
    autoQueue: true,
    /**
    * If `true`, this will add a link to every file preview to remove or cancel (if
    * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
    * and `dictRemoveFile` options are used for the wording.
    */
    addRemoveLinks: false,
    /**
    * Defines where to display the file previews  if `null` the
    * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
    * selector. The element should have the `dropzone-previews` class so
    * the previews are displayed properly.
    */
    previewsContainer: null,
    /**
    * Set this to `true` if you don't want previews to be shown.
    */
    disablePreviews: false,
    /**
    * This is the element the hidden input field (which is used when clicking on the
    * dropzone to trigger file selection) will be appended to. This might
    * be important in case you use frameworks to switch the content of your page.
    *
    * Can be a selector string, or an element directly.
    */
    hiddenInputContainer: "body",
    /**
    * If null, no capture type will be specified
    * If camera, mobile devices will skip the file selection and choose camera
    * If microphone, mobile devices will skip the file selection and choose the microphone
    * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
    * On apple devices multiple must be set to false.  AcceptedFiles may need to
    * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
    */
    capture: null,
    /**
    * **Deprecated**. Use `renameFile` instead.
    */
    renameFilename: null,
    /**
    * A function that is invoked before the file is uploaded to the server and renames the file.
    * This function gets the `File` as argument and can use the `file.name`. The actual name of the
    * file that gets used during the upload can be accessed through `file.upload.filename`.
    */
    renameFile: null,
    /**
    * If `true` the fallback will be forced. This is very useful to test your server
    * implementations first and make sure that everything works as
    * expected without dropzone if you experience problems, and to test
    * how your fallbacks will look.
    */
    forceFallback: false,
    /**
    * The text used before any files are dropped.
    */
    dictDefaultMessage: "Drop files here to upload",
    /**
    * The text that replaces the default message text it the browser is not supported.
    */
    dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
    /**
    * The text that will be added before the fallback form.
    * If you provide a  fallback element yourself, or if this option is `null` this will
    * be ignored.
    */
    dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
    /**
    * If the filesize is too big.
    * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
    */
    dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
    /**
    * If the file doesn't match the file type.
    */
    dictInvalidFileType: "You can't upload files of this type.",
    /**
    * If the server response was invalid.
    * `{{statusCode}}` will be replaced with the servers status code.
    */
    dictResponseError: "Server responded with {{statusCode}} code.",
    /**
    * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
    */
    dictCancelUpload: "Cancel upload",
    /**
    * The text that is displayed if an upload was manually canceled
    */
    dictUploadCanceled: "Upload canceled.",
    /**
    * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
    */
    dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
    /**
    * If `addRemoveLinks` is true, the text to be used to remove a file.
    */
    dictRemoveFile: "Remove file",
    /**
    * If this is not null, then the user will be prompted before removing a file.
    */
    dictRemoveFileConfirmation: null,
    /**
    * Displayed if `maxFiles` is st and exceeded.
    * The string `{{maxFiles}}` will be replaced by the configuration value.
    */
    dictMaxFilesExceeded: "You can not upload any more files.",
    /**
    * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
    * `b` for bytes.
    */
    dictFileSizeUnits: {
      tb: "TB",
      gb: "GB",
      mb: "MB",
      kb: "KB",
      b: "b"
    },
    /**
    * Called when dropzone initialized
    * You can add event listeners here
    */
    init() {
    },
    /**
    * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
    * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
    * of a function, this needs to return a map.
    *
    * The default implementation does nothing for normal uploads, but adds relevant information for
    * chunked uploads.
    *
    * This is the same as adding hidden input fields in the form element.
    */
    params(files, xhr, chunk) {
      if (chunk) return {
        dzuuid: chunk.file.upload.uuid,
        dzchunkindex: chunk.index,
        dztotalfilesize: chunk.file.size,
        dzchunksize: this.options.chunkSize,
        dztotalchunkcount: chunk.file.upload.totalChunkCount,
        dzchunkbyteoffset: chunk.index * this.options.chunkSize
      };
    },
    /**
    * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
    * and a `done` function as parameters.
    *
    * If the done function is invoked without arguments, the file is "accepted" and will
    * be processed. If you pass an error message, the file is rejected, and the error
    * message will be displayed.
    * This function will not be called if the file is too big or doesn't match the mime types.
    */
    accept(file, done) {
      return done();
    },
    /**
    * The callback that will be invoked when all chunks have been uploaded for a file.
    * It gets the file for which the chunks have been uploaded as the first parameter,
    * and the `done` function as second. `done()` needs to be invoked when everything
    * needed to finish the upload process is done.
    */
    chunksUploaded: function(file, done) {
      done();
    },
    /**
    * Sends the file as binary blob in body instead of form data.
    * If this is set, the `params` option will be ignored.
    * It's an error to set this to `true` along with `uploadMultiple` since
    * multiple files cannot be in a single binary body.
    */
    binaryBody: false,
    /**
    * Gets called when the browser is not supported.
    * The default implementation shows the fallback input field and adds
    * a text.
    */
    fallback() {
      let messageElement;
      this.element.className = `${this.element.className} dz-browser-not-supported`;
      for (let child of this.element.getElementsByTagName("div")) if (/(^| )dz-message($| )/.test(child.className)) {
        messageElement = child;
        child.className = "dz-message";
        break;
      }
      if (!messageElement) {
        messageElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement('<div class="dz-message"><span></span></div>');
        this.element.appendChild(messageElement);
      }
      let span = messageElement.getElementsByTagName("span")[0];
      if (span) {
        if (span.textContent != null) span.textContent = this.options.dictFallbackMessage;
        else if (span.innerText != null) span.innerText = this.options.dictFallbackMessage;
      }
      return this.element.appendChild(this.getFallbackForm());
    },
    /**
    * Gets called to calculate the thumbnail dimensions.
    *
    * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
    *
    *  - `srcWidth` & `srcHeight` (required)
    *  - `trgWidth` & `trgHeight` (required)
    *  - `srcX` & `srcY` (optional, default `0`)
    *  - `trgX` & `trgY` (optional, default `0`)
    *
    * Those values are going to be used by `ctx.drawImage()`.
    */
    resize(file, width, height, resizeMethod) {
      let info = {
        srcX: 0,
        srcY: 0,
        srcWidth: file.width,
        srcHeight: file.height
      };
      let srcRatio = file.width / file.height;
      if (width == null && height == null) {
        width = info.srcWidth;
        height = info.srcHeight;
      } else if (width == null) width = height * srcRatio;
      else if (height == null) height = width / srcRatio;
      width = Math.min(width, info.srcWidth);
      height = Math.min(height, info.srcHeight);
      let trgRatio = width / height;
      if (info.srcWidth > width || info.srcHeight > height) {
        if (resizeMethod === "crop") {
          if (srcRatio > trgRatio) {
            info.srcHeight = file.height;
            info.srcWidth = info.srcHeight * trgRatio;
          } else {
            info.srcWidth = file.width;
            info.srcHeight = info.srcWidth / trgRatio;
          }
        } else if (resizeMethod === "contain") {
          if (srcRatio > trgRatio) height = width / srcRatio;
          else width = height * srcRatio;
        } else throw new Error(`Unknown resizeMethod '${resizeMethod}'`);
      }
      info.srcX = (file.width - info.srcWidth) / 2;
      info.srcY = (file.height - info.srcHeight) / 2;
      info.trgWidth = width;
      info.trgHeight = height;
      return info;
    },
    /**
    * Can be used to transform the file (for example, resize an image if necessary).
    *
    * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
    * images according to those dimensions.
    *
    * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
    * to be invoked with the file when the transformation is done.
    */
    transformFile(file, done) {
      if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
      else return done(file);
    },
    /**
    * A string that contains the template used for each dropped
    * file. Change it to fulfill your needs but make sure to properly
    * provide all elements.
    *
    * If you want to use an actual HTML element instead of providing a String
    * as a config option, you could create a div with the id `tpl`,
    * put the template inside it and provide the element like this:
    *
    *     document
    *       .querySelector('#tpl')
    *       .innerHTML
    *
    */
    previewTemplate: /* @__PURE__ */ $parcel$interopDefault($fd6031f88dce2e32$exports),
    /*
    Those functions register themselves to the events on init and handle all
    the user interface specific stuff. Overwriting them won't break the upload
    but can break the way it's displayed.
    You can overwrite them if you don't like the default behavior. If you just
    want to add an additional event handler, register it on the dropzone object
    and don't overwrite those options.
    */
    // Those are self explanatory and simply concern the DragnDrop.
    drop(e3) {
      return this.element.classList.remove("dz-drag-hover");
    },
    dragstart(e3) {
    },
    dragend(e3) {
      return this.element.classList.remove("dz-drag-hover");
    },
    dragenter(e3) {
      return this.element.classList.add("dz-drag-hover");
    },
    dragover(e3) {
      return this.element.classList.add("dz-drag-hover");
    },
    dragleave(e3) {
      return this.element.classList.remove("dz-drag-hover");
    },
    paste(e3) {
    },
    // Called whenever there are no files left in the dropzone anymore, and the
    // dropzone should be displayed as if in the initial state.
    reset() {
      return this.element.classList.remove("dz-started");
    },
    // Called when a file is added to the queue
    // Receives `file`
    addedfile(file) {
      if (this.element === this.previewsContainer) this.element.classList.add("dz-started");
      if (this.previewsContainer && !this.options.disablePreviews) {
        file.previewElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(this.options.previewTemplate.trim());
        file.previewTemplate = file.previewElement;
        this.previewsContainer.appendChild(file.previewElement);
        for (var node of file.previewElement.querySelectorAll("[data-dz-name]")) node.textContent = file.name;
        for (node of file.previewElement.querySelectorAll("[data-dz-size]")) node.innerHTML = this.filesize(file.size);
        if (this.options.addRemoveLinks) {
          file._removeLink = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<a class="dz-remove" href="javascript:undefined;" data-dz-remove>${this.options.dictRemoveFile}</a>`);
          file.previewElement.appendChild(file._removeLink);
        }
        let removeFileEvent = (e3) => {
          e3.preventDefault();
          e3.stopPropagation();
          if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(
            this.options.dictCancelUploadConfirmation,
            () => this.removeFile(file)
          );
          else {
            if (this.options.dictRemoveFileConfirmation) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(
              this.options.dictRemoveFileConfirmation,
              () => this.removeFile(file)
            );
            else return this.removeFile(file);
          }
        };
        for (let removeLink of file.previewElement.querySelectorAll("[data-dz-remove]")) removeLink.addEventListener("click", removeFileEvent);
      }
    },
    // Called whenever a file is removed.
    removedfile(file) {
      if (file.previewElement != null && file.previewElement.parentNode != null) file.previewElement.parentNode.removeChild(file.previewElement);
      return this._updateMaxFilesReachedClass();
    },
    // Called when a thumbnail has been generated
    // Receives `file` and `dataUrl`
    thumbnail(file, dataUrl) {
      if (file.previewElement) {
        file.previewElement.classList.remove("dz-file-preview");
        for (let thumbnailElement of file.previewElement.querySelectorAll("[data-dz-thumbnail]")) {
          thumbnailElement.alt = file.name;
          thumbnailElement.src = dataUrl;
        }
        return setTimeout(
          () => file.previewElement.classList.add("dz-image-preview"),
          1
        );
      }
    },
    // Called whenever an error occurs
    // Receives `file` and `message`
    error(file, message) {
      if (file.previewElement) {
        file.previewElement.classList.add("dz-error");
        if (typeof message !== "string" && message.error) message = message.error;
        for (let node of file.previewElement.querySelectorAll("[data-dz-errormessage]")) node.textContent = message;
      }
    },
    errormultiple() {
    },
    // Called when a file gets processed. Since there is a cue, not all added
    // files are processed immediately.
    // Receives `file`
    processing(file) {
      if (file.previewElement) {
        file.previewElement.classList.add("dz-processing");
        if (file._removeLink) return file._removeLink.innerHTML = this.options.dictCancelUpload;
      }
    },
    processingmultiple() {
    },
    // Called whenever the upload progress gets updated.
    // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
    // To get the total number of bytes of the file, use `file.size`
    uploadprogress(file, progress, bytesSent) {
      if (file.previewElement) for (let node of file.previewElement.querySelectorAll("[data-dz-uploadprogress]")) node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = `${progress}%`;
    },
    // Called whenever the total upload progress gets updated.
    // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
    totaluploadprogress() {
    },
    // Called just before the file is sent. Gets the `xhr` object as second
    // parameter, so you can modify it (for example to add a CSRF token) and a
    // `formData` object to add additional information.
    sending() {
    },
    sendingmultiple() {
    },
    // When the complete upload is finished and successful
    // Receives `file`
    success(file) {
      if (file.previewElement) return file.previewElement.classList.add("dz-success");
    },
    successmultiple() {
    },
    // When the upload is canceled.
    canceled(file) {
      return this.emit("error", file, this.options.dictUploadCanceled);
    },
    canceledmultiple() {
    },
    // When the upload is finished, either with success or an error.
    // Receives `file`
    complete(file) {
      if (file._removeLink) file._removeLink.innerHTML = this.options.dictRemoveFile;
      if (file.previewElement) return file.previewElement.classList.add("dz-complete");
    },
    completemultiple() {
    },
    maxfilesexceeded() {
    },
    maxfilesreached() {
    },
    queuecomplete() {
    },
    addedfiles() {
    }
  };
  var $4ca367182776f80b$export$2e2bcd8739ae039 = $4ca367182776f80b$var$defaultOptions;
  var $3ed269f2f0fb224b$export$2e2bcd8739ae039 = class _$3ed269f2f0fb224b$export$2e2bcd8739ae039 extends $4040acfd8584338d$export$2e2bcd8739ae039 {
    static initClass() {
      this.prototype.Emitter = $4040acfd8584338d$export$2e2bcd8739ae039;
      this.prototype.events = [
        "drop",
        "dragstart",
        "dragend",
        "dragenter",
        "dragover",
        "dragleave",
        "addedfile",
        "addedfiles",
        "removedfile",
        "thumbnail",
        "error",
        "errormultiple",
        "processing",
        "processingmultiple",
        "uploadprogress",
        "totaluploadprogress",
        "sending",
        "sendingmultiple",
        "success",
        "successmultiple",
        "canceled",
        "canceledmultiple",
        "complete",
        "completemultiple",
        "reset",
        "maxfilesexceeded",
        "maxfilesreached",
        "queuecomplete"
      ];
      this.prototype._thumbnailQueue = [];
      this.prototype._processingThumbnail = false;
    }
    // Returns all files that have been accepted
    getAcceptedFiles() {
      return this.files.filter(
        (file) => file.accepted
      ).map(
        (file) => file
      );
    }
    // Returns all files that have been rejected
    // Not sure when that's going to be useful, but added for completeness.
    getRejectedFiles() {
      return this.files.filter(
        (file) => !file.accepted
      ).map(
        (file) => file
      );
    }
    getFilesWithStatus(status) {
      return this.files.filter(
        (file) => file.status === status
      ).map(
        (file) => file
      );
    }
    // Returns all files that are in the queue
    getQueuedFiles() {
      return this.getFilesWithStatus(_$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED);
    }
    getUploadingFiles() {
      return this.getFilesWithStatus(_$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING);
    }
    getAddedFiles() {
      return this.getFilesWithStatus(_$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED);
    }
    // Files that are either queued or uploading
    getActiveFiles() {
      return this.files.filter(
        (file) => file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED
      ).map(
        (file) => file
      );
    }
    // The function that gets called when Dropzone is initialized. You
    // can (and should) setup event listeners inside this function.
    init() {
      if (this.element.tagName === "form") this.element.setAttribute("enctype", "multipart/form-data");
      if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) this.element.appendChild(_$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<div class="dz-default dz-message"><button class="dz-button" type="button">${this.options.dictDefaultMessage}</button></div>`));
      if (this.clickableElements.length) {
        let setupHiddenFileInput = () => {
          if (this.hiddenFileInput) this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
          this.hiddenFileInput = document.createElement("input");
          this.hiddenFileInput.setAttribute("type", "file");
          if (this.options.maxFiles === null || this.options.maxFiles > 1) this.hiddenFileInput.setAttribute("multiple", "multiple");
          this.hiddenFileInput.className = "dz-hidden-input";
          if (this.options.acceptedFiles !== null) this.hiddenFileInput.setAttribute("accept", this.options.acceptedFiles);
          if (this.options.capture !== null) this.hiddenFileInput.setAttribute("capture", this.options.capture);
          this.hiddenFileInput.setAttribute("tabindex", "-1");
          this.hiddenFileInput.style.visibility = "hidden";
          this.hiddenFileInput.style.position = "absolute";
          this.hiddenFileInput.style.top = "0";
          this.hiddenFileInput.style.left = "0";
          this.hiddenFileInput.style.height = "0";
          this.hiddenFileInput.style.width = "0";
          _$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.hiddenInputContainer, "hiddenInputContainer").appendChild(this.hiddenFileInput);
          this.hiddenFileInput.addEventListener("change", () => {
            let { files } = this.hiddenFileInput;
            if (files.length) for (let file of files) this.addFile(file);
            this.emit("addedfiles", files);
            setupHiddenFileInput();
          });
        };
        setupHiddenFileInput();
      }
      this.URL = window.URL !== null ? window.URL : window.webkitURL;
      for (let eventName of this.events) this.on(eventName, this.options[eventName]);
      this.on(
        "uploadprogress",
        () => this.updateTotalUploadProgress()
      );
      this.on(
        "removedfile",
        () => this.updateTotalUploadProgress()
      );
      this.on(
        "canceled",
        (file) => this.emit("complete", file)
      );
      this.on("complete", (file) => {
        if (this.getAddedFiles().length === 0 && this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0)
          return setTimeout(
            () => this.emit("queuecomplete"),
            0
          );
      });
      const containsFiles = function(e3) {
        if (e3.dataTransfer.types)
          for (var i3 = 0; i3 < e3.dataTransfer.types.length; i3++) {
            if (e3.dataTransfer.types[i3] === "Files") return true;
          }
        return false;
      };
      let noPropagation = function(e3) {
        if (!containsFiles(e3)) return;
        e3.stopPropagation();
        if (e3.preventDefault) return e3.preventDefault();
        else return e3.returnValue = false;
      };
      this.listeners = [
        {
          element: this.element,
          events: {
            dragstart: (e3) => {
              return this.emit("dragstart", e3);
            },
            dragenter: (e3) => {
              noPropagation(e3);
              return this.emit("dragenter", e3);
            },
            dragover: (e3) => {
              let efct;
              try {
                efct = e3.dataTransfer.effectAllowed;
              } catch (error2) {
              }
              e3.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
              noPropagation(e3);
              return this.emit("dragover", e3);
            },
            dragleave: (e3) => {
              return this.emit("dragleave", e3);
            },
            drop: (e3) => {
              noPropagation(e3);
              return this.drop(e3);
            },
            dragend: (e3) => {
              return this.emit("dragend", e3);
            }
          }
        }
      ];
      this.clickableElements.forEach((clickableElement) => {
        return this.listeners.push({
          element: clickableElement,
          events: {
            click: (evt) => {
              if (clickableElement !== this.element || evt.target === this.element || _$3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside(evt.target, this.element.querySelector(".dz-message"))) this.hiddenFileInput.click();
              return true;
            }
          }
        });
      });
      this.enable();
      return this.options.init.call(this);
    }
    // Not fully tested yet
    destroy() {
      this.disable();
      this.removeAllFiles(true);
      if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : void 0) {
        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
        this.hiddenFileInput = null;
      }
      delete this.element.dropzone;
      return _$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.splice(_$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.indexOf(this), 1);
    }
    updateTotalUploadProgress() {
      let totalUploadProgress;
      let totalBytesSent = 0;
      let totalBytes = 0;
      let activeFiles = this.getActiveFiles();
      if (activeFiles.length) {
        for (let file of this.getActiveFiles()) {
          totalBytesSent += file.upload.bytesSent;
          totalBytes += file.upload.total;
        }
        totalUploadProgress = 100 * totalBytesSent / totalBytes;
      } else totalUploadProgress = 100;
      return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
    }
    // @options.paramName can be a function taking one parameter rather than a string.
    // A parameter name for a file is obtained simply by calling this with an index number.
    _getParamName(n2) {
      if (typeof this.options.paramName === "function") return this.options.paramName(n2);
      else return `${this.options.paramName}${this.options.uploadMultiple ? `[${n2}]` : ""}`;
    }
    // If @options.renameFile is a function,
    // the function will be used to rename the file.name before appending it to the formData
    _renameFile(file) {
      if (typeof this.options.renameFile !== "function") return file.name;
      return this.options.renameFile(file);
    }
    // Returns a form that can be used as fallback if the browser does not support DragnDrop
    //
    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
    // This code has to pass in IE7 :(
    getFallbackForm() {
      let existingFallback, form;
      if (existingFallback = this.getExistingFallback()) return existingFallback;
      let fieldsString = '<div class="dz-fallback">';
      if (this.options.dictFallbackText) fieldsString += `<p>${this.options.dictFallbackText}</p>`;
      fieldsString += `<input type="file" name="${this._getParamName(0)}" ${this.options.uploadMultiple ? 'multiple="multiple"' : void 0} /><input type="submit" value="Upload!"></div>`;
      let fields = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(fieldsString);
      if (this.element.tagName !== "FORM") {
        form = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<form action="${this.options.url}" enctype="multipart/form-data" method="${this.options.method}"></form>`);
        form.appendChild(fields);
      } else {
        this.element.setAttribute("enctype", "multipart/form-data");
        this.element.setAttribute("method", this.options.method);
      }
      return form != null ? form : fields;
    }
    // Returns the fallback elements if they exist already
    //
    // This code has to pass in IE7 :(
    getExistingFallback() {
      let getFallback = function(elements) {
        for (let el of elements) {
          if (/(^| )fallback($| )/.test(el.className)) return el;
        }
      };
      for (let tagName of [
        "div",
        "form"
      ]) {
        var fallback;
        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) return fallback;
      }
    }
    // Activates all listeners stored in @listeners
    setupEventListeners() {
      return this.listeners.map(
        (elementListeners) => (() => {
          let result = [];
          for (let event in elementListeners.events) {
            let listener = elementListeners.events[event];
            result.push(elementListeners.element.addEventListener(event, listener, false));
          }
          return result;
        })()
      );
    }
    // Deactivates all listeners stored in @listeners
    removeEventListeners() {
      return this.listeners.map(
        (elementListeners) => (() => {
          let result = [];
          for (let event in elementListeners.events) {
            let listener = elementListeners.events[event];
            result.push(elementListeners.element.removeEventListener(event, listener, false));
          }
          return result;
        })()
      );
    }
    // Removes all event listeners and cancels all files in the queue or being processed.
    disable() {
      this.clickableElements.forEach(
        (element) => element.classList.remove("dz-clickable")
      );
      this.removeEventListeners();
      this.disabled = true;
      return this.files.map(
        (file) => this.cancelUpload(file)
      );
    }
    enable() {
      delete this.disabled;
      this.clickableElements.forEach(
        (element) => element.classList.add("dz-clickable")
      );
      return this.setupEventListeners();
    }
    // Returns a nicely formatted filesize
    filesize(size2) {
      let selectedSize = 0;
      let selectedUnit = "b";
      if (size2 > 0) {
        let units = [
          "tb",
          "gb",
          "mb",
          "kb",
          "b"
        ];
        for (let i3 = 0; i3 < units.length; i3++) {
          let unit = units[i3];
          let cutoff = Math.pow(this.options.filesizeBase, 4 - i3) / 10;
          if (size2 >= cutoff) {
            selectedSize = size2 / Math.pow(this.options.filesizeBase, 4 - i3);
            selectedUnit = unit;
            break;
          }
        }
        selectedSize = Math.round(10 * selectedSize) / 10;
      }
      return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;
    }
    // Adds or removes the `dz-max-files-reached` class from the form.
    _updateMaxFilesReachedClass() {
      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
        if (this.getAcceptedFiles().length === this.options.maxFiles) this.emit("maxfilesreached", this.files);
        return this.element.classList.add("dz-max-files-reached");
      } else return this.element.classList.remove("dz-max-files-reached");
    }
    drop(e3) {
      if (!e3.dataTransfer) return;
      this.emit("drop", e3);
      let files = [];
      for (let i3 = 0; i3 < e3.dataTransfer.files.length; i3++) files[i3] = e3.dataTransfer.files[i3];
      if (files.length) {
        let { items } = e3.dataTransfer;
        if (items && items.length && items[0].webkitGetAsEntry != null)
          this._addFilesFromItems(items);
        else this.handleFiles(files);
      }
      this.emit("addedfiles", files);
    }
    paste(e3) {
      if ($3ed269f2f0fb224b$var$__guard__(
        e3 != null ? e3.clipboardData : void 0,
        (x4) => x4.items
      ) == null) return;
      this.emit("paste", e3);
      let { items } = e3.clipboardData;
      if (items.length) return this._addFilesFromItems(items);
    }
    handleFiles(files) {
      for (let file of files) this.addFile(file);
    }
    // When a folder is dropped (or files are pasted), items must be handled
    // instead of files.
    _addFilesFromItems(items) {
      return (() => {
        let result = [];
        for (let item of items) {
          var entry;
          if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
            if (entry.isFile) result.push(this.addFile(item.getAsFile()));
            else if (entry.isDirectory)
              result.push(this._addFilesFromDirectory(entry, entry.name));
            else result.push(void 0);
          } else if (item.getAsFile != null) {
            if (item.kind == null || item.kind === "file") result.push(this.addFile(item.getAsFile()));
            else result.push(void 0);
          } else result.push(void 0);
        }
        return result;
      })();
    }
    // Goes through the directory, and adds each file it finds recursively
    _addFilesFromDirectory(directory, path) {
      let dirReader = directory.createReader();
      let errorHandler = (error2) => $3ed269f2f0fb224b$var$__guardMethod__(
        console,
        "log",
        (o2) => o2.log(error2)
      );
      var readEntries = () => {
        return dirReader.readEntries((entries) => {
          if (entries.length > 0) {
            for (let entry of entries) {
              if (entry.isFile) entry.file((file) => {
                if (this.options.ignoreHiddenFiles && file.name.substring(0, 1) === ".") return;
                file.fullPath = `${path}/${file.name}`;
                return this.addFile(file);
              });
              else if (entry.isDirectory) this._addFilesFromDirectory(entry, `${path}/${entry.name}`);
            }
            readEntries();
          }
          return null;
        }, errorHandler);
      };
      return readEntries();
    }
    // If `done()` is called without argument the file is accepted
    // If you call it with an error message, the file is rejected
    // (This allows for asynchronous validation)
    //
    // This function checks the filesize, and if the file.type passes the
    // `acceptedFiles` check.
    accept(file, done) {
      if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1048576) done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
      else if (!_$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile(file, this.options.acceptedFiles)) done(this.options.dictInvalidFileType);
      else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
        done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
        this.emit("maxfilesexceeded", file);
      } else this.options.accept.call(this, file, done);
    }
    addFile(file) {
      file.upload = {
        uuid: _$3ed269f2f0fb224b$export$2e2bcd8739ae039.uuidv4(),
        progress: 0,
        // Setting the total upload size to file.size for the beginning
        // It's actual different than the size to be transmitted.
        total: file.size,
        bytesSent: 0,
        filename: this._renameFile(file)
      };
      this.files.push(file);
      file.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED;
      this.emit("addedfile", file);
      this._enqueueThumbnail(file);
      this.accept(file, (error2) => {
        if (error2) {
          file.accepted = false;
          this._errorProcessing([
            file
          ], error2);
        } else {
          file.accepted = true;
          if (this.options.autoQueue) this.enqueueFile(file);
        }
        this._updateMaxFilesReachedClass();
      });
    }
    // Wrapper for enqueueFile
    enqueueFiles(files) {
      for (let file of files) this.enqueueFile(file);
      return null;
    }
    enqueueFile(file) {
      if (file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED && file.accepted === true) {
        file.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
        if (this.options.autoProcessQueue) return setTimeout(
          () => this.processQueue(),
          0
        );
      } else throw new Error("This file can't be queued because it has already been processed or was rejected.");
    }
    _enqueueThumbnail(file) {
      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1048576) {
        this._thumbnailQueue.push(file);
        return setTimeout(
          () => this._processThumbnailQueue(),
          0
        );
      }
    }
    _processThumbnailQueue() {
      if (this._processingThumbnail || this._thumbnailQueue.length === 0) return;
      this._processingThumbnail = true;
      let file = this._thumbnailQueue.shift();
      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, (dataUrl) => {
        this.emit("thumbnail", file, dataUrl);
        this._processingThumbnail = false;
        return this._processThumbnailQueue();
      });
    }
    // Can be called by the user to remove a file
    removeFile(file) {
      if (file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) this.cancelUpload(file);
      this.files = $3ed269f2f0fb224b$var$without(this.files, file);
      this.emit("removedfile", file);
      if (this.files.length === 0) return this.emit("reset");
    }
    // Removes all files that aren't currently processed from the list
    removeAllFiles(cancelIfNecessary) {
      if (cancelIfNecessary == null) cancelIfNecessary = false;
      for (let file of this.files.slice()) if (file.status !== _$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || cancelIfNecessary) this.removeFile(file);
      return null;
    }
    // Resizes an image before it gets sent to the server. This function is the default behavior of
    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
    // the resized blob.
    resizeImage(file, width, height, resizeMethod, callback) {
      return this.createThumbnail(file, width, height, resizeMethod, true, (dataUrl, canvas) => {
        if (canvas == null)
          return callback(file);
        else {
          let { resizeMimeType } = this.options;
          if (resizeMimeType == null) resizeMimeType = file.type;
          let resizedDataURL = canvas.toDataURL(resizeMimeType, this.options.resizeQuality);
          if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg")
            resizedDataURL = $3ed269f2f0fb224b$var$ExifRestore.restore(file.dataURL, resizedDataURL);
          return callback(_$3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob(resizedDataURL));
        }
      });
    }
    createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
      let fileReader = new FileReader();
      fileReader.onload = () => {
        file.dataURL = fileReader.result;
        if (file.type === "image/svg+xml") {
          if (callback != null) callback(fileReader.result);
          return;
        }
        this.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
      };
      fileReader.readAsDataURL(file);
    }
    // `mockFile` needs to have these attributes:
    //
    //     { name: 'name', size: 12345, imageUrl: '' }
    //
    // `callback` will be invoked when the image has been downloaded and displayed.
    // `crossOrigin` will be added to the `img` tag when accessing the file.
    displayExistingFile(mockFile, imageUrl, callback, crossOrigin, resizeThumbnail = true) {
      this.emit("addedfile", mockFile);
      this.emit("complete", mockFile);
      if (!resizeThumbnail) {
        this.emit("thumbnail", mockFile, imageUrl);
        if (callback) callback();
      } else {
        let onDone = (thumbnail) => {
          this.emit("thumbnail", mockFile, thumbnail);
          if (callback) callback();
        };
        mockFile.dataURL = imageUrl;
        this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
      }
    }
    createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
      let img = document.createElement("img");
      if (crossOrigin) img.crossOrigin = crossOrigin;
      fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
      img.onload = () => {
        let loadExif = (callback2) => callback2(1);
        if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) loadExif = (callback2) => EXIF.getData(img, function() {
          return callback2(EXIF.getTag(this, "Orientation"));
        });
        return loadExif((orientation) => {
          file.width = img.width;
          file.height = img.height;
          let resizeInfo = this.options.resize.call(this, file, width, height, resizeMethod);
          let canvas = document.createElement("canvas");
          let ctx = canvas.getContext("2d");
          canvas.width = resizeInfo.trgWidth;
          canvas.height = resizeInfo.trgHeight;
          if (orientation > 4) {
            canvas.width = resizeInfo.trgHeight;
            canvas.height = resizeInfo.trgWidth;
          }
          switch (orientation) {
            case 2:
              ctx.translate(canvas.width, 0);
              ctx.scale(-1, 1);
              break;
            case 3:
              ctx.translate(canvas.width, canvas.height);
              ctx.rotate(Math.PI);
              break;
            case 4:
              ctx.translate(0, canvas.height);
              ctx.scale(1, -1);
              break;
            case 5:
              ctx.rotate(0.5 * Math.PI);
              ctx.scale(1, -1);
              break;
            case 6:
              ctx.rotate(0.5 * Math.PI);
              ctx.translate(0, -canvas.width);
              break;
            case 7:
              ctx.rotate(0.5 * Math.PI);
              ctx.translate(canvas.height, -canvas.width);
              ctx.scale(-1, 1);
              break;
            case 8:
              ctx.rotate(-0.5 * Math.PI);
              ctx.translate(-canvas.height, 0);
              break;
          }
          $3ed269f2f0fb224b$var$drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
          let thumbnail = canvas.toDataURL("image/png");
          if (callback != null) return callback(thumbnail, canvas);
        });
      };
      if (callback != null) img.onerror = callback;
      return img.src = file.dataURL;
    }
    // Goes through the queue and processes files if there aren't too many already.
    processQueue() {
      let { parallelUploads } = this.options;
      let processingLength = this.getUploadingFiles().length;
      let i3 = processingLength;
      if (processingLength >= parallelUploads) return;
      let queuedFiles = this.getQueuedFiles();
      if (!(queuedFiles.length > 0)) return;
      if (this.options.uploadMultiple)
        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
      else while (i3 < parallelUploads) {
        if (!queuedFiles.length) return;
        this.processFile(queuedFiles.shift());
        i3++;
      }
    }
    // Wrapper for `processFiles`
    processFile(file) {
      return this.processFiles([
        file
      ]);
    }
    // Loads the file, then calls finishedLoading()
    processFiles(files) {
      for (let file of files) {
        file.processing = true;
        file.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
        this.emit("processing", file);
      }
      if (this.options.uploadMultiple) this.emit("processingmultiple", files);
      return this.uploadFiles(files);
    }
    _getFilesWithXhr(xhr) {
      let files;
      return files = this.files.filter(
        (file) => file.xhr === xhr
      ).map(
        (file) => file
      );
    }
    // Cancels the file upload and sets the status to CANCELED
    // **if** the file is actually being uploaded.
    // If it's still in the queue, the file is being removed from it and the status
    // set to CANCELED.
    cancelUpload(file) {
      if (file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) {
        let groupedFiles = this._getFilesWithXhr(file.xhr);
        for (let groupedFile of groupedFiles) groupedFile.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
        if (typeof file.xhr !== "undefined") file.xhr.abort();
        for (let groupedFile1 of groupedFiles) this.emit("canceled", groupedFile1);
        if (this.options.uploadMultiple) this.emit("canceledmultiple", groupedFiles);
      } else if (file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED || file.status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED) {
        file.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
        this.emit("canceled", file);
        if (this.options.uploadMultiple) this.emit("canceledmultiple", [
          file
        ]);
      }
      if (this.options.autoProcessQueue) return this.processQueue();
    }
    resolveOption(option, ...args) {
      if (typeof option === "function") return option.apply(this, args);
      return option;
    }
    uploadFile(file) {
      return this.uploadFiles([
        file
      ]);
    }
    uploadFiles(files) {
      this._transformFiles(files, (transformedFiles) => {
        if (this.options.chunking) {
          let transformedFile = transformedFiles[0];
          files[0].upload.chunked = this.options.chunking && (this.options.forceChunking || transformedFile.size > this.options.chunkSize);
          files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / this.options.chunkSize);
        }
        if (files[0].upload.chunked) {
          let file = files[0];
          let transformedFile = transformedFiles[0];
          let startedChunkCount = 0;
          file.upload.chunks = [];
          let handleNextChunk = () => {
            let chunkIndex = 0;
            while (file.upload.chunks[chunkIndex] !== void 0) chunkIndex++;
            if (chunkIndex >= file.upload.totalChunkCount) return;
            startedChunkCount++;
            let start2 = chunkIndex * this.options.chunkSize;
            let end = Math.min(start2 + this.options.chunkSize, transformedFile.size);
            let dataBlock = {
              name: this._getParamName(0),
              data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start2, end) : transformedFile.slice(start2, end),
              filename: file.upload.filename,
              chunkIndex
            };
            file.upload.chunks[chunkIndex] = {
              file,
              index: chunkIndex,
              dataBlock,
              status: _$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING,
              progress: 0,
              retries: 0
            };
            this._uploadData(files, [
              dataBlock
            ]);
          };
          file.upload.finishedChunkUpload = (chunk, response) => {
            let allFinished = true;
            chunk.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
            chunk.dataBlock = null;
            chunk.response = chunk.xhr.responseText;
            chunk.responseHeaders = chunk.xhr.getAllResponseHeaders();
            chunk.xhr = null;
            for (let i3 = 0; i3 < file.upload.totalChunkCount; i3++) {
              if (file.upload.chunks[i3] === void 0) return handleNextChunk();
              if (file.upload.chunks[i3].status !== _$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS) allFinished = false;
            }
            if (allFinished) this.options.chunksUploaded(file, () => {
              this._finished(files, response, null);
            });
          };
          if (this.options.parallelChunkUploads) for (let i3 = 0; i3 < file.upload.totalChunkCount; i3++) handleNextChunk();
          else handleNextChunk();
        } else {
          let dataBlocks = [];
          for (let i3 = 0; i3 < files.length; i3++) dataBlocks[i3] = {
            name: this._getParamName(i3),
            data: transformedFiles[i3],
            filename: files[i3].upload.filename
          };
          this._uploadData(files, dataBlocks);
        }
      });
    }
    /// Returns the right chunk for given file and xhr
    _getChunk(file, xhr) {
      for (let i3 = 0; i3 < file.upload.totalChunkCount; i3++) {
        if (file.upload.chunks[i3] !== void 0 && file.upload.chunks[i3].xhr === xhr) return file.upload.chunks[i3];
      }
    }
    // This function actually uploads the file(s) to the server.
    //
    //  If dataBlocks contains the actual data to upload (meaning, that this could
    // either be transformed files, or individual chunks for chunked upload) then
    // they will be used for the actual data to upload.
    _uploadData(files, dataBlocks) {
      let xhr = new XMLHttpRequest();
      for (let file of files) file.xhr = xhr;
      if (files[0].upload.chunked)
        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
      let method = this.resolveOption(this.options.method, files, dataBlocks);
      let url = this.resolveOption(this.options.url, files, dataBlocks);
      xhr.open(method, url, true);
      let timeout = this.resolveOption(this.options.timeout, files);
      if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files);
      xhr.withCredentials = !!this.options.withCredentials;
      xhr.onload = (e3) => {
        this._finishedUploading(files, xhr, e3);
      };
      xhr.ontimeout = () => {
        this._handleUploadError(files, xhr, `Request timedout after ${this.options.timeout / 1e3} seconds`);
      };
      xhr.onerror = () => {
        this._handleUploadError(files, xhr);
      };
      let progressObj = xhr.upload != null ? xhr.upload : xhr;
      progressObj.onprogress = (e3) => this._updateFilesUploadProgress(files, xhr, e3);
      let headers = this.options.defaultHeaders ? {
        Accept: "application/json",
        "Cache-Control": "no-cache",
        "X-Requested-With": "XMLHttpRequest"
      } : {};
      if (this.options.binaryBody) headers["Content-Type"] = files[0].type;
      if (this.options.headers) objectExtend(headers, this.options.headers);
      for (let headerName in headers) {
        let headerValue = headers[headerName];
        if (headerValue) xhr.setRequestHeader(headerName, headerValue);
      }
      if (this.options.binaryBody) {
        for (let file of files) this.emit("sending", file, xhr);
        if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr);
        this.submitRequest(xhr, null, files);
      } else {
        let formData = new FormData();
        if (this.options.params) {
          let additionalParams = this.options.params;
          if (typeof additionalParams === "function") additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
          for (let key in additionalParams) {
            let value = additionalParams[key];
            if (Array.isArray(value))
              for (let i3 = 0; i3 < value.length; i3++) formData.append(key, value[i3]);
            else formData.append(key, value);
          }
        }
        for (let file of files) this.emit("sending", file, xhr, formData);
        if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr, formData);
        this._addFormElementData(formData);
        for (let i3 = 0; i3 < dataBlocks.length; i3++) {
          let dataBlock = dataBlocks[i3];
          formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
        }
        this.submitRequest(xhr, formData, files);
      }
    }
    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
    _transformFiles(files, done) {
      let transformedFiles = [];
      let doneCounter = 0;
      for (let i3 = 0; i3 < files.length; i3++) this.options.transformFile.call(this, files[i3], (transformedFile) => {
        transformedFiles[i3] = transformedFile;
        if (++doneCounter === files.length) done(transformedFiles);
      });
    }
    // Takes care of adding other input elements of the form to the AJAX request
    _addFormElementData(formData) {
      if (this.element.tagName === "FORM") for (let input of this.element.querySelectorAll("input, textarea, select, button")) {
        let inputName = input.getAttribute("name");
        let inputType = input.getAttribute("type");
        if (inputType) inputType = inputType.toLowerCase();
        if (typeof inputName === "undefined" || inputName === null) continue;
        if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
          for (let option of input.options) if (option.selected) formData.append(inputName, option.value);
        } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) formData.append(inputName, input.value);
      }
    }
    // Invoked when there is new progress information about given files.
    // If e is not provided, it is assumed that the upload is finished.
    _updateFilesUploadProgress(files, xhr, e3) {
      if (!files[0].upload.chunked)
        for (let file of files) {
          if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) continue;
          if (e3) {
            file.upload.progress = 100 * e3.loaded / e3.total;
            file.upload.total = e3.total;
            file.upload.bytesSent = e3.loaded;
          } else {
            file.upload.progress = 100;
            file.upload.bytesSent = file.upload.total;
          }
          this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
      else {
        let file = files[0];
        let chunk = this._getChunk(file, xhr);
        if (e3) {
          chunk.progress = 100 * e3.loaded / e3.total;
          chunk.total = e3.total;
          chunk.bytesSent = e3.loaded;
        } else {
          chunk.progress = 100;
          chunk.bytesSent = chunk.total;
        }
        file.upload.progress = 0;
        file.upload.total = 0;
        file.upload.bytesSent = 0;
        for (let i3 = 0; i3 < file.upload.totalChunkCount; i3++) if (file.upload.chunks[i3] && typeof file.upload.chunks[i3].progress !== "undefined") {
          file.upload.progress += file.upload.chunks[i3].progress;
          file.upload.total += file.upload.chunks[i3].total;
          file.upload.bytesSent += file.upload.chunks[i3].bytesSent;
        }
        file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
        this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
      }
    }
    _finishedUploading(files, xhr, e3) {
      let response;
      if (files[0].status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
      if (xhr.readyState !== 4) return;
      if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
        response = xhr.responseText;
        if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) try {
          response = JSON.parse(response);
        } catch (error2) {
          e3 = error2;
          response = "Invalid JSON response from server.";
        }
      }
      this._updateFilesUploadProgress(files, xhr);
      if (!(200 <= xhr.status && xhr.status < 300)) this._handleUploadError(files, xhr, response);
      else if (files[0].upload.chunked) files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);
      else this._finished(files, response, e3);
    }
    _handleUploadError(files, xhr, response) {
      if (files[0].status === _$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
      if (files[0].upload.chunked && this.options.retryChunks) {
        let chunk = this._getChunk(files[0], xhr);
        if (chunk.retries++ < this.options.retryChunksLimit) {
          this._uploadData(files, [
            chunk.dataBlock
          ]);
          return;
        } else console.warn("Retried this chunk too often. Giving up.");
      }
      this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
    }
    submitRequest(xhr, formData, files) {
      if (xhr.readyState != 1) {
        console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
        return;
      }
      if (this.options.binaryBody) {
        if (files[0].upload.chunked) {
          const chunk = this._getChunk(files[0], xhr);
          xhr.send(chunk.dataBlock.data);
        } else xhr.send(files[0]);
      } else xhr.send(formData);
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _finished(files, responseText, e3) {
      for (let file of files) {
        file.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
        this.emit("success", file, responseText, e3);
        this.emit("complete", file);
      }
      if (this.options.uploadMultiple) {
        this.emit("successmultiple", files, responseText, e3);
        this.emit("completemultiple", files);
      }
      if (this.options.autoProcessQueue) return this.processQueue();
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _errorProcessing(files, message, xhr) {
      for (let file of files) {
        file.status = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR;
        this.emit("error", file, message, xhr);
        this.emit("complete", file);
      }
      if (this.options.uploadMultiple) {
        this.emit("errormultiple", files, message, xhr);
        this.emit("completemultiple", files);
      }
      if (this.options.autoProcessQueue) return this.processQueue();
    }
    static uuidv4() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c3) {
        let r3 = Math.random() * 16 | 0, v3 = c3 === "x" ? r3 : r3 & 3 | 8;
        return v3.toString(16);
      });
    }
    constructor(el, options) {
      super();
      let fallback, left;
      this.element = el;
      this.clickableElements = [];
      this.listeners = [];
      this.files = [];
      if (typeof this.element === "string") this.element = document.querySelector(this.element);
      if (!this.element || this.element.nodeType == null) throw new Error("Invalid dropzone element.");
      if (this.element.dropzone) throw new Error("Dropzone already attached.");
      _$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.push(this);
      this.element.dropzone = this;
      let elementOptions = (left = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(this.element)) != null ? left : {};
      this.options = objectExtend(true, {}, $4ca367182776f80b$export$2e2bcd8739ae039, elementOptions, options != null ? options : {});
      this.options.previewTemplate = this.options.previewTemplate.replace(/\n*/g, "");
      if (this.options.forceFallback || !_$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported()) return this.options.fallback.call(this);
      if (this.options.url == null) this.options.url = this.element.getAttribute("action");
      if (!this.options.url) throw new Error("No URL provided.");
      if (this.options.acceptedFiles && this.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
      if (this.options.uploadMultiple && this.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking.");
      if (this.options.binaryBody && this.options.uploadMultiple) throw new Error("You cannot set both: binaryBody and uploadMultiple.");
      if (this.options.acceptedMimeTypes) {
        this.options.acceptedFiles = this.options.acceptedMimeTypes;
        delete this.options.acceptedMimeTypes;
      }
      if (this.options.renameFilename != null) this.options.renameFile = (file) => this.options.renameFilename.call(this, file.name, file);
      if (typeof this.options.method === "string") this.options.method = this.options.method.toUpperCase();
      if ((fallback = this.getExistingFallback()) && fallback.parentNode)
        fallback.parentNode.removeChild(fallback);
      if (this.options.previewsContainer !== false) {
        if (this.options.previewsContainer) this.previewsContainer = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.previewsContainer, "previewsContainer");
        else this.previewsContainer = this.element;
      }
      if (this.options.clickable) {
        if (this.options.clickable === true) this.clickableElements = [
          this.element
        ];
        else this.clickableElements = _$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements(this.options.clickable, "clickable");
      }
      this.init();
    }
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.initClass();
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.options = {};
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement = function(element) {
    if (element.getAttribute("id")) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.options[$3ed269f2f0fb224b$var$camelize(element.getAttribute("id"))];
    else return void 0;
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances = [];
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.forElement = function(element) {
    if (typeof element === "string") element = document.querySelector(element);
    if ((element != null ? element.dropzone : void 0) == null) throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
    return element.dropzone;
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.discover = function() {
    let dropzones;
    if (document.querySelectorAll) dropzones = document.querySelectorAll(".dropzone");
    else {
      dropzones = [];
      let checkElements = (elements) => (() => {
        let result = [];
        for (let el of elements) if (/(^| )dropzone($| )/.test(el.className)) result.push(dropzones.push(el));
        else result.push(void 0);
        return result;
      })();
      checkElements(document.getElementsByTagName("div"));
      checkElements(document.getElementsByTagName("form"));
    }
    return (() => {
      let result = [];
      for (let dropzone of dropzones)
        if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(dropzone) !== false) result.push(new $3ed269f2f0fb224b$export$2e2bcd8739ae039(dropzone));
        else result.push(void 0);
      return result;
    })();
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = [
    // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
    /opera.*(Macintosh|Windows Phone).*version\/12/i
  ];
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported = function() {
    let capableBrowser = true;
    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
      if (!("classList" in document.createElement("a"))) capableBrowser = false;
      else {
        if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers !== void 0)
          $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = $3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers;
        for (let regex of $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers) if (regex.test(navigator.userAgent)) {
          capableBrowser = false;
          continue;
        }
      }
    } else capableBrowser = false;
    return capableBrowser;
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob = function(dataURI) {
    let byteString = atob(dataURI.split(",")[1]);
    let mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
    let ab = new ArrayBuffer(byteString.length);
    let ia = new Uint8Array(ab);
    for (let i3 = 0, end = byteString.length, asc = 0 <= end; asc ? i3 <= end : i3 >= end; asc ? i3++ : i3--) ia[i3] = byteString.charCodeAt(i3);
    return new Blob([
      ab
    ], {
      type: mimeString
    });
  };
  var $3ed269f2f0fb224b$var$without = (list, rejectedItem) => list.filter(
    (item) => item !== rejectedItem
  ).map(
    (item) => item
  );
  var $3ed269f2f0fb224b$var$camelize = (str) => str.replace(
    /[\-_](\w)/g,
    (match) => match.charAt(1).toUpperCase()
  );
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement = function(string) {
    let div = document.createElement("div");
    div.innerHTML = string;
    return div.childNodes[0];
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside = function(element, container) {
    if (element === container) return true;
    while (element = element.parentNode) {
      if (element === container) return true;
    }
    return false;
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement = function(el, name) {
    let element;
    if (typeof el === "string") element = document.querySelector(el);
    else if (el.nodeType != null) element = el;
    if (element == null) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector or a plain HTML element.`);
    return element;
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements = function(els, name) {
    let el, elements;
    if (els instanceof Array) {
      elements = [];
      try {
        for (el of els) elements.push(this.getElement(el, name));
      } catch (e3) {
        elements = null;
      }
    } else if (typeof els === "string") {
      elements = [];
      for (el of document.querySelectorAll(els)) elements.push(el);
    } else if (els.nodeType != null) elements = [
      els
    ];
    if (elements == null || !elements.length) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`);
    return elements;
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm = function(question, accepted, rejected) {
    if (window.confirm(question)) return accepted();
    else if (rejected != null) return rejected();
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile = function(file, acceptedFiles) {
    if (!acceptedFiles) return true;
    acceptedFiles = acceptedFiles.split(",");
    let mimeType = file.type;
    let baseMimeType = mimeType.replace(/\/.*$/, "");
    for (let validType of acceptedFiles) {
      validType = validType.trim();
      if (validType.charAt(0) === ".") {
        if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) return true;
      } else if (/\/\*$/.test(validType)) {
        if (baseMimeType === validType.replace(/\/.*$/, "")) return true;
      } else {
        if (mimeType === validType) return true;
      }
    }
    return false;
  };
  if (typeof jQuery !== "undefined" && jQuery !== null) jQuery.fn.dropzone = function(options) {
    return this.each(function() {
      return new $3ed269f2f0fb224b$export$2e2bcd8739ae039(this, options);
    });
  };
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED = "added";
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED = "queued";
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.ACCEPTED = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING = "uploading";
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.PROCESSING = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED = "canceled";
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR = "error";
  $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS = "success";
  var $3ed269f2f0fb224b$var$detectVerticalSquash = function(img) {
    let iw = img.naturalWidth;
    let ih = img.naturalHeight;
    let canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = ih;
    let ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);
    let { data: data2 } = ctx.getImageData(1, 0, 1, ih);
    let sy = 0;
    let ey = ih;
    let py = ih;
    while (py > sy) {
      let alpha = data2[(py - 1) * 4 + 3];
      if (alpha === 0) ey = py;
      else sy = py;
      py = ey + sy >> 1;
    }
    let ratio = py / ih;
    if (ratio === 0) return 1;
    else return ratio;
  };
  var $3ed269f2f0fb224b$var$drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
    let vertSquashRatio = $3ed269f2f0fb224b$var$detectVerticalSquash(img);
    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
  };
  var $3ed269f2f0fb224b$var$ExifRestore = class {
    static initClass() {
      this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    }
    static encode64(input) {
      let output = "";
      let chr1 = void 0;
      let chr2 = void 0;
      let chr3 = "";
      let enc1 = void 0;
      let enc2 = void 0;
      let enc3 = void 0;
      let enc4 = "";
      let i3 = 0;
      while (true) {
        chr1 = input[i3++];
        chr2 = input[i3++];
        chr3 = input[i3++];
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) enc3 = enc4 = 64;
        else if (isNaN(chr3)) enc4 = 64;
        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
        if (!(i3 < input.length)) break;
      }
      return output;
    }
    static restore(origFileBase64, resizedFileBase64) {
      if (!origFileBase64.match("data:image/jpeg;base64,")) return resizedFileBase64;
      let rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
      let segments = this.slice2Segments(rawImage);
      let image = this.exifManipulation(resizedFileBase64, segments);
      return `data:image/jpeg;base64,${this.encode64(image)}`;
    }
    static exifManipulation(resizedFileBase64, segments) {
      let exifArray = this.getExifArray(segments);
      let newImageArray = this.insertExif(resizedFileBase64, exifArray);
      let aBuffer = new Uint8Array(newImageArray);
      return aBuffer;
    }
    static getExifArray(segments) {
      let seg = void 0;
      let x4 = 0;
      while (x4 < segments.length) {
        seg = segments[x4];
        if (seg[0] === 255 & seg[1] === 225) return seg;
        x4++;
      }
      return [];
    }
    static insertExif(resizedFileBase64, exifArray) {
      let imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
      let buf = this.decode64(imageData);
      let separatePoint = buf.indexOf(255, 3);
      let mae = buf.slice(0, separatePoint);
      let ato = buf.slice(separatePoint);
      let array = mae;
      array = array.concat(exifArray);
      array = array.concat(ato);
      return array;
    }
    static slice2Segments(rawImageArray) {
      let head = 0;
      let segments = [];
      while (true) {
        var length;
        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) break;
        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) head += 2;
        else {
          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
          let endPoint = head + length + 2;
          let seg = rawImageArray.slice(head, endPoint);
          segments.push(seg);
          head = endPoint;
        }
        if (head > rawImageArray.length) break;
      }
      return segments;
    }
    static decode64(input) {
      let output = "";
      let chr1 = void 0;
      let chr2 = void 0;
      let chr3 = "";
      let enc1 = void 0;
      let enc2 = void 0;
      let enc3 = void 0;
      let enc4 = "";
      let i3 = 0;
      let buf = [];
      let base64test = /[^A-Za-z0-9\+\/\=]/g;
      if (base64test.exec(input)) console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (true) {
        enc1 = this.KEY_STR.indexOf(input.charAt(i3++));
        enc2 = this.KEY_STR.indexOf(input.charAt(i3++));
        enc3 = this.KEY_STR.indexOf(input.charAt(i3++));
        enc4 = this.KEY_STR.indexOf(input.charAt(i3++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        buf.push(chr1);
        if (enc3 !== 64) buf.push(chr2);
        if (enc4 !== 64) buf.push(chr3);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
        if (!(i3 < input.length)) break;
      }
      return buf;
    }
  };
  $3ed269f2f0fb224b$var$ExifRestore.initClass();
  function $3ed269f2f0fb224b$var$__guard__(value, transform) {
    return typeof value !== "undefined" && value !== null ? transform(value) : void 0;
  }
  function $3ed269f2f0fb224b$var$__guardMethod__(obj, methodName, transform) {
    if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function") return transform(obj, methodName);
    else return void 0;
  }

  // assets/scripts/components/charts/chart-01.js
  var import_apexcharts = __toESM(require_apexcharts_common());
  var chart01 = () => {
    const chartOneOptions = {
      series: [
        {
          name: "Sales",
          data: [168, 385, 201, 298, 187, 195, 291, 110, 215, 390, 280, 112]
        }
      ],
      colors: ["#465fff"],
      chart: {
        fontFamily: "Outfit, sans-serif",
        type: "bar",
        height: 180,
        toolbar: {
          show: false
        }
      },
      plotOptions: {
        bar: {
          horizontal: false,
          columnWidth: "39%",
          borderRadius: 5,
          borderRadiusApplication: "end"
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        show: true,
        width: 4,
        colors: ["transparent"]
      },
      xaxis: {
        categories: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        axisBorder: {
          show: false
        },
        axisTicks: {
          show: false
        }
      },
      legend: {
        show: true,
        position: "top",
        horizontalAlign: "left",
        fontFamily: "Outfit",
        markers: {
          radius: 99
        }
      },
      yaxis: {
        title: false
      },
      grid: {
        yaxis: {
          lines: {
            show: true
          }
        }
      },
      fill: {
        opacity: 1
      },
      tooltip: {
        x: {
          show: false
        },
        y: {
          formatter: function(val) {
            return val;
          }
        }
      }
    };
    const chartSelector = document.querySelectorAll("#chartOne");
    if (chartSelector.length) {
      const chartFour = new import_apexcharts.default(
        document.querySelector("#chartOne"),
        chartOneOptions
      );
      chartFour.render();
    }
  };
  var chart_01_default = chart01;

  // assets/scripts/components/charts/chart-02.js
  var import_apexcharts2 = __toESM(require_apexcharts_common());
  var chart02 = () => {
    const chartTwoOptions = {
      series: [75.55],
      colors: ["#465FFF"],
      chart: {
        fontFamily: "Outfit, sans-serif",
        type: "radialBar",
        height: 330,
        sparkline: {
          enabled: true
        }
      },
      plotOptions: {
        radialBar: {
          startAngle: -90,
          endAngle: 90,
          hollow: {
            size: "80%"
          },
          track: {
            background: "#E4E7EC",
            strokeWidth: "100%",
            margin: 5
            // margin is in pixels
          },
          dataLabels: {
            name: {
              show: false
            },
            value: {
              fontSize: "36px",
              fontWeight: "600",
              offsetY: 60,
              color: "#1D2939",
              formatter: function(val) {
                return val + "%";
              }
            }
          }
        }
      },
      fill: {
        type: "solid",
        colors: ["#465FFF"]
      },
      stroke: {
        lineCap: "round"
      },
      labels: ["Progress"]
    };
    const chartSelector = document.querySelectorAll("#chartTwo");
    if (chartSelector.length) {
      const chartFour = new import_apexcharts2.default(
        document.querySelector("#chartTwo"),
        chartTwoOptions
      );
      chartFour.render();
    }
  };
  var chart_02_default = chart02;

  // assets/scripts/components/charts/chart-03.js
  var import_apexcharts3 = __toESM(require_apexcharts_common());
  var chart03 = () => {
    const chartThreeOptions = {
      series: [
        {
          name: "Sales",
          data: [180, 190, 170, 160, 175, 165, 170, 205, 230, 210, 240, 235]
        },
        {
          name: "Revenue",
          data: [40, 30, 50, 40, 55, 40, 70, 100, 110, 120, 150, 140]
        }
      ],
      legend: {
        show: false,
        position: "top",
        horizontalAlign: "left"
      },
      colors: ["#465FFF", "#9CB9FF"],
      chart: {
        fontFamily: "Outfit, sans-serif",
        height: 310,
        type: "area",
        toolbar: {
          show: false
        }
      },
      fill: {
        gradient: {
          enabled: true,
          opacityFrom: 0.55,
          opacityTo: 0
        }
      },
      stroke: {
        curve: "straight",
        width: ["2", "2"]
      },
      markers: {
        size: 0
      },
      labels: {
        show: false,
        position: "top"
      },
      grid: {
        xaxis: {
          lines: {
            show: false
          }
        },
        yaxis: {
          lines: {
            show: true
          }
        }
      },
      dataLabels: {
        enabled: false
      },
      tooltip: {
        x: {
          format: "dd MMM yyyy"
        }
      },
      xaxis: {
        type: "category",
        categories: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        axisBorder: {
          show: false
        },
        axisTicks: {
          show: false
        },
        tooltip: false
      },
      yaxis: {
        title: {
          style: {
            fontSize: "0px"
          }
        }
      }
    };
    const chartSelector = document.querySelectorAll("#chartThree");
    if (chartSelector.length) {
      const chartThree = new import_apexcharts3.default(
        document.querySelector("#chartThree"),
        chartThreeOptions
      );
      chartThree.render();
    }
  };
  var chart_03_default = chart03;

  // node_modules/jsvectormap/dist/jsvectormap.esm.js
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isNode(value) || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function isNode(value) {
    return value instanceof Node;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return target.propertyIsEnumerable(symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_3) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  var deepmerge = function deepmerge2(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  };
  var getElement = function getElement2(selector) {
    if (typeof selector === "object" && typeof selector.nodeType !== "undefined") {
      return selector;
    }
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return null;
  };
  var createElement2 = function createElement3(type, classes, content, html) {
    if (html === void 0) {
      html = false;
    }
    var el = document.createElement(type);
    if (content) {
      el[!html ? "textContent" : "innerHTML"] = content;
    }
    if (classes) {
      el.className = classes;
    }
    return el;
  };
  var findElement = function findElement2(parentElement, selector) {
    return Element.prototype.querySelector.call(parentElement, selector);
  };
  var removeElement = function removeElement2(target) {
    target.parentNode.removeChild(target);
  };
  var isImageUrl = function isImageUrl2(url) {
    return /\.(jpg|gif|png)$/.test(url);
  };
  var hyphenate2 = function hyphenate3(string) {
    return string.replace(/[\w]([A-Z])/g, function(m3) {
      return m3[0] + "-" + m3[1];
    }).toLowerCase();
  };
  var merge = function merge2(target, source, deep) {
    if (deep === void 0) {
      deep = false;
    }
    if (deep) {
      return deepmerge(target, source);
    }
    return Object.assign(target, source);
  };
  var getLineUid = function getLineUid2(from, to) {
    return from.toLowerCase() + ":to:" + to.toLowerCase();
  };
  var inherit = function inherit2(target, source) {
    Object.assign(target.prototype, source);
  };
  var eventRegistry = {};
  var eventUid = 1;
  var EventHandler = {
    on: function on2(element, event, handler4, options) {
      if (options === void 0) {
        options = {};
      }
      var uid2 = "jvm:" + event + "::" + eventUid++;
      eventRegistry[uid2] = {
        selector: element,
        handler: handler4
      };
      handler4._uid = uid2;
      element.addEventListener(event, handler4, options);
    },
    delegate: function delegate(element, event, selector, handler4) {
      event = event.split(" ");
      event.forEach(function(eventName) {
        EventHandler.on(element, eventName, function(e3) {
          var target = e3.target;
          if (target.matches(selector)) {
            handler4.call(target, e3);
          }
        });
      });
    },
    off: function off(element, event, handler4) {
      var eventType = event.split(":")[1];
      element.removeEventListener(eventType, handler4);
      delete eventRegistry[handler4._uid];
    },
    flush: function flush() {
      Object.keys(eventRegistry).forEach(function(event) {
        EventHandler.off(eventRegistry[event].selector, event, eventRegistry[event].handler);
      });
    },
    getEventRegistry: function getEventRegistry() {
      return eventRegistry;
    }
  };
  function setupContainerEvents() {
    var _this = this;
    var map = this;
    var mouseDown = false;
    var oldPageX;
    var oldPageY;
    if (this.params.draggable) {
      EventHandler.on(this.container, "mousemove", function(e3) {
        if (!mouseDown) {
          return false;
        }
        map.transX -= (oldPageX - e3.pageX) / map.scale;
        map.transY -= (oldPageY - e3.pageY) / map.scale;
        map._applyTransform();
        oldPageX = e3.pageX;
        oldPageY = e3.pageY;
      });
      EventHandler.on(this.container, "mousedown", function(e3) {
        mouseDown = true;
        oldPageX = e3.pageX;
        oldPageY = e3.pageY;
        return false;
      });
      EventHandler.on(document.body, "mouseup", function() {
        mouseDown = false;
      });
    }
    if (this.params.zoomOnScroll) {
      EventHandler.on(this.container, "wheel", function(event) {
        var deltaY = ((event.deltaY || -event.wheelDelta || event.detail) >> 10 || 1) * 75;
        var rect = _this.container.getBoundingClientRect();
        var offsetX = event.pageX - rect.left - window.scrollX;
        var offsetY = event.pageY - rect.top - window.scrollY;
        var zoomStep = Math.pow(1 + map.params.zoomOnScrollSpeed / 1e3, -1.5 * deltaY);
        if (map.tooltip) {
          map._tooltip.hide();
        }
        map._setScale(map.scale * zoomStep, offsetX, offsetY);
        event.preventDefault();
      });
    }
  }
  var Events = {
    onLoaded: "map:loaded",
    onViewportChange: "viewport:changed",
    onRegionClick: "region:clicked",
    onMarkerClick: "marker:clicked",
    onRegionSelected: "region:selected",
    onMarkerSelected: "marker:selected",
    onRegionTooltipShow: "region.tooltip:show",
    onMarkerTooltipShow: "marker.tooltip:show",
    onDestroyed: "map:destroyed"
  };
  var parseEvent = function parseEvent2(map, selector, isTooltip) {
    var element = getElement(selector);
    var type = element.getAttribute("class").indexOf("jvm-region") === -1 ? "marker" : "region";
    var isRegion = type === "region";
    var code = isRegion ? element.getAttribute("data-code") : element.getAttribute("data-index");
    var event = isRegion ? Events.onRegionSelected : Events.onMarkerSelected;
    if (isTooltip) {
      event = isRegion ? Events.onRegionTooltipShow : Events.onMarkerTooltipShow;
    }
    return {
      type,
      code,
      event,
      element: isRegion ? map.regions[code].element : map._markers[code].element,
      tooltipText: isRegion ? map._mapData.paths[code].name || "" : map._markers[code].config.name || ""
    };
  };
  function setupElementEvents() {
    var map = this;
    var container = this.container;
    var pageX, pageY, mouseMoved;
    EventHandler.on(container, "mousemove", function(event) {
      if (Math.abs(pageX - event.pageX) + Math.abs(pageY - event.pageY) > 2) {
        mouseMoved = true;
      }
    });
    EventHandler.delegate(container, "mousedown", ".jvm-element", function(event) {
      pageX = event.pageX;
      pageY = event.pageY;
      mouseMoved = false;
    });
    EventHandler.delegate(container, "mouseover mouseout", ".jvm-element", function(event) {
      var data2 = parseEvent(map, this, true);
      var showTooltip = map.params.showTooltip;
      if (event.type === "mouseover") {
        data2.element.hover(true);
        if (showTooltip) {
          map._tooltip.text(data2.tooltipText);
          map._emit(data2.event, [event, map._tooltip, data2.code]);
          if (!event.defaultPrevented) {
            map._tooltip.show();
          }
        }
      } else {
        data2.element.hover(false);
        if (showTooltip) {
          map._tooltip.hide();
        }
      }
    });
    EventHandler.delegate(container, "mouseup", ".jvm-element", function(event) {
      var data2 = parseEvent(map, this);
      if (mouseMoved) {
        return;
      }
      if (data2.type === "region" && map.params.regionsSelectable || data2.type === "marker" && map.params.markersSelectable) {
        var element = data2.element;
        if (map.params[data2.type + "sSelectableOne"]) {
          data2.type === "region" ? map.clearSelectedRegions() : map.clearSelectedMarkers();
        }
        if (data2.element.isSelected) {
          element.select(false);
        } else {
          element.select(true);
        }
        map._emit(data2.event, [data2.code, element.isSelected, data2.type === "region" ? map.getSelectedRegions() : map.getSelectedMarkers()]);
      }
    });
    EventHandler.delegate(container, "click", ".jvm-element", function(event) {
      var _parseEvent = parseEvent(map, this), type = _parseEvent.type, code = _parseEvent.code;
      map._emit(type === "region" ? Events.onRegionClick : Events.onMarkerClick, [event, code]);
    });
  }
  function setupZoomButtons() {
    var _this = this;
    var zoomInOption = this.params.zoomInButton;
    var zoomOutOption = this.params.zoomOutButton;
    var getZoomButton = function getZoomButton2(zoomOption) {
      return typeof zoomOption === "string" ? document.querySelector(zoomOption) : zoomOption;
    };
    var zoomIn = zoomInOption ? getZoomButton(zoomInOption) : createElement2("div", "jvm-zoom-btn jvm-zoomin", "&#43;", true);
    var zoomOut = zoomOutOption ? getZoomButton(zoomOutOption) : createElement2("div", "jvm-zoom-btn jvm-zoomout", "&#x2212", true);
    if (!zoomInOption) {
      this.container.appendChild(zoomIn);
    }
    if (!zoomOutOption) {
      this.container.appendChild(zoomOut);
    }
    var handler4 = function handler5(zoomin) {
      if (zoomin === void 0) {
        zoomin = true;
      }
      return function() {
        return _this._setScale(zoomin ? _this.scale * _this.params.zoomStep : _this.scale / _this.params.zoomStep, _this._width / 2, _this._height / 2, false, _this.params.zoomAnimate);
      };
    };
    EventHandler.on(zoomIn, "click", handler4());
    EventHandler.on(zoomOut, "click", handler4(false));
  }
  function setupContainerTouchEvents() {
    var map = this, touchStartScale, touchStartDistance, touchX, touchY, centerTouchX, centerTouchY, lastTouchesLength;
    var handleTouchEvent = function handleTouchEvent2(e3) {
      var touches = e3.touches;
      var offset, scale, transXOld, transYOld;
      if (e3.type == "touchstart") {
        lastTouchesLength = 0;
      }
      if (touches.length == 1) {
        if (lastTouchesLength == 1) {
          var _map$_tooltip;
          transXOld = map.transX;
          transYOld = map.transY;
          map.transX -= (touchX - touches[0].pageX) / map.scale;
          map.transY -= (touchY - touches[0].pageY) / map.scale;
          (_map$_tooltip = map._tooltip) == null || _map$_tooltip.hide();
          map._applyTransform();
          if (transXOld != map.transX || transYOld != map.transY) {
            e3.preventDefault();
          }
        }
        touchX = touches[0].pageX;
        touchY = touches[0].pageY;
      } else if (touches.length == 2) {
        if (lastTouchesLength == 2) {
          var _map$_tooltip2;
          scale = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2)) / touchStartDistance;
          map._setScale(touchStartScale * scale, centerTouchX, centerTouchY);
          (_map$_tooltip2 = map._tooltip) == null || _map$_tooltip2.hide();
          e3.preventDefault();
        } else {
          var rect = map.container.getBoundingClientRect();
          offset = {
            top: rect.top + window.scrollY,
            left: rect.left + window.scrollX
          };
          if (touches[0].pageX > touches[1].pageX) {
            centerTouchX = touches[1].pageX + (touches[0].pageX - touches[1].pageX) / 2;
          } else {
            centerTouchX = touches[0].pageX + (touches[1].pageX - touches[0].pageX) / 2;
          }
          if (touches[0].pageY > touches[1].pageY) {
            centerTouchY = touches[1].pageY + (touches[0].pageY - touches[1].pageY) / 2;
          } else {
            centerTouchY = touches[0].pageY + (touches[1].pageY - touches[0].pageY) / 2;
          }
          centerTouchX -= offset.left;
          centerTouchY -= offset.top;
          touchStartScale = map.scale;
          touchStartDistance = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2));
        }
      }
      lastTouchesLength = touches.length;
    };
    EventHandler.on(map.container, "touchstart", handleTouchEvent);
    EventHandler.on(map.container, "touchmove", handleTouchEvent);
  }
  function _arrayLikeToArray(r3, a3) {
    (null == a3 || a3 > r3.length) && (a3 = r3.length);
    for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r3[e3];
    return n2;
  }
  function _assertThisInitialized(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }
  function _defineProperties(e3, r3) {
    for (var t3 = 0; t3 < r3.length; t3++) {
      var o2 = r3[t3];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e3, r3, t3) {
    return r3 && _defineProperties(e3.prototype, r3), t3 && _defineProperties(e3, t3), Object.defineProperty(e3, "prototype", {
      writable: false
    }), e3;
  }
  function _createForOfIteratorHelperLoose(r3, e3) {
    var t3 = "undefined" != typeof Symbol && r3[Symbol.iterator] || r3["@@iterator"];
    if (t3) return (t3 = t3.call(r3)).next.bind(t3);
    if (Array.isArray(r3) || (t3 = _unsupportedIterableToArray(r3)) || e3 && r3 && "number" == typeof r3.length) {
      t3 && (r3 = t3);
      var o2 = 0;
      return function() {
        return o2 >= r3.length ? {
          done: true
        } : {
          done: false,
          value: r3[o2++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t3 = arguments[e3];
        for (var r3 in t3) ({}).hasOwnProperty.call(t3, r3) && (n2[r3] = t3[r3]);
      }
      return n2;
    }, _extends.apply(null, arguments);
  }
  function _inheritsLoose(t3, o2) {
    t3.prototype = Object.create(o2.prototype), t3.prototype.constructor = t3, _setPrototypeOf(t3, o2);
  }
  function _objectWithoutPropertiesLoose(r3, e3) {
    if (null == r3) return {};
    var t3 = {};
    for (var n2 in r3) if ({}.hasOwnProperty.call(r3, n2)) {
      if (-1 !== e3.indexOf(n2)) continue;
      t3[n2] = r3[n2];
    }
    return t3;
  }
  function _setPrototypeOf(t3, e3) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
      return t4.__proto__ = e4, t4;
    }, _setPrototypeOf(t3, e3);
  }
  function _toPrimitive(t3, r3) {
    if ("object" != typeof t3 || !t3) return t3;
    var e3 = t3[Symbol.toPrimitive];
    if (void 0 !== e3) {
      var i3 = e3.call(t3, r3 || "default");
      if ("object" != typeof i3) return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r3 ? String : Number)(t3);
  }
  function _toPropertyKey(t3) {
    var i3 = _toPrimitive(t3, "string");
    return "symbol" == typeof i3 ? i3 : i3 + "";
  }
  function _unsupportedIterableToArray(r3, a3) {
    if (r3) {
      if ("string" == typeof r3) return _arrayLikeToArray(r3, a3);
      var t3 = {}.toString.call(r3).slice(8, -1);
      return "Object" === t3 && r3.constructor && (t3 = r3.constructor.name), "Map" === t3 || "Set" === t3 ? Array.from(r3) : "Arguments" === t3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? _arrayLikeToArray(r3, a3) : void 0;
    }
  }
  var BaseComponent = /* @__PURE__ */ (function() {
    function BaseComponent3() {
    }
    var _proto = BaseComponent3.prototype;
    _proto.dispose = function dispose() {
      if (this._tooltip) {
        removeElement(this._tooltip);
      } else {
        this.shape.remove();
      }
      for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(this)), _step; !(_step = _iterator()).done; ) {
        var propertyName = _step.value;
        this[propertyName] = null;
      }
    };
    return BaseComponent3;
  })();
  var Interactable = {
    getLabelText: function getLabelText(key, label) {
      if (!label) {
        return;
      }
      if (typeof label.render === "function") {
        var params = [];
        if (this.constructor.Name === "marker") {
          params.push(this.getConfig());
        }
        params.push(key);
        return label.render.apply(this, params);
      }
      return key;
    },
    getLabelOffsets: function getLabelOffsets(key, label) {
      if (typeof label.offsets === "function") {
        return label.offsets(key);
      }
      if (Array.isArray(label.offsets)) {
        return label.offsets[key];
      }
      return [0, 0];
    },
    setStyle: function setStyle(property, value) {
      this.shape.setStyle(property, value);
    },
    remove: function remove() {
      this.shape.remove();
      if (this.label) this.label.remove();
    },
    hover: function hover(state) {
      this._setStatus("isHovered", state);
    },
    select: function select(state) {
      this._setStatus("isSelected", state);
    },
    // Private
    _setStatus: function _setStatus(property, state) {
      this.shape[property] = state;
      this.shape.updateStyle();
      this[property] = state;
      if (this.label) {
        this.label[property] = state;
        this.label.updateStyle();
      }
    }
  };
  var Region = /* @__PURE__ */ (function(_BaseComponent) {
    function Region2(_ref) {
      var _this;
      var map = _ref.map, code = _ref.code, path = _ref.path, style = _ref.style, label = _ref.label, labelStyle = _ref.labelStyle, labelsGroup = _ref.labelsGroup;
      _this = _BaseComponent.call(this) || this;
      _this._map = map;
      _this.shape = _this._createRegion(path, code, style);
      var text = _this.getLabelText(code, label);
      if (label && text) {
        var bbox = _this.shape.getBBox();
        var offsets = _this.getLabelOffsets(code, label);
        _this.labelX = bbox.x + bbox.width / 2 + offsets[0];
        _this.labelY = bbox.y + bbox.height / 2 + offsets[1];
        _this.label = _this._map.canvas.createText({
          text,
          textAnchor: "middle",
          alignmentBaseline: "central",
          dataCode: code,
          x: _this.labelX,
          y: _this.labelY
        }, labelStyle, labelsGroup);
        _this.label.addClass("jvm-region jvm-element");
      }
      return _this;
    }
    _inheritsLoose(Region2, _BaseComponent);
    var _proto = Region2.prototype;
    _proto._createRegion = function _createRegion(path, code, style) {
      path = this._map.canvas.createPath({
        d: path,
        dataCode: code
      }, style);
      path.addClass("jvm-region jvm-element");
      return path;
    };
    _proto.updateLabelPosition = function updateLabelPosition() {
      if (this.label) {
        this.label.set({
          x: this.labelX * this._map.scale + this._map.transX * this._map.scale,
          y: this.labelY * this._map.scale + this._map.transY * this._map.scale
        });
      }
    };
    return Region2;
  })(BaseComponent);
  inherit(Region, Interactable);
  function createRegions() {
    this._regionLabelsGroup = this._regionLabelsGroup || this.canvas.createGroup("jvm-regions-labels-group");
    for (var code in this._mapData.paths) {
      var region = new Region({
        map: this,
        code,
        path: this._mapData.paths[code].path,
        style: merge({}, this.params.regionStyle),
        labelStyle: this.params.regionLabelStyle,
        labelsGroup: this._regionLabelsGroup,
        label: this.params.labels && this.params.labels.regions
      });
      this.regions[code] = {
        config: this._mapData.paths[code],
        element: region
      };
    }
  }
  var LINE_CLASS = "jvm-line";
  var Line = /* @__PURE__ */ (function(_BaseComponent) {
    function Line2(options, style) {
      var _this;
      _this = _BaseComponent.call(this) || this;
      _this._options = options;
      _this._style = {
        initial: style
      };
      _this._draw();
      return _this;
    }
    _inheritsLoose(Line2, _BaseComponent);
    var _proto = Line2.prototype;
    _proto.setStyle = function setStyle2(property, value) {
      this.shape.setStyle(property, value);
    };
    _proto.getConfig = function getConfig() {
      return this._options.config;
    };
    _proto._draw = function _draw() {
      var _this$_options = this._options, index6 = _this$_options.index, group = _this$_options.group, map = _this$_options.map;
      var config2 = {
        d: this._getDAttribute(),
        fill: "none",
        dataIndex: index6
      };
      this.shape = map.canvas.createPath(config2, this._style, group);
      this.shape.addClass(LINE_CLASS);
    };
    _proto._getDAttribute = function _getDAttribute() {
      var _this$_options2 = this._options, x1 = _this$_options2.x1, y1 = _this$_options2.y1, x22 = _this$_options2.x2, y22 = _this$_options2.y2, curvature = _this$_options2.curvature;
      return "M" + x1 + "," + y1 + this._getQCommand(x1, y1, x22, y22, curvature) + x22 + "," + y22;
    };
    _proto._getQCommand = function _getQCommand(x1, y1, x22, y22, curvature) {
      if (!curvature) {
        return " ";
      }
      var curveX = (x1 + x22) / 2 + curvature * (y22 - y1);
      var curveY = (y1 + y22) / 2 - curvature * (x22 - x1);
      return " Q" + curveX + "," + curveY + " ";
    };
    return Line2;
  })(BaseComponent);
  var _excluded = ["curvature"];
  var _excluded2 = ["curvature"];
  function createLines(lines) {
    var point1 = false, point2 = false;
    var _this$params$lineStyl = this.params.lineStyle, curvature = _this$params$lineStyl.curvature, lineStyle = _objectWithoutPropertiesLoose(_this$params$lineStyl, _excluded);
    for (var index6 in lines) {
      var lineConfig = lines[index6];
      for (var _i = 0, _Object$values = Object.values(this._markers); _i < _Object$values.length; _i++) {
        var markerConfig = _Object$values[_i].config;
        if (markerConfig.name === lineConfig.from) {
          point1 = this.getMarkerPosition(markerConfig);
        }
        if (markerConfig.name === lineConfig.to) {
          point2 = this.getMarkerPosition(markerConfig);
        }
      }
      if (point1 !== false && point2 !== false) {
        var _ref = lineConfig.style || {}, curvatureOption = _ref.curvature, style = _objectWithoutPropertiesLoose(_ref, _excluded2);
        this._lines[getLineUid(lineConfig.from, lineConfig.to)] = new Line({
          index: index6,
          map: this,
          group: this._linesGroup,
          config: lineConfig,
          x1: point1.x,
          y1: point1.y,
          x2: point2.x,
          y2: point2.y,
          curvature: curvatureOption == 0 ? 0 : curvatureOption || curvature
        }, merge(lineStyle, style, true));
      }
    }
  }
  var NAME = "marker";
  var JVM_PREFIX$1 = "jvm-";
  var MARKER_CLASS = JVM_PREFIX$1 + "element " + JVM_PREFIX$1 + "marker";
  var MARKER_LABEL_CLASS = JVM_PREFIX$1 + "element " + JVM_PREFIX$1 + "label";
  var Marker = /* @__PURE__ */ (function(_BaseComponent) {
    function Marker2(options, style) {
      var _this;
      _this = _BaseComponent.call(this) || this;
      _this._options = options;
      _this._style = style;
      _this._labelX = null;
      _this._labelY = null;
      _this._offsets = null;
      _this._isImage = !!style.initial.image;
      _this._draw();
      if (_this._options.label) {
        _this._drawLabel();
      }
      if (_this._isImage) {
        _this.updateLabelPosition();
      }
      return _this;
    }
    _inheritsLoose(Marker2, _BaseComponent);
    var _proto = Marker2.prototype;
    _proto.getConfig = function getConfig() {
      return this._options.config;
    };
    _proto.updateLabelPosition = function updateLabelPosition() {
      var map = this._options.map;
      if (this.label) {
        this.label.set({
          x: this._labelX * map.scale + this._offsets[0] + map.transX * map.scale + 5 + (this._isImage ? (this.shape.width || 0) / 2 : this.shape.node.r.baseVal.value),
          y: this._labelY * map.scale + map.transY * this._options.map.scale + this._offsets[1]
        });
      }
    };
    _proto._draw = function _draw() {
      var _this$_options = this._options, index6 = _this$_options.index, map = _this$_options.map, group = _this$_options.group, cx = _this$_options.cx, cy = _this$_options.cy;
      var shapeType = this._isImage ? "createImage" : "createCircle";
      this.shape = map.canvas[shapeType]({
        dataIndex: index6,
        cx,
        cy
      }, this._style, group);
      this.shape.addClass(MARKER_CLASS);
    };
    _proto._drawLabel = function _drawLabel() {
      var _this$_options2 = this._options, index6 = _this$_options2.index, map = _this$_options2.map, label = _this$_options2.label, labelsGroup = _this$_options2.labelsGroup, cx = _this$_options2.cx, cy = _this$_options2.cy, config2 = _this$_options2.config, isRecentlyCreated = _this$_options2.isRecentlyCreated;
      var labelText = this.getLabelText(index6, label);
      this._labelX = cx / map.scale - map.transX;
      this._labelY = cy / map.scale - map.transY;
      this._offsets = isRecentlyCreated && config2.offsets ? config2.offsets : this.getLabelOffsets(index6, label);
      this.label = map.canvas.createText({
        text: labelText,
        dataIndex: index6,
        x: this._labelX,
        y: this._labelY,
        dy: "0.6ex"
      }, map.params.markerLabelStyle, labelsGroup);
      this.label.addClass(MARKER_LABEL_CLASS);
      if (isRecentlyCreated) {
        this.updateLabelPosition();
      }
    };
    return _createClass(Marker2, null, [{
      key: "Name",
      get: function get3() {
        return NAME;
      }
    }]);
  })(BaseComponent);
  inherit(Marker, Interactable);
  function createMarkers(markers, isRecentlyCreated) {
    var _this = this;
    if (markers === void 0) {
      markers = {};
    }
    if (isRecentlyCreated === void 0) {
      isRecentlyCreated = false;
    }
    var _loop = function _loop2() {
      var config2 = markers[index6];
      var point = _this.getMarkerPosition(config2);
      var uid2 = config2.coords.join(":");
      if (!point) {
        return 0;
      }
      if (isRecentlyCreated) {
        if (Object.keys(_this._markers).filter(function(i3) {
          return _this._markers[i3]._uid === uid2;
        }).length) {
          return 0;
        }
        index6 = Object.keys(_this._markers).length;
      }
      var marker = new Marker({
        index: index6,
        map: _this,
        label: _this.params.labels && _this.params.labels.markers,
        labelsGroup: _this._markerLabelsGroup,
        cx: point.x,
        cy: point.y,
        group: _this._markersGroup,
        config: config2,
        isRecentlyCreated
      }, merge(_this.params.markerStyle, _extends({}, config2.style || {}), true));
      if (_this._markers[index6]) {
        _this.removeMarkers([index6]);
      }
      _this._markers[index6] = {
        _uid: uid2,
        config: config2,
        element: marker
      };
    }, _ret;
    for (var index6 in markers) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
  }
  var Legend = /* @__PURE__ */ (function() {
    function Legend2(options) {
      if (options === void 0) {
        options = {};
      }
      this._options = options;
      this._map = this._options.map;
      this._series = this._options.series;
      this._body = createElement2("div", "jvm-legend");
      if (this._options.cssClass) {
        this._body.setAttribute("class", this._options.cssClass);
      }
      if (options.vertical) {
        this._map.legendVertical.appendChild(this._body);
      } else {
        this._map.legendHorizontal.appendChild(this._body);
      }
      this.render();
    }
    var _proto = Legend2.prototype;
    _proto.render = function render() {
      var ticks = this._series.scale.getTicks();
      this._body.innderHTML = "";
      if (this._options.title) {
        var legendTitle = createElement2("div", "jvm-legend-title", this._options.title);
        this._body.appendChild(legendTitle);
      }
      for (var i3 = 0; i3 < ticks.length; i3++) {
        var tick = createElement2("div", "jvm-legend-tick");
        var sample = createElement2("div", "jvm-legend-tick-sample");
        switch (this._series.config.attribute) {
          case "fill":
            if (isImageUrl(ticks[i3].value)) {
              sample.style.background = "url(" + ticks[i3].value + ")";
            } else {
              sample.style.background = ticks[i3].value;
            }
            break;
          case "stroke":
            sample.style.background = ticks[i3].value;
            break;
          case "image":
            sample.style.background = "url(" + (typeof ticks[i3].value === "object" ? ticks[i3].value.url : ticks[i3].value) + ") no-repeat center center";
            sample.style.backgroundSize = "cover";
            break;
        }
        tick.appendChild(sample);
        var label = ticks[i3].label;
        if (this._options.labelRender) {
          label = this._options.labelRender(label);
        }
        var tickText = createElement2("div", "jvm-legend-tick-text", label);
        tick.appendChild(tickText);
        this._body.appendChild(tick);
      }
    };
    return Legend2;
  })();
  var OrdinalScale = /* @__PURE__ */ (function() {
    function OrdinalScale2(scale) {
      this._scale = scale;
    }
    var _proto = OrdinalScale2.prototype;
    _proto.getValue = function getValue(value) {
      return this._scale[value];
    };
    _proto.getTicks = function getTicks() {
      var ticks = [];
      for (var key in this._scale) {
        ticks.push({
          label: key,
          value: this._scale[key]
        });
      }
      return ticks;
    };
    return OrdinalScale2;
  })();
  var Series = /* @__PURE__ */ (function() {
    function Series2(config2, elements, map) {
      if (config2 === void 0) {
        config2 = {};
      }
      this._map = map;
      this._elements = elements;
      this._values = config2.values || {};
      this.config = config2;
      this.config.attribute = config2.attribute || "fill";
      if (config2.attributes) {
        this.setAttributes(config2.attributes);
      }
      if (typeof config2.scale === "object") {
        this.scale = new OrdinalScale(config2.scale);
      }
      if (this.config.legend) {
        this.legend = new Legend(merge({
          map: this._map,
          series: this
        }, this.config.legend));
      }
      this.setValues(this._values);
    }
    var _proto = Series2.prototype;
    _proto.setValues = function setValues(values) {
      var attrs = {};
      for (var key in values) {
        if (values[key]) {
          attrs[key] = this.scale.getValue(values[key]);
        }
      }
      this.setAttributes(attrs);
    };
    _proto.setAttributes = function setAttributes(attrs) {
      for (var code in attrs) {
        if (this._elements[code]) {
          this._elements[code].element.setStyle(this.config.attribute, attrs[code]);
        }
      }
    };
    _proto.clear = function clear2() {
      var key, attrs = {};
      for (key in this._values) {
        if (this._elements[key]) {
          attrs[key] = this._elements[key].element.shape.style.initial[this.config.attribute];
        }
      }
      this.setAttributes(attrs);
      this._values = {};
    };
    return Series2;
  })();
  function createSeries() {
    this.series = {
      markers: [],
      regions: []
    };
    for (var key in this.params.series) {
      for (var i3 = 0; i3 < this.params.series[key].length; i3++) {
        this.series[key][i3] = new Series(this.params.series[key][i3], key === "markers" ? this._markers : this.regions, this);
      }
    }
  }
  function applyTransform() {
    var maxTransX, maxTransY, minTransX, minTransY;
    if (this._defaultWidth * this.scale <= this._width) {
      maxTransX = (this._width - this._defaultWidth * this.scale) / (2 * this.scale);
      minTransX = (this._width - this._defaultWidth * this.scale) / (2 * this.scale);
    } else {
      maxTransX = 0;
      minTransX = (this._width - this._defaultWidth * this.scale) / this.scale;
    }
    if (this._defaultHeight * this.scale <= this._height) {
      maxTransY = (this._height - this._defaultHeight * this.scale) / (2 * this.scale);
      minTransY = (this._height - this._defaultHeight * this.scale) / (2 * this.scale);
    } else {
      maxTransY = 0;
      minTransY = (this._height - this._defaultHeight * this.scale) / this.scale;
    }
    if (this.transY > maxTransY) {
      this.transY = maxTransY;
    } else if (this.transY < minTransY) {
      this.transY = minTransY;
    }
    if (this.transX > maxTransX) {
      this.transX = maxTransX;
    } else if (this.transX < minTransX) {
      this.transX = minTransX;
    }
    this.canvas.applyTransformParams(this.scale, this.transX, this.transY);
    if (this._markers) {
      this._repositionMarkers();
    }
    if (this._lines) {
      this._repositionLines();
    }
    this._repositionLabels();
  }
  function resize() {
    var curBaseScale = this._baseScale;
    if (this._width / this._height > this._defaultWidth / this._defaultHeight) {
      this._baseScale = this._height / this._defaultHeight;
      this._baseTransX = Math.abs(this._width - this._defaultWidth * this._baseScale) / (2 * this._baseScale);
    } else {
      this._baseScale = this._width / this._defaultWidth;
      this._baseTransY = Math.abs(this._height - this._defaultHeight * this._baseScale) / (2 * this._baseScale);
    }
    this.scale *= this._baseScale / curBaseScale;
    this.transX *= this._baseScale / curBaseScale;
    this.transY *= this._baseScale / curBaseScale;
  }
  function setScale(scale, anchorX, anchorY, isCentered, animate) {
    var _this = this;
    var zoomStep, interval, i3 = 0, count = Math.abs(Math.round((scale - this.scale) * 60 / Math.max(scale, this.scale))), scaleStart, scaleDiff, transXStart, transXDiff, transYStart, transYDiff, transX, transY;
    if (scale > this.params.zoomMax * this._baseScale) {
      scale = this.params.zoomMax * this._baseScale;
    } else if (scale < this.params.zoomMin * this._baseScale) {
      scale = this.params.zoomMin * this._baseScale;
    }
    if (typeof anchorX != "undefined" && typeof anchorY != "undefined") {
      zoomStep = scale / this.scale;
      if (isCentered) {
        transX = anchorX + this._defaultWidth * (this._width / (this._defaultWidth * scale)) / 2;
        transY = anchorY + this._defaultHeight * (this._height / (this._defaultHeight * scale)) / 2;
      } else {
        transX = this.transX - (zoomStep - 1) / scale * anchorX;
        transY = this.transY - (zoomStep - 1) / scale * anchorY;
      }
    }
    if (animate && count > 0) {
      scaleStart = this.scale;
      scaleDiff = (scale - scaleStart) / count;
      transXStart = this.transX * this.scale;
      transYStart = this.transY * this.scale;
      transXDiff = (transX * scale - transXStart) / count;
      transYDiff = (transY * scale - transYStart) / count;
      interval = setInterval(function() {
        i3 += 1;
        _this.scale = scaleStart + scaleDiff * i3;
        _this.transX = (transXStart + transXDiff * i3) / _this.scale;
        _this.transY = (transYStart + transYDiff * i3) / _this.scale;
        _this._applyTransform();
        if (i3 == count) {
          clearInterval(interval);
          _this._emit(Events.onViewportChange, [_this.scale, _this.transX, _this.transY]);
        }
      }, 10);
    } else {
      this.transX = transX;
      this.transY = transY;
      this.scale = scale;
      this._applyTransform();
      this._emit(Events.onViewportChange, [this.scale, this.transX, this.transY]);
    }
  }
  function setFocus(config2) {
    var _this = this;
    if (config2 === void 0) {
      config2 = {};
    }
    var bbox, codes = [];
    if (config2.region) {
      codes.push(config2.region);
    } else if (config2.regions) {
      codes = config2.regions;
    }
    if (codes.length) {
      codes.forEach(function(code) {
        if (_this.regions[code]) {
          var itemBbox = _this.regions[code].element.shape.getBBox();
          if (itemBbox) {
            if (typeof bbox == "undefined") {
              bbox = itemBbox;
            } else {
              bbox = {
                x: Math.min(bbox.x, itemBbox.x),
                y: Math.min(bbox.y, itemBbox.y),
                width: Math.max(bbox.x + bbox.width, itemBbox.x + itemBbox.width) - Math.min(bbox.x, itemBbox.x),
                height: Math.max(bbox.y + bbox.height, itemBbox.y + itemBbox.height) - Math.min(bbox.y, itemBbox.y)
              };
            }
          }
        }
      });
      return this._setScale(Math.min(this._width / bbox.width, this._height / bbox.height), -(bbox.x + bbox.width / 2), -(bbox.y + bbox.height / 2), true, config2.animate);
    } else if (config2.coords) {
      var point = this.coordsToPoint(config2.coords[0], config2.coords[1]);
      var x4 = this.transX - point.x / this.scale;
      var y3 = this.transY - point.y / this.scale;
      return this._setScale(config2.scale * this._baseScale, x4, y3, true, config2.animate);
    }
  }
  function updateSize() {
    this._width = this.container.offsetWidth;
    this._height = this.container.offsetHeight;
    this._resize();
    this.canvas.setSize(this._width, this._height);
    this._applyTransform();
  }
  var Proj = {
    /* sgn(n){
      if (n > 0) {
        return 1;
      } else if (n < 0) {
        return -1;
      } else {
        return n;
      }
    }, */
    mill: function mill(lat, lng, c3) {
      return {
        x: this.radius * (lng - c3) * this.radDeg,
        y: -this.radius * Math.log(Math.tan((45 + 0.4 * lat) * this.radDeg)) / 0.8
      };
    },
    /* mill_inv(x, y, c) {
      return {
        lat: (2.5 * Math.atan(Math.exp(0.8 * y / this.radius)) - 5 * Math.PI / 8) * this.degRad,
        lng: (c * this.radDeg + x / this.radius) * this.degRad
      };
    }, */
    merc: function merc(lat, lng, c3) {
      return {
        x: this.radius * (lng - c3) * this.radDeg,
        y: -this.radius * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))
      };
    },
    /* merc_inv(x, y, c) {
      return {
        lat: (2 * Math.atan(Math.exp(y / this.radius)) - Math.PI / 2) * this.degRad,
        lng: (c * this.radDeg + x / this.radius) * this.degRad
      };
    }, */
    aea: function aea(lat, lng, c3) {
      var fi0 = 0, lambda0 = c3 * this.radDeg, fi1 = 29.5 * this.radDeg, fi2 = 45.5 * this.radDeg, fi = lat * this.radDeg, lambda = lng * this.radDeg, n2 = (Math.sin(fi1) + Math.sin(fi2)) / 2, C3 = Math.cos(fi1) * Math.cos(fi1) + 2 * n2 * Math.sin(fi1), theta = n2 * (lambda - lambda0), ro = Math.sqrt(C3 - 2 * n2 * Math.sin(fi)) / n2, ro0 = Math.sqrt(C3 - 2 * n2 * Math.sin(fi0)) / n2;
      return {
        x: ro * Math.sin(theta) * this.radius,
        y: -(ro0 - ro * Math.cos(theta)) * this.radius
      };
    },
    /* aea_inv(xCoord, yCoord, c) {
      var x = xCoord / this.radius,
          y = yCoord / this.radius,
          fi0 = 0,
          lambda0 = c * this.radDeg,
          fi1 = 29.5 * this.radDeg,
          fi2 = 45.5 * this.radDeg,
          n = (Math.sin(fi1)+Math.sin(fi2)) / 2,
          C = Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),
          ro0 = Math.sqrt(C-2*n*Math.sin(fi0))/n,
          ro = Math.sqrt(x*x+(ro0-y)*(ro0-y)),
          theta = Math.atan( x / (ro0 - y) );
       return {
        lat: (Math.asin((C - ro * ro * n * n) / (2 * n))) * this.degRad,
        lng: (lambda0 + theta / n) * this.degRad
      };
    }, */
    lcc: function lcc(lat, lng, c3) {
      var fi0 = 0, lambda0 = c3 * this.radDeg, lambda = lng * this.radDeg, fi1 = 33 * this.radDeg, fi2 = 45 * this.radDeg, fi = lat * this.radDeg, n2 = Math.log(Math.cos(fi1) * (1 / Math.cos(fi2))) / Math.log(Math.tan(Math.PI / 4 + fi2 / 2) * (1 / Math.tan(Math.PI / 4 + fi1 / 2))), F4 = Math.cos(fi1) * Math.pow(Math.tan(Math.PI / 4 + fi1 / 2), n2) / n2, ro = F4 * Math.pow(1 / Math.tan(Math.PI / 4 + fi / 2), n2), ro0 = F4 * Math.pow(1 / Math.tan(Math.PI / 4 + fi0 / 2), n2);
      return {
        x: ro * Math.sin(n2 * (lambda - lambda0)) * this.radius,
        y: -(ro0 - ro * Math.cos(n2 * (lambda - lambda0))) * this.radius
      };
    }
    /* lcc_inv(xCoord, yCoord, c) {
      var x = xCoord / this.radius,
          y = yCoord / this.radius,
          fi0 = 0,
          lambda0 = c * this.radDeg,
          fi1 = 33 * this.radDeg,
          fi2 = 45 * this.radDeg,
          n = Math.log( Math.cos(fi1) * (1 / Math.cos(fi2)) ) / Math.log( Math.tan( Math.PI / 4 + fi2 / 2) * (1 / Math.tan( Math.PI / 4 + fi1 / 2) ) ),
          F = ( Math.cos(fi1) * Math.pow( Math.tan( Math.PI / 4 + fi1 / 2 ), n ) ) / n,
          ro0 = F * Math.pow( 1 / Math.tan( Math.PI / 4 + fi0 / 2 ), n ),
          ro = this.sgn(n) * Math.sqrt(x*x+(ro0-y)*(ro0-y)),
          theta = Math.atan( x / (ro0 - y) );
       return {
        lat: (2 * Math.atan(Math.pow(F/ro, 1/n)) - Math.PI / 2) * this.degRad,
        lng: (lambda0 + theta / n) * this.degRad
      };
    } */
  };
  Proj.degRad = 180 / Math.PI;
  Proj.radDeg = Math.PI / 180;
  Proj.radius = 6381372;
  function coordsToPoint(lat, lng) {
    var projection = Map2.maps[this.params.map].projection;
    var _Proj$projection$type = Proj[projection.type](lat, lng, projection.centralMeridian), x4 = _Proj$projection$type.x, y3 = _Proj$projection$type.y;
    var inset = this.getInsetForPoint(x4, y3);
    if (!inset) {
      return false;
    }
    var bbox = inset.bbox;
    x4 = (x4 - bbox[0].x) / (bbox[1].x - bbox[0].x) * inset.width * this.scale;
    y3 = (y3 - bbox[0].y) / (bbox[1].y - bbox[0].y) * inset.height * this.scale;
    return {
      x: x4 + this.transX * this.scale + inset.left * this.scale,
      y: y3 + this.transY * this.scale + inset.top * this.scale
    };
  }
  function getInsetForPoint(x4, y3) {
    var insets = Map2.maps[this.params.map].insets;
    for (var index6 = 0; index6 < insets.length; index6++) {
      var _insets$index$bbox = insets[index6].bbox, start2 = _insets$index$bbox[0], end = _insets$index$bbox[1];
      if (x4 > start2.x && x4 < end.x && y3 > start2.y && y3 < end.y) {
        return insets[index6];
      }
    }
  }
  function getMarkerPosition(_ref) {
    var coords = _ref.coords;
    if (Map2.maps[this.params.map].projection) {
      return this.coordsToPoint.apply(this, coords);
    }
    return {
      x: coords[0] * this.scale + this.transX * this.scale,
      y: coords[1] * this.scale + this.transY * this.scale
    };
  }
  function repositionLines() {
    var _this = this;
    var curvature = this.params.lineStyle.curvature;
    Object.values(this._lines).forEach(function(line) {
      var startMarker = Object.values(_this._markers).find(function(_ref) {
        var config2 = _ref.config;
        return config2.name === line.getConfig().from;
      });
      var endMarker = Object.values(_this._markers).find(function(_ref2) {
        var config2 = _ref2.config;
        return config2.name === line.getConfig().to;
      });
      if (startMarker && endMarker) {
        var _this$getMarkerPositi = _this.getMarkerPosition(startMarker.config), x1 = _this$getMarkerPositi.x, y1 = _this$getMarkerPositi.y;
        var _this$getMarkerPositi2 = _this.getMarkerPosition(endMarker.config), x22 = _this$getMarkerPositi2.x, y22 = _this$getMarkerPositi2.y;
        var curvatureOption = line._options.curvature == 0 ? 0 : line._options.curvature || curvature;
        var midX = (x1 + x22) / 2;
        var midY = (y1 + y22) / 2;
        var curveX = midX + curvatureOption * (y22 - y1);
        var curveY = midY - curvatureOption * (x22 - x1);
        line.setStyle({
          d: "M" + x1 + "," + y1 + " Q" + curveX + "," + curveY + " " + x22 + "," + y22
        });
      }
    });
  }
  function repositionMarkers() {
    for (var index6 in this._markers) {
      var point = this.getMarkerPosition(this._markers[index6].config);
      if (point !== false) {
        this._markers[index6].element.setStyle({
          cx: point.x,
          cy: point.y
        });
      }
    }
  }
  function repositionLabels() {
    var labels = this.params.labels;
    if (!labels) {
      return;
    }
    if (labels.regions) {
      for (var key in this.regions) {
        this.regions[key].element.updateLabelPosition();
      }
    }
    if (labels.markers) {
      for (var _key in this._markers) {
        this._markers[_key].element.updateLabelPosition();
      }
    }
  }
  var core = {
    _setupContainerEvents: setupContainerEvents,
    _setupElementEvents: setupElementEvents,
    _setupZoomButtons: setupZoomButtons,
    _setupContainerTouchEvents: setupContainerTouchEvents,
    _createRegions: createRegions,
    _createLines: createLines,
    _createMarkers: createMarkers,
    _createSeries: createSeries,
    _applyTransform: applyTransform,
    _resize: resize,
    _setScale: setScale,
    setFocus,
    updateSize,
    coordsToPoint,
    getInsetForPoint,
    getMarkerPosition,
    _repositionLines: repositionLines,
    _repositionMarkers: repositionMarkers,
    _repositionLabels: repositionLabels
  };
  var Defaults = {
    map: "world",
    backgroundColor: "transparent",
    draggable: true,
    zoomButtons: true,
    zoomOnScroll: true,
    zoomOnScrollSpeed: 3,
    zoomMax: 12,
    zoomMin: 1,
    zoomAnimate: true,
    showTooltip: true,
    zoomStep: 1.5,
    bindTouchEvents: true,
    // Line options
    lineStyle: {
      curvature: 0,
      stroke: "#808080",
      strokeWidth: 1,
      strokeLinecap: "round"
    },
    // Marker options
    markersSelectable: false,
    markersSelectableOne: false,
    markerStyle: {
      initial: {
        r: 7,
        fill: "#374151",
        fillOpacity: 1,
        stroke: "#FFF",
        strokeWidth: 5,
        strokeOpacity: 0.5
      },
      hover: {
        fill: "#3cc0ff",
        cursor: "pointer"
      },
      selected: {
        fill: "blue"
      },
      selectedHover: {}
    },
    markerLabelStyle: {
      initial: {
        fontFamily: "Verdana",
        fontSize: 12,
        fontWeight: 500,
        cursor: "default",
        fill: "#374151"
      },
      hover: {
        cursor: "pointer"
      },
      selected: {},
      selectedHover: {}
    },
    // Region options
    regionsSelectable: false,
    regionsSelectableOne: false,
    regionStyle: {
      initial: {
        fill: "#dee2e8",
        fillOpacity: 1,
        stroke: "none",
        strokeWidth: 0
      },
      hover: {
        fillOpacity: 0.7,
        cursor: "pointer"
      },
      selected: {
        fill: "#9ca3af"
      },
      selectedHover: {}
    },
    regionLabelStyle: {
      initial: {
        fontFamily: "Verdana",
        fontSize: "12",
        fontWeight: "bold",
        cursor: "default",
        fill: "#35373e"
      },
      hover: {
        cursor: "pointer"
      }
    }
  };
  var SVGElement = /* @__PURE__ */ (function() {
    function SVGElement2(name, config2) {
      this.node = this._createElement(name);
      if (config2) {
        this.set(config2);
      }
    }
    var _proto = SVGElement2.prototype;
    _proto._createElement = function _createElement(tagName) {
      return document.createElementNS("http://www.w3.org/2000/svg", tagName);
    };
    _proto.addClass = function addClass(className) {
      this.node.setAttribute("class", className);
    };
    _proto.getBBox = function getBBox() {
      return this.node.getBBox();
    };
    _proto.set = function set3(property, value) {
      if (typeof property === "object") {
        for (var attr in property) {
          this.applyAttr(attr, property[attr]);
        }
      } else {
        this.applyAttr(property, value);
      }
    };
    _proto.get = function get3(property) {
      return this.style.initial[property];
    };
    _proto.applyAttr = function applyAttr(property, value) {
      this.node.setAttribute(hyphenate2(property), value);
    };
    _proto.remove = function remove2() {
      removeElement(this.node);
    };
    return SVGElement2;
  })();
  var SVGShapeElement = /* @__PURE__ */ (function(_SVGElement) {
    function SVGShapeElement2(name, config2, style) {
      var _this;
      if (style === void 0) {
        style = {};
      }
      _this = _SVGElement.call(this, name, config2) || this;
      _this.isHovered = false;
      _this.isSelected = false;
      _this.style = style;
      _this.style.current = {};
      _this.updateStyle();
      return _this;
    }
    _inheritsLoose(SVGShapeElement2, _SVGElement);
    var _proto = SVGShapeElement2.prototype;
    _proto.setStyle = function setStyle2(property, value) {
      if (typeof property === "object") {
        merge(this.style.current, property);
      } else {
        var _merge;
        merge(this.style.current, (_merge = {}, _merge[property] = value, _merge));
      }
      this.updateStyle();
    };
    _proto.updateStyle = function updateStyle() {
      var attrs = {};
      merge(attrs, this.style.initial);
      merge(attrs, this.style.current);
      if (this.isHovered) {
        merge(attrs, this.style.hover);
      }
      if (this.isSelected) {
        merge(attrs, this.style.selected);
        if (this.isHovered) {
          merge(attrs, this.style.selectedHover);
        }
      }
      this.set(attrs);
    };
    return SVGShapeElement2;
  })(SVGElement);
  var SVGTextElement = /* @__PURE__ */ (function(_SVGShapeElement) {
    function SVGTextElement2(config2, style) {
      return _SVGShapeElement.call(this, "text", config2, style) || this;
    }
    _inheritsLoose(SVGTextElement2, _SVGShapeElement);
    var _proto = SVGTextElement2.prototype;
    _proto.applyAttr = function applyAttr(attr, value) {
      attr === "text" ? this.node.textContent = value : _SVGShapeElement.prototype.applyAttr.call(this, attr, value);
    };
    return SVGTextElement2;
  })(SVGShapeElement);
  var SVGImageElement = /* @__PURE__ */ (function(_SVGShapeElement) {
    function SVGImageElement2(config2, style) {
      return _SVGShapeElement.call(this, "image", config2, style) || this;
    }
    _inheritsLoose(SVGImageElement2, _SVGShapeElement);
    var _proto = SVGImageElement2.prototype;
    _proto.applyAttr = function applyAttr(attr, value) {
      var imageUrl;
      if (attr === "image") {
        if (typeof value === "object") {
          imageUrl = value.url;
          this.offset = value.offset || [0, 0];
        } else {
          imageUrl = value;
          this.offset = [0, 0];
        }
        this.node.setAttributeNS("http://www.w3.org/1999/xlink", "href", imageUrl);
        this.width = 23;
        this.height = 23;
        this.applyAttr("width", this.width);
        this.applyAttr("height", this.height);
        this.applyAttr("x", this.cx - this.width / 2 + this.offset[0]);
        this.applyAttr("y", this.cy - this.height / 2 + this.offset[1]);
      } else if (attr == "cx") {
        this.cx = value;
        if (this.width) {
          this.applyAttr("x", value - this.width / 2 + this.offset[0]);
        }
      } else if (attr == "cy") {
        this.cy = value;
        if (this.height) {
          this.applyAttr("y", value - this.height / 2 + this.offset[1]);
        }
      } else {
        _SVGShapeElement.prototype.applyAttr.apply(this, arguments);
      }
    };
    return SVGImageElement2;
  })(SVGShapeElement);
  var SVGCanvasElement = /* @__PURE__ */ (function(_SVGElement) {
    function SVGCanvasElement2(container) {
      var _this;
      _this = _SVGElement.call(this, "svg") || this;
      _this._container = container;
      _this._defsElement = new SVGElement("defs");
      _this._rootElement = new SVGElement("g", {
        id: "jvm-regions-group"
      });
      _this.node.appendChild(_this._defsElement.node);
      _this.node.appendChild(_this._rootElement.node);
      _this._container.appendChild(_this.node);
      return _this;
    }
    _inheritsLoose(SVGCanvasElement2, _SVGElement);
    var _proto = SVGCanvasElement2.prototype;
    _proto.setSize = function setSize(width, height) {
      this.node.setAttribute("width", width);
      this.node.setAttribute("height", height);
    };
    _proto.applyTransformParams = function applyTransformParams(scale, transX, transY) {
      this._rootElement.node.setAttribute("transform", "scale(" + scale + ") translate(" + transX + ", " + transY + ")");
    };
    _proto.createPath = function createPath(config2, style, group) {
      var path = new SVGShapeElement("path", config2, style);
      path.node.setAttribute("fill-rule", "evenodd");
      return this._add(path, group);
    };
    _proto.createCircle = function createCircle(config2, style, group) {
      var circle = new SVGShapeElement("circle", config2, style);
      return this._add(circle, group);
    };
    _proto.createLine = function createLine(config2, style, group) {
      var line = new SVGShapeElement("line", config2, style);
      return this._add(line, group);
    };
    _proto.createText = function createText(config2, style, group) {
      var text = new SVGTextElement(config2, style);
      return this._add(text, group);
    };
    _proto.createImage = function createImage(config2, style, group) {
      var image = new SVGImageElement(config2, style);
      return this._add(image, group);
    };
    _proto.createGroup = function createGroup(id) {
      var group = new SVGElement("g");
      this.node.appendChild(group.node);
      if (id) {
        group.node.id = id;
      }
      group.canvas = this;
      return group;
    };
    _proto._add = function _add(element, group) {
      group = group || this._rootElement;
      group.node.appendChild(element.node);
      return element;
    };
    return SVGCanvasElement2;
  })(SVGElement);
  var Tooltip = /* @__PURE__ */ (function(_BaseComponent) {
    function Tooltip2(map) {
      var _this;
      _this = _BaseComponent.call(this) || this;
      var tooltip = createElement2("div", "jvm-tooltip");
      _this._map = map;
      _this._tooltip = document.body.appendChild(tooltip);
      _this._bindEventListeners();
      return _this || _assertThisInitialized(_this);
    }
    _inheritsLoose(Tooltip2, _BaseComponent);
    var _proto = Tooltip2.prototype;
    _proto._bindEventListeners = function _bindEventListeners() {
      var _this2 = this;
      EventHandler.on(this._map.container, "mousemove", function(event) {
        if (!_this2._tooltip.classList.contains("active")) {
          return;
        }
        var container = findElement(_this2._map.container, "#jvm-regions-group").getBoundingClientRect();
        var space = 5;
        var _this2$_tooltip$getBo = _this2._tooltip.getBoundingClientRect(), height = _this2$_tooltip$getBo.height, width = _this2$_tooltip$getBo.width;
        var topIsPassed = event.clientY <= container.top + height + space;
        var top = event.pageY - height - space;
        var left = event.pageX - width - space;
        if (topIsPassed) {
          top += height + space;
          left -= space * 2;
        }
        if (event.clientX < container.left + width + space) {
          left = event.pageX + space + 2;
          if (topIsPassed) {
            left += space * 2;
          }
        }
        _this2.css({
          top: top + "px",
          left: left + "px"
        });
      });
    };
    _proto.getElement = function getElement3() {
      return this._tooltip;
    };
    _proto.show = function show() {
      this._tooltip.classList.add("active");
    };
    _proto.hide = function hide() {
      this._tooltip.classList.remove("active");
    };
    _proto.text = function text(string, html) {
      if (html === void 0) {
        html = false;
      }
      var property = html ? "innerHTML" : "textContent";
      if (!string) {
        return this._tooltip[property];
      }
      this._tooltip[property] = string;
    };
    _proto.css = function css(_css) {
      for (var style in _css) {
        this._tooltip.style[style] = _css[style];
      }
      return this;
    };
    return Tooltip2;
  })(BaseComponent);
  var DataVisualization = /* @__PURE__ */ (function() {
    function DataVisualization2(_ref, map) {
      var scale = _ref.scale, values = _ref.values;
      this._scale = scale;
      this._values = values;
      this._fromColor = this.hexToRgb(scale[0]);
      this._toColor = this.hexToRgb(scale[1]);
      this._map = map;
      this.setMinMaxValues(values);
      this.visualize();
    }
    var _proto = DataVisualization2.prototype;
    _proto.setMinMaxValues = function setMinMaxValues(values) {
      this.min = Number.MAX_VALUE;
      this.max = 0;
      for (var value in values) {
        value = parseFloat(values[value]);
        if (value > this.max) {
          this.max = value;
        }
        if (value < this.min) {
          this.min = value;
        }
      }
    };
    _proto.visualize = function visualize() {
      var attrs = {}, value;
      for (var regionCode in this._values) {
        value = parseFloat(this._values[regionCode]);
        if (!isNaN(value)) {
          attrs[regionCode] = this.getValue(value);
        }
      }
      this.setAttributes(attrs);
    };
    _proto.setAttributes = function setAttributes(attrs) {
      for (var code in attrs) {
        if (this._map.regions[code]) {
          this._map.regions[code].element.setStyle("fill", attrs[code]);
        }
      }
    };
    _proto.getValue = function getValue(value) {
      if (this.min === this.max) {
        return "#" + this._toColor.join("");
      }
      var hex, color = "#";
      for (var i3 = 0; i3 < 3; i3++) {
        hex = Math.round(this._fromColor[i3] + (this._toColor[i3] - this._fromColor[i3]) * ((value - this.min) / (this.max - this.min))).toString(16);
        color += (hex.length === 1 ? "0" : "") + hex;
      }
      return color;
    };
    _proto.hexToRgb = function hexToRgb(h3) {
      var r3 = 0, g4 = 0, b3 = 0;
      if (h3.length == 4) {
        r3 = "0x" + h3[1] + h3[1];
        g4 = "0x" + h3[2] + h3[2];
        b3 = "0x" + h3[3] + h3[3];
      } else if (h3.length == 7) {
        r3 = "0x" + h3[1] + h3[2];
        g4 = "0x" + h3[3] + h3[4];
        b3 = "0x" + h3[5] + h3[6];
      }
      return [parseInt(r3), parseInt(g4), parseInt(b3)];
    };
    return DataVisualization2;
  })();
  var JVM_PREFIX = "jvm-";
  var CONTAINER_CLASS = JVM_PREFIX + "container";
  var MARKERS_GROUP_ID = JVM_PREFIX + "markers-group";
  var MARKERS_LABELS_GROUP_ID = JVM_PREFIX + "markers-labels-group";
  var LINES_GROUP_ID = JVM_PREFIX + "lines-group";
  var SERIES_CONTAINER_CLASS = JVM_PREFIX + "series-container";
  var SERIES_CONTAINER_H_CLASS = SERIES_CONTAINER_CLASS + " " + JVM_PREFIX + "series-h";
  var SERIES_CONTAINER_V_CLASS = SERIES_CONTAINER_CLASS + " " + JVM_PREFIX + "series-v";
  var Map2 = /* @__PURE__ */ (function() {
    function Map3(options) {
      var _this = this;
      if (options === void 0) {
        options = {};
      }
      this.params = merge(Map3.defaults, options, true);
      if (!Map3.maps[this.params.map]) {
        throw new Error("Attempt to use map which was not loaded: " + options.map);
      }
      this.regions = {};
      this.scale = 1;
      this.transX = 0;
      this.transY = 0;
      this._mapData = Map3.maps[this.params.map];
      this._markers = {};
      this._lines = {};
      this._defaultWidth = this._mapData.width;
      this._defaultHeight = this._mapData.height;
      this._height = 0;
      this._width = 0;
      this._baseScale = 1;
      this._baseTransX = 0;
      this._baseTransY = 0;
      if (document.readyState !== "loading") {
        this._init();
      } else {
        window.addEventListener("DOMContentLoaded", function() {
          return _this._init();
        });
      }
    }
    var _proto = Map3.prototype;
    _proto._init = function _init() {
      var options = this.params;
      this.container = getElement(options.selector);
      this.container.classList.add(CONTAINER_CLASS);
      this.canvas = new SVGCanvasElement(this.container);
      this.setBackgroundColor(options.backgroundColor);
      this._createRegions();
      this.updateSize();
      if (options.lines) {
        this._linesGroup = this.canvas.createGroup(LINES_GROUP_ID);
      }
      if (options.markers) {
        this._markersGroup = this.canvas.createGroup(MARKERS_GROUP_ID);
        this._markerLabelsGroup = this.canvas.createGroup(MARKERS_LABELS_GROUP_ID);
      }
      this._createMarkers(options.markers);
      this._createLines(options.lines || {});
      this._repositionLabels();
      this._setupContainerEvents();
      this._setupElementEvents();
      if (options.zoomButtons) {
        this._setupZoomButtons();
      }
      if (options.showTooltip) {
        this._tooltip = new Tooltip(this);
      }
      if (options.selectedRegions) {
        this._setSelected("regions", options.selectedRegions);
      }
      if (options.selectedMarkers) {
        this._setSelected("_markers", options.selectedMarkers);
      }
      if (options.focusOn) {
        this.setFocus(options.focusOn);
      }
      if (options.visualizeData) {
        this.dataVisualization = new DataVisualization(options.visualizeData, this);
      }
      if (options.bindTouchEvents) {
        if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) {
          this._setupContainerTouchEvents();
        }
      }
      if (options.series) {
        this.container.appendChild(this.legendHorizontal = createElement2("div", SERIES_CONTAINER_H_CLASS));
        this.container.appendChild(this.legendVertical = createElement2("div", SERIES_CONTAINER_V_CLASS));
        this._createSeries();
      }
      this._emit(Events.onLoaded, [this]);
    };
    _proto.setBackgroundColor = function setBackgroundColor(color) {
      this.container.style.backgroundColor = color;
    };
    _proto.getSelectedRegions = function getSelectedRegions() {
      return this._getSelected("regions");
    };
    _proto.clearSelectedRegions = function clearSelectedRegions(regions) {
      var _this2 = this;
      if (regions === void 0) {
        regions = void 0;
      }
      regions = this._normalizeRegions(regions) || this._getSelected("regions");
      regions.forEach(function(key) {
        _this2.regions[key].element.select(false);
      });
    };
    _proto.setSelectedRegions = function setSelectedRegions(regions) {
      this.clearSelectedRegions();
      this._setSelected("regions", this._normalizeRegions(regions));
    };
    _proto.getSelectedMarkers = function getSelectedMarkers() {
      return this._getSelected("_markers");
    };
    _proto.clearSelectedMarkers = function clearSelectedMarkers() {
      this._clearSelected("_markers");
    };
    _proto.setSelectedMarkers = function setSelectedMarkers(markers) {
      this._setSelected("_markers", markers);
    };
    _proto.addMarkers = function addMarkers(config2) {
      config2 = Array.isArray(config2) ? config2 : [config2];
      this._createMarkers(config2, true);
    };
    _proto.removeMarkers = function removeMarkers(markers) {
      var _this3 = this;
      if (!markers) {
        markers = Object.keys(this._markers);
      }
      markers.forEach(function(index6) {
        _this3._markers[index6].element.remove();
        delete _this3._markers[index6];
      });
    };
    _proto.addLine = function addLine(from, to, style) {
      if (style === void 0) {
        style = {};
      }
      console.warn("`addLine` method is deprecated, please use `addLines` instead.");
      this._createLines([{
        from,
        to,
        style
      }], this._markers, true);
    };
    _proto.addLines = function addLines(config2) {
      var uids = this._getLinesAsUids();
      if (!Array.isArray(config2)) {
        config2 = [config2];
      }
      this._createLines(config2.filter(function(line) {
        return !(uids.indexOf(getLineUid(line.from, line.to)) > -1);
      }), true);
    };
    _proto.removeLines = function removeLines(lines) {
      var _this4 = this;
      if (Array.isArray(lines)) {
        lines = lines.map(function(line) {
          return getLineUid(line.from, line.to);
        });
      } else {
        lines = this._getLinesAsUids();
      }
      lines.forEach(function(uid2) {
        _this4._lines[uid2].dispose();
        delete _this4._lines[uid2];
      });
    };
    _proto.removeLine = function removeLine(from, to) {
      console.warn("`removeLine` method is deprecated, please use `removeLines` instead.");
      var uid2 = getLineUid(from, to);
      if (this._lines.hasOwnProperty(uid2)) {
        this._lines[uid2].element.remove();
        delete this._lines[uid2];
      }
    };
    _proto.reset = function reset() {
      for (var key in this.series) {
        for (var i3 = 0; i3 < this.series[key].length; i3++) {
          this.series[key][i3].clear();
        }
      }
      if (this.legendHorizontal) {
        removeElement(this.legendHorizontal);
        this.legendHorizontal = null;
      }
      if (this.legendVertical) {
        removeElement(this.legendVertical);
        this.legendVertical = null;
      }
      this.scale = this._baseScale;
      this.transX = this._baseTransX;
      this.transY = this._baseTransY;
      this._applyTransform();
      this.clearSelectedMarkers();
      this.clearSelectedRegions();
      this.removeMarkers();
    };
    _proto.destroy = function destroy(destroyInstance) {
      var _this5 = this;
      if (destroyInstance === void 0) {
        destroyInstance = true;
      }
      EventHandler.flush();
      this._tooltip.dispose();
      this._emit(Events.onDestroyed);
      if (destroyInstance) {
        Object.keys(this).forEach(function(key) {
          try {
            delete _this5[key];
          } catch (e3) {
          }
        });
      }
    };
    _proto.extend = function extend2(name, callback) {
      if (typeof this[name] === "function") {
        throw new Error("The method [" + name + "] does already exist, please use another name.");
      }
      Map3.prototype[name] = callback;
    };
    _proto._emit = function _emit(eventName, args) {
      for (var event in Events) {
        if (Events[event] === eventName && typeof this.params[event] === "function") {
          this.params[event].apply(this, args);
        }
      }
    };
    _proto._getSelected = function _getSelected(type) {
      var selected = [];
      for (var key in this[type]) {
        if (this[type][key].element.isSelected) {
          selected.push(key);
        }
      }
      return selected;
    };
    _proto._setSelected = function _setSelected(type, keys) {
      var _this6 = this;
      keys.forEach(function(key) {
        if (_this6[type][key]) {
          _this6[type][key].element.select(true);
        }
      });
    };
    _proto._clearSelected = function _clearSelected(type) {
      var _this7 = this;
      this._getSelected(type).forEach(function(key) {
        _this7[type][key].element.select(false);
      });
    };
    _proto._getLinesAsUids = function _getLinesAsUids() {
      return Object.keys(this._lines);
    };
    _proto._normalizeRegions = function _normalizeRegions(regions) {
      return typeof regions === "string" ? [regions] : regions;
    };
    return Map3;
  })();
  Map2.maps = {};
  Map2.defaults = Defaults;
  Object.assign(Map2.prototype, core);
  var jsVectorMap2 = /* @__PURE__ */ (function() {
    function jsVectorMap3(options) {
      if (options === void 0) {
        options = {};
      }
      if (!options.selector) {
        throw new Error("Selector is not given.");
      }
      return new Map2(options);
    }
    jsVectorMap3.addMap = function addMap(name, map) {
      Map2.maps[name] = map;
    };
    return jsVectorMap3;
  })();
  var index = window.jsVectorMap = jsVectorMap2;

  // node_modules/jsvectormap/dist/maps/world.js
  jsVectorMap.addMap("world", { insets: [{ width: 900, top: 0, left: 0, height: 440.70631074413296, bbox: [{ y: -12671671123330014e-9, x: -20004297151525836e-9 }, { y: 6930392025135122e-9, x: 2002657239474939e-8 }] }], paths: { BD: { path: "M651.84,230.21l-0.6,-2.0l-1.36,-1.71l-2.31,-0.11l-0.41,0.48l0.2,0.94l-0.53,0.99l-0.72,-0.36l-0.68,0.35l-1.2,-0.36l-0.37,-2.0l-0.81,-1.86l0.39,-1.46l-0.22,-0.47l-1.14,-0.53l0.29,-0.5l1.48,-0.94l0.03,-0.65l-1.55,-1.22l0.55,-1.14l1.61,0.94l1.04,0.15l0.18,1.54l0.34,0.35l5.64,0.63l-0.84,1.64l-1.22,0.34l-0.77,1.51l0.07,0.47l1.37,1.37l0.67,-0.19l0.42,-1.39l1.21,3.84l-0.03,1.21l-0.33,-0.15l-0.4,0.28Z", name: "Bangladesh" }, BE: { path: "M429.29,144.05l1.91,0.24l2.1,-0.63l2.63,1.99l-0.21,1.66l-0.69,0.4l-0.18,1.2l-1.66,-1.13l-1.39,0.15l-2.73,-2.7l-1.17,-0.18l-0.16,-0.52l1.54,-0.5Z", name: "Belgium" }, BF: { path: "M421.42,247.64l-0.11,0.95l0.34,1.16l1.4,1.71l0.07,1.1l0.32,0.37l2.55,0.51l-0.04,1.28l-0.38,0.53l-1.07,0.21l-0.72,1.18l-0.63,0.21l-3.22,-0.25l-0.94,0.39l-5.4,-0.05l-0.39,0.38l0.16,2.73l-1.23,-0.43l-1.17,0.1l-0.89,0.57l-2.27,-1.72l-0.13,-1.11l0.61,-0.96l0.02,-0.93l1.87,-1.98l0.44,-1.81l0.43,-0.39l1.28,0.26l1.05,-0.52l0.47,-0.73l1.84,-1.09l0.55,-0.83l2.2,-1.0l1.15,-0.3l0.72,0.45l1.13,-0.01Z", name: "Burkina Faso" }, BG: { path: "M491.65,168.18l-0.86,0.88l-0.91,2.17l0.48,1.34l-1.6,-0.24l-2.55,0.95l-0.28,1.51l-1.8,0.22l-2.0,-1.0l-1.92,0.79l-1.42,-0.07l-0.15,-1.63l-1.05,-0.97l0.0,-0.8l1.2,-1.57l0.01,-0.56l-1.14,-1.23l-0.05,-0.94l0.88,0.97l0.88,-0.2l1.91,0.47l3.68,0.16l1.42,-0.81l2.72,-0.66l2.55,1.24Z", name: "Bulgaria" }, BA: { path: "M463.49,163.65l2.1,0.5l1.72,-0.03l1.52,0.68l-0.36,0.78l0.08,0.45l1.04,1.02l-0.25,0.98l-1.81,1.15l-0.38,1.38l-1.67,-0.87l-0.89,-1.2l-2.11,-1.83l-1.63,-2.22l0.23,-0.57l0.48,0.38l0.55,-0.06l0.43,-0.51l0.94,-0.06Z", name: "Bosnia and Herz." }, BN: { path: "M707.48,273.58l0.68,-0.65l1.41,-0.91l-0.15,1.63l-0.81,-0.05l-0.61,0.58l-0.53,-0.6Z", name: "Brunei" }, BO: { path: "M263.83,340.69l-3.09,-0.23l-0.38,0.23l-0.7,1.52l-1.31,-1.53l-3.28,-0.64l-2.37,2.4l-1.31,0.26l-0.88,-3.26l-1.3,-2.86l0.74,-2.37l-0.13,-0.43l-1.2,-1.01l-0.37,-1.89l-1.08,-1.55l1.45,-2.56l-0.96,-2.33l0.47,-1.06l-0.34,-0.73l0.91,-1.32l0.16,-3.84l0.5,-1.18l-1.81,-3.41l2.46,0.07l0.8,-0.85l3.4,-1.91l2.66,-0.35l-0.19,1.38l0.3,1.07l-0.05,1.97l2.72,2.27l2.88,0.49l0.89,0.86l1.79,0.58l0.98,0.7l1.71,0.05l1.17,0.61l0.6,2.7l-0.7,0.54l0.96,2.99l0.37,0.28l4.3,0.1l-0.25,1.2l0.27,1.02l1.43,0.9l0.5,1.35l-0.41,1.86l-0.65,1.08l0.12,1.35l-2.69,-1.65l-2.4,-0.03l-4.36,0.76l-1.49,2.5l-0.11,1.52l-0.75,2.37Z", name: "Bolivia" }, JP: { path: "M781.12,166.87l1.81,0.68l1.62,-0.97l0.39,2.42l-3.35,0.75l-2.23,2.88l-3.63,-1.9l-0.56,0.2l-1.26,3.05l-2.16,0.03l-0.29,-2.51l1.08,-2.03l2.45,-0.16l0.37,-0.33l1.25,-5.94l2.47,2.71l2.03,1.12ZM773.56,187.34l-0.91,2.22l0.37,1.52l-1.14,1.75l-3.02,1.26l-4.58,0.27l-3.34,3.01l-1.25,-0.8l-0.09,-1.9l-0.46,-0.38l-4.35,0.62l-3.0,1.32l-2.85,0.05l-0.37,0.27l0.13,0.44l2.32,1.89l-1.54,4.34l-1.26,0.9l-0.79,-0.7l0.56,-2.27l-0.21,-0.45l-1.47,-0.75l-0.74,-1.4l2.12,-0.84l1.26,-1.7l2.45,-1.42l1.83,-1.91l4.78,-0.81l2.6,0.57l0.44,-0.21l2.39,-4.66l1.29,1.06l0.5,0.01l5.1,-4.02l1.69,-3.73l-0.38,-3.4l0.9,-1.61l2.14,-0.44l1.23,3.72l-0.07,2.18l-2.23,2.84l-0.04,3.16ZM757.78,196.26l0.19,0.56l-1.01,1.21l-1.16,-0.68l-1.28,0.65l-0.69,1.45l-1.02,-0.5l0.01,-0.93l1.14,-1.38l1.57,0.14l0.85,-0.98l1.4,0.46Z", name: "Japan" }, BI: { path: "M495.45,295.49l-1.08,-2.99l1.14,-0.11l0.64,-1.19l0.76,0.09l0.65,1.83l-2.1,2.36Z", name: "Burundi" }, BJ: { path: "M429.57,255.75l-0.05,0.8l0.5,1.34l-0.42,0.86l0.17,0.79l-1.81,2.12l-0.57,1.76l-0.08,5.42l-1.41,0.2l-0.48,-1.36l0.11,-5.71l-0.52,-0.7l-0.2,-1.35l-1.48,-1.48l0.21,-0.9l0.89,-0.43l0.42,-0.92l1.27,-0.36l1.22,-1.34l0.61,-0.0l1.62,1.24Z", name: "Benin" }, BT: { path: "M650.32,213.86l0.84,0.71l-0.12,1.1l-3.76,-0.11l-1.57,0.4l-1.93,-0.87l1.48,-1.96l1.13,-0.57l1.63,0.57l1.33,0.08l0.99,0.65Z", name: "Bhutan" }, JM: { path: "M228.38,239.28l-0.8,0.4l-2.26,-1.06l0.84,-0.23l2.14,0.3l1.17,0.56l-1.08,0.03Z", name: "Jamaica" }, BW: { path: "M483.92,330.07l2.27,4.01l2.83,2.86l0.96,0.31l0.78,2.43l2.13,0.61l1.02,0.76l-3.0,1.64l-2.32,2.02l-1.54,2.69l-1.52,0.45l-0.64,1.94l-1.34,0.52l-1.85,-0.12l-1.21,-0.74l-1.35,-0.3l-1.22,0.62l-0.75,1.37l-2.31,1.9l-1.4,0.21l-0.35,-0.59l0.16,-1.75l-1.48,-2.54l-0.62,-0.43l-0.0,-7.1l2.08,-0.08l0.39,-0.4l0.07,-8.9l5.19,-0.93l0.8,0.89l0.51,0.07l1.5,-0.95l2.21,-0.49Z", name: "Botswana" }, BR: { path: "M259.98,275.05l3.24,0.7l0.65,-0.53l4.55,-1.32l1.08,-1.06l-0.02,-0.63l0.55,-0.05l0.28,0.28l-0.26,0.87l0.22,0.48l0.73,0.32l0.4,0.81l-0.62,0.86l-0.4,2.13l0.82,2.56l1.69,1.43l1.43,0.2l3.17,-1.68l3.18,0.3l0.65,-0.75l-0.27,-0.92l1.9,-0.09l2.39,0.99l1.06,-0.61l0.84,0.78l1.2,-0.18l1.18,-1.06l0.84,-1.94l1.36,-2.11l0.37,-0.05l1.89,5.45l1.33,0.59l0.05,1.28l-1.77,1.94l0.02,0.56l1.02,0.87l4.07,0.36l0.08,2.16l0.66,0.29l1.74,-1.5l6.97,2.32l1.02,1.22l-0.35,1.18l0.49,0.5l2.81,-0.74l4.77,1.3l3.75,-0.08l3.57,2.0l3.29,2.86l1.93,0.72l2.12,0.12l0.71,0.62l1.21,4.51l-0.95,3.98l-4.72,5.06l-1.64,2.92l-1.72,2.05l-0.8,0.3l-0.72,2.03l0.18,4.75l-0.94,5.53l-0.81,1.13l-0.43,3.36l-2.55,3.5l-0.4,2.51l-1.86,1.04l-0.67,1.53l-2.54,0.01l-3.94,1.01l-1.83,1.2l-2.87,0.82l-3.03,2.19l-2.2,2.83l-0.36,2.0l0.4,1.58l-0.44,2.6l-0.51,1.2l-1.77,1.54l-2.75,4.78l-3.83,3.42l-1.24,2.74l-1.18,1.15l-0.36,-0.83l0.95,-1.14l0.01,-0.5l-1.52,-1.97l-4.56,-3.32l-1.03,-0.0l-2.38,-2.02l-0.81,-0.0l5.34,-5.45l3.77,-2.58l0.22,-2.46l-1.35,-1.81l-0.91,0.07l0.58,-2.33l0.01,-1.54l-1.11,-0.83l-1.75,0.3l-0.44,-3.11l-0.52,-0.95l-1.88,-0.88l-1.24,0.47l-2.17,-0.41l0.15,-3.21l-0.62,-1.34l0.66,-0.73l-0.22,-1.34l0.66,-1.13l0.44,-2.04l-0.61,-1.83l-1.4,-0.86l-0.2,-0.75l0.34,-1.39l-0.38,-0.5l-4.52,-0.1l-0.72,-2.22l0.59,-0.42l-0.03,-1.1l-0.5,-0.87l-0.32,-1.7l-1.45,-0.76l-1.63,-0.02l-1.05,-0.72l-1.6,-0.48l-1.13,-0.99l-2.69,-0.4l-2.47,-2.06l0.13,-4.35l-0.45,-0.45l-3.46,0.5l-3.44,1.94l-0.6,0.74l-2.9,-0.17l-1.47,0.42l-0.72,-0.18l0.15,-3.52l-0.63,-0.34l-1.94,1.41l-1.87,-0.06l-0.83,-1.18l-1.37,-0.26l0.21,-1.01l-1.35,-1.49l-0.88,-1.91l0.56,-0.6l-0.0,-0.81l1.29,-0.62l0.22,-0.43l-0.22,-1.19l0.61,-0.91l0.15,-0.99l2.65,-1.58l1.99,-0.47l0.42,-0.36l2.06,0.11l0.42,-0.33l1.19,-8.0l-0.41,-1.56l-1.1,-1.0l0.01,-1.33l1.91,-0.42l0.08,-0.96l-0.33,-0.43l-1.14,-0.2l-0.02,-0.83l4.47,0.05l0.82,-0.67l0.82,1.81l0.8,0.07l1.15,1.1l2.26,-0.05l0.71,-0.83l2.78,-0.96l0.48,-1.13l1.6,-0.64l0.24,-0.47l-0.48,-0.82l-1.83,-0.19l-0.36,-3.22Z", name: "Brazil" }, BS: { path: "M226.4,223.87l-0.48,-1.15l-0.84,-0.75l0.36,-1.11l0.95,1.95l0.01,1.06ZM225.56,216.43l-1.87,0.29l-0.04,-0.22l0.74,-0.14l1.17,0.06Z", name: "Bahamas" }, BY: { path: "M493.84,128.32l0.29,0.7l0.49,0.23l1.19,-0.38l2.09,0.72l0.19,1.26l-0.45,1.24l1.57,2.26l0.89,0.59l0.17,0.81l1.58,0.56l0.4,0.5l-0.53,0.41l-1.87,-0.11l-0.73,0.38l-0.13,0.52l1.04,2.74l-1.91,0.26l-0.89,0.99l-0.11,1.18l-2.73,-0.04l-0.53,-0.62l-0.52,-0.08l-0.75,0.46l-0.91,-0.42l-1.92,-0.07l-2.75,-0.79l-2.6,-0.28l-2.0,0.07l-1.5,0.92l-0.67,0.07l-0.08,-1.22l-0.59,-1.19l1.36,-0.88l0.01,-1.35l-0.7,-1.41l-0.07,-1.0l2.16,-0.02l2.72,-1.3l0.75,-2.04l1.91,-1.04l0.2,-0.41l-0.19,-1.25l3.8,-1.78l2.3,0.77Z", name: "Belarus" }, BZ: { path: "M198.03,244.38l0.1,-4.49l0.69,-0.06l0.74,-1.3l0.34,0.28l-0.4,1.3l0.17,0.58l-0.34,2.25l-1.3,1.42Z", name: "Belize" }, RU: { path: "M491.55,115.25l2.55,-1.85l-0.01,-0.65l-2.2,-1.5l7.32,-6.76l1.03,-2.11l-0.13,-0.49l-3.46,-2.52l0.86,-2.7l-2.11,-2.81l1.56,-3.67l-2.77,-4.52l2.15,-2.99l-0.08,-0.55l-3.65,-2.73l0.3,-2.54l1.81,-0.37l4.26,-1.77l2.42,-1.45l4.06,2.61l6.79,1.04l9.34,4.85l1.78,1.88l0.14,2.46l-2.55,2.02l-3.9,1.06l-11.07,-3.14l-2.06,0.53l-0.13,0.7l3.94,2.94l0.31,5.86l0.26,0.36l5.14,2.24l0.58,-0.29l0.32,-1.94l-1.35,-1.78l1.13,-1.09l6.13,2.42l2.11,-0.98l0.18,-0.56l-1.51,-2.67l5.41,-3.76l2.07,0.22l2.26,1.41l0.57,-0.16l1.46,-2.87l-0.05,-0.44l-1.92,-2.32l1.12,-2.32l-1.32,-2.27l5.87,1.16l1.04,1.75l-2.59,0.43l-0.33,0.4l0.02,2.36l2.46,1.83l3.87,-0.91l0.86,-2.8l13.69,-5.65l0.99,0.11l-1.92,2.06l0.23,0.67l3.11,0.45l2.0,-1.48l4.56,-0.12l3.64,-1.73l2.65,2.44l0.56,-0.01l2.85,-2.88l-0.01,-0.57l-2.35,-2.29l0.9,-1.01l7.14,1.3l3.41,1.36l9.05,4.97l0.51,-0.11l1.67,-2.27l-0.05,-0.53l-2.43,-2.21l-0.06,-0.78l-0.34,-0.36l-2.52,-0.36l0.64,-1.93l-1.32,-3.46l-0.06,-1.21l4.48,-4.06l1.69,-4.29l1.6,-0.81l6.23,1.18l0.44,2.21l-2.29,3.64l0.06,0.5l1.47,1.39l0.76,3.0l-0.56,6.03l2.69,2.82l-0.96,2.57l-4.86,5.95l0.23,0.64l2.86,0.61l0.42,-0.17l0.93,-1.4l2.64,-1.03l0.87,-2.24l2.09,-1.96l0.07,-0.5l-1.36,-2.28l1.09,-2.69l-0.32,-0.55l-2.47,-0.33l-0.5,-2.06l1.94,-4.38l-0.06,-0.42l-2.96,-3.4l4.12,-2.88l0.16,-0.4l-0.51,-2.93l0.54,-0.05l1.13,2.25l-0.96,4.35l0.27,0.47l2.68,0.84l0.5,-0.51l-1.02,-2.99l3.79,-1.66l5.01,-0.24l4.53,2.61l0.48,-0.06l0.07,-0.48l-2.18,-3.82l-0.23,-4.67l3.98,-0.9l5.97,0.21l5.49,-0.64l0.27,-0.65l-1.83,-2.31l2.56,-2.9l2.87,-0.17l4.8,-2.47l6.54,-0.67l1.03,-1.42l6.25,-0.45l2.32,1.11l5.53,-2.7l4.5,0.08l0.39,-0.28l0.66,-2.15l2.26,-2.12l5.69,-2.11l3.21,1.29l-2.46,0.94l-0.25,0.42l0.34,0.35l5.41,0.77l0.61,2.33l0.58,0.25l2.2,-1.22l7.13,0.07l5.51,2.47l1.79,1.72l-0.53,2.24l-9.16,4.15l-1.97,1.52l0.16,0.71l6.77,1.91l2.16,-0.78l1.13,2.74l0.67,0.11l1.01,-1.15l3.81,-0.73l7.7,0.77l0.54,1.99l0.36,0.29l10.47,0.71l0.43,-0.38l0.13,-3.23l4.87,0.78l3.95,-0.02l3.83,2.4l1.03,2.71l-1.35,1.79l0.02,0.5l3.15,3.64l4.07,1.96l0.53,-0.18l2.23,-4.47l3.95,1.93l4.16,-1.21l4.73,1.39l2.05,-1.26l3.94,0.62l0.43,-0.55l-1.68,-4.02l2.89,-1.8l22.31,3.03l2.16,2.75l6.55,3.51l10.29,-0.81l4.82,0.73l1.85,1.66l-0.29,3.08l0.25,0.41l3.08,1.26l3.56,-0.88l4.35,-0.11l4.8,0.87l4.57,-0.47l4.23,3.79l0.43,0.07l3.1,-1.4l0.16,-0.6l-1.88,-2.62l0.85,-1.52l7.71,1.21l5.22,-0.26l7.09,2.09l9.59,5.22l6.35,4.11l-0.2,2.38l1.88,1.41l0.6,-0.42l-0.48,-2.53l6.15,0.57l4.4,3.51l-1.97,1.43l-4.0,0.41l-0.36,0.39l-0.06,3.79l-0.74,0.62l-2.07,-0.11l-1.91,-1.39l-3.14,-1.11l-0.78,-1.85l-2.72,-0.68l-2.63,0.49l-1.04,-1.1l0.46,-1.31l-0.5,-0.51l-3.0,0.98l-0.22,0.58l0.99,1.7l-1.21,1.48l-3.04,1.68l-3.12,-0.28l-0.4,0.23l0.09,0.46l2.2,2.09l1.46,3.2l1.15,1.1l0.24,1.33l-0.42,0.67l-4.63,-0.77l-6.96,2.9l-2.19,0.44l-7.6,5.06l-0.84,1.45l-3.61,-2.37l-6.24,2.82l-0.94,-1.15l-0.53,-0.08l-2.28,1.52l-3.2,-0.49l-0.44,0.27l-0.78,2.37l-3.05,3.78l0.09,1.47l0.29,0.36l2.54,0.72l-0.29,4.53l-1.97,0.11l-0.35,0.26l-1.07,2.94l0.8,1.45l-3.91,1.58l-1.05,3.95l-3.48,0.77l-0.3,0.3l-0.72,3.29l-3.09,2.65l-0.7,-1.74l-2.44,-12.44l1.16,-4.71l2.04,-2.06l0.22,-1.64l3.8,-0.86l4.46,-4.61l4.28,-3.81l4.48,-3.01l2.17,-5.63l-0.42,-0.54l-3.04,0.33l-1.77,3.31l-5.86,3.86l-1.86,-4.25l-0.45,-0.23l-6.46,1.3l-6.47,6.44l-0.01,0.55l1.58,1.74l-8.24,1.17l0.15,-2.2l-0.34,-0.42l-3.89,-0.56l-3.25,1.81l-7.62,-0.62l-8.45,1.19l-17.71,15.41l0.22,0.7l3.74,0.41l1.36,2.17l2.43,0.76l1.88,-1.68l2.4,0.2l3.4,3.54l0.08,2.6l-1.95,3.42l-0.21,3.9l-1.1,5.06l-3.71,4.54l-0.87,2.21l-8.29,8.89l-3.19,1.7l-1.32,0.03l-1.45,-1.36l-0.49,-0.04l-2.27,1.5l0.41,-3.65l-0.59,-2.47l1.75,-0.89l2.91,0.53l0.42,-0.2l1.68,-3.03l0.87,-3.46l0.97,-1.18l1.32,-2.88l-0.45,-0.56l-4.14,0.95l-2.19,1.25l-3.41,-0.0l-1.06,-2.93l-2.97,-2.3l-4.28,-1.06l-1.75,-5.07l-2.66,-5.01l-2.29,-1.29l-3.75,-1.01l-3.44,0.08l-3.18,0.62l-2.24,1.77l0.05,0.66l1.18,0.69l0.02,1.43l-1.33,1.05l-2.26,3.51l-0.04,1.43l-3.16,1.84l-2.82,-1.16l-3.01,0.23l-1.35,-1.07l-1.5,-0.35l-3.9,2.31l-3.22,0.52l-2.27,0.79l-3.05,-0.51l-2.21,0.03l-1.48,-1.6l-2.6,-1.63l-2.63,-0.43l-5.46,1.01l-3.23,-1.25l-0.72,-2.57l-5.2,-1.24l-2.75,-1.36l-0.5,0.12l-2.59,3.45l0.84,2.1l-2.06,1.93l-3.41,-0.77l-2.42,-0.12l-1.83,-1.54l-2.53,-0.05l-2.42,-0.98l-3.86,1.57l-4.72,2.78l-3.3,0.75l-1.55,-1.92l-3.0,0.41l-1.11,-1.33l-1.62,-0.59l-1.31,-1.94l-1.38,-0.6l-3.7,0.79l-3.31,-1.83l-0.51,0.11l-0.99,1.29l-5.29,-8.05l-2.96,-2.48l0.65,-0.77l0.01,-0.51l-0.5,-0.11l-6.2,3.21l-1.84,0.15l0.15,-1.39l-0.26,-0.42l-3.22,-1.17l-2.46,0.7l-0.69,-3.16l-0.32,-0.31l-4.5,-0.75l-2.47,1.47l-6.19,1.27l-1.29,0.86l-9.51,1.3l-1.15,1.17l-0.03,0.53l1.47,1.9l-1.89,0.69l-0.22,0.56l0.31,0.6l-2.11,1.44l0.03,0.68l3.75,2.12l-0.39,0.98l-3.23,-0.13l-0.86,0.86l-3.09,-1.59l-3.97,0.07l-2.66,1.35l-8.32,-3.56l-4.07,0.06l-5.39,3.68l-0.39,2.0l-2.03,-1.5l-0.59,0.13l-2.0,3.59l0.57,0.93l-1.28,2.16l0.06,0.48l2.13,2.17l1.95,0.04l1.37,1.82l-0.23,1.46l0.25,0.43l0.83,0.33l-0.8,1.31l-2.49,0.62l-2.49,3.2l0.0,0.49l2.17,2.78l-0.15,2.18l2.5,3.24l-1.58,1.59l-0.7,-0.13l-1.63,-1.72l-2.29,-0.84l-0.94,-1.31l-2.34,-0.63l-1.48,0.4l-0.43,-0.47l-3.51,-1.48l-5.76,-1.01l-0.45,0.19l-2.89,-2.34l-2.9,-1.2l-1.53,-1.29l1.29,-0.43l2.08,-2.61l-0.05,-0.55l-0.89,-0.79l3.05,-1.06l0.27,-0.42l-0.07,-0.69l-0.49,-0.35l-1.73,0.39l0.04,-0.68l1.04,-0.72l2.66,-0.48l0.4,-1.32l-0.5,-1.6l0.92,-1.54l0.03,-1.17l-0.29,-0.37l-3.69,-1.06l-1.41,0.02l-1.42,-1.41l-2.19,0.38l-2.77,-1.01l-0.03,-0.59l-0.89,-1.43l-2.0,-0.32l-0.11,-0.54l0.49,-0.53l0.01,-0.53l-1.6,-1.9l-3.58,0.02l-0.88,0.73l-0.46,-0.07l-1.0,-2.79l2.22,-0.02l0.97,-0.74l0.07,-0.57l-0.9,-1.04l-1.35,-0.48l-0.11,-0.7l-0.95,-0.58l-1.38,-1.99l0.46,-0.98l-0.51,-1.96l-2.45,-0.84l-1.21,0.3l-0.46,-0.76l-2.46,-0.83l-0.72,-1.87l-0.21,-1.69l-0.99,-0.85l0.85,-1.17l-0.7,-3.21l1.66,-1.97l-0.16,-0.79ZM749.2,170.72l-0.6,0.4l-0.13,0.16l-0.01,-0.51l0.74,-0.05ZM874.85,67.94l-5.63,0.48l-0.26,-0.84l3.15,-1.89l1.94,0.01l3.19,1.16l-2.39,1.09ZM797.39,48.49l-2.0,1.36l-3.8,-0.42l-4.25,-1.8l0.35,-0.97l9.69,1.83ZM783.67,46.12l-1.63,3.09l-8.98,-0.13l-4.09,1.14l-4.54,-2.97l1.16,-3.01l3.05,-0.89l6.5,0.22l8.54,2.56ZM778.2,134.98l-0.56,-0.9l0.27,-0.12l0.29,1.01ZM778.34,135.48l0.94,3.53l-0.05,3.38l1.05,3.39l2.18,5.0l-2.89,-0.83l-0.49,0.26l-1.54,4.65l2.42,3.5l-0.04,1.13l-1.24,-1.24l-0.61,0.06l-1.09,1.61l-0.28,-1.61l0.27,-3.1l-0.28,-3.4l0.58,-2.47l0.11,-4.39l-1.46,-3.36l0.21,-4.32l2.15,-1.46l0.07,-0.34ZM771.95,56.61l1.76,-1.42l2.89,-0.42l3.28,1.71l0.14,0.6l-3.27,0.03l-4.81,-0.5ZM683.76,31.09l-13.01,1.93l4.03,-6.35l1.82,-0.56l1.73,0.34l5.99,2.98l-0.56,1.66ZM670.85,27.93l-5.08,0.64l-6.86,-1.57l-3.99,-2.05l-2.1,-4.16l-2.6,-0.87l5.72,-3.5l5.2,-1.28l4.69,2.85l5.59,5.4l-0.56,4.53ZM564.15,68.94l-0.64,0.17l-7.85,-0.57l-0.86,-2.04l-4.28,-1.17l-0.28,-1.94l2.27,-0.89l0.25,-0.39l-0.08,-2.38l4.81,-3.97l-0.15,-0.7l-1.47,-0.38l5.3,-3.81l0.15,-0.44l-0.58,-1.94l5.28,-2.51l8.21,-3.27l8.28,-0.96l4.35,-1.94l4.6,-0.64l1.36,1.61l-1.34,1.28l-16.43,4.94l-7.97,4.88l-7.74,9.63l0.66,4.14l4.16,3.27ZM548.81,18.48l-5.5,1.18l-0.58,1.02l-2.59,0.84l-2.13,-1.07l1.12,-1.42l-0.3,-0.65l-2.33,-0.07l1.68,-0.36l3.47,-0.06l0.42,1.29l0.66,0.16l1.38,-1.34l2.15,-0.88l2.94,1.01l-0.39,0.36ZM477.37,133.15l-4.08,0.05l-2.56,-0.32l0.33,-0.87l3.17,-1.03l3.24,0.96l-0.09,1.23Z", name: "Russia" }, RW: { path: "M497.0,288.25l0.71,1.01l-0.11,1.09l-1.63,0.03l-1.04,1.39l-0.83,-0.11l0.51,-1.2l0.08,-1.34l0.42,-0.41l0.7,0.14l1.19,-0.61Z", name: "Rwanda" }, RS: { path: "M469.4,163.99l0.42,-0.5l-0.01,-0.52l-1.15,-1.63l1.43,-0.62l1.33,0.12l1.17,1.06l0.46,1.13l1.34,0.64l0.35,1.35l1.46,0.9l0.76,-0.29l0.2,0.69l-0.48,0.78l0.22,1.12l1.05,1.22l-0.77,0.8l-0.37,1.52l-1.21,0.08l0.24,-0.64l-0.39,-0.54l-2.08,-1.64l-0.9,0.05l-0.48,0.94l-2.12,-1.37l0.53,-1.6l-1.11,-1.37l0.51,-1.1l-0.41,-0.57Z", name: "Serbia" }, LT: { path: "M486.93,129.3l0.17,1.12l-1.81,0.98l-0.72,2.02l-2.47,1.18l-2.1,-0.02l-0.73,-1.05l-1.06,-0.3l-0.09,-1.87l-3.56,-1.13l-0.43,-2.36l2.48,-0.94l4.12,0.22l2.25,-0.31l0.52,0.69l1.24,0.21l2.19,1.56Z", name: "Lithuania" }, LU: { path: "M436.08,149.45l-0.48,-0.07l0.3,-1.28l0.27,0.4l-0.09,0.96Z", name: "Luxembourg" }, LR: { path: "M399.36,265.97l0.18,1.54l-0.48,0.99l0.08,0.47l2.47,1.8l-0.33,2.8l-2.65,-1.13l-5.78,-4.61l0.58,-1.32l2.1,-2.33l0.86,-0.22l0.77,1.14l-0.14,0.85l0.59,0.87l1.0,0.14l0.76,-0.99Z", name: "Liberia" }, RO: { path: "M487.53,154.23l0.6,0.24l2.87,3.98l-0.17,2.69l0.45,1.42l1.32,0.81l1.35,-0.42l0.76,0.36l0.02,0.31l-0.83,0.45l-0.59,-0.22l-0.54,0.3l-0.62,3.3l-1.0,-0.22l-2.07,-1.13l-2.95,0.71l-1.25,0.76l-3.51,-0.15l-1.89,-0.47l-0.87,0.16l-0.82,-1.3l0.29,-0.26l-0.06,-0.64l-1.09,-0.34l-0.56,0.5l-1.05,-0.64l-0.39,-1.39l-1.36,-0.65l-0.35,-1.0l-0.83,-0.75l1.54,-0.54l2.66,-4.21l2.4,-1.24l2.96,0.34l1.48,0.73l0.79,-0.45l1.78,-0.3l0.75,-0.74l0.79,0.0Z", name: "Romania" }, GW: { path: "M386.23,253.6l-0.29,0.84l0.15,0.6l-2.21,0.59l-0.86,0.96l-1.04,-0.83l-1.09,-0.23l-0.54,-1.06l-0.66,-0.49l2.41,-0.48l4.13,0.1Z", name: "Guinea-Bissau" }, GT: { path: "M195.08,249.77l-2.48,-0.37l-1.03,-0.45l-1.14,-0.89l0.3,-0.99l-0.24,-0.68l0.96,-1.66l2.98,-0.01l0.4,-0.37l-0.19,-1.28l-1.67,-1.4l0.51,-0.4l0.0,-1.05l3.85,0.02l-0.21,4.53l0.4,0.43l1.46,0.38l-1.48,0.98l-0.35,0.7l0.12,0.57l-2.2,1.96Z", name: "Guatemala" }, GR: { path: "M487.07,174.59l-0.59,1.43l-0.37,0.21l-2.84,-0.35l-3.03,0.77l-0.18,0.68l1.28,1.23l-0.61,0.23l-1.14,0.0l-1.2,-1.39l-0.63,0.03l-0.53,1.01l0.56,1.76l1.03,1.19l-0.56,0.38l-0.05,0.62l2.52,2.12l0.02,0.87l-1.78,-0.59l-0.48,0.56l0.5,1.0l-1.07,0.2l-0.3,0.53l0.75,2.01l-0.98,0.02l-1.84,-1.12l-1.37,-4.2l-2.21,-2.95l-0.11,-0.56l1.04,-1.28l0.2,-0.95l0.85,-0.66l0.03,-0.46l1.32,-0.21l1.01,-0.64l1.22,0.05l0.65,-0.56l2.26,-0.0l1.82,-0.75l1.85,1.0l2.28,-0.28l0.35,-0.39l0.01,-0.77l0.34,0.22ZM480.49,192.16l0.58,0.4l-0.68,-0.12l0.11,-0.28ZM482.52,192.82l2.51,0.06l0.24,0.32l-1.99,0.13l-0.77,-0.51Z", name: "Greece" }, GQ: { path: "M448.79,279.62l0.02,2.22l-4.09,0.0l0.69,-2.27l3.38,0.05Z", name: "Eq. Guinea" }, GY: { path: "M277.42,270.07l-0.32,1.83l-1.32,0.57l-0.23,0.46l-0.28,2.0l1.11,1.82l0.83,0.19l0.32,1.25l1.13,1.62l-1.21,-0.19l-1.08,0.71l-1.77,0.5l-0.44,0.46l-0.86,-0.09l-1.32,-1.01l-0.77,-2.27l0.36,-1.9l0.68,-1.23l-0.57,-1.17l-0.74,-0.43l0.12,-1.16l-0.9,-0.69l-1.1,0.09l-1.31,-1.48l0.53,-0.72l-0.04,-0.84l1.99,-0.86l0.05,-0.59l-0.71,-0.78l0.14,-0.57l1.66,-1.24l1.36,0.77l1.41,1.49l0.06,1.15l0.37,0.38l0.8,0.05l2.06,1.86Z", name: "Guyana" }, GE: { path: "M521.71,168.93l5.29,0.89l4.07,2.01l1.41,-0.44l2.07,0.56l0.68,1.1l1.07,0.55l-0.12,0.59l0.98,1.29l-1.01,-0.13l-1.81,-0.83l-0.94,0.47l-3.23,0.43l-2.29,-1.39l-2.33,0.05l0.21,-0.97l-0.76,-2.26l-1.45,-1.12l-1.43,-0.39l-0.41,-0.42Z", name: "Georgia" }, GB: { path: "M412.61,118.72l-2.19,3.22l-0.0,0.45l5.13,-0.3l-0.53,2.37l-2.2,3.12l0.29,0.63l2.37,0.21l2.33,4.3l1.76,0.69l2.2,5.12l2.94,0.77l-0.23,1.62l-1.15,0.88l-0.1,0.52l0.82,1.42l-1.86,1.43l-3.3,-0.02l-4.12,0.87l-1.04,-0.58l-0.47,0.06l-1.51,1.41l-2.12,-0.34l-1.86,1.18l-0.6,-0.29l3.19,-3.0l2.16,-0.69l0.28,-0.41l-0.34,-0.36l-3.73,-0.53l-0.4,-0.76l2.2,-0.87l0.17,-0.61l-1.26,-1.67l0.36,-1.7l3.38,0.28l0.43,-0.33l0.37,-1.99l-1.79,-2.49l-3.11,-0.72l-0.38,-0.59l0.79,-1.35l-0.04,-0.46l-0.82,-0.97l-0.61,0.01l-0.68,0.84l-0.1,-2.34l-1.23,-1.88l0.85,-3.47l1.77,-2.68l1.85,0.26l2.17,-0.22ZM406.26,132.86l-1.01,1.77l-1.57,-0.59l-1.16,0.01l0.37,-1.54l-0.39,-1.39l1.45,-0.1l2.3,1.84Z", name: "United Kingdom" }, GA: { path: "M453.24,279.52l-0.08,0.98l0.7,1.29l2.36,0.24l-0.98,2.63l1.18,1.79l0.25,1.78l-0.29,1.52l-0.6,0.93l-1.84,-0.09l-1.23,-1.11l-0.66,0.23l-0.15,0.84l-1.42,0.26l-1.02,0.7l-0.11,0.52l0.77,1.35l-1.34,0.97l-3.94,-4.3l-1.44,-2.45l0.06,-0.6l0.54,-0.81l1.05,-3.46l4.17,-0.07l0.4,-0.4l-0.02,-2.66l2.39,0.21l1.25,-0.27Z", name: "Gabon" }, GN: { path: "M391.8,254.11l0.47,0.8l1.11,-0.32l0.98,0.7l1.07,0.2l2.26,-1.22l0.64,0.44l1.13,1.56l-0.48,1.4l0.8,0.3l-0.08,0.48l0.46,0.68l-0.35,1.36l1.05,2.61l-1.0,0.69l0.03,1.41l-0.72,-0.06l-1.08,1.0l-0.24,-0.27l0.07,-1.11l-1.05,-1.54l-1.79,0.21l-0.35,-2.01l-1.6,-2.18l-2.0,-0.0l-1.31,0.54l-1.95,2.18l-1.86,-2.19l-1.2,-0.78l-0.3,-1.11l-0.8,-0.85l0.65,-0.72l0.81,-0.03l1.64,-0.8l0.23,-1.87l2.67,0.64l0.89,-0.3l1.21,0.15Z", name: "Guinea" }, GM: { path: "M379.31,251.39l0.1,-0.35l2.43,-0.07l0.74,-0.61l0.51,-0.03l0.77,0.49l-1.03,-0.3l-1.87,0.9l-1.65,-0.04ZM384.03,250.91l0.91,0.05l0.75,-0.24l-0.59,0.31l-1.08,-0.13Z", name: "Gambia" }, GL: { path: "M353.02,1.2l14.69,4.67l-3.68,1.89l-22.97,0.86l-0.36,0.27l0.12,0.43l1.55,1.18l8.79,-0.66l7.48,2.07l4.86,-1.77l1.66,1.73l-2.53,3.19l-0.01,0.48l0.46,0.15l6.35,-2.2l12.06,-2.31l7.24,1.13l1.09,1.99l-9.79,4.01l-1.44,1.32l-7.87,0.98l-0.35,0.41l0.38,0.38l5.07,0.24l-2.53,3.58l-2.07,3.81l0.08,6.05l2.57,3.11l-3.22,0.2l-4.12,1.66l-0.05,0.72l4.45,2.65l0.51,3.75l-2.3,0.4l-0.25,0.64l2.79,3.69l-4.82,0.31l-0.36,0.29l0.16,0.44l2.62,1.8l-0.59,1.22l-3.3,0.7l-3.45,0.01l-0.29,0.68l3.03,3.12l0.02,1.34l-4.4,-1.73l-1.72,1.35l0.15,0.66l3.31,1.15l3.13,2.71l0.81,3.16l-3.85,0.75l-4.89,-4.26l-0.47,-0.03l-0.17,0.44l0.79,2.86l-2.71,2.21l-0.13,0.44l0.37,0.27l8.73,0.34l-12.32,6.64l-7.24,1.48l-2.94,0.08l-2.69,1.75l-3.43,4.41l-5.24,2.84l-1.73,0.18l-7.12,2.1l-2.15,2.52l-0.13,2.99l-1.19,2.45l-4.01,3.09l-0.14,0.44l0.97,2.9l-2.28,6.48l-3.1,0.2l-3.83,-3.07l-4.86,-0.02l-2.25,-1.93l-1.7,-3.79l-4.3,-4.84l-1.21,-2.49l-0.44,-3.8l-3.32,-3.63l0.84,-2.86l-1.56,-1.7l2.28,-4.6l3.83,-1.74l1.03,-1.96l0.52,-3.47l-0.59,-0.41l-4.17,2.21l-2.07,0.58l-2.72,-1.28l-0.15,-2.71l0.85,-2.09l2.01,-0.06l5.06,1.2l0.46,-0.23l-0.14,-0.49l-6.54,-4.47l-2.67,0.55l-1.58,-0.86l2.56,-4.01l-0.03,-0.48l-1.5,-1.74l-4.98,-8.5l-3.13,-1.96l0.03,-1.88l-0.24,-0.37l-6.85,-3.02l-5.36,-0.38l-12.7,0.58l-2.78,-1.57l-3.66,-2.77l5.73,-1.45l5.0,-0.28l0.38,-0.38l-0.35,-0.41l-10.67,-1.38l-5.3,-2.06l0.25,-1.54l18.41,-5.26l1.22,-2.27l-0.25,-0.55l-6.14,-1.86l1.68,-1.77l8.55,-4.03l3.59,-0.63l0.3,-0.54l-0.88,-2.27l5.47,-1.47l7.65,-0.95l7.55,-0.05l3.04,1.85l6.48,-3.27l5.81,2.22l3.56,0.5l5.16,1.94l0.5,-0.21l-0.17,-0.52l-5.71,-3.13l0.28,-2.13l8.12,-3.6l8.7,0.28l3.35,-2.34l8.71,-0.6l19.93,0.8Z", name: "Greenland" }, KW: { path: "M540.81,207.91l0.37,0.86l-0.17,0.76l0.6,1.53l-0.95,0.04l-0.82,-1.28l-1.57,-0.18l1.31,-1.88l1.22,0.17Z", name: "Kuwait" }, GH: { path: "M420.53,257.51l-0.01,0.72l0.96,1.2l0.24,3.73l0.59,0.95l-0.51,2.1l0.19,1.41l1.02,2.21l-6.97,2.84l-1.8,-0.57l0.04,-0.89l-1.02,-2.04l0.61,-2.65l1.07,-2.32l-0.96,-6.47l5.01,0.07l0.94,-0.39l0.61,0.11Z", name: "Ghana" }, OM: { path: "M568.09,230.93l-0.91,1.67l-1.22,0.04l-0.6,0.76l-0.41,1.51l0.27,1.58l-1.16,0.05l-1.56,0.97l-0.76,1.74l-1.62,0.05l-0.98,0.65l-0.17,1.15l-0.89,0.52l-1.49,-0.18l-2.4,0.94l-2.47,-5.4l7.35,-2.71l1.67,-5.23l-1.12,-2.09l0.05,-0.83l0.67,-1.0l0.07,-1.05l0.9,-0.42l-0.05,-2.07l0.7,-0.01l1.0,1.62l1.51,1.08l3.3,0.84l1.73,2.29l0.81,0.37l-1.23,2.35l-0.99,0.79Z", name: "Oman" }, _2: { path: "M531.15,258.94l1.51,0.12l5.13,-0.95l5.3,-1.48l-0.01,4.4l-2.67,3.39l-1.85,0.01l-8.04,-2.94l-2.55,-3.17l1.12,-1.71l2.04,2.34Z", name: "Somaliland" }, _1: { path: "M472.77,172.64l-1.08,-1.29l0.96,-0.77l0.29,-0.83l1.98,1.64l-0.36,0.67l-1.79,0.58Z", name: "Kosovo" }, _0: { path: "M504.91,192.87l0.34,0.01l0.27,-0.07l-0.29,0.26l-0.31,-0.2Z", name: "N. Cyprus" }, JO: { path: "M518.64,201.38l-5.14,1.56l-0.19,0.65l2.16,2.39l-0.89,1.14l-1.71,0.34l-1.71,1.8l-2.34,-0.37l1.21,-4.32l0.56,-4.07l2.8,0.94l4.46,-2.71l0.79,2.66Z", name: "Jordan" }, HR: { path: "M455.59,162.84l1.09,0.07l-0.82,0.94l-0.27,-1.01ZM456.96,162.92l0.62,-0.41l1.73,0.45l0.42,-0.4l-0.01,-0.59l0.86,-0.52l0.2,-1.05l1.63,-0.68l2.57,1.68l2.07,0.6l0.87,-0.31l1.05,1.57l-0.52,0.63l-1.05,-0.56l-1.68,0.04l-2.1,-0.5l-1.29,0.06l-0.57,0.49l-0.59,-0.47l-0.62,0.16l-0.46,1.7l1.79,2.42l2.79,2.75l-1.18,-0.87l-2.21,-0.87l-1.67,-1.78l0.13,-0.63l-1.05,-1.19l-0.32,-1.27l-1.42,-0.43Z", name: "Croatia" }, HT: { path: "M237.05,238.38l-1.16,0.43l-0.91,-0.55l0.05,-0.2l2.02,0.31ZM237.53,238.43l1.06,0.12l-0.05,0.01l-1.01,-0.12ZM239.25,238.45l0.79,-0.51l0.06,-0.62l-1.02,-1.0l0.02,-0.82l-0.3,-0.4l-0.93,-0.32l3.16,0.45l0.02,1.84l-0.48,0.34l-0.08,0.58l0.54,0.72l-1.78,-0.26Z", name: "Haiti" }, HU: { path: "M462.08,157.89l0.65,-1.59l-0.09,-0.44l0.64,-0.0l0.39,-0.34l0.1,-0.69l1.75,0.87l2.32,-0.37l0.43,-0.66l3.49,-0.78l0.69,-0.78l0.57,-0.14l2.57,0.93l0.67,-0.23l1.03,0.65l0.08,0.37l-1.42,0.71l-2.59,4.14l-1.8,0.53l-1.68,-0.1l-2.74,1.23l-1.85,-0.54l-2.54,-1.66l-0.66,-1.1Z", name: "Hungary" }, HN: { path: "M199.6,249.52l-1.7,-1.21l0.06,-0.94l3.04,-2.14l2.37,0.28l1.27,-0.09l1.1,-0.52l1.3,0.28l1.14,-0.25l1.38,0.37l2.23,1.37l-2.36,0.93l-1.23,-0.39l-0.88,1.3l-1.28,0.99l-0.98,-0.22l-0.42,0.52l-0.96,0.05l-0.36,0.41l0.04,0.88l-0.52,0.6l-0.3,0.04l-0.3,-0.55l-0.66,-0.31l0.11,-0.67l-0.48,-0.65l-0.87,-0.26l-0.73,0.2Z", name: "Honduras" }, PR: { path: "M256.17,238.73l-0.26,0.27l-2.83,0.05l-0.07,-0.55l1.95,-0.1l1.22,0.33Z", name: "Puerto Rico" }, PS: { path: "M509.21,203.07l0.1,-0.06l-0.02,0.03l-0.09,0.03ZM509.36,202.91l-0.02,-0.63l-0.33,-0.16l0.31,-1.09l0.24,0.1l-0.2,1.78Z", name: "Palestine" }, PT: { path: "M401.84,187.38l-0.64,0.47l-1.13,-0.35l-0.91,0.17l0.28,-1.78l-0.24,-1.78l-1.25,-0.56l-0.45,-0.84l0.17,-1.66l1.01,-1.18l0.69,-2.92l-0.04,-1.39l-0.59,-1.9l1.3,-0.85l0.84,1.35l3.1,-0.3l0.46,0.99l-1.05,0.94l-0.03,2.16l-0.41,0.57l-0.08,1.1l-0.79,0.18l-0.26,0.59l0.91,1.6l-0.63,1.75l0.76,1.09l-1.1,1.52l0.07,1.05Z", name: "Portugal" }, PY: { path: "M274.9,336.12l0.74,1.52l-0.16,3.45l0.32,0.41l2.64,0.5l1.11,-0.47l1.4,0.59l0.36,0.6l0.53,3.42l1.27,0.4l0.98,-0.38l0.51,0.27l-0.0,1.18l-1.21,5.32l-2.09,1.9l-1.8,0.4l-4.71,-0.98l2.2,-3.63l-0.32,-1.5l-2.78,-1.28l-3.03,-1.94l-2.07,-0.44l-4.34,-4.06l0.91,-2.9l0.08,-1.42l1.07,-2.04l4.13,-0.72l2.18,0.03l2.05,1.17l0.03,0.59Z", name: "Paraguay" }, PA: { path: "M213.8,263.68l0.26,-1.52l-0.36,-0.26l-0.01,-0.49l0.44,-0.1l0.93,1.4l1.26,0.03l0.77,0.49l1.38,-0.23l2.51,-1.11l0.86,-0.72l3.45,0.85l1.4,1.18l0.41,1.74l-0.21,0.34l-0.53,-0.12l-0.47,0.29l-0.16,0.6l-0.68,-1.28l0.45,-0.49l-0.19,-0.66l-0.47,-0.13l-0.54,-0.84l-1.5,-0.75l-1.1,0.16l-0.75,0.99l-1.62,0.84l-0.18,0.96l0.85,0.97l-0.58,0.45l-0.69,0.08l-0.34,-1.18l-1.27,0.03l-0.71,-1.05l-2.59,-0.46Z", name: "Panama" }, PG: { path: "M808.58,298.86l2.54,2.56l-0.13,0.26l-0.33,0.12l-0.87,-0.78l-1.22,-2.16ZM801.41,293.04l0.5,0.29l0.26,0.27l-0.49,-0.35l-0.27,-0.21ZM803.17,294.58l0.59,0.5l0.08,1.06l-0.29,-0.91l-0.38,-0.65ZM796.68,298.41l0.52,0.75l1.43,-0.19l2.27,-1.81l-0.01,-1.43l1.12,0.16l-0.04,1.1l-0.7,1.28l-1.12,0.18l-0.62,0.79l-2.46,1.11l-1.17,-0.0l-3.08,-1.25l3.41,0.0l0.45,-0.68ZM789.15,303.55l2.31,1.8l1.59,2.61l1.34,0.13l-0.06,0.66l0.31,0.43l1.06,0.24l0.06,0.65l2.25,1.05l-1.22,0.13l-0.72,-0.63l-4.56,-0.65l-3.22,-2.87l-1.49,-2.34l-3.27,-1.1l-2.38,0.72l-1.59,0.86l-0.2,0.42l0.27,1.55l-1.55,0.68l-1.36,-0.4l-2.21,-0.09l-0.08,-15.41l8.39,2.93l2.95,2.4l0.6,1.64l4.02,1.49l0.31,0.68l-1.76,0.21l-0.33,0.52l0.55,1.68Z", name: "Papua New Guinea" }, PE: { path: "M244.96,295.21l-1.26,-0.07l-0.57,0.42l-1.93,0.45l-2.98,1.75l-0.36,1.36l-0.58,0.8l0.12,1.37l-1.24,0.59l-0.22,1.22l-0.62,0.84l1.04,2.27l1.28,1.44l-0.41,0.84l0.32,0.57l1.48,0.13l1.16,1.37l2.21,0.07l1.63,-1.08l-0.13,3.02l0.3,0.4l1.14,0.29l1.31,-0.34l1.9,3.59l-0.48,0.85l-0.17,3.85l-0.94,1.59l0.35,0.75l-0.47,1.07l0.98,1.97l-2.1,3.82l-0.98,0.5l-2.17,-1.28l-0.39,-1.16l-4.95,-2.58l-4.46,-2.79l-1.84,-1.51l-0.91,-1.84l0.3,-0.96l-2.11,-3.33l-4.82,-9.68l-1.04,-1.2l-0.87,-1.94l-3.4,-2.48l0.58,-1.18l-1.13,-2.23l0.66,-1.49l1.45,-1.15l-0.6,0.98l0.07,0.92l0.47,0.36l1.74,0.03l0.97,1.17l0.54,0.07l1.42,-1.03l0.6,-1.84l1.42,-2.02l3.04,-1.04l2.73,-2.62l0.86,-1.74l-0.1,-1.87l1.44,1.02l0.9,1.25l1.06,0.59l1.7,2.73l1.86,0.31l1.45,-0.61l0.96,0.39l1.36,-0.19l1.45,0.89l-1.4,2.21l0.31,0.61l0.59,0.05l0.47,0.5Z", name: "Peru" }, PK: { path: "M615.09,192.34l-1.83,1.81l-2.6,0.39l-3.73,-0.68l-1.58,1.33l-0.09,0.42l1.77,4.39l1.7,1.23l-1.69,1.27l-0.12,2.14l-2.33,2.64l-1.6,2.8l-2.46,2.67l-3.03,-0.07l-2.76,2.83l0.05,0.6l1.5,1.11l0.26,1.9l1.44,1.5l0.37,1.68l-5.01,-0.01l-1.78,1.7l-1.42,-0.52l-0.76,-1.87l-2.27,-2.15l-11.61,0.86l0.71,-2.34l3.43,-1.32l0.25,-0.44l-0.21,-1.24l-1.2,-0.65l-0.28,-2.46l-2.29,-1.14l-1.28,-1.94l2.82,0.94l2.62,-0.38l1.42,0.33l0.76,-0.56l1.71,0.19l3.25,-1.14l0.27,-0.36l0.08,-2.19l1.18,-1.32l1.68,0.0l0.58,-0.82l1.6,-0.3l1.19,0.16l0.98,-0.78l0.02,-1.88l0.93,-1.47l1.48,-0.66l0.19,-0.55l-0.66,-1.25l2.04,-0.11l0.69,-1.01l-0.02,-1.16l1.11,-1.06l-0.17,-1.78l-0.49,-1.03l1.15,-0.98l5.42,-0.91l2.6,-0.82l1.6,1.16l0.97,2.34l3.45,0.97Z", name: "Pakistan" }, PH: { path: "M737.01,263.84l0.39,2.97l-0.44,1.18l-0.55,-1.53l-0.67,-0.14l-1.17,1.28l0.65,2.09l-0.42,0.69l-2.48,-1.23l-0.57,-1.49l0.65,-1.03l-0.1,-0.54l-1.59,-1.19l-0.56,0.08l-0.65,0.87l-1.23,0.0l-1.58,0.97l0.83,-1.8l2.56,-1.42l0.65,0.84l0.45,0.13l1.9,-0.69l0.56,-1.11l1.5,-0.06l0.38,-0.43l-0.09,-1.19l1.21,0.71l0.36,2.02ZM733.59,256.58l0.05,0.75l0.08,0.26l-0.8,-0.42l-0.18,-0.71l0.85,0.12ZM734.08,256.1l-0.12,-1.12l-1.0,-1.27l1.36,0.03l0.53,0.73l0.51,2.04l-1.27,-0.4ZM733.76,257.68l0.38,0.98l-0.32,0.15l-0.07,-1.13ZM724.65,238.43l1.46,0.7l0.72,-0.31l-0.32,1.17l0.79,1.71l-0.57,1.84l-1.53,1.04l-0.39,2.25l0.56,2.04l1.63,0.57l1.16,-0.27l2.71,1.23l-0.19,1.08l0.76,0.84l-0.08,0.36l-1.4,-0.9l-0.88,-1.27l-0.66,0.0l-0.38,0.55l-1.6,-1.31l-2.15,0.36l-0.87,-0.39l0.07,-0.61l0.66,-0.55l-0.01,-0.62l-0.75,-0.59l-0.72,0.44l-0.74,-0.87l-0.39,-2.49l0.32,0.27l0.66,-0.28l0.26,-3.97l0.7,-2.02l1.14,0.0ZM731.03,258.87l-0.88,0.85l-1.19,1.94l-1.05,-1.19l0.93,-1.1l0.32,-1.47l0.52,-0.06l-0.27,1.15l0.22,0.45l0.49,-0.12l1.0,-1.32l-0.08,0.85ZM726.83,255.78l0.83,0.38l1.17,-0.0l-0.02,0.48l-2.0,1.4l0.03,-2.26ZM724.81,252.09l-0.38,1.27l-1.42,-1.95l1.2,0.05l0.6,0.63ZM716.55,261.82l1.1,-0.95l0.03,-0.03l-0.28,0.36l-0.85,0.61ZM719.22,259.06l0.04,-0.06l0.8,-1.53l0.16,0.75l-1.0,0.84Z", name: "Philippines" }, PL: { path: "M468.44,149.42l-1.11,-1.54l-1.86,-0.33l-0.48,-1.05l-1.72,-0.37l-0.65,0.69l-0.72,-0.36l0.11,-0.61l-0.33,-0.46l-1.75,-0.27l-1.04,-0.93l-0.94,-1.94l0.16,-1.22l-0.62,-1.8l-0.78,-1.07l0.57,-1.04l-0.48,-1.43l1.41,-0.83l6.91,-2.71l2.14,0.5l0.52,0.91l5.51,0.44l4.55,-0.05l1.07,0.31l0.48,0.84l0.15,1.58l0.65,1.2l-0.01,0.99l-1.27,0.58l-0.19,0.54l0.73,1.48l0.08,1.55l1.2,2.76l-0.17,0.58l-1.23,0.44l-2.27,2.72l0.18,0.95l-1.97,-1.03l-1.98,0.4l-1.36,-0.28l-1.24,0.58l-1.07,-0.97l-1.16,0.24Z", name: "Poland" }, ZM: { path: "M481.47,313.3l0.39,0.31l2.52,0.14l0.99,1.17l2.01,0.35l1.4,-0.64l0.69,1.17l1.78,0.33l1.84,2.35l2.23,0.18l0.4,-0.43l-0.21,-2.74l-0.62,-0.3l-0.48,0.32l-1.98,-1.17l0.72,-5.29l-0.51,-1.18l0.57,-1.3l3.68,-0.62l0.26,0.63l1.21,0.63l0.9,-0.22l2.16,0.67l1.33,0.71l1.07,1.02l0.56,1.87l-0.88,2.7l0.43,2.09l-0.73,0.87l-0.76,2.37l0.59,0.68l-6.6,1.83l-0.29,0.44l0.19,1.45l-1.68,0.35l-1.43,1.02l-0.38,0.87l-0.87,0.26l-3.48,3.69l-4.16,-0.53l-1.52,-1.0l-1.77,-0.13l-1.83,0.52l-3.04,-3.4l0.11,-7.59l4.82,0.03l0.39,-0.49l-0.18,-0.76l0.33,-0.83l-0.4,-1.36l0.24,-1.05Z", name: "Zambia" }, EH: { path: "M384.42,230.28l0.25,-0.79l1.06,-1.29l0.8,-3.51l3.38,-2.78l0.7,-1.81l0.06,4.84l-1.98,0.2l-0.94,1.59l0.39,3.56l-3.7,-0.01ZM392.01,218.1l0.7,-1.8l1.77,-0.24l2.09,0.34l0.95,-0.62l1.28,-0.07l-0.0,2.51l-6.79,-0.12Z", name: "W. Sahara" }, EE: { path: "M485.71,115.04l2.64,0.6l2.56,0.11l-1.6,1.91l0.61,3.54l-0.81,0.87l-1.78,-0.01l-3.22,-1.76l-1.8,0.45l0.21,-1.53l-0.58,-0.41l-0.69,0.34l-1.26,-1.03l-0.17,-1.63l2.83,-0.92l3.05,-0.52Z", name: "Estonia" }, EG: { path: "M492.06,205.03l1.46,0.42l2.95,-1.64l2.04,-0.21l1.53,0.3l0.59,1.19l0.69,0.04l0.41,-0.64l1.81,0.58l1.95,0.16l1.04,-0.51l1.42,4.08l-2.03,4.54l-1.66,-1.77l-1.76,-3.85l-0.64,-0.12l-0.36,0.67l1.04,2.88l3.44,6.95l1.78,3.04l2.03,2.65l-0.36,0.53l0.23,2.01l2.7,2.19l-28.41,0.0l0.0,-18.96l-0.73,-2.2l0.59,-1.56l-0.32,-1.26l0.68,-0.99l3.06,-0.04l4.82,1.52Z", name: "Egypt" }, ZA: { path: "M467.14,373.21l-0.13,-1.96l-0.68,-1.56l0.7,-0.68l-0.13,-2.33l-4.56,-8.19l0.77,-0.86l0.6,0.45l0.69,1.31l2.83,0.72l1.5,-0.26l2.24,-1.39l0.19,-9.55l1.35,2.3l-0.21,1.5l0.61,1.2l0.4,0.19l1.79,-0.27l2.6,-2.07l0.69,-1.32l0.96,-0.48l2.19,1.04l2.04,0.13l1.77,-0.65l0.85,-2.12l1.38,-0.33l1.59,-2.76l2.15,-1.89l3.41,-1.87l2.0,0.45l1.02,-0.28l0.99,0.2l1.75,5.29l-0.38,3.25l-0.81,-0.23l-1.0,0.46l-0.87,1.68l-0.05,1.16l1.97,1.84l1.47,-0.29l0.69,-1.18l1.09,0.01l-0.76,3.69l-0.58,1.09l-2.2,1.79l-3.17,4.76l-2.8,2.83l-3.57,2.88l-2.53,1.05l-1.22,0.14l-0.51,0.7l-1.18,-0.32l-1.39,0.5l-2.59,-0.52l-1.61,0.33l-1.18,-0.11l-2.55,1.1l-2.1,0.44l-1.6,1.07l-0.85,0.05l-0.93,-0.89l-0.93,-0.15l-0.97,-1.13l-0.25,0.05ZM491.45,364.19l0.62,-0.93l1.48,-0.59l1.18,-2.19l-0.07,-0.49l-1.99,-1.69l-1.66,0.56l-1.43,1.14l-1.34,1.73l0.02,0.51l1.88,2.11l1.31,-0.16Z", name: "South Africa" }, EC: { path: "M231.86,285.53l0.29,1.59l-0.69,1.45l-2.61,2.51l-3.13,1.11l-1.53,2.18l-0.49,1.68l-1.0,0.73l-1.02,-1.11l-1.78,-0.16l0.67,-1.15l-0.24,-0.86l1.25,-2.13l-0.54,-1.09l-0.67,-0.08l-0.72,0.87l-0.87,-0.64l0.35,-0.69l-0.36,-1.96l0.81,-0.51l0.45,-1.51l0.92,-1.57l-0.07,-0.97l2.65,-1.33l2.75,1.35l0.77,1.05l2.12,0.35l0.76,-0.32l1.96,1.21Z", name: "Ecuador" }, AL: { path: "M470.32,171.8l0.74,0.03l0.92,0.89l-0.17,1.95l0.36,1.28l1.01,0.82l-1.82,2.83l-0.19,-0.61l-1.25,-0.89l-0.18,-1.2l0.53,-2.82l-0.54,-1.47l0.6,-0.83Z", name: "Albania" }, AO: { path: "M461.55,300.03l1.26,3.15l1.94,2.36l2.47,-0.53l1.25,0.32l0.44,-0.18l0.93,-1.92l1.31,-0.08l0.41,-0.44l0.47,-0.0l-0.1,0.41l0.39,0.49l2.65,-0.02l0.03,1.19l0.48,1.01l-0.34,1.52l0.18,1.55l0.83,1.04l-0.13,2.85l0.54,0.39l3.96,-0.41l-0.1,1.79l0.39,1.05l-0.24,1.43l-4.7,-0.03l-0.4,0.39l-0.12,8.13l2.92,3.49l-3.83,0.88l-5.89,-0.36l-1.88,-1.24l-10.47,0.22l-1.3,-1.01l-1.85,-0.16l-2.4,0.77l-0.15,-1.06l0.33,-2.16l1.0,-3.45l1.35,-3.2l2.24,-2.8l0.33,-2.06l-0.13,-1.53l-0.8,-1.08l-1.21,-2.87l0.87,-1.62l-1.27,-4.12l-1.17,-1.53l2.47,-0.63l7.03,0.03ZM451.71,298.87l-0.47,-1.25l1.25,-1.11l0.32,0.3l-0.99,1.03l-0.12,1.03Z", name: "Angola" }, KZ: { path: "M552.8,172.89l0.46,-1.27l-0.48,-1.05l-2.96,-1.19l-1.06,-2.58l-1.37,-0.87l-0.03,-0.3l1.95,0.23l0.45,-0.38l0.08,-1.96l1.75,-0.41l2.1,0.45l0.48,-0.33l0.45,-3.04l-0.45,-2.09l-0.41,-0.31l-2.42,0.15l-2.36,-0.73l-2.87,1.37l-2.17,0.61l-0.85,-0.34l0.13,-1.61l-1.6,-2.12l-2.02,-0.08l-1.78,-1.82l1.29,-2.18l-0.57,-0.95l1.62,-2.91l2.21,1.63l0.63,-0.27l0.29,-2.22l4.92,-3.43l3.71,-0.08l8.4,3.6l2.92,-1.36l3.77,-0.06l3.11,1.66l0.51,-0.11l0.6,-0.81l3.31,0.13l0.39,-0.25l0.63,-1.57l-0.17,-0.5l-3.5,-1.98l1.87,-1.27l-0.13,-1.03l1.98,-0.72l0.18,-0.62l-1.59,-2.06l0.81,-0.82l9.23,-1.18l1.33,-0.88l6.18,-1.26l2.26,-1.42l4.08,0.68l0.73,3.33l0.51,0.3l2.48,-0.8l2.79,1.02l-0.17,1.56l0.43,0.44l2.55,-0.24l4.89,-2.53l0.03,0.32l3.15,2.61l5.56,8.47l0.65,0.02l1.12,-1.46l3.15,1.74l3.76,-0.78l1.15,0.49l1.14,1.8l1.84,0.76l0.99,1.29l3.35,-0.25l1.02,1.52l-1.6,1.81l-1.93,0.28l-0.34,0.38l-0.11,3.05l-1.13,1.16l-4.75,-1.0l-0.46,0.27l-1.76,5.47l-1.1,0.59l-4.91,1.23l-0.27,0.54l2.1,4.97l-1.37,0.63l-0.23,0.41l0.13,1.13l-0.88,-0.25l-1.42,-1.13l-7.89,-0.4l-0.92,0.31l-3.73,-1.22l-1.42,0.63l-0.53,1.66l-3.72,-0.94l-1.85,0.43l-0.76,1.4l-4.65,2.62l-1.13,2.08l-0.44,0.01l-0.92,-1.4l-2.87,-0.09l-0.45,-2.14l-0.38,-0.32l-0.8,-0.01l0.0,-2.96l-3.0,-2.22l-7.31,0.58l-2.35,-2.68l-6.71,-3.69l-6.45,1.83l-0.29,0.39l0.1,10.85l-0.7,0.08l-1.62,-2.17l-1.83,-0.96l-3.11,0.59l-0.64,0.51Z", name: "Kazakhstan" }, ET: { path: "M516.04,247.79l1.1,0.84l1.63,-0.45l0.68,0.47l1.63,0.03l2.01,0.94l1.73,1.66l1.64,2.07l-1.52,2.04l0.16,1.72l0.39,0.38l2.05,0.0l-0.36,1.03l2.86,3.58l8.32,3.08l1.31,0.02l-6.32,6.75l-3.1,0.11l-2.36,1.77l-1.47,0.04l-0.86,0.79l-1.38,-0.0l-1.32,-0.81l-2.29,1.05l-0.76,0.98l-3.29,-0.41l-3.07,-2.07l-1.8,-0.07l-0.62,-0.6l0.0,-1.24l-0.28,-0.38l-1.15,-0.37l-1.4,-2.59l-1.19,-0.68l-0.47,-1.0l-1.27,-1.23l-1.16,-0.22l0.43,-0.72l1.45,-0.28l0.41,-0.95l-0.03,-2.21l0.68,-2.44l1.05,-0.63l1.43,-3.06l1.57,-1.37l1.02,-2.51l0.35,-1.88l2.52,0.46l0.44,-0.24l0.58,-1.43Z", name: "Ethiopia" }, ZW: { path: "M498.91,341.09l-1.11,-0.22l-0.92,0.28l-2.09,-0.44l-1.5,-1.11l-1.89,-0.43l-0.62,-1.4l-0.01,-0.84l-0.3,-0.38l-0.97,-0.25l-2.71,-2.74l-1.92,-3.32l3.83,0.45l3.73,-3.82l1.08,-0.44l0.26,-0.77l1.25,-0.9l1.41,-0.26l0.5,0.89l1.99,-0.05l1.72,1.17l1.11,0.17l1.05,0.66l0.01,2.99l-0.59,3.76l0.38,0.86l-0.23,1.23l-0.39,0.35l-0.63,1.81l-2.43,2.75Z", name: "Zimbabwe" }, ES: { path: "M416.0,169.21l1.07,1.17l4.61,1.38l1.06,-0.57l2.6,1.26l2.71,-0.3l0.09,1.12l-2.14,1.8l-3.11,0.61l-0.31,0.31l-0.2,0.89l-1.54,1.69l-0.97,2.4l0.84,1.74l-1.32,1.27l-0.48,1.68l-1.88,0.65l-1.66,2.07l-5.36,-0.01l-1.79,1.08l-0.89,0.98l-0.88,-0.17l-0.79,-0.82l-0.68,-1.59l-2.37,-0.63l-0.11,-0.5l1.21,-1.82l-0.77,-1.13l0.61,-1.68l-0.76,-1.62l0.87,-0.49l0.09,-1.25l0.42,-0.6l0.03,-2.11l0.99,-0.69l0.13,-0.5l-1.03,-1.73l-1.46,-0.11l-0.61,0.38l-1.06,0.0l-0.52,-1.23l-0.53,-0.21l-1.32,0.67l-0.01,-1.49l-0.75,-0.96l3.03,-1.88l2.99,0.53l3.32,-0.02l2.63,0.51l6.01,-0.06Z", name: "Spain" }, ER: { path: "M520.38,246.23l3.42,2.43l3.5,3.77l0.84,0.54l-0.95,-0.01l-3.51,-3.89l-2.33,-1.15l-1.73,-0.07l-0.91,-0.51l-1.26,0.51l-1.34,-1.02l-0.61,0.17l-0.66,1.61l-2.35,-0.43l-0.17,-0.67l1.29,-5.29l0.61,-0.61l1.95,-0.53l0.87,-1.01l1.17,2.41l0.68,2.33l1.49,1.43Z", name: "Eritrea" }, ME: { path: "M468.91,172.53l-1.22,-1.02l0.47,-1.81l0.89,-0.72l2.26,1.51l-0.5,0.57l-0.75,-0.27l-1.14,1.73Z", name: "Montenegro" }, MD: { path: "M488.41,153.73l1.4,-0.27l1.72,0.93l1.07,0.15l0.85,0.65l-0.14,0.84l0.96,0.85l1.12,2.47l-1.15,-0.07l-0.66,-0.41l-0.52,0.25l-0.09,0.86l-1.08,1.89l-0.27,-0.86l0.25,-1.34l-0.16,-1.6l-3.29,-4.34Z", name: "Moldova" }, MG: { path: "M545.91,319.14l0.4,3.03l0.62,1.21l-0.21,1.02l-0.57,-0.8l-0.69,-0.01l-0.47,0.76l0.41,2.12l-0.18,0.87l-0.73,0.78l-0.15,2.14l-4.71,15.2l-1.06,2.88l-3.92,1.64l-3.12,-1.49l-0.6,-1.21l-0.19,-2.4l-0.86,-2.05l-0.21,-1.77l0.38,-1.62l1.21,-0.75l0.01,-0.76l1.19,-2.04l0.23,-1.66l-1.06,-2.99l-0.19,-2.21l0.81,-1.33l0.32,-1.46l4.63,-1.22l3.44,-3.0l0.85,-1.4l-0.08,-0.7l0.78,-0.04l1.38,-1.77l0.13,-1.64l0.45,-0.61l1.16,1.69l0.59,1.6Z", name: "Madagascar" }, MA: { path: "M378.78,230.02l0.06,-0.59l0.92,-0.73l0.82,-1.37l-0.09,-1.04l0.79,-1.7l1.31,-1.58l0.96,-0.59l0.66,-1.55l0.09,-1.47l0.81,-1.48l1.72,-1.07l1.55,-2.69l1.16,-0.96l2.44,-0.39l1.94,-1.82l1.31,-0.78l2.09,-2.28l-0.51,-3.65l1.24,-3.7l1.5,-1.75l4.46,-2.57l2.37,-4.47l1.44,0.01l1.68,1.21l2.32,-0.19l3.47,0.65l0.8,1.54l0.16,1.71l0.86,2.96l0.56,0.59l-0.26,0.61l-3.05,0.44l-1.26,1.05l-1.33,0.22l-0.33,0.37l-0.09,1.78l-2.68,1.0l-1.07,1.42l-4.47,1.13l-4.04,2.01l-0.54,4.64l-1.15,0.06l-0.92,0.61l-1.96,-0.35l-2.42,0.54l-0.74,1.9l-0.86,0.4l-1.14,3.26l-3.53,3.01l-0.8,3.55l-0.96,1.1l-0.29,0.82l-4.95,0.18Z", name: "Morocco" }, UZ: { path: "M598.64,172.75l-1.63,1.52l0.06,0.64l1.85,1.12l1.97,-0.64l2.21,1.17l-2.52,1.68l-2.59,-0.22l-0.18,-0.41l0.46,-1.23l-0.45,-0.53l-3.35,0.69l-2.1,3.51l-1.87,-0.12l-1.03,1.51l0.22,0.55l1.64,0.62l0.46,1.83l-1.19,2.49l-2.66,-0.53l0.05,-1.36l-0.26,-0.39l-3.3,-1.23l-2.56,-1.4l-4.4,-3.34l-1.34,-3.14l-1.08,-0.6l-2.58,0.13l-0.69,-0.44l-0.47,-2.52l-3.37,-1.6l-0.43,0.05l-2.07,1.72l-2.1,1.01l-0.21,0.47l0.28,1.01l-1.91,0.03l-0.09,-10.5l5.99,-1.7l6.19,3.54l2.71,2.84l7.05,-0.67l2.71,2.01l-0.17,2.81l0.39,0.42l0.9,0.02l0.44,2.14l0.38,0.32l2.94,0.09l0.95,1.42l1.28,-0.24l1.05,-2.04l4.43,-2.5Z", name: "Uzbekistan" }, MM: { path: "M673.9,230.21l-1.97,1.57l-0.57,0.96l-1.4,0.6l-1.36,1.05l-1.99,0.36l-1.08,2.66l-0.91,0.4l-0.19,0.55l1.21,2.27l2.52,3.43l-0.79,1.91l-0.74,0.41l-0.17,0.52l0.65,1.37l1.61,1.95l0.25,2.58l0.9,2.13l-1.92,3.57l0.68,-2.25l-0.81,-1.74l0.19,-2.65l-1.05,-1.53l-1.24,-6.17l-1.12,-2.26l-0.6,-0.13l-4.34,3.02l-2.39,-0.65l0.77,-2.84l-0.52,-2.61l-1.91,-2.96l0.25,-0.75l-0.29,-0.51l-1.33,-0.3l-1.61,-1.93l-0.1,-1.3l0.82,-0.24l0.04,-1.64l1.02,-0.52l0.21,-0.45l-0.23,-0.95l0.54,-0.96l0.08,-2.22l1.46,0.45l0.47,-0.2l1.12,-2.19l0.16,-1.35l1.33,-2.16l-0.0,-1.52l2.89,-1.66l1.63,0.44l0.5,-0.44l-0.17,-1.4l0.64,-0.36l0.08,-1.04l0.77,-0.11l0.71,1.35l1.06,0.69l-0.03,3.86l-2.38,2.37l-0.3,3.15l0.46,0.43l2.28,-0.38l0.51,2.08l1.47,0.67l-0.6,1.8l0.19,0.48l2.97,1.48l1.64,-0.55l0.02,0.32Z", name: "Myanmar" }, ML: { path: "M392.61,254.08l-0.19,-2.37l-0.99,-0.87l-0.44,-1.3l-0.09,-1.28l0.81,-0.58l0.35,-1.24l2.37,0.65l1.31,-0.47l0.86,0.15l0.66,-0.56l9.83,-0.04l0.38,-0.28l0.56,-1.8l-0.44,-0.65l-2.35,-21.95l3.27,-0.04l16.7,11.38l0.74,1.31l2.5,1.09l0.02,1.38l0.44,0.39l2.34,-0.21l0.01,5.38l-1.28,1.61l-0.26,1.49l-5.31,0.57l-1.07,0.92l-2.9,0.1l-0.86,-0.48l-1.38,0.36l-2.4,1.08l-0.6,0.87l-1.85,1.09l-0.43,0.7l-0.79,0.39l-1.44,-0.21l-0.81,0.84l-0.34,1.64l-1.91,2.02l-0.06,1.03l-0.67,1.22l0.13,1.16l-0.97,0.39l-0.23,-0.64l-0.52,-0.24l-1.35,0.4l-0.34,0.55l-2.69,-0.28l-0.37,-0.35l-0.02,-0.9l-0.65,-0.35l0.45,-0.64l-0.03,-0.53l-2.12,-2.44l-0.76,-0.01l-2.0,1.16l-0.78,-0.15l-0.8,-0.67l-1.21,0.23Z", name: "Mali" }, MN: { path: "M676.61,146.48l3.81,1.68l5.67,-1.0l2.37,0.41l2.34,1.5l1.79,1.75l2.29,-0.03l3.12,0.52l2.47,-0.81l3.41,-0.59l3.53,-2.21l1.25,0.29l1.53,1.13l2.27,-0.21l-2.66,5.01l0.64,1.68l0.47,0.21l1.32,-0.38l2.38,0.48l2.02,-1.11l1.76,0.89l2.06,2.02l-0.13,0.53l-1.72,-0.29l-3.77,0.46l-1.88,0.99l-1.76,1.99l-3.71,1.17l-2.45,1.6l-3.83,-0.87l-0.41,0.17l-1.31,1.99l1.04,2.24l-1.52,0.9l-1.74,1.57l-2.79,1.02l-3.78,0.13l-4.05,1.05l-2.77,1.52l-1.16,-0.85l-2.94,0.0l-3.62,-1.79l-2.58,-0.49l-3.4,0.41l-5.12,-0.67l-2.63,0.06l-1.31,-1.6l-1.4,-3.0l-1.48,-0.33l-3.13,-1.94l-6.16,-0.93l-0.71,-1.06l0.86,-3.82l-1.93,-2.71l-3.5,-1.18l-1.95,-1.58l-0.5,-1.72l2.34,-0.52l4.75,-2.8l3.62,-1.47l2.18,0.97l2.46,0.05l1.81,1.53l2.46,0.12l3.95,0.71l2.43,-2.28l0.08,-0.48l-0.9,-1.72l2.24,-2.98l2.62,1.27l4.94,1.17l0.43,2.24Z", name: "Mongolia" }, MK: { path: "M472.8,173.98l0.49,-0.71l3.57,-0.71l1.0,0.77l0.13,1.45l-0.65,0.53l-1.15,-0.05l-1.12,0.67l-1.39,0.22l-0.79,-0.55l-0.29,-1.03l0.19,-0.6Z", name: "Macedonia" }, MW: { path: "M505.5,309.31l0.85,1.95l0.15,2.86l-0.69,1.65l0.71,1.8l0.06,1.28l0.49,0.64l0.07,1.06l0.4,0.55l0.8,-0.23l0.55,0.61l0.69,-0.21l0.34,0.6l0.19,2.94l-1.04,0.62l-0.54,1.25l-1.11,-1.08l-0.16,-1.56l0.51,-1.31l-0.32,-1.3l-0.99,-0.65l-0.82,0.12l-2.36,-1.64l0.63,-1.96l0.82,-1.18l-0.46,-2.01l0.9,-2.86l-0.94,-2.51l0.96,0.18l0.29,0.4Z", name: "Malawi" }, MR: { path: "M407.36,220.66l-2.58,0.03l-0.39,0.44l2.42,22.56l0.36,0.43l-0.39,1.24l-9.75,0.04l-0.56,0.53l-0.91,-0.11l-1.27,0.45l-1.61,-0.66l-0.97,0.03l-0.36,0.29l-0.38,1.35l-0.42,0.23l-2.93,-3.4l-2.96,-1.52l-1.62,-0.03l-1.27,0.54l-1.12,-0.2l-0.65,0.4l-0.08,-0.49l0.68,-1.29l0.31,-2.43l-0.57,-3.91l0.23,-1.21l-0.69,-1.5l-1.15,-1.02l0.25,-0.39l9.58,0.02l0.4,-0.45l-0.46,-3.68l0.47,-1.04l2.12,-0.21l0.36,-0.4l-0.08,-6.4l7.81,0.13l0.41,-0.4l0.01,-3.31l7.76,5.35Z", name: "Mauritania" }, UG: { path: "M498.55,276.32l0.7,-0.46l1.65,0.5l1.96,-0.57l1.7,0.01l1.45,-0.98l0.91,1.33l1.33,3.95l-2.57,4.03l-1.46,-0.4l-2.54,0.91l-1.37,1.61l-0.01,0.81l-2.42,-0.01l-2.26,1.01l-0.17,-1.59l0.58,-1.04l0.14,-1.94l1.37,-2.28l1.78,-1.58l-0.17,-0.65l-0.72,-0.24l0.13,-2.43Z", name: "Uganda" }, MY: { path: "M717.47,273.46l-1.39,0.65l-2.12,-0.41l-2.88,-0.0l-0.38,0.28l-0.84,2.75l-0.99,0.96l-1.21,3.29l-1.73,0.45l-2.45,-0.68l-1.39,0.31l-1.33,1.15l-1.59,-0.14l-1.41,0.44l-1.44,-1.19l-0.18,-0.73l1.34,0.53l1.93,-0.47l0.75,-2.22l4.02,-1.03l2.75,-3.21l0.82,0.94l0.64,-0.05l0.4,-0.65l0.96,0.06l0.42,-0.36l0.24,-2.68l1.81,-1.64l1.21,-1.86l0.63,-0.01l1.07,1.05l0.34,1.28l3.44,1.35l-0.06,0.35l-1.37,0.1l-0.35,0.54l0.32,0.88ZM673.68,269.59l0.17,1.09l0.47,0.33l1.65,-0.3l0.87,-0.94l1.61,1.52l0.98,1.56l-0.12,2.81l0.41,2.29l0.95,0.9l0.88,2.44l-1.27,0.12l-5.1,-3.67l-0.34,-1.29l-1.37,-1.59l-0.33,-1.97l-0.88,-1.4l0.25,-1.68l-0.46,-1.05l1.63,0.84Z", name: "Malaysia" }, MX: { path: "M133.12,200.41l0.2,0.47l9.63,3.33l6.96,-0.02l0.4,-0.4l0.0,-0.74l3.77,0.0l3.55,2.93l1.39,2.83l1.52,1.04l2.08,0.82l0.47,-0.14l1.46,-2.0l1.73,-0.04l1.59,0.98l2.05,3.35l1.47,1.56l1.26,3.14l2.18,1.02l2.26,0.58l-1.18,3.72l-0.42,5.04l1.79,4.89l1.62,1.89l0.61,1.52l1.2,1.42l2.55,0.66l1.37,1.1l7.54,-1.89l1.86,-1.3l1.14,-4.3l4.1,-1.21l3.57,-0.11l0.32,0.3l-0.06,0.94l-1.26,1.45l-0.67,1.71l0.38,0.7l-0.72,2.27l-0.49,-0.3l-1.0,0.08l-1.0,1.39l-0.47,-0.11l-0.53,0.47l-4.26,-0.02l-0.4,0.4l-0.0,1.06l-1.1,0.26l0.1,0.44l1.82,1.44l0.56,0.91l-3.19,0.21l-1.21,2.09l0.24,0.72l-0.2,0.44l-2.24,-2.18l-1.45,-0.93l-2.22,-0.69l-1.52,0.22l-3.07,1.16l-10.55,-3.85l-2.86,-1.96l-3.78,-0.92l-1.08,-1.19l-2.62,-1.43l-1.18,-1.54l-0.38,-0.81l0.66,-0.63l-0.18,-0.53l0.52,-0.76l0.01,-0.91l-2.0,-3.82l-2.21,-2.63l-2.53,-2.09l-1.19,-1.62l-2.2,-1.17l-0.3,-0.43l0.34,-1.48l-0.21,-0.45l-1.23,-0.6l-1.36,-1.2l-0.59,-1.78l-1.54,-0.47l-2.44,-2.55l-0.16,-0.9l-1.33,-2.03l-0.84,-1.99l-0.16,-1.33l-1.81,-1.1l-0.97,0.05l-1.31,-0.7l-0.57,0.22l-0.4,1.12l0.72,3.77l3.51,3.89l0.28,0.78l0.53,0.26l0.41,1.43l1.33,1.73l1.58,1.41l0.8,2.39l1.43,2.41l0.13,1.32l0.37,0.36l1.04,0.08l1.67,2.28l-0.85,0.76l-0.66,-1.51l-1.68,-1.54l-2.91,-1.87l0.06,-1.82l-0.54,-1.68l-2.91,-2.03l-0.55,0.09l-1.95,-1.1l-0.88,-0.94l0.68,-0.08l0.93,-1.01l0.08,-1.78l-1.93,-1.94l-1.46,-0.77l-3.75,-7.56l4.88,-0.42Z", name: "Mexico" }, VU: { path: "M839.04,322.8l0.22,1.14l-0.44,0.03l-0.2,-1.45l0.42,0.27Z", name: "Vanuatu" }, FR: { path: "M444.48,172.62l-0.64,1.78l-0.58,-0.31l-0.49,-1.72l0.4,-0.89l1.0,-0.72l0.3,1.85ZM429.64,147.1l1.78,1.58l1.46,-0.13l2.1,1.42l1.35,0.27l1.23,0.83l3.04,0.5l-1.03,1.85l-0.3,2.12l-0.41,0.32l-0.95,-0.24l-0.5,0.43l0.06,0.61l-1.81,1.92l-0.04,1.42l0.55,0.38l0.88,-0.36l0.61,0.97l-0.03,1.0l0.57,0.91l-0.75,1.09l0.65,2.39l1.27,0.57l-0.18,0.82l-2.01,1.53l-4.77,-0.8l-3.82,1.0l-0.53,1.85l-2.49,0.34l-2.71,-1.31l-1.16,0.57l-4.31,-1.29l-0.72,-0.86l1.19,-1.78l0.39,-6.45l-2.58,-3.3l-1.9,-1.66l-3.72,-1.23l-0.19,-1.72l2.81,-0.61l4.12,0.81l0.47,-0.48l-0.6,-2.77l1.94,0.95l5.83,-2.54l0.92,-2.74l1.6,-0.49l0.24,0.78l1.36,0.33l1.05,1.19ZM289.01,278.39l-0.81,0.8l-0.78,0.12l-0.5,-0.66l-0.56,-0.1l-0.91,0.6l-0.46,-0.22l1.09,-2.96l-0.96,-1.77l-0.17,-1.49l1.07,-1.77l2.32,0.75l2.51,2.01l0.3,0.74l-2.14,3.96Z", name: "France" }, FI: { path: "M492.17,76.39l-0.23,3.5l3.52,2.63l-2.08,2.88l-0.02,0.44l2.8,4.56l-1.59,3.31l2.16,3.24l-0.94,2.39l0.14,0.47l3.44,2.51l-0.77,1.62l-7.52,6.95l-4.5,0.31l-4.38,1.37l-3.8,0.74l-1.44,-1.96l-2.17,-1.11l0.5,-3.66l-1.16,-3.33l1.09,-2.08l2.21,-2.42l5.67,-4.32l1.64,-0.83l0.21,-0.42l-0.46,-2.02l-3.38,-1.89l-0.75,-1.43l-0.22,-6.74l-6.79,-4.8l0.8,-0.62l2.54,2.12l3.46,-0.12l3.0,0.96l2.51,-2.11l1.17,-3.08l3.55,-1.38l2.76,1.53l-0.95,2.79Z", name: "Finland" }, FJ: { path: "M871.53,326.34l-2.8,1.05l-0.08,-0.23l2.97,-1.21l-0.1,0.39ZM867.58,329.25l0.43,0.37l-0.27,0.88l-1.24,0.28l-1.04,-0.24l-0.14,-0.66l0.63,-0.58l0.92,0.26l0.7,-0.31Z", name: "Fiji" }, FK: { path: "M274.36,425.85l1.44,1.08l-0.47,0.73l-3.0,0.89l-0.96,-1.0l-0.52,-0.05l-1.83,1.29l-0.73,-0.88l2.46,-1.64l1.93,0.76l1.67,-1.19Z", name: "Falkland Is." }, NI: { path: "M202.33,252.67l0.81,-0.18l1.03,-1.02l-0.04,-0.88l0.68,-0.0l0.63,-0.54l0.97,0.22l1.53,-1.26l0.58,-0.99l1.17,0.34l2.41,-0.94l0.13,1.32l-0.81,1.94l0.1,2.74l-0.36,0.37l-0.11,1.75l-0.47,0.81l0.18,1.14l-1.73,-0.85l-0.71,0.27l-1.47,-0.6l-0.52,0.16l-4.01,-3.81Z", name: "Nicaragua" }, NL: { path: "M430.31,143.39l0.6,-0.5l2.13,-4.8l3.2,-1.33l1.74,0.08l0.33,0.8l-0.59,2.92l-0.5,0.99l-1.26,0.0l-0.4,0.45l0.33,2.7l-2.2,-1.78l-2.62,0.58l-0.75,-0.11Z", name: "Netherlands" }, NO: { path: "M491.44,67.41l6.8,2.89l-2.29,0.86l-0.15,0.65l2.33,2.38l-4.98,1.79l0.84,-2.45l-0.18,-0.48l-3.55,-1.8l-3.89,1.52l-1.42,3.38l-2.12,1.72l-2.64,-1.0l-3.11,0.21l-2.66,-2.22l-0.5,-0.01l-1.41,1.1l-1.44,0.17l-0.35,0.35l-0.32,2.47l-4.32,-0.64l-0.44,0.29l-0.58,2.11l-2.45,0.2l-4.15,7.68l-3.88,5.76l0.78,1.62l-0.64,1.16l-2.24,-0.06l-0.38,0.24l-1.66,3.89l0.15,5.17l1.57,2.04l-0.78,4.16l-2.02,2.48l-0.85,1.63l-1.3,-1.75l-0.58,-0.07l-4.87,4.19l-3.1,0.79l-3.16,-1.7l-0.85,-3.77l-0.77,-8.55l2.14,-2.31l6.55,-3.27l5.02,-4.17l10.63,-13.84l10.98,-8.7l5.35,-1.91l4.34,0.12l3.69,-3.64l4.49,0.19l4.37,-0.89ZM484.55,20.04l4.26,1.75l-3.1,2.55l-7.1,0.65l-7.08,-0.9l-0.37,-1.31l-0.37,-0.29l-3.44,-0.1l-2.08,-2.0l6.87,-1.44l3.9,1.31l2.39,-1.64l6.13,1.4ZM481.69,33.93l-4.45,1.74l-3.54,-0.99l1.12,-0.9l0.05,-0.58l-1.06,-1.22l4.22,-0.89l1.09,1.97l2.57,0.87ZM466.44,24.04l7.43,3.77l-5.41,1.86l-1.58,4.08l-2.26,1.2l-1.12,4.11l-2.61,0.18l-4.79,-2.86l1.84,-1.54l-0.1,-0.68l-3.69,-1.53l-4.77,-4.51l-1.73,-3.89l6.11,-1.82l1.54,1.92l3.57,-0.08l1.2,-1.96l3.32,-0.18l3.05,1.92Z", name: "Norway" }, NA: { path: "M474.26,330.66l-0.97,0.04l-0.38,0.4l-0.07,8.9l-2.09,0.08l-0.39,0.4l-0.0,17.42l-1.98,1.23l-1.17,0.17l-2.44,-0.66l-0.48,-1.13l-0.99,-0.74l-0.54,0.05l-0.9,1.01l-1.53,-1.68l-0.93,-1.88l-1.99,-8.56l-0.06,-3.12l-0.33,-1.52l-2.3,-3.34l-1.91,-4.83l-1.96,-2.43l-0.12,-1.57l2.33,-0.79l1.43,0.07l1.81,1.13l10.23,-0.25l1.84,1.23l5.87,0.35ZM474.66,330.64l6.51,-1.6l1.9,0.39l-1.69,0.4l-1.31,0.83l-1.12,-0.94l-4.29,0.92Z", name: "Namibia" }, NC: { path: "M838.78,341.24l-0.33,0.22l-2.9,-1.75l-3.26,-3.37l1.65,0.83l4.85,4.07Z", name: "New Caledonia" }, NE: { path: "M454.75,226.53l1.33,1.37l0.48,0.07l1.27,-0.7l0.53,3.52l0.94,0.83l0.17,0.92l0.81,0.69l-0.44,0.95l-0.96,5.26l-0.13,3.22l-3.04,2.31l-1.22,3.57l1.02,1.24l-0.0,1.46l0.39,0.4l1.13,0.04l-0.9,1.25l-1.47,-2.42l-0.86,-0.29l-2.09,1.37l-1.74,-0.67l-1.45,-0.17l-0.85,0.35l-1.36,-0.07l-1.64,1.09l-1.06,0.05l-2.94,-1.28l-1.44,0.59l-1.01,-0.03l-0.97,-0.94l-2.7,-0.98l-2.69,0.3l-0.87,0.64l-0.47,1.6l-0.75,1.16l-0.12,1.53l-1.57,-1.1l-1.31,0.24l0.03,-0.81l-0.32,-0.41l-2.59,-0.52l-0.15,-1.16l-1.35,-1.6l-0.29,-1.0l0.13,-0.84l1.29,-0.08l1.08,-0.92l3.31,-0.22l2.22,-0.41l0.32,-0.34l0.2,-1.47l1.39,-1.88l-0.01,-5.66l3.36,-1.12l7.24,-5.12l8.42,-4.92l3.69,1.06Z", name: "Niger" }, NG: { path: "M456.32,253.89l0.64,0.65l-0.28,1.04l-2.11,2.01l-2.03,5.18l-1.37,1.16l-1.15,3.18l-1.33,0.66l-1.46,-0.97l-1.21,0.16l-1.38,1.36l-0.91,0.24l-1.79,4.06l-2.33,0.81l-1.11,-0.07l-0.86,0.5l-1.71,-0.05l-1.19,-1.39l-0.89,-1.89l-1.77,-1.66l-3.95,-0.08l0.07,-5.21l0.42,-1.43l1.95,-2.3l-0.14,-0.91l0.43,-1.18l-0.53,-1.41l0.25,-2.92l0.72,-1.07l0.32,-1.34l0.46,-0.39l2.47,-0.28l2.34,0.89l1.15,1.02l1.28,0.04l1.22,-0.58l3.03,1.27l1.49,-0.14l1.36,-1.0l1.33,0.07l0.82,-0.35l3.45,0.8l1.82,-1.32l1.84,2.67l0.66,0.16Z", name: "Nigeria" }, NZ: { path: "M857.8,379.65l1.86,3.12l0.44,0.18l0.3,-0.38l0.03,-1.23l0.38,0.27l0.57,2.31l2.02,0.94l1.81,0.27l1.57,-1.06l0.7,0.18l-1.15,3.59l-1.98,0.11l-0.74,1.2l0.2,1.11l-2.42,3.98l-1.49,0.92l-1.04,-0.85l1.21,-2.05l-0.81,-2.01l-2.63,-1.25l0.04,-0.57l1.82,-1.19l0.43,-2.34l-0.16,-2.03l-0.95,-1.82l-0.06,-0.72l-3.11,-3.64l-0.79,-1.52l1.56,1.45l1.76,0.66l0.65,2.34ZM853.83,393.59l0.57,1.24l0.59,0.16l1.42,-0.97l0.46,0.79l0.0,1.03l-2.47,3.48l-1.26,1.2l-0.06,0.5l0.55,0.87l-1.41,0.07l-2.33,1.38l-2.03,5.02l-3.02,2.16l-2.06,-0.06l-1.71,-1.04l-2.47,-0.2l-0.27,-0.73l1.22,-2.1l3.05,-2.94l1.62,-0.59l4.02,-2.82l1.57,-1.67l1.07,-2.16l0.88,-0.7l0.48,-1.75l1.24,-0.97l0.35,0.79Z", name: "New Zealand" }, NP: { path: "M641.14,213.62l0.01,3.19l-1.74,0.04l-4.8,-0.86l-1.58,-1.39l-3.37,-0.34l-7.65,-3.7l0.8,-2.09l2.33,-1.7l1.77,0.75l2.49,1.76l1.38,0.41l0.99,1.35l1.9,0.52l1.99,1.17l5.49,0.9Z", name: "Nepal" }, CI: { path: "M407.4,259.27l0.86,0.42l0.56,0.9l1.13,0.53l1.19,-0.61l0.97,-0.08l1.42,0.54l0.6,3.24l-1.03,2.08l-0.65,2.84l1.06,2.33l-0.06,0.53l-2.54,-0.47l-1.66,0.03l-3.06,0.46l-4.11,1.6l0.32,-3.06l-1.18,-1.31l-1.32,-0.66l0.42,-0.85l-0.2,-1.4l0.5,-0.67l0.01,-1.59l0.84,-0.32l0.26,-0.5l-1.15,-3.01l0.12,-0.5l0.51,-0.25l0.66,0.31l1.93,0.02l0.67,-0.71l0.71,-0.14l0.25,0.69l0.57,0.22l1.4,-0.61Z", name: "C\xF4te d'Ivoire" }, CH: { path: "M444.62,156.35l-0.29,0.87l0.18,0.53l1.13,0.58l1.0,0.1l-0.1,0.65l-0.79,0.38l-1.72,-0.37l-0.45,0.23l-0.45,1.04l-0.75,0.06l-0.84,-0.4l-1.32,1.0l-0.96,0.12l-0.88,-0.55l-0.81,-1.3l-0.49,-0.16l-0.63,0.26l0.02,-0.65l1.71,-1.66l0.1,-0.56l0.93,0.08l0.58,-0.46l1.99,0.02l0.66,-0.61l2.19,0.79Z", name: "Switzerland" }, CO: { path: "M242.07,254.93l-1.7,0.59l-0.59,1.18l-1.7,1.69l-0.38,1.93l-0.67,1.43l0.31,0.57l1.03,0.13l0.25,0.9l0.57,0.64l-0.04,2.34l1.64,1.42l3.16,-0.24l1.26,0.28l1.67,2.06l0.41,0.13l4.09,-0.39l0.45,0.22l-0.92,1.95l-0.2,1.8l0.52,1.83l0.75,1.05l-1.12,1.1l0.07,0.63l0.84,0.51l0.74,1.29l-0.39,-0.45l-0.59,-0.01l-0.71,0.74l-4.71,-0.05l-0.4,0.41l0.03,1.57l0.33,0.39l1.11,0.2l-1.68,0.4l-0.29,0.38l-0.01,1.82l1.16,1.14l0.34,1.25l-1.05,7.05l-1.04,-0.87l1.26,-1.99l-0.13,-0.56l-2.18,-1.23l-1.38,0.2l-1.14,-0.38l-1.27,0.61l-1.55,-0.26l-1.38,-2.46l-1.23,-0.75l-0.85,-1.2l-1.67,-1.19l-0.86,0.13l-2.11,-1.32l-1.01,0.31l-1.8,-0.29l-0.52,-0.91l-3.09,-1.68l0.77,-0.52l-0.1,-1.12l0.41,-0.64l1.34,-0.32l2.0,-2.88l-0.11,-0.57l-0.66,-0.43l0.39,-1.38l-0.52,-2.1l0.49,-0.83l-0.4,-2.13l-0.97,-1.35l0.17,-0.66l0.86,-0.08l0.47,-0.75l-0.46,-1.63l1.41,-0.07l1.8,-1.69l0.93,-0.24l0.3,-0.38l0.45,-2.76l1.22,-1.0l1.44,-0.04l0.45,-0.5l1.91,0.12l2.93,-1.84l1.15,-1.14l0.91,0.46l-0.25,0.45Z", name: "Colombia" }, CN: { path: "M740.23,148.97l4.57,1.3l2.8,2.17l0.98,2.9l0.38,0.27l3.8,0.0l2.32,-1.28l3.29,-0.75l-0.96,2.09l-1.02,1.28l-0.85,3.4l-1.52,2.73l-2.76,-0.5l-2.4,1.13l-0.21,0.45l0.64,2.57l-0.32,3.2l-0.94,0.06l-0.37,0.89l-0.91,-1.01l-0.64,0.07l-0.92,1.57l-3.73,1.25l-0.26,0.48l0.26,1.06l-1.5,-0.08l-1.09,-0.86l-0.56,0.06l-1.67,2.06l-2.7,1.56l-2.03,1.88l-3.4,0.83l-1.93,1.4l-1.15,0.34l0.33,-0.7l-0.41,-0.89l1.79,-1.79l0.02,-0.54l-1.32,-1.56l-0.48,-0.1l-2.24,1.09l-2.83,2.06l-1.51,1.83l-2.28,0.13l-1.55,1.49l-0.04,0.5l1.32,1.97l2.0,0.58l0.31,1.35l1.98,0.84l3.0,-1.96l2.0,1.02l1.49,0.11l0.22,0.83l-3.37,0.86l-1.12,1.48l-2.5,1.52l-1.29,1.99l0.14,0.56l2.57,1.48l0.97,2.7l3.17,4.63l-0.03,1.66l-1.35,0.65l-0.2,0.51l0.6,1.47l1.4,0.91l-0.89,3.82l-1.43,0.38l-3.85,6.44l-2.27,3.11l-6.78,4.57l-2.73,0.29l-1.45,1.04l-0.62,-0.61l-0.55,-0.01l-1.36,1.25l-3.39,1.27l-2.61,0.4l-1.1,2.79l-0.81,0.09l-0.49,-1.42l0.5,-0.85l-0.25,-0.59l-3.36,-0.84l-1.3,0.4l-2.31,-0.62l-0.94,-0.84l0.33,-1.28l-0.3,-0.49l-2.19,-0.46l-1.13,-0.93l-0.47,-0.02l-2.06,1.36l-4.29,0.28l-2.76,1.05l-0.28,0.43l0.32,2.53l-0.59,-0.03l-0.19,-1.34l-0.55,-0.34l-1.68,0.7l-2.46,-1.23l0.62,-1.87l-0.26,-0.51l-1.37,-0.44l-0.54,-2.22l-0.45,-0.3l-2.13,0.35l0.24,-2.48l2.39,-2.4l0.03,-4.31l-1.19,-0.92l-0.78,-1.49l-0.41,-0.21l-1.41,0.19l-1.98,-0.3l0.46,-1.07l-1.17,-1.7l-0.55,-0.11l-1.63,1.05l-2.25,-0.57l-2.89,1.73l-2.25,1.98l-1.75,0.29l-1.17,-0.71l-3.31,-0.65l-1.48,0.79l-1.04,1.27l-0.12,-1.17l-0.54,-0.34l-1.44,0.54l-5.55,-0.86l-1.98,-1.16l-1.89,-0.54l-0.99,-1.35l-1.34,-0.37l-2.55,-1.79l-2.01,-0.84l-1.21,0.56l-5.57,-3.45l-0.53,-2.31l1.19,0.25l0.48,-0.37l0.08,-1.42l-0.98,-1.56l0.15,-2.44l-2.69,-3.32l-4.12,-1.23l-0.67,-2.0l-1.92,-1.48l-0.38,-0.7l-0.51,-3.01l-1.52,-0.66l-0.7,0.13l-0.48,-2.05l0.55,-0.51l-0.09,-0.82l2.03,-1.19l1.6,-0.54l2.56,0.38l0.42,-0.22l0.85,-1.7l3.0,-0.33l1.1,-1.26l4.05,-1.77l0.39,-0.91l-0.17,-1.44l1.45,-0.67l0.2,-0.52l-2.07,-4.9l4.51,-1.12l1.37,-0.73l1.89,-5.51l4.98,0.86l1.51,-1.7l0.11,-2.87l1.99,-0.38l1.83,-2.06l0.49,-0.13l0.68,2.08l2.23,1.77l3.44,1.16l1.55,2.29l-0.92,3.49l0.96,1.67l6.54,1.13l2.95,1.87l1.47,0.35l1.06,2.62l1.53,1.91l3.05,0.08l5.14,0.67l3.37,-0.41l2.36,0.43l3.65,1.8l3.06,0.04l1.45,0.88l2.87,-1.59l3.95,-1.02l3.83,-0.14l3.06,-1.14l1.77,-1.6l1.72,-1.01l0.17,-0.49l-1.1,-2.05l1.02,-1.54l4.02,0.8l2.45,-1.61l3.76,-1.19l1.96,-2.13l1.63,-0.83l3.51,-0.4l1.92,0.34l0.46,-0.3l0.17,-1.5l-2.27,-2.22l-2.11,-1.09l-2.18,1.11l-2.32,-0.47l-1.29,0.32l-0.4,-0.82l2.73,-5.16l3.02,1.06l3.53,-2.06l0.18,-1.68l2.16,-3.35l1.49,-1.35l-0.03,-1.85l-1.07,-0.85l1.54,-1.26l2.98,-0.59l3.23,-0.09l3.64,0.99l2.04,1.16l3.29,6.71l0.92,3.19ZM696.92,237.31l-1.87,1.08l-1.63,-0.64l-0.06,-1.79l1.03,-0.98l2.58,-0.69l1.16,0.05l0.3,0.54l-0.98,1.06l-0.53,1.37Z", name: "China" }, CM: { path: "M457.92,257.49l1.05,1.91l-1.4,0.16l-1.05,-0.23l-0.45,0.22l-0.54,1.19l0.08,0.45l1.48,1.47l1.05,0.45l1.01,2.46l-1.52,2.99l-0.68,0.68l-0.13,3.69l2.38,3.84l1.09,0.8l0.24,2.48l-3.67,-1.14l-11.27,-0.13l0.23,-1.79l-0.98,-1.66l-1.19,-0.54l-0.44,-0.97l-0.6,-0.42l1.71,-4.27l0.75,-0.13l1.38,-1.36l0.65,-0.03l1.71,0.99l1.93,-1.12l1.14,-3.18l1.38,-1.17l2.0,-5.14l2.17,-2.13l0.3,-1.64l-0.86,-0.88l0.03,-0.33l0.94,1.28l0.07,3.22Z", name: "Cameroon" }, CL: { path: "M246.5,429.18l-3.14,1.83l-0.57,3.16l-0.64,0.05l-2.68,-1.06l-2.82,-2.33l-3.04,-1.89l-0.69,-1.85l0.63,-2.14l-1.21,-2.11l-0.31,-5.37l1.01,-2.91l2.57,-2.38l-0.18,-0.68l-3.16,-0.77l2.05,-2.47l0.77,-4.65l2.32,0.9l0.54,-0.29l1.31,-6.31l-0.22,-0.44l-1.68,-0.8l-0.56,0.28l-0.7,3.36l-0.81,-0.22l1.56,-9.41l1.15,-2.24l-0.71,-2.82l-0.18,-2.84l1.01,-0.33l3.26,-9.14l1.07,-4.22l-0.56,-4.21l0.74,-2.34l-0.29,-3.27l1.46,-3.34l2.04,-16.59l-0.66,-7.76l1.03,-0.53l0.54,-0.9l0.79,1.14l0.32,1.78l1.25,1.16l-0.69,2.55l1.33,2.9l0.97,3.59l0.46,0.29l1.5,-0.3l0.11,0.23l-0.76,2.44l-2.57,1.23l-0.23,0.37l0.08,4.33l-0.46,0.77l0.56,1.21l-1.58,1.51l-1.68,2.62l-0.89,2.47l0.2,2.7l-1.48,2.73l1.12,5.09l0.64,0.61l-0.01,2.29l-1.38,2.68l0.01,2.4l-1.89,2.04l0.02,2.75l0.69,2.57l-1.43,1.13l-1.26,5.68l0.39,3.51l-0.97,0.89l0.58,3.5l1.02,1.14l-0.65,1.02l0.15,0.57l1.0,0.53l0.16,0.69l-1.03,0.85l0.26,1.75l-0.89,4.03l-1.31,2.66l0.24,1.75l-0.71,1.83l-1.99,1.7l0.3,3.67l0.88,1.19l1.58,0.01l0.01,2.21l1.04,1.95l5.98,0.63ZM248.69,430.79l0.0,7.33l0.4,0.4l3.52,0.05l-0.44,0.75l-1.94,0.98l-2.49,-0.37l-1.88,-1.06l-2.55,-0.49l-5.59,-3.71l-2.38,-2.63l4.1,2.48l3.32,1.23l0.45,-0.12l1.29,-1.57l0.83,-2.32l2.05,-1.24l1.31,0.29Z", name: "Chile" }, CA: { path: "M280.06,145.6l-1.67,2.88l0.07,0.49l0.5,0.04l1.46,-0.98l1.0,0.42l-0.56,0.72l0.17,0.62l2.22,0.89l1.35,-0.71l1.95,0.78l-0.66,2.01l0.5,0.51l1.32,-0.42l0.98,3.17l-0.91,2.41l-0.8,0.08l-1.23,-0.45l0.47,-2.25l-0.89,-0.83l-0.48,0.06l-2.78,2.63l-0.34,-0.02l1.02,-0.85l-0.14,-0.69l-2.4,-0.77l-7.4,0.08l-0.17,-0.41l1.3,-0.94l0.02,-0.64l-0.73,-0.58l1.85,-1.74l2.57,-5.16l1.47,-1.79l1.99,-1.05l0.46,0.06l-1.53,2.45ZM68.32,74.16l4.13,0.95l4.02,2.14l2.61,0.4l2.47,-1.89l2.88,-1.31l3.85,0.48l3.71,-1.94l3.82,-1.04l1.56,1.68l0.49,0.08l1.87,-1.04l0.65,-1.98l1.24,0.35l4.16,3.94l0.54,0.01l2.75,-2.49l0.26,2.59l0.49,0.35l3.08,-0.73l1.04,-1.27l2.73,0.23l3.83,1.86l5.86,1.61l3.47,0.75l2.44,-0.26l2.73,1.78l-2.98,1.81l-0.19,0.41l0.31,0.32l4.53,0.92l6.87,-0.5l2.0,-0.69l2.49,2.39l0.53,0.02l2.72,-2.16l-0.02,-0.64l-2.16,-1.54l1.15,-1.06l4.83,-0.61l1.84,0.95l2.48,2.31l3.01,-0.23l4.55,1.92l3.85,-0.67l3.61,0.1l0.41,-0.44l-0.25,-2.36l1.79,-0.61l3.49,1.32l-0.01,3.77l0.31,0.39l0.45,-0.22l1.48,-3.16l1.74,0.1l0.41,-0.3l1.13,-4.37l-2.78,-3.11l-2.8,-1.74l0.19,-4.64l2.71,-3.07l2.98,0.67l2.41,1.95l3.19,4.8l-1.99,1.97l0.21,0.68l4.33,0.84l-0.01,4.15l0.25,0.37l0.44,-0.09l3.07,-3.15l2.54,2.39l-0.61,3.33l2.42,2.88l0.61,0.0l2.61,-3.08l1.88,-3.82l0.17,-4.58l6.72,0.94l3.13,2.04l0.13,1.82l-1.76,2.19l-0.01,0.49l1.66,2.16l-0.26,1.71l-4.68,2.8l-3.28,0.61l-2.47,-1.2l-0.55,0.23l-0.73,2.04l-2.38,3.43l-0.74,1.77l-2.74,2.57l-3.44,0.25l-2.21,1.78l-0.28,2.53l-2.82,0.55l-3.12,3.22l-2.72,4.31l-1.03,3.17l-0.14,4.31l0.33,0.41l3.44,0.57l2.24,5.95l0.45,0.23l3.4,-0.69l4.52,1.51l2.43,1.31l1.91,1.73l3.1,0.96l2.62,1.46l6.6,0.54l-0.35,2.74l0.81,3.53l1.81,3.78l3.83,3.3l0.45,0.04l2.1,-1.28l1.37,-3.69l-1.31,-5.38l-1.45,-1.58l3.57,-1.47l2.84,-2.46l1.52,-2.8l-0.25,-2.55l-1.7,-3.07l-2.85,-2.61l2.8,-3.95l-1.08,-3.37l-0.79,-5.67l1.36,-0.7l6.76,1.41l2.12,-0.96l5.12,3.36l1.05,1.61l4.08,0.26l-0.06,2.87l0.83,4.7l0.3,0.32l2.16,0.54l1.73,2.06l0.5,0.09l3.63,-2.03l2.52,-4.19l1.26,-1.32l7.6,11.72l-0.92,2.04l0.16,0.51l3.3,1.97l2.22,1.98l4.1,0.98l1.43,0.99l0.95,2.79l2.1,0.68l0.84,1.08l0.17,3.45l-3.37,2.26l-4.22,1.24l-3.06,2.63l-4.06,0.51l-5.35,-0.69l-6.39,0.2l-2.3,2.41l-3.26,1.51l-6.47,7.15l-0.06,0.48l0.44,0.19l2.13,-0.52l4.17,-4.24l5.12,-2.62l3.52,-0.3l1.69,1.21l-2.12,2.21l0.81,3.47l1.02,2.61l3.47,1.6l4.14,-0.45l2.15,-2.8l0.26,1.48l1.14,0.8l-2.56,1.69l-5.5,1.82l-2.54,1.27l-2.74,2.15l-1.4,-0.16l-0.07,-2.01l4.14,-2.44l0.18,-0.45l-0.39,-0.29l-6.63,0.45l-1.39,-1.49l-0.14,-4.43l-1.11,-0.91l-1.82,0.39l-0.66,-0.66l-0.6,0.03l-1.91,2.39l-0.82,2.52l-0.8,1.27l-1.67,0.56l-0.46,0.76l-8.31,0.07l-1.21,0.62l-2.35,1.97l-0.71,-0.14l-1.37,0.96l-1.12,-0.48l-4.74,1.26l-0.9,1.17l0.21,0.62l1.73,0.3l-1.81,0.31l-1.85,0.81l-2.11,-0.13l-2.95,1.78l-0.69,-0.09l1.39,-2.1l1.73,-1.21l0.1,-2.29l1.16,-1.99l0.49,0.53l2.03,0.42l1.2,-1.16l0.02,-0.47l-2.66,-3.51l-2.28,-0.61l-5.64,-0.71l-0.4,-0.57l-0.79,0.13l0.2,-0.41l-0.22,-0.55l-0.68,-0.26l0.19,-1.26l-0.78,-0.73l0.31,-0.64l-0.29,-0.57l-2.6,-0.44l-0.75,-1.63l-0.94,-0.66l-4.31,-0.65l-1.13,1.19l-1.48,0.59l-0.85,1.06l-2.83,-0.76l-2.09,0.39l-2.39,-0.97l-4.24,-0.7l-0.57,-0.4l-0.41,-1.63l-0.4,-0.3l-0.85,0.02l-0.39,0.4l-0.01,0.85l-69.13,-0.01l-6.51,-4.52l-4.5,-1.38l-1.26,-2.66l0.33,-1.93l-0.23,-0.43l-3.01,-1.35l-0.55,-2.77l-2.89,-2.38l-0.04,-1.45l1.39,-1.83l-0.28,-2.55l-4.16,-2.2l-4.07,-6.6l-4.02,-3.22l-1.3,-1.88l-0.5,-0.13l-2.51,1.21l-2.23,1.87l-3.85,-3.88l-2.44,-1.04l-2.22,-0.13l0.03,-37.49ZM260.37,148.65l3.04,0.76l2.26,1.2l-3.78,-0.95l-1.53,-1.01ZM249.4,3.81l6.68,0.49l5.32,0.79l4.26,1.57l-0.07,1.1l-5.85,2.53l-6.02,1.21l-2.39,1.39l-0.18,0.45l0.39,0.29l4.01,-0.02l-4.65,2.82l-4.2,1.74l-4.19,4.59l-5.03,0.92l-1.67,1.15l-7.47,0.59l-0.37,0.37l0.32,0.42l2.41,0.49l-0.81,0.47l-0.12,0.59l1.83,2.41l-2.02,1.59l-3.81,1.51l-1.32,2.16l-3.38,1.53l-0.22,0.48l0.35,1.19l0.4,0.29l3.88,-0.18l0.03,0.61l-6.33,2.95l-6.41,-1.4l-7.43,0.79l-3.72,-0.62l-4.4,-0.25l-0.23,-1.83l4.29,-1.11l0.28,-0.51l-1.1,-3.45l1.0,-0.25l6.58,2.28l0.47,-0.16l-0.05,-0.49l-3.41,-3.45l-3.58,-0.98l1.48,-1.55l4.34,-1.29l0.97,-2.19l-0.16,-0.48l-3.42,-2.13l-0.81,-2.26l6.2,0.22l2.24,0.58l3.91,-2.1l0.2,-0.43l-0.35,-0.32l-5.64,-0.67l-8.73,0.36l-4.26,-1.9l-2.12,-2.4l-2.78,-1.66l-0.41,-1.52l3.31,-1.03l2.93,-0.2l4.91,-0.99l3.7,-2.27l2.87,0.3l2.62,1.67l0.56,-0.14l1.82,-3.2l3.13,-0.94l4.44,-0.69l7.53,-0.26l1.48,0.67l7.19,-1.06l10.8,0.79ZM203.85,57.54l0.01,0.42l1.97,2.97l0.68,-0.02l2.24,-3.72l5.95,-1.86l4.01,4.64l-0.35,2.91l0.5,0.43l4.95,-1.36l2.32,-1.8l5.31,2.28l3.27,2.11l0.3,1.84l0.48,0.33l4.42,-0.99l2.64,2.87l5.97,1.77l2.06,1.72l2.11,3.71l-4.19,1.86l-0.01,0.73l5.9,2.83l3.94,0.94l3.78,3.95l3.46,0.25l-0.63,2.37l-4.11,4.47l-2.76,-1.56l-3.9,-3.94l-3.59,0.41l-0.33,0.34l-0.19,2.72l2.63,2.38l3.42,1.89l0.94,0.97l1.55,3.75l-0.7,2.29l-2.74,-0.92l-6.25,-3.15l-0.51,0.13l0.05,0.52l6.07,5.69l0.18,0.59l-6.09,-1.39l-5.31,-2.24l-2.63,-1.66l0.6,-0.77l-0.12,-0.6l-7.39,-4.01l-0.59,0.37l0.03,0.79l-6.73,0.6l-1.69,-1.1l1.36,-2.46l4.51,-0.07l5.15,-0.52l0.31,-0.6l-0.74,-1.3l0.78,-1.84l3.21,-4.05l-0.67,-2.35l-1.11,-1.6l-3.84,-2.1l-4.35,-1.28l0.91,-0.63l0.06,-0.61l-2.65,-2.75l-2.34,-0.36l-1.89,-1.46l-0.53,0.03l-1.24,1.23l-4.36,0.55l-9.04,-0.99l-9.26,-1.98l-1.6,-1.22l2.22,-1.77l0.13,-0.44l-0.38,-0.27l-3.22,-0.02l-0.72,-4.25l1.83,-4.04l2.42,-1.85l5.5,-1.1l-1.39,2.35ZM261.19,159.33l2.07,0.61l1.44,-0.04l-1.15,0.63l-2.94,-1.23l-0.4,-0.68l0.36,-0.37l0.61,1.07ZM230.83,84.39l-2.37,0.18l-0.49,-1.63l0.93,-2.09l1.94,-0.51l1.62,0.99l0.02,1.52l-1.66,1.54ZM229.43,58.25l0.11,0.65l-4.87,-0.21l-2.72,0.62l-3.1,-2.57l0.08,-1.26l0.86,-0.23l5.57,0.51l4.08,2.5ZM222.0,105.02l-0.72,1.49l-0.63,-0.19l-0.48,-0.84l0.81,-0.99l0.65,0.05l0.37,0.46ZM183.74,38.32l2.9,1.7l4.79,-0.01l1.84,1.46l-0.49,1.68l0.23,0.48l2.82,1.14l1.76,1.26l7.01,0.65l4.1,-1.1l5.03,-0.43l3.93,0.35l2.48,1.77l0.46,1.7l-1.3,1.1l-3.56,1.01l-3.23,-0.59l-7.17,0.76l-5.09,0.09l-3.99,-0.6l-6.42,-1.54l-0.79,-2.51l-0.3,-2.49l-2.64,-2.5l-5.32,-0.72l-2.52,-1.4l0.68,-1.57l4.78,0.31ZM207.38,91.35l0.4,1.56l0.56,0.26l1.06,-0.52l1.32,0.96l5.42,2.57l0.2,1.68l0.46,0.35l1.68,-0.28l1.15,0.85l-1.55,0.87l-3.61,-0.88l-1.32,-1.69l-0.57,-0.06l-2.45,2.1l-3.12,1.79l-0.7,-1.87l-0.42,-0.26l-2.16,0.24l1.39,-1.39l0.32,-3.14l0.76,-3.35l1.18,0.22ZM215.49,102.6l-2.67,1.95l-1.4,-0.07l-0.3,-0.58l1.53,-1.48l2.84,0.18ZM202.7,24.12l2.53,1.59l-2.87,1.4l-4.53,4.05l-4.25,0.38l-5.03,-0.68l-2.45,-2.04l0.03,-1.62l1.82,-1.37l0.14,-0.45l-0.38,-0.27l-4.45,0.04l-2.59,-1.76l-1.41,-2.29l1.57,-2.32l1.62,-1.66l2.44,-0.39l0.25,-0.65l-0.6,-0.74l4.86,-0.25l3.24,3.11l8.16,2.3l1.9,3.61ZM187.47,59.2l-2.76,3.49l-2.38,-0.15l-1.44,-3.84l0.04,-2.2l1.19,-1.88l2.3,-1.23l5.07,0.17l4.11,1.02l-3.24,3.72l-2.88,0.89ZM186.07,48.79l-1.08,1.53l-3.34,-0.34l-2.56,-1.1l1.03,-1.75l3.25,-1.23l1.95,1.58l0.75,1.3ZM185.71,35.32l-5.3,-0.2l-0.32,-0.71l4.31,0.07l1.3,0.84ZM180.68,32.48l-3.34,1.0l-1.79,-1.1l-0.98,-1.87l-0.15,-1.73l4.1,0.53l2.67,1.7l-0.51,1.47ZM180.9,76.31l-1.1,1.08l-3.13,-1.23l-2.12,0.43l-2.71,-1.57l1.72,-1.09l1.55,-1.72l3.81,1.9l1.98,2.2ZM169.74,54.87l2.96,0.97l4.17,-0.57l0.41,0.88l-2.14,2.11l0.09,0.64l3.55,1.92l-0.4,3.72l-3.79,1.65l-2.17,-0.35l-1.72,-1.74l-6.02,-3.5l0.03,-0.85l4.68,0.54l0.4,-0.21l-0.05,-0.45l-2.48,-2.81l2.46,-1.95ZM174.45,40.74l1.37,1.73l0.07,2.44l-1.05,3.45l-3.79,0.47l-2.32,-0.69l0.05,-2.64l-0.44,-0.41l-3.68,0.35l-0.12,-3.1l2.45,0.1l3.67,-1.73l3.41,0.29l0.37,-0.26ZM170.05,31.55l0.67,1.56l-3.33,-0.49l-4.22,-1.77l-4.35,-0.16l1.4,-0.94l-0.06,-0.7l-2.81,-1.23l-0.12,-1.39l4.39,0.68l6.62,1.98l1.81,2.47ZM134.5,58.13l-1.02,1.82l0.45,0.58l5.4,-1.39l3.33,2.29l0.49,-0.03l2.6,-2.23l1.94,1.32l2.0,4.5l0.7,0.06l1.3,-2.29l-1.63,-4.46l1.69,-0.54l2.31,0.71l2.65,1.81l2.49,7.92l8.48,4.27l-0.19,1.35l-3.79,0.33l-0.26,0.67l1.4,1.49l-0.58,1.1l-4.23,-0.64l-4.43,-1.19l-3.0,0.28l-4.66,1.47l-10.52,1.04l-1.43,-2.02l-3.42,-1.2l-2.21,0.43l-2.51,-2.86l4.84,-1.05l3.6,0.19l3.27,-0.78l0.31,-0.39l-0.31,-0.39l-4.84,-1.06l-8.79,0.27l-0.85,-1.07l5.26,-1.66l0.27,-0.45l-0.4,-0.34l-3.8,0.06l-3.81,-1.06l1.81,-3.01l1.66,-1.79l6.48,-2.81l1.97,0.71ZM158.7,56.61l-1.7,2.44l-3.2,-2.75l0.37,-0.3l3.11,-0.18l1.42,0.79ZM149.61,42.73l1.01,1.89l0.5,0.18l2.14,-0.82l2.23,0.19l0.36,2.04l-1.33,2.09l-8.28,0.76l-6.35,2.15l-3.41,0.1l-0.19,-0.96l4.9,-2.08l0.23,-0.46l-0.41,-0.31l-11.25,0.59l-2.89,-0.74l3.04,-4.44l2.14,-1.32l6.81,1.69l4.58,3.06l4.37,0.39l0.36,-0.63l-3.36,-4.6l1.85,-1.53l2.18,0.51l0.77,2.26ZM144.76,34.41l-4.36,1.44l-3.0,-1.4l1.46,-1.24l3.47,-0.52l2.96,0.71l-0.52,1.01ZM145.13,29.83l-1.9,0.66l-3.67,-0.0l2.27,-1.61l3.3,0.95ZM118.92,65.79l-6.03,2.02l-1.33,-1.9l-5.38,-2.28l2.59,-5.05l2.16,-3.14l-0.02,-0.48l-1.97,-2.41l7.64,-0.7l3.6,1.02l6.3,0.27l4.42,2.95l-2.53,0.98l-6.24,3.43l-3.1,3.28l-0.11,2.01ZM129.54,35.53l-0.28,3.37l-1.72,1.62l-2.33,0.28l-4.61,2.19l-3.86,0.76l-2.64,-0.87l3.72,-3.4l5.01,-3.34l3.72,0.07l3.0,-0.67ZM111.09,152.69l-0.67,0.24l-3.85,-1.37l-0.83,-1.17l-2.12,-1.07l-0.66,-1.02l-2.4,-0.55l-0.74,-1.71l6.02,1.45l2.0,2.55l2.52,1.39l0.73,1.27ZM87.8,134.64l0.89,0.29l1.86,-0.21l-0.65,3.34l1.69,2.33l-1.31,-1.33l-0.99,-1.62l-1.17,-0.98l-0.33,-1.82Z", name: "Canada" }, CG: { path: "M466.72,276.48l-0.1,1.03l-1.25,2.97l-0.19,3.62l-0.46,1.78l-0.23,0.63l-1.61,1.19l-1.21,1.39l-1.09,2.43l0.04,2.09l-3.25,3.24l-0.5,-0.24l-0.5,-0.83l-1.36,-0.02l-0.98,0.89l-1.68,-0.99l-1.54,1.24l-1.52,-1.96l1.57,-1.14l0.11,-0.52l-0.77,-1.35l2.1,-0.66l0.39,-0.73l1.05,0.82l2.21,0.11l1.12,-1.37l0.37,-1.81l-0.27,-2.09l-1.13,-1.5l1.0,-2.69l-0.13,-0.45l-0.92,-0.58l-1.6,0.17l-0.51,-0.94l0.1,-0.61l2.75,0.09l3.97,1.24l0.51,-0.33l0.17,-1.28l1.24,-2.21l1.28,-1.14l2.76,0.49Z", name: "Congo" }, CF: { path: "M461.16,278.2l-0.26,-1.19l-1.09,-0.77l-0.84,-1.17l-0.29,-1.0l-1.04,-1.15l0.08,-3.43l0.58,-0.49l1.16,-2.35l1.85,-0.17l0.61,-0.62l0.97,0.58l3.15,-0.96l2.48,-1.92l0.02,-0.96l2.81,0.02l2.36,-1.17l1.93,-2.85l1.16,-0.93l1.11,-0.3l0.27,0.86l1.34,1.47l-0.39,2.01l0.3,1.01l4.01,2.75l0.17,0.93l2.63,2.31l0.6,1.44l2.08,1.4l-3.84,-0.21l-1.94,0.88l-1.23,-0.49l-2.67,1.2l-1.29,-0.18l-0.51,0.36l-0.6,1.22l-3.35,-0.65l-1.57,-0.91l-2.42,-0.83l-1.45,0.91l-0.97,1.27l-0.26,1.56l-3.22,-0.43l-1.49,1.33l-0.94,1.62Z", name: "Central African Rep." }, CD: { path: "M487.01,272.38l2.34,-0.14l1.35,1.84l1.34,0.45l0.86,-0.39l1.21,0.12l1.07,-0.41l0.54,0.89l2.04,1.54l-0.14,2.72l0.7,0.54l-1.38,1.13l-1.53,2.54l-0.17,2.05l-0.59,1.08l-0.02,1.72l-0.72,0.84l-0.66,3.01l0.63,1.32l-0.44,4.26l0.64,1.47l-0.37,1.22l0.86,1.8l1.53,1.41l0.3,1.26l0.44,0.5l-4.08,0.75l-0.92,1.81l0.51,1.34l-0.74,5.43l0.17,0.38l2.45,1.46l0.54,-0.1l0.12,1.62l-1.28,-0.01l-1.85,-2.35l-1.94,-0.45l-0.48,-1.13l-0.55,-0.2l-1.41,0.74l-1.71,-0.3l-1.01,-1.18l-2.49,-0.19l-0.44,-0.77l-1.98,-0.21l-2.88,0.36l0.11,-2.41l-0.85,-1.13l-0.16,-1.36l0.32,-1.73l-0.46,-0.89l-0.04,-1.49l-0.4,-0.39l-2.53,0.02l0.1,-0.41l-0.39,-0.49l-1.28,0.01l-0.43,0.45l-1.62,0.32l-0.83,1.79l-1.09,-0.28l-2.4,0.52l-1.37,-1.91l-1.3,-3.3l-0.38,-0.27l-7.39,-0.03l-2.46,0.42l0.5,-0.45l0.37,-1.47l0.66,-0.38l0.92,0.08l0.73,-0.82l0.87,0.02l0.31,0.68l1.4,0.36l3.59,-3.63l0.01,-2.23l1.02,-2.29l2.69,-2.39l0.43,-0.99l0.49,-1.96l0.17,-3.51l1.25,-2.95l0.36,-3.14l0.86,-1.13l1.1,-0.66l3.57,1.73l3.65,0.73l0.46,-0.21l0.8,-1.46l1.24,0.19l2.61,-1.17l0.81,0.44l1.04,-0.03l0.59,-0.66l0.7,-0.16l1.81,0.25Z", name: "Dem. Rep. Congo" }, CZ: { path: "M458.46,144.88l1.22,1.01l1.47,0.23l0.13,0.93l1.36,0.68l0.54,-0.2l0.24,-0.55l1.15,0.25l0.53,1.09l1.68,0.18l0.6,0.84l-1.04,0.73l-0.96,1.28l-1.6,0.17l-0.55,0.56l-1.04,-0.46l-1.05,0.15l-2.12,-0.96l-1.05,0.34l-1.2,1.12l-1.56,-0.87l-2.57,-2.1l-0.53,-1.88l4.7,-2.52l0.71,0.26l0.9,-0.28Z", name: "Czech Rep." }, CY: { path: "M504.36,193.47l0.43,0.28l-1.28,0.57l-0.92,-0.28l-0.24,-0.46l2.01,-0.13Z", name: "Cyprus" }, CR: { path: "M211.34,258.05l0.48,0.99l1.6,1.6l-0.54,0.45l0.29,1.42l-0.25,1.19l-1.09,-0.59l-0.05,-1.25l-2.46,-1.42l-0.28,-0.77l-0.66,-0.45l-0.45,-0.0l-0.11,1.04l-1.32,-0.95l0.31,-1.3l-0.36,-0.6l0.31,-0.27l1.42,0.58l1.29,-0.14l0.56,0.56l0.74,0.17l0.55,-0.27Z", name: "Costa Rica" }, CU: { path: "M221.21,227.25l1.27,1.02l2.19,-0.28l4.43,3.33l2.08,0.43l-0.1,0.38l0.36,0.5l1.75,0.1l1.48,0.84l-3.11,0.51l-4.15,-0.03l0.77,-0.67l-0.04,-0.64l-1.2,-0.74l-1.49,-0.16l-0.7,-0.61l-0.56,-1.4l-0.4,-0.25l-1.34,0.1l-2.2,-0.66l-0.88,-0.58l-3.18,-0.4l-0.27,-0.16l0.58,-0.74l-0.36,-0.29l-2.72,-0.05l-1.7,1.29l-0.91,0.03l-0.61,0.69l-1.01,0.22l1.11,-1.29l1.01,-0.52l3.69,-1.01l3.98,0.21l2.21,0.84Z", name: "Cuba" }, SZ: { path: "M500.35,351.36l0.5,2.04l-0.38,0.89l-1.05,0.21l-1.23,-1.2l-0.02,-0.64l0.83,-1.57l1.34,0.27Z", name: "Swaziland" }, SY: { path: "M511.0,199.79l0.05,-1.33l0.54,-1.36l1.28,-0.99l0.13,-0.45l-0.41,-1.11l-1.14,-0.36l-0.19,-1.74l0.52,-1.0l1.29,-1.21l0.2,-1.18l0.59,0.23l2.62,-0.76l1.36,0.52l2.06,-0.01l2.95,-1.08l3.25,-0.26l-0.67,0.94l-1.28,0.66l-0.21,0.4l0.23,2.01l-0.88,3.19l-10.15,5.73l-2.15,-0.85Z", name: "Syria" }, KG: { path: "M621.35,172.32l-3.87,1.69l-0.96,1.18l-3.04,0.34l-1.13,1.86l-2.36,-0.35l-1.99,0.63l-2.39,1.4l0.06,0.95l-0.4,0.37l-4.52,0.43l-3.02,-0.93l-2.37,0.17l0.11,-0.79l2.32,0.42l1.13,-0.88l1.99,0.2l3.21,-2.14l-0.03,-0.69l-2.97,-1.57l-1.94,0.65l-1.22,-0.74l1.71,-1.58l-0.12,-0.67l-0.36,-0.15l0.32,-0.77l1.36,-0.35l4.02,1.02l0.49,-0.3l0.35,-1.59l1.09,-0.48l3.42,1.22l1.11,-0.31l7.64,0.39l1.16,1.0l1.23,0.39Z", name: "Kyrgyzstan" }, KE: { path: "M506.26,284.69l1.87,-2.56l0.93,-2.15l-1.38,-4.08l-1.06,-1.6l2.82,-2.75l0.79,0.26l0.12,1.41l0.86,0.83l1.9,0.11l3.28,2.13l3.57,0.44l1.05,-1.12l1.96,-0.9l0.82,0.68l1.16,0.09l-1.78,2.45l0.03,9.12l1.3,1.94l-1.37,0.78l-0.67,1.03l-1.08,0.46l-0.34,1.67l-0.81,1.07l-0.45,1.55l-0.68,0.56l-3.2,-2.23l-0.35,-1.58l-8.86,-4.98l0.14,-1.6l-0.57,-1.04Z", name: "Kenya" }, SS: { path: "M481.71,263.34l1.07,-0.72l1.2,-3.18l1.36,-0.26l1.61,1.99l0.87,0.34l1.1,-0.41l1.5,0.07l0.57,0.53l2.49,0.0l0.44,-0.63l1.07,-0.4l0.45,-0.84l0.59,-0.33l1.9,1.33l1.6,-0.2l2.83,-3.33l-0.32,-2.21l1.59,-0.52l-0.24,1.6l0.3,1.83l1.35,1.18l0.2,1.87l0.35,0.41l0.02,1.53l-0.23,0.47l-1.42,0.25l-0.85,1.44l0.3,0.6l1.4,0.16l1.11,1.08l0.59,1.13l1.03,0.53l1.28,2.36l-4.41,3.98l-1.74,0.01l-1.89,0.55l-1.47,-0.52l-1.15,0.57l-2.96,-2.62l-1.3,0.49l-1.06,-0.15l-0.79,0.39l-0.82,-0.22l-1.8,-2.7l-1.91,-1.1l-0.66,-1.5l-2.62,-2.32l-0.18,-0.94l-2.37,-1.6Z", name: "S. Sudan" }, SR: { path: "M283.12,270.19l2.1,0.53l-1.08,1.95l0.2,1.72l0.93,1.49l-0.59,2.03l-0.43,0.71l-1.12,-0.42l-1.32,0.22l-0.93,-0.2l-0.46,0.26l-0.25,0.73l0.33,0.7l-0.89,-0.13l-1.39,-1.97l-0.31,-1.34l-0.97,-0.31l-0.89,-1.47l0.35,-1.61l1.45,-0.82l0.33,-1.87l2.61,0.44l0.57,-0.47l1.75,-0.16Z", name: "Suriname" }, KH: { path: "M689.52,249.39l0.49,1.45l-0.28,2.74l-4.0,1.86l-0.16,0.6l0.68,0.95l-2.06,0.17l-2.05,0.97l-1.82,-0.32l-2.12,-3.7l-0.55,-2.85l1.4,-1.85l3.02,-0.45l2.23,0.35l2.01,0.98l0.51,-0.14l0.95,-1.48l1.74,0.74Z", name: "Cambodia" }, SV: { path: "M195.8,250.13l1.4,-1.19l2.24,1.45l0.98,-0.27l0.44,0.2l-0.27,1.05l-1.14,-0.03l-3.64,-1.21Z", name: "El Salvador" }, SK: { path: "M476.82,151.17l-1.14,1.9l-2.73,-0.92l-0.82,0.2l-0.74,0.8l-3.46,0.73l-0.47,0.69l-1.76,0.33l-1.88,-1.0l-0.18,-0.81l0.38,-0.75l1.87,-0.32l1.74,-1.89l0.83,0.16l0.79,-0.34l1.51,1.04l1.34,-0.63l1.25,0.3l1.65,-0.42l1.81,0.95Z", name: "Slovakia" }, KR: { path: "M737.51,185.84l0.98,-0.1l0.87,-1.17l2.69,-0.32l0.33,-0.29l1.76,2.79l0.58,1.76l0.02,3.12l-0.8,1.32l-2.21,0.55l-1.93,1.13l-1.8,0.19l-0.2,-1.1l0.43,-2.28l-0.95,-2.56l1.43,-0.37l0.23,-0.62l-1.43,-2.06Z", name: "Korea" }, SI: { path: "M456.18,162.07l-0.51,-1.32l0.18,-1.05l1.69,0.2l1.42,-0.71l2.09,-0.07l0.62,-0.51l0.21,0.47l-1.61,0.67l-0.44,1.34l-0.66,0.24l-0.26,0.82l-1.22,-0.49l-0.84,0.46l-0.69,-0.04Z", name: "Slovenia" }, KP: { path: "M736.77,185.16l-0.92,-0.42l-0.88,0.62l-1.21,-0.88l0.96,-1.15l0.59,-2.59l-0.46,-0.74l-2.09,-0.77l1.64,-1.52l2.72,-1.58l1.58,-1.91l1.11,0.78l2.17,0.11l0.41,-0.5l-0.3,-1.22l3.52,-1.18l0.94,-1.4l0.98,1.08l-2.19,2.18l0.01,2.14l-1.06,0.54l-1.41,1.4l-1.7,0.52l-1.25,1.09l-0.14,1.98l0.94,0.45l1.15,1.04l-0.13,0.26l-2.6,0.29l-1.13,1.29l-1.22,0.08Z", name: "Dem. Rep. Korea" }, SO: { path: "M525.13,288.48l-1.13,-1.57l-0.03,-8.86l2.66,-3.38l1.67,-0.13l2.13,-1.69l3.41,-0.23l7.08,-7.55l2.91,-3.69l0.08,-4.82l2.98,-0.67l1.24,-0.86l0.45,-0.0l-0.2,3.0l-1.21,3.62l-2.73,5.97l-2.13,3.65l-5.03,6.16l-8.56,6.4l-2.78,3.08l-0.8,1.56Z", name: "Somalia" }, SN: { path: "M390.09,248.21l0.12,1.55l0.49,1.46l0.96,0.82l0.05,1.28l-1.26,-0.19l-0.75,0.33l-1.84,-0.61l-5.84,-0.13l-2.54,0.51l-0.22,-1.03l1.77,0.04l2.01,-0.91l1.03,0.48l1.09,0.04l1.29,-0.62l0.14,-0.58l-0.51,-0.74l-1.81,0.25l-1.13,-0.63l-0.79,0.04l-0.72,0.61l-2.31,0.06l-0.92,-1.77l-0.81,-0.64l0.64,-0.35l2.46,-3.74l1.04,0.19l1.38,-0.56l1.19,-0.02l2.72,1.37l3.03,3.48Z", name: "Senegal" }, SL: { path: "M394.46,264.11l-1.73,1.98l-0.58,1.33l-2.07,-1.06l-1.22,-1.26l-0.65,-2.39l1.16,-0.96l0.67,-1.17l1.21,-0.52l1.66,0.0l1.03,1.64l0.52,2.41Z", name: "Sierra Leone" }, SB: { path: "M826.69,311.6l-0.61,0.09l-0.2,-0.33l0.37,0.15l0.44,0.09ZM824.18,307.38l-0.26,-0.3l-0.31,-0.91l0.03,0.0l0.54,1.21ZM823.04,309.33l-1.66,-0.22l-0.2,-0.52l1.16,0.28l0.69,0.46ZM819.28,304.68l1.14,0.65l0.02,0.03l-0.81,-0.44l-0.35,-0.23Z", name: "Solomon Is." }, SA: { path: "M537.53,210.34l2.0,0.24l0.9,1.32l1.49,-0.06l0.87,2.08l1.29,0.76l0.51,0.99l1.56,1.03l-0.1,1.9l0.32,0.9l1.58,2.47l0.76,0.53l0.7,-0.04l1.68,4.23l7.53,1.33l0.51,-0.29l0.77,1.25l-1.55,4.87l-7.29,2.52l-7.3,1.03l-2.34,1.17l-1.88,2.74l-0.76,0.28l-0.82,-0.78l-0.91,0.12l-2.88,-0.51l-3.51,0.25l-0.86,-0.56l-0.57,0.15l-0.66,1.27l0.16,1.11l-0.43,0.32l-0.93,-1.4l-0.33,-1.16l-1.23,-0.88l-1.27,-2.06l-0.78,-2.22l-1.73,-1.79l-1.14,-0.48l-1.54,-2.31l-0.21,-3.41l-1.44,-2.93l-1.27,-1.16l-1.33,-0.57l-1.31,-3.37l-0.77,-0.67l-0.97,-1.97l-2.8,-4.03l-1.06,-0.17l0.37,-1.96l0.2,-0.72l2.74,0.3l1.08,-0.84l0.6,-0.94l1.74,-0.35l0.65,-1.03l0.71,-0.4l0.1,-0.62l-2.06,-2.28l4.39,-1.22l0.48,-0.37l2.77,0.69l3.66,1.9l7.03,5.5l4.87,0.3Z", name: "Saudi Arabia" }, SE: { path: "M480.22,89.3l-4.03,1.17l-2.43,2.86l0.26,2.57l-8.77,6.64l-1.78,5.79l1.78,2.68l2.22,1.96l-2.07,3.77l-2.72,1.13l-0.95,6.04l-1.29,3.01l-2.74,-0.31l-0.4,0.22l-1.31,2.59l-2.34,0.13l-0.75,-3.09l-2.08,-4.03l-1.83,-4.96l1.0,-1.93l2.14,-2.7l0.83,-4.45l-1.6,-2.17l-0.15,-4.94l1.48,-3.39l2.58,-0.15l0.87,-1.59l-0.78,-1.57l3.76,-5.59l4.04,-7.48l2.17,0.01l0.39,-0.29l0.57,-2.07l4.37,0.64l0.46,-0.34l0.33,-2.56l1.1,-0.13l6.94,4.87l0.06,6.32l0.66,1.36Z", name: "Sweden" }, SD: { path: "M505.98,259.4l-0.34,-0.77l-1.17,-0.9l-0.26,-1.61l0.29,-1.81l-0.34,-0.46l-1.16,-0.17l-0.54,0.59l-1.23,0.11l-0.28,0.65l0.53,0.65l0.17,1.22l-2.44,3.0l-0.96,0.19l-2.39,-1.4l-0.95,0.52l-0.38,0.78l-1.11,0.41l-0.29,0.5l-1.94,0.0l-0.54,-0.52l-1.81,-0.09l-0.95,0.4l-2.45,-2.35l-2.07,0.54l-0.73,1.26l-0.6,2.1l-1.25,0.58l-0.75,-0.62l0.27,-2.65l-1.48,-1.78l-0.22,-1.48l-0.92,-0.96l-0.02,-1.29l-0.57,-1.16l-0.68,-0.16l0.69,-1.29l-0.18,-1.14l0.65,-0.62l0.03,-0.55l-0.36,-0.41l1.55,-2.97l1.91,0.16l0.43,-0.4l-0.1,-10.94l2.49,-0.01l0.4,-0.4l-0.0,-4.82l29.02,0.0l0.64,2.04l-0.49,0.66l0.36,2.69l0.93,3.16l2.12,1.55l-0.89,1.04l-1.72,0.39l-0.98,0.9l-1.43,5.65l0.24,1.15l-0.38,2.06l-0.96,2.38l-1.53,1.31l-1.32,2.91l-1.22,0.86l-0.37,1.34Z", name: "Sudan" }, DO: { path: "M241.8,239.2l0.05,-0.65l-0.46,-0.73l0.42,-0.44l0.19,-1.0l-0.09,-1.53l1.66,0.01l1.99,0.63l0.33,0.67l1.28,0.19l0.33,0.76l1.0,0.08l0.8,0.62l-0.45,0.51l-1.13,-0.47l-1.88,-0.01l-1.27,0.59l-0.75,-0.55l-1.01,0.54l-0.79,1.4l-0.23,-0.61Z", name: "Dominican Rep." }, DJ: { path: "M528.43,256.18l-0.45,0.66l-0.58,-0.25l-1.51,0.13l-0.18,-1.01l1.45,-1.95l0.83,0.17l0.77,-0.44l0.2,1.0l-1.2,0.51l-0.06,0.7l0.73,0.47Z", name: "Djibouti" }, DK: { path: "M452.28,129.07l-1.19,2.24l-2.13,-1.6l-0.23,-0.95l2.98,-0.95l0.57,1.26ZM447.74,126.31l-0.26,0.57l-0.88,-0.07l-1.8,2.53l0.48,1.69l-1.09,0.36l-1.61,-0.39l-0.89,-1.69l-0.07,-3.43l0.96,-1.73l2.02,-0.2l1.09,-1.07l1.33,-0.67l-0.05,1.06l-0.73,1.41l0.3,1.0l1.2,0.64Z", name: "Denmark" }, DE: { path: "M453.14,155.55l-0.55,-0.36l-1.2,-0.1l-1.87,0.57l-2.13,-0.13l-0.56,0.63l-0.86,-0.6l-0.96,0.09l-2.57,-0.93l-0.85,0.67l-1.47,-0.02l0.24,-1.75l1.23,-2.14l-0.28,-0.59l-3.52,-0.58l-0.92,-0.66l0.12,-1.2l-0.48,-0.88l0.27,-2.17l-0.37,-3.03l1.41,-0.22l0.63,-1.26l0.66,-3.19l-0.41,-1.18l0.26,-0.39l1.66,-0.15l0.33,0.54l0.62,0.07l1.7,-1.69l-0.54,-3.02l1.37,0.33l1.31,-0.37l0.31,1.18l2.25,0.71l-0.02,0.92l0.5,0.4l2.55,-0.65l1.34,-0.87l2.57,1.24l1.06,0.98l0.48,1.44l-0.57,0.74l-0.0,0.48l0.87,1.15l0.57,1.64l-0.14,1.29l0.82,1.7l-1.5,-0.07l-0.56,0.57l-4.47,2.15l-0.22,0.54l0.68,2.26l2.58,2.16l-0.66,1.11l-0.79,0.36l-0.23,0.43l0.32,1.87Z", name: "Germany" }, YE: { path: "M528.27,246.72l0.26,-0.42l-0.22,-1.01l0.19,-1.5l0.92,-0.69l-0.07,-1.35l0.39,-0.75l1.01,0.47l3.34,-0.27l3.76,0.41l0.95,0.81l1.36,-0.58l1.74,-2.62l2.18,-1.09l6.86,-0.94l2.48,5.41l-1.64,0.76l-0.56,1.9l-6.23,2.16l-2.29,1.8l-1.93,0.05l-1.41,1.02l-4.24,0.74l-1.72,1.49l-3.28,0.19l-0.52,-1.18l0.02,-1.51l-1.34,-3.29Z", name: "Yemen" }, AT: { path: "M462.89,152.8l0.04,2.25l-1.07,0.0l-0.33,0.63l0.36,0.51l-1.04,2.13l-2.02,0.07l-1.33,0.7l-5.29,-0.99l-0.47,-0.93l-0.44,-0.21l-2.47,0.55l-0.42,0.51l-3.18,-0.81l0.43,-0.91l1.12,0.78l0.6,-0.17l0.25,-0.58l1.93,0.12l1.86,-0.56l1.0,0.08l0.68,0.57l0.62,-0.15l0.26,-0.77l-0.3,-1.78l0.8,-0.44l0.68,-1.15l1.52,0.85l0.47,-0.06l1.34,-1.25l0.64,-0.17l1.81,0.92l1.28,-0.11l0.7,0.37Z", name: "Austria" }, DZ: { path: "M441.46,188.44l-0.32,1.07l0.39,2.64l-0.54,2.16l-1.58,1.82l0.37,2.39l1.91,1.55l0.18,0.8l1.42,1.03l1.84,7.23l0.12,1.16l-0.57,5.0l0.2,1.51l-0.87,0.99l-0.02,0.51l1.41,1.86l0.14,1.2l0.89,1.48l0.5,0.16l0.98,-0.41l1.73,1.08l0.82,1.23l-8.22,4.81l-7.23,5.11l-3.43,1.13l-2.3,0.21l-0.28,-1.59l-2.56,-1.09l-0.67,-1.25l-26.12,-17.86l0.01,-3.47l3.77,-1.88l2.44,-0.41l2.12,-0.75l1.08,-1.42l2.81,-1.05l0.35,-2.08l1.33,-0.29l1.04,-0.94l3.47,-0.69l0.46,-1.08l-0.1,-0.45l-0.58,-0.52l-0.82,-2.81l-0.19,-1.83l-0.78,-1.49l2.03,-1.31l2.63,-0.48l1.7,-1.22l2.31,-0.84l8.24,-0.73l1.49,0.38l2.28,-1.1l2.46,-0.02l0.92,0.6l1.35,-0.05Z", name: "Algeria" }, US: { path: "M892.72,99.2l1.31,0.53l1.41,-0.37l1.89,0.98l1.89,0.42l-1.32,0.58l-2.9,-1.53l-2.08,0.22l-0.26,-0.15l0.07,-0.67ZM183.22,150.47l0.37,1.47l1.12,0.85l4.23,0.7l2.39,0.98l2.17,-0.38l1.85,0.5l-1.55,0.65l-3.49,2.61l-0.16,0.77l0.5,0.39l2.33,-0.61l1.77,1.02l5.15,-2.4l-0.31,0.65l0.25,0.56l1.36,0.38l1.71,1.16l4.7,-0.88l0.67,0.85l1.31,0.21l0.58,0.58l-1.34,0.17l-2.18,-0.32l-3.6,0.89l-2.71,3.25l0.35,0.9l0.59,-0.0l0.55,-0.6l-1.36,4.65l0.29,3.09l0.67,1.58l0.61,0.45l1.77,-0.44l1.6,-1.96l0.14,-2.21l-0.82,-1.96l0.11,-1.13l1.19,-2.37l0.44,-0.33l0.48,0.75l0.4,-0.29l0.4,-1.37l0.6,-0.47l0.24,-0.8l1.69,0.49l1.65,1.08l-0.03,2.37l-1.27,1.13l-0.0,1.13l0.87,0.36l1.66,-1.29l0.5,0.17l0.5,2.6l-2.49,3.75l0.17,0.61l1.54,0.62l1.48,0.17l1.92,-0.44l4.72,-2.15l2.16,-1.8l-0.05,-1.24l0.75,-0.22l3.92,0.36l2.12,-1.05l0.21,-0.4l-0.28,-1.48l3.27,-2.4l8.32,-0.02l0.56,-0.82l1.9,-0.77l0.93,-1.51l0.74,-2.37l1.58,-1.98l0.92,0.62l1.47,-0.47l0.8,0.66l-0.0,4.09l1.96,2.6l-2.34,1.31l-5.37,2.09l-1.83,2.72l0.02,1.79l0.83,1.59l0.54,0.23l-6.19,0.94l-2.2,0.89l-0.23,0.48l0.45,0.29l2.99,-0.46l-2.19,0.56l-1.13,0.0l-0.15,-0.32l-0.48,0.08l-0.76,0.82l0.22,0.67l0.32,0.06l-0.41,1.62l-1.27,1.58l-1.48,-1.07l-0.49,-0.04l-0.16,0.46l0.52,1.58l0.61,0.59l0.03,0.79l-0.95,1.38l-1.21,-1.22l-0.27,-2.27l-0.35,-0.35l-0.42,0.25l-0.48,1.27l0.33,1.41l-0.97,-0.27l-0.48,0.24l0.18,0.5l1.52,0.83l0.1,2.52l0.79,0.51l0.52,3.42l-1.42,1.88l-2.47,0.8l-1.71,1.66l-1.31,0.25l-1.27,1.03l-0.43,0.99l-2.69,1.78l-2.64,3.03l-0.45,2.12l0.45,2.08l0.85,2.38l1.09,1.9l0.04,1.2l1.16,3.06l-0.18,2.69l-0.55,1.43l-0.47,0.21l-0.89,-0.23l-0.49,-1.18l-0.87,-0.56l-2.75,-5.16l0.48,-1.68l-0.72,-1.78l-2.01,-2.38l-1.12,-0.53l-2.72,1.18l-1.47,-1.35l-1.57,-0.68l-2.99,0.31l-2.17,-0.3l-2.0,0.19l-1.15,0.46l-0.19,0.58l0.39,0.63l0.14,1.34l-0.84,-0.2l-0.84,0.46l-1.58,-0.07l-2.08,-1.44l-2.09,0.33l-1.91,-0.62l-3.73,0.84l-2.39,2.07l-2.54,1.22l-1.45,1.41l-0.61,1.38l0.34,3.71l-0.29,0.02l-3.5,-1.33l-1.25,-3.11l-1.44,-1.5l-2.24,-3.56l-1.76,-1.09l-2.27,-0.01l-1.71,2.07l-1.76,-0.69l-1.16,-0.74l-1.52,-2.98l-3.93,-3.16l-4.34,-0.0l-0.4,0.4l-0.0,0.74l-6.5,0.02l-9.02,-3.14l-0.34,-0.71l-5.7,0.49l-0.43,-1.29l-1.62,-1.61l-1.14,-0.38l-0.55,-0.88l-1.28,-0.13l-1.01,-0.77l-2.22,-0.27l-0.43,-0.3l-0.36,-1.58l-2.4,-2.83l-2.01,-3.85l-0.06,-0.9l-2.92,-3.26l-0.33,-2.29l-1.3,-1.66l0.52,-2.37l-0.09,-2.57l-0.78,-2.3l0.95,-2.82l0.61,-5.68l-0.47,-4.27l-1.46,-4.08l3.19,0.79l1.26,2.83l0.69,0.08l0.69,-1.14l-1.1,-4.79l68.76,-0.0l0.4,-0.4l0.14,-0.86ZM32.44,67.52l1.73,1.97l0.55,0.05l0.99,-0.79l3.65,0.24l-0.09,0.62l0.32,0.45l3.83,0.77l2.61,-0.43l5.19,1.4l4.84,0.43l1.89,0.57l3.42,-0.7l6.14,1.87l-0.03,38.06l0.38,0.4l2.39,0.11l2.31,0.98l3.9,3.99l0.55,0.04l2.4,-2.03l2.16,-1.04l1.2,1.71l3.95,3.14l4.09,6.63l4.2,2.29l0.06,1.83l-1.02,1.23l-1.16,-1.08l-2.04,-1.03l-0.67,-2.89l-3.28,-3.03l-1.65,-3.57l-6.35,-0.32l-2.82,-1.01l-5.26,-3.85l-6.77,-2.04l-3.53,0.3l-4.81,-1.69l-3.25,-1.63l-2.78,0.8l-0.28,0.46l0.44,2.21l-3.91,0.96l-2.26,1.27l-2.3,0.65l-0.27,-1.65l1.05,-3.42l2.49,-1.09l0.16,-0.6l-0.69,-0.96l-0.55,-0.1l-3.19,2.12l-1.78,2.56l-3.55,2.61l-0.04,0.61l1.56,1.52l-2.07,2.29l-5.11,2.57l-0.77,1.66l-3.76,1.77l-0.92,1.73l-2.69,1.38l-1.81,-0.22l-6.95,3.32l-3.97,0.91l4.85,-2.5l2.59,-1.86l3.26,-0.52l1.19,-1.4l3.42,-2.1l2.59,-2.27l0.42,-2.68l1.23,-2.1l-0.04,-0.46l-0.45,-0.11l-2.68,1.03l-0.63,-0.49l-0.53,0.03l-1.05,1.04l-1.36,-1.54l-0.66,0.08l-0.32,0.62l-0.58,-1.14l-0.56,-0.16l-2.41,1.42l-1.07,-0.0l-0.17,-1.75l0.3,-1.71l-1.61,-1.33l-3.41,0.59l-1.96,-1.63l-1.57,-0.84l-0.15,-2.21l-1.7,-1.43l0.82,-1.88l1.99,-2.12l0.88,-1.92l1.71,-0.24l2.04,0.51l1.87,-1.77l1.91,0.25l1.91,-1.23l0.17,-0.43l-0.47,-1.82l-1.07,-0.7l1.39,-1.17l0.12,-0.45l-0.39,-0.26l-1.65,0.07l-2.66,0.88l-0.75,0.78l-1.92,-0.8l-3.46,0.44l-3.44,-0.91l-1.06,-1.61l-2.65,-1.99l2.91,-1.43l5.5,-2.0l1.52,0.0l-0.26,1.62l0.41,0.46l5.29,-0.16l0.3,-0.65l-2.03,-2.59l-3.14,-1.68l-1.79,-2.12l-2.4,-1.83l-3.09,-1.24l1.04,-1.69l4.23,-0.14l3.36,-2.07l0.73,-2.27l2.39,-1.99l2.42,-0.52l4.65,-1.97l2.46,0.23l3.71,-2.35l3.5,0.89ZM37.6,123.41l-2.25,1.23l-0.95,-0.69l-0.29,-1.24l3.21,-1.63l1.42,0.21l0.67,0.7l-1.8,1.42ZM31.06,234.03l0.98,0.47l0.74,0.87l-1.77,1.07l-0.44,-1.53l0.49,-0.89ZM29.34,232.07l0.18,0.05l0.08,0.05l-0.16,0.03l-0.11,-0.14ZM25.16,230.17l0.05,-0.03l0.18,0.22l-0.13,-0.01l-0.1,-0.18ZM5.89,113.26l-1.08,0.41l-2.21,-1.12l1.53,-0.4l1.62,0.28l0.14,0.83Z", name: "United States" }, LV: { path: "M489.16,122.85l0.96,0.66l0.22,1.65l0.68,1.76l-3.65,1.7l-2.23,-1.58l-1.29,-0.26l-0.68,-0.77l-2.42,0.34l-4.16,-0.23l-2.47,0.9l0.06,-1.98l1.13,-2.06l1.95,-1.02l2.12,2.58l2.01,-0.07l0.38,-0.33l0.44,-2.52l1.76,-0.53l3.06,1.7l2.15,0.07Z", name: "Latvia" }, UY: { path: "M286.85,372.74l-0.92,1.5l-2.59,1.44l-1.69,-0.52l-1.42,0.26l-2.39,-1.19l-1.52,0.08l-1.27,-1.3l0.16,-1.5l0.56,-0.79l-0.02,-2.73l1.21,-4.74l1.19,-0.21l2.37,2.0l1.08,0.03l4.36,3.17l1.22,1.6l-0.96,1.5l0.61,1.4Z", name: "Uruguay" }, LB: { path: "M510.37,198.01l-0.88,0.51l1.82,-3.54l0.62,0.08l0.22,0.61l-1.13,0.88l-0.65,1.47Z", name: "Lebanon" }, LA: { path: "M689.54,248.53l-1.76,-0.74l-0.49,0.15l-0.94,1.46l-1.32,-0.64l0.62,-0.98l0.11,-2.17l-2.04,-2.42l-0.25,-2.65l-1.9,-2.1l-2.15,-0.31l-0.78,0.91l-1.12,0.06l-1.05,-0.4l-2.06,1.2l-0.04,-1.59l0.61,-2.68l-0.36,-0.49l-1.35,-0.1l-0.11,-1.23l-0.96,-0.88l1.96,-1.89l0.39,0.36l1.33,0.07l0.42,-0.45l-0.34,-2.66l0.7,-0.21l1.28,1.81l1.11,2.35l0.36,0.23l2.82,0.02l0.71,1.67l-1.39,0.65l-0.72,0.93l0.13,0.6l2.91,1.51l3.6,5.25l1.88,1.78l0.56,1.62l-0.35,1.96Z", name: "Lao PDR" }, TW: { path: "M724.01,226.68l-0.74,1.48l-0.9,-1.52l-0.25,-1.74l1.38,-2.44l1.73,-1.74l0.64,0.44l-1.85,5.52Z", name: "Taiwan" }, TT: { path: "M266.64,259.32l0.28,-1.16l1.13,-0.22l-0.06,1.2l-1.35,0.18Z", name: "Trinidad and Tobago" }, TR: { path: "M513.21,175.47l3.64,1.17l3.05,-0.44l2.1,0.26l3.11,-1.56l2.46,-0.13l2.19,1.33l0.33,0.82l-0.22,1.33l0.25,0.44l2.28,1.13l-1.17,0.57l-0.21,0.45l0.75,3.2l-0.41,1.16l1.13,1.92l-0.55,0.22l-0.9,-0.67l-2.91,-0.37l-1.24,0.46l-4.23,0.41l-2.81,1.05l-1.91,0.01l-1.52,-0.53l-2.58,0.75l-0.66,-0.45l-0.62,0.3l-0.12,1.45l-0.89,0.84l-0.47,-0.67l0.79,-1.3l-0.41,-0.2l-1.43,0.23l-2.0,-0.63l-2.02,1.65l-3.51,0.3l-2.13,-1.53l-2.7,-0.1l-0.86,1.24l-1.38,0.27l-2.29,-1.44l-2.71,-0.01l-1.37,-2.65l-1.68,-1.52l1.07,-1.99l-0.09,-0.49l-1.27,-1.12l2.37,-2.41l3.7,-0.11l1.28,-2.24l4.49,0.37l3.21,-1.97l2.81,-0.82l3.99,-0.06l4.29,2.07ZM488.79,176.72l-1.72,1.31l-0.5,-0.88l1.37,-2.57l-0.7,-0.85l1.7,-0.63l1.8,0.34l0.46,1.17l1.76,0.78l-2.87,0.32l-1.3,1.01Z", name: "Turkey" }, LK: { path: "M624.16,268.99l-1.82,0.48l-0.99,-1.67l-0.42,-3.46l0.95,-3.43l1.21,0.98l2.26,4.19l-0.34,2.33l-0.85,0.58Z", name: "Sri Lanka" }, TN: { path: "M448.1,188.24l-1.0,1.27l-0.02,1.32l0.84,0.88l-0.28,2.09l-1.53,1.32l-0.12,0.42l0.48,1.54l1.42,0.32l0.53,1.11l0.9,0.52l-0.11,1.67l-3.54,2.64l-0.1,2.38l-0.58,0.3l-0.96,-4.45l-1.54,-1.25l-0.16,-0.78l-1.92,-1.56l-0.18,-1.76l1.51,-1.62l0.59,-2.34l-0.38,-2.78l0.42,-1.21l2.45,-1.05l1.29,0.26l-0.06,1.11l0.58,0.38l1.47,-0.73Z", name: "Tunisia" }, TL: { path: "M734.55,307.93l-0.1,-0.97l4.5,-0.86l-2.82,1.28l-1.59,0.55Z", name: "Timor-Leste" }, TM: { path: "M553.03,173.76l-0.04,0.34l-0.09,-0.22l0.13,-0.12ZM555.87,172.66l0.45,-0.1l1.48,0.74l2.06,2.43l4.07,-0.18l0.38,-0.51l-0.32,-1.19l1.92,-0.94l1.91,-1.59l2.94,1.39l0.43,2.47l1.19,0.67l2.58,-0.13l0.62,0.4l1.32,3.12l4.54,3.44l2.67,1.45l3.06,1.14l-0.04,1.05l-1.33,-0.75l-0.59,0.19l-0.32,0.84l-2.2,0.81l-0.46,2.13l-1.21,0.74l-1.91,0.42l-0.73,1.33l-1.56,0.31l-2.22,-0.94l-0.2,-2.17l-0.38,-0.36l-1.73,-0.09l-2.76,-2.46l-2.14,-0.4l-2.84,-1.48l-1.78,-0.27l-1.24,0.53l-1.57,-0.08l-2.0,1.69l-1.7,0.43l-0.36,-1.58l0.36,-2.98l-0.22,-0.4l-1.65,-0.84l0.54,-1.69l-0.34,-0.52l-1.22,-0.13l0.36,-1.64l2.22,0.59l2.2,-0.95l0.12,-0.65l-1.77,-1.74l-0.66,-1.57Z", name: "Turkmenistan" }, TJ: { path: "M597.75,178.82l-2.54,-0.44l-0.47,0.34l-0.24,1.7l0.43,0.45l2.64,-0.22l3.18,0.95l4.39,-0.41l0.56,2.37l0.52,0.29l0.67,-0.24l1.11,0.49l0.21,2.13l-3.76,-0.21l-1.8,1.32l-1.76,0.74l-0.61,-0.58l0.21,-2.23l-0.64,-0.49l-0.07,-0.93l-1.36,-0.66l-0.45,0.07l-1.08,1.01l-0.55,1.48l-1.31,-0.05l-0.95,1.16l-0.9,-0.35l-1.86,0.74l1.26,-2.83l-0.54,-2.17l-1.67,-0.82l0.33,-0.66l2.18,-0.04l1.19,-1.63l0.76,-1.79l2.43,-0.5l-0.26,1.0l0.73,1.05Z", name: "Tajikistan" }, LS: { path: "M491.06,363.48l-0.49,0.15l-1.49,-1.67l1.1,-1.43l2.19,-1.44l1.51,1.27l-0.98,1.82l-1.23,0.38l-0.62,0.93Z", name: "Lesotho" }, TH: { path: "M670.27,255.86l-1.41,3.87l0.15,2.0l0.38,0.36l1.38,0.07l0.9,2.04l0.55,2.34l1.4,1.44l1.61,0.38l0.96,0.97l-0.5,0.64l-1.1,0.2l-0.34,-1.18l-2.04,-1.1l-0.63,0.23l-0.63,-0.62l-0.48,-1.3l-2.56,-2.63l-0.73,0.41l0.95,-3.89l2.16,-4.22ZM670.67,254.77l-0.92,-2.18l-0.26,-2.61l-2.14,-3.06l0.71,-0.49l0.89,-2.59l-3.61,-5.45l0.87,-0.51l1.05,-2.58l1.74,-0.18l2.6,-1.59l0.76,0.56l0.13,1.39l0.37,0.36l1.23,0.09l-0.51,2.28l0.05,2.42l0.6,0.34l2.43,-1.42l0.77,0.39l1.47,-0.07l0.71,-0.88l1.48,0.14l1.71,1.88l0.25,2.65l1.92,2.11l-0.1,1.89l-0.61,0.86l-2.22,-0.33l-3.5,0.64l-1.6,2.12l0.36,2.58l-1.51,-0.79l-1.84,-0.01l0.28,-1.52l-0.4,-0.47l-2.21,0.01l-0.4,0.37l-0.19,2.74l-0.34,0.93Z", name: "Thailand" }, TF: { path: "M596.68,420.38l-3.2,0.18l-0.05,-1.26l0.39,-1.41l1.3,0.78l2.08,0.35l-0.52,1.36Z", name: "Fr. S. Antarctic Lands" }, TG: { path: "M422.7,257.63l-0.09,1.23l1.53,1.52l0.08,1.09l0.5,0.65l-0.11,5.62l0.49,1.47l-1.31,0.35l-1.02,-2.13l-0.18,-1.12l0.53,-2.19l-0.63,-1.16l-0.22,-3.68l-1.01,-1.4l0.07,-0.28l1.37,0.03Z", name: "Togo" }, TD: { path: "M480.25,235.49l0.12,9.57l-2.1,0.05l-1.14,1.89l-0.69,1.63l0.34,0.73l-0.66,0.91l0.24,0.89l-0.86,1.95l0.45,0.5l0.6,-0.1l0.34,0.64l0.03,1.38l0.9,1.04l-1.45,0.43l-1.27,1.03l-1.83,2.76l-2.16,1.07l-2.31,-0.15l-0.86,0.25l-0.26,0.49l0.17,0.61l-2.11,1.68l-2.85,0.87l-1.09,-0.57l-0.73,0.66l-1.12,0.1l-1.1,-3.12l-1.25,-0.64l-1.22,-1.22l0.29,-0.64l3.01,0.04l0.35,-0.6l-1.3,-2.2l-0.08,-3.31l-0.97,-1.66l0.22,-1.04l-0.38,-0.48l-1.22,-0.04l0.0,-1.25l-0.98,-1.07l0.96,-3.01l3.25,-2.65l0.13,-3.33l0.95,-5.18l0.52,-1.07l-0.1,-0.48l-0.91,-0.78l-0.2,-0.96l-0.8,-0.58l-0.55,-3.65l2.1,-1.2l19.57,9.83Z", name: "Chad" }, LY: { path: "M483.48,203.15l-0.75,1.1l0.29,1.39l-0.6,1.83l0.73,2.14l0.0,24.12l-2.48,0.01l-0.41,0.85l-19.41,-9.76l-4.41,2.28l-1.37,-1.33l-3.82,-1.1l-1.14,-1.65l-1.98,-1.23l-1.22,0.32l-0.66,-1.11l-0.17,-1.26l-1.28,-1.69l0.87,-1.19l-0.07,-4.34l0.43,-2.27l-0.86,-3.45l1.13,-0.76l0.22,-1.16l-0.2,-1.03l3.48,-2.61l0.29,-1.94l2.45,0.8l1.18,-0.21l1.98,0.44l3.15,1.18l1.37,2.54l5.72,1.67l2.64,1.35l1.61,-0.72l1.29,-1.34l-0.44,-2.34l0.66,-1.13l1.67,-1.21l1.57,-0.35l3.14,0.53l1.08,1.28l3.99,0.78l0.36,0.54Z", name: "Libya" }, AE: { path: "M550.76,223.97l1.88,-0.4l3.84,0.02l4.78,-4.75l0.19,0.36l0.26,1.58l-0.81,0.01l-0.39,0.35l-0.08,2.04l-0.81,0.63l-0.01,0.96l-0.66,0.99l-0.39,1.41l-7.08,-1.25l-0.7,-1.96Z", name: "United Arab Emirates" }, VE: { path: "M240.68,256.69l0.53,0.75l-0.02,1.06l-1.07,1.78l0.95,2.0l0.42,0.22l1.4,-0.44l0.56,-1.83l-0.77,-1.17l-0.1,-1.47l2.82,-0.93l0.26,-0.49l-0.28,-0.96l0.3,-0.28l0.66,1.31l1.96,0.26l1.4,1.22l0.08,0.68l0.39,0.35l4.81,-0.22l1.49,1.11l1.92,0.31l1.67,-0.84l0.22,-0.6l3.44,-0.14l-0.17,0.55l0.86,1.19l2.19,0.35l1.67,1.1l0.37,1.86l0.41,0.32l1.55,0.17l-1.66,1.35l-0.22,0.92l0.65,0.97l-1.67,0.54l-0.3,0.4l0.04,0.99l-0.56,0.57l-0.01,0.55l1.85,2.27l-0.66,0.69l-4.47,1.29l-0.72,0.54l-3.69,-0.9l-0.71,0.27l-0.02,0.7l0.91,0.53l-0.08,1.54l0.35,1.58l0.35,0.31l1.66,0.17l-1.3,0.52l-0.48,1.13l-2.68,0.91l-0.6,0.77l-1.57,0.13l-1.17,-1.13l-0.8,-2.52l-1.25,-1.26l1.02,-1.23l-1.29,-2.95l0.18,-1.62l1.0,-2.21l-0.2,-0.49l-1.14,-0.46l-4.02,0.36l-1.82,-2.1l-1.57,-0.33l-2.99,0.22l-1.06,-0.97l0.25,-1.23l-0.2,-1.01l-0.59,-0.69l-0.29,-1.06l-1.08,-0.39l0.78,-2.79l1.9,-2.11Z", name: "Venezuela" }, AF: { path: "M600.7,188.88l-1.57,1.3l-0.1,0.48l0.8,2.31l-1.09,1.04l-0.03,1.27l-0.48,0.71l-2.16,-0.08l-0.37,0.59l0.78,1.48l-1.38,0.69l-1.06,1.69l0.06,1.7l-0.65,0.52l-0.91,-0.21l-1.91,0.36l-0.48,0.77l-1.88,0.13l-1.4,1.56l-0.18,2.32l-2.91,1.02l-1.65,-0.23l-0.71,0.55l-1.41,-0.3l-2.41,0.39l-3.52,-1.17l1.96,-2.35l-0.21,-1.78l-0.3,-0.34l-1.63,-0.4l-0.19,-1.58l-0.75,-2.03l0.95,-1.36l-0.19,-0.6l-0.73,-0.28l1.47,-4.8l2.14,0.9l2.12,-0.36l0.74,-1.34l1.77,-0.39l1.54,-0.92l0.63,-2.31l1.87,-0.5l0.49,-0.81l0.94,0.56l2.13,0.11l2.55,0.92l1.95,-0.83l0.65,0.43l0.56,-0.13l0.69,-1.12l1.57,-0.08l0.72,-1.66l0.79,-0.74l0.8,0.39l-0.17,0.56l0.71,0.58l-0.08,2.39l1.11,0.95ZM601.37,188.71l1.73,-0.71l1.43,-1.18l4.03,0.35l-2.23,0.74l-4.95,0.8Z", name: "Afghanistan" }, IQ: { path: "M530.82,187.47l0.79,0.66l1.26,-0.28l1.46,3.08l1.63,0.94l0.14,1.23l-1.22,1.05l-0.53,2.52l1.73,2.67l3.12,1.62l1.15,1.88l-0.38,1.85l0.39,0.48l0.41,-0.0l0.02,1.07l0.76,0.94l-2.47,-0.1l-1.71,2.44l-4.31,-0.2l-7.02,-5.48l-3.73,-1.94l-2.88,-0.73l-0.85,-2.87l5.45,-3.02l0.95,-3.43l-0.19,-1.96l1.27,-0.7l1.22,-1.7l0.87,-0.36l2.69,0.34Z", name: "Iraq" }, IS: { path: "M384.14,88.06l-0.37,2.61l2.54,2.51l-2.9,2.75l-9.19,3.4l-9.25,-1.66l1.7,-1.22l-0.1,-0.7l-4.05,-1.47l2.96,-0.53l0.33,-0.43l-0.11,-1.2l-0.33,-0.36l-4.67,-0.85l1.28,-2.04l3.45,-0.56l3.77,2.72l0.44,0.02l3.64,-2.16l3.3,1.08l3.98,-2.16l3.58,0.26Z", name: "Iceland" }, IR: { path: "M533.43,187.16l-1.27,-2.15l0.42,-0.98l-0.71,-3.04l1.03,-0.5l0.33,0.83l1.26,1.35l2.05,0.51l1.11,-0.16l2.89,-2.11l0.62,-0.14l0.39,0.46l-0.72,1.2l0.06,0.49l1.56,1.53l0.65,0.04l0.67,1.81l2.56,0.83l1.87,1.48l3.69,0.49l3.91,-0.76l0.47,-0.73l2.17,-0.6l1.66,-1.54l1.51,0.08l1.18,-0.53l1.59,0.24l2.83,1.48l1.88,0.3l2.77,2.47l1.77,0.18l0.18,1.99l-1.68,5.49l0.24,0.5l0.61,0.23l-0.82,1.48l0.8,2.18l0.19,1.71l0.3,0.34l1.63,0.4l0.15,1.32l-2.15,2.35l-0.01,0.53l2.21,3.03l2.34,1.24l0.06,2.14l1.24,0.72l0.11,0.69l-3.31,1.27l-1.08,3.03l-9.68,-1.68l-0.99,-3.05l-1.43,-0.73l-2.17,0.46l-2.47,1.26l-2.83,-0.82l-2.46,-2.02l-2.41,-0.8l-3.42,-6.06l-0.48,-0.2l-1.18,0.39l-1.44,-0.82l-0.5,0.08l-0.65,0.74l-0.97,-1.01l-0.02,-1.31l-0.71,-0.39l0.26,-1.81l-1.29,-2.11l-3.13,-1.63l-1.58,-2.43l0.5,-1.9l1.31,-1.26l-0.19,-1.66l-1.74,-1.1l-1.57,-3.3Z", name: "Iran" }, AM: { path: "M536.99,182.33l-0.28,0.03l-1.23,-2.13l-0.93,0.01l-0.62,-0.66l-0.69,-0.07l-0.96,-0.81l-1.56,-0.62l0.19,-1.12l-0.26,-0.79l2.72,-0.36l1.09,1.01l-0.17,0.92l1.02,0.78l-0.47,0.62l0.08,0.56l2.04,1.23l0.04,1.4Z", name: "Armenia" }, IT: { path: "M451.59,158.63l3.48,0.94l-0.21,1.17l0.3,0.83l-1.49,-0.24l-2.04,1.1l-0.21,0.39l0.13,1.45l-0.25,1.12l0.82,1.57l2.39,1.63l1.31,2.54l2.79,2.43l2.05,0.08l0.21,0.23l-0.39,0.33l0.09,0.67l4.05,1.97l2.17,1.76l-0.16,0.36l-1.17,-1.08l-2.18,-0.49l-0.44,0.2l-1.05,1.91l0.14,0.54l1.57,0.95l-0.19,0.98l-1.06,0.33l-1.25,2.34l-0.37,0.08l0.0,-0.33l1.0,-2.45l-1.73,-3.17l-1.12,-0.51l-0.88,-1.33l-1.51,-0.51l-1.27,-1.25l-1.75,-0.18l-4.12,-3.21l-1.62,-1.65l-1.03,-3.19l-3.53,-1.36l-1.3,0.51l-1.69,1.41l0.16,-0.72l-0.28,-0.47l-1.14,-0.33l-0.53,-1.96l0.72,-0.78l0.04,-0.48l-0.65,-1.17l0.8,0.39l1.4,-0.23l1.11,-0.84l0.52,0.35l1.19,-0.1l0.75,-1.2l1.53,0.33l1.36,-0.56l0.35,-1.14l1.08,0.32l0.68,-0.64l1.98,-0.44l0.42,0.82ZM459.19,184.75l-0.65,1.65l0.32,1.05l-0.31,0.89l-1.5,-0.85l-4.5,-1.67l0.19,-0.82l2.67,0.23l3.78,-0.48ZM443.93,176.05l1.18,1.66l-0.3,3.32l-1.06,-0.01l-0.77,0.73l-0.53,-0.44l-0.1,-3.37l-0.39,-1.22l1.04,0.01l0.92,-0.68Z", name: "Italy" }, VN: { path: "M690.56,230.25l-2.7,1.82l-2.09,2.46l-0.63,1.95l4.31,6.45l2.32,1.65l1.43,1.94l1.11,4.59l-0.32,4.24l-1.93,1.54l-2.84,1.61l-2.11,2.15l-2.73,2.06l-0.59,-1.05l0.63,-1.53l-0.13,-0.47l-1.34,-1.04l1.51,-0.71l2.55,-0.18l0.3,-0.63l-0.82,-1.14l4.0,-2.07l0.31,-3.05l-0.57,-1.77l0.42,-2.66l-0.73,-1.97l-1.86,-1.76l-3.63,-5.29l-2.72,-1.46l0.36,-0.47l1.5,-0.64l0.21,-0.52l-0.97,-2.27l-0.37,-0.24l-2.83,-0.02l-2.24,-3.9l0.83,-0.4l4.39,-0.29l2.06,-1.31l1.15,0.89l1.88,0.4l-0.17,1.51l1.35,1.16l1.67,0.45Z", name: "Vietnam" }, AR: { path: "M249.29,428.93l-2.33,-0.52l-5.83,-0.43l-0.89,-1.66l0.05,-2.37l-0.45,-0.4l-1.43,0.18l-0.67,-0.91l-0.2,-3.13l1.88,-1.47l0.79,-2.04l-0.25,-1.7l1.3,-2.68l0.91,-4.15l-0.22,-1.69l0.85,-0.45l0.2,-0.44l-0.27,-1.16l-0.98,-0.68l0.59,-0.92l-0.05,-0.5l-1.04,-1.07l-0.52,-3.1l0.97,-0.86l-0.42,-3.58l1.2,-5.43l1.38,-0.98l0.16,-0.43l-0.75,-2.79l-0.01,-2.43l1.78,-1.75l0.06,-2.57l1.43,-2.85l0.01,-2.58l-0.69,-0.74l-1.09,-4.52l1.47,-2.7l-0.18,-2.79l0.85,-2.35l1.59,-2.46l1.73,-1.64l0.05,-0.52l-0.6,-0.84l0.44,-0.85l-0.07,-4.19l2.7,-1.44l0.86,-2.75l-0.21,-0.71l1.76,-2.01l2.9,0.57l1.38,1.78l0.68,-0.08l0.87,-1.87l2.39,0.09l4.95,4.77l2.17,0.49l3.0,1.92l2.47,1.0l0.25,0.82l-2.37,3.93l0.23,0.59l5.39,1.16l2.12,-0.44l2.45,-2.16l0.5,-2.38l0.76,-0.31l0.98,1.2l-0.04,1.8l-3.67,2.51l-2.85,2.66l-3.43,3.88l-1.3,5.07l0.01,2.72l-0.54,0.73l-0.36,3.28l3.14,2.64l-0.16,2.11l1.4,1.11l-0.1,1.09l-2.29,3.52l-3.55,1.49l-4.92,0.6l-2.71,-0.29l-0.43,0.51l0.5,1.65l-0.49,2.1l0.38,1.42l-1.19,0.83l-2.36,0.38l-2.3,-1.04l-1.38,0.83l0.41,3.64l1.69,0.91l1.4,-0.71l0.36,0.76l-2.04,0.86l-2.01,1.89l-0.97,4.63l-2.34,0.1l-2.09,1.78l-0.61,2.75l2.46,2.31l2.17,0.63l-0.7,2.32l-2.83,1.73l-1.73,3.86l-2.17,1.22l-1.16,1.67l0.75,3.76l1.04,1.28ZM256.71,438.88l-2.0,0.15l-1.4,-1.22l-3.82,-0.1l-0.0,-5.83l1.6,3.05l3.26,2.07l3.08,0.78l-0.71,1.1Z", name: "Argentina" }, AU: { path: "M705.8,353.26l0.26,0.04l0.17,-0.47l-0.48,-1.42l0.92,1.11l0.45,0.15l0.27,-0.39l-0.1,-1.56l-1.98,-3.63l1.09,-3.31l-0.24,-1.57l0.34,-0.62l0.38,1.06l0.43,-0.19l0.99,-1.7l1.91,-0.83l1.29,-1.15l1.81,-0.91l0.96,-0.17l0.92,0.26l1.92,-0.95l1.47,-0.28l1.03,-0.8l1.43,0.04l2.78,-0.84l1.36,-1.15l0.71,-1.45l1.41,-1.26l0.3,-2.58l1.27,-1.59l0.78,1.65l0.54,0.19l1.07,-0.51l0.15,-0.6l-0.73,-1.0l0.45,-0.71l0.78,0.39l0.58,-0.3l0.28,-1.82l1.87,-2.14l1.12,-0.39l0.28,-0.58l0.62,0.17l0.53,-0.73l1.87,-0.57l1.65,1.05l1.35,1.48l3.39,0.38l0.43,-0.54l-0.46,-1.23l1.05,-1.79l1.04,-0.61l0.14,-0.55l-0.25,-0.41l0.88,-1.17l1.31,-0.77l1.3,0.27l2.1,-0.48l0.31,-0.4l-0.05,-1.3l-0.92,-0.77l1.48,0.56l1.41,1.07l2.11,0.65l0.81,-0.2l1.4,0.7l1.69,-0.66l0.8,0.19l0.64,-0.33l0.71,0.77l-1.33,1.94l-0.71,0.07l-0.35,0.51l0.24,0.86l-1.52,2.35l0.12,1.05l2.15,1.65l1.97,0.85l3.04,2.36l1.97,0.65l0.55,0.88l2.72,0.85l1.84,-1.1l2.07,-5.97l-0.42,-3.59l0.3,-1.73l0.47,-0.87l-0.31,-0.68l1.09,-3.28l0.46,-0.47l0.4,0.71l0.16,1.51l0.65,0.52l0.16,1.04l0.85,1.21l0.12,2.38l0.9,2.0l0.57,0.18l1.3,-0.78l1.69,1.7l-0.2,1.08l0.53,2.2l0.39,1.3l0.68,0.48l0.6,1.95l-0.19,1.48l0.81,1.76l6.01,3.69l-0.11,0.76l1.38,1.58l0.95,2.77l0.58,0.22l0.72,-0.41l0.8,0.9l0.61,0.01l0.46,2.41l4.81,4.71l0.66,2.02l-0.07,3.31l1.14,2.2l-0.13,2.24l-1.1,3.68l0.03,1.64l-0.47,1.89l-1.05,2.4l-1.9,1.47l-1.72,3.51l-2.38,6.09l-0.24,2.82l-1.14,0.8l-2.85,0.15l-2.31,1.19l-2.51,2.25l-3.09,-1.57l0.3,-1.15l-0.54,-0.47l-1.5,0.63l-2.01,1.94l-7.12,-2.18l-1.48,-1.63l-1.14,-3.74l-1.45,-1.26l-1.81,-0.26l0.56,-1.18l-0.61,-2.1l-0.72,-0.1l-1.14,1.82l-0.9,0.21l0.63,-0.82l0.36,-1.55l0.92,-1.31l-0.13,-2.34l-0.7,-0.22l-2.0,2.34l-1.51,0.93l-0.94,2.01l-1.35,-0.81l-0.02,-1.52l-1.57,-2.04l-1.09,-0.88l0.24,-0.33l-0.14,-0.59l-3.21,-1.69l-1.83,-0.12l-2.54,-1.35l-4.58,0.28l-6.02,1.9l-2.53,-0.13l-2.62,1.41l-2.13,0.63l-1.49,2.6l-3.49,0.31l-2.29,-0.5l-3.48,0.43l-1.6,1.47l-0.81,-0.04l-2.37,1.63l-3.26,-0.1l-3.72,-2.21l0.04,-1.05l1.19,-0.46l0.49,-0.89l0.21,-2.97l-0.28,-1.64l-1.34,-2.86l-0.38,-1.47l0.05,-1.72l-0.95,-1.7l-0.18,-0.97l-1.01,-0.99l-0.29,-1.98l-1.13,-1.75ZM784.92,393.44l2.65,1.02l3.23,-0.96l1.09,0.14l0.15,3.06l-0.85,1.13l-0.17,1.63l-0.87,-0.24l-1.57,1.91l-1.68,-0.18l-1.4,-2.36l-0.37,-2.04l-1.39,-2.51l0.04,-0.8l1.15,0.18Z", name: "Australia" }, IL: { path: "M507.76,203.05l0.4,-0.78l0.18,0.4l-0.33,1.03l0.52,0.44l0.68,-0.22l-0.86,3.6l-1.16,-3.32l0.59,-0.74l-0.03,-0.41ZM508.73,200.34l0.37,-1.02l0.64,0.0l0.52,-0.51l-0.49,1.53l-0.56,-0.24l-0.48,0.23Z", name: "Israel" }, IN: { path: "M623.34,207.03l-1.24,1.04l-0.97,2.55l0.22,0.51l8.04,3.87l3.42,0.37l1.57,1.38l4.92,0.88l2.18,-0.04l0.38,-0.3l0.29,-1.24l-0.32,-1.64l0.14,-0.87l0.82,-0.31l0.45,2.48l2.28,1.02l1.77,-0.38l4.14,0.1l0.38,-0.36l0.18,-1.66l-0.5,-0.65l1.37,-0.29l2.25,-1.99l2.7,-1.62l1.93,0.62l1.8,-0.98l0.79,1.14l-0.68,0.91l0.26,0.63l2.42,0.36l0.09,0.47l-0.83,0.75l0.13,1.07l-1.52,-0.29l-3.24,1.86l-0.13,1.78l-1.32,2.14l-0.18,1.39l-0.93,1.82l-1.64,-0.5l-0.52,0.37l-0.09,2.63l-0.56,1.11l0.19,0.81l-0.53,0.27l-1.18,-3.73l-1.08,-0.27l-0.38,0.31l-0.24,1.0l-0.66,-0.66l0.54,-1.06l1.22,-0.34l1.15,-2.25l-0.24,-0.56l-1.57,-0.47l-4.34,-0.28l-0.18,-1.56l-0.35,-0.35l-1.11,-0.12l-1.91,-1.12l-0.56,0.17l-0.88,1.82l0.11,0.49l1.36,1.07l-1.09,0.69l-0.69,1.11l0.18,0.56l1.24,0.57l-0.32,1.54l0.85,1.94l0.36,2.01l-0.22,0.59l-4.58,0.52l-0.33,0.42l0.13,1.8l-1.17,1.36l-3.65,1.81l-2.79,3.03l-4.32,3.28l-0.18,1.27l-4.65,1.79l-0.77,2.16l0.64,5.3l-1.06,2.49l-0.01,3.94l-1.24,0.28l-1.14,1.93l0.39,0.84l-1.68,0.53l-1.04,1.83l-0.65,0.47l-2.06,-2.05l-2.1,-6.02l-2.2,-3.64l-1.05,-4.75l-2.29,-3.57l-1.76,-8.2l0.01,-3.11l-0.49,-2.53l-0.55,-0.29l-3.53,1.52l-1.53,-0.27l-2.86,-2.77l0.85,-0.67l0.08,-0.55l-0.74,-1.03l-2.67,-2.06l1.24,-1.32l5.34,0.01l0.39,-0.49l-0.5,-2.29l-1.42,-1.46l-0.27,-1.93l-1.43,-1.2l2.31,-2.37l3.05,0.06l2.62,-2.85l1.6,-2.81l2.4,-2.73l0.07,-2.04l1.97,-1.48l-0.02,-0.65l-1.93,-1.31l-0.82,-1.78l-0.8,-2.21l0.9,-0.89l3.59,0.65l2.92,-0.42l2.33,-2.19l2.31,2.85l-0.24,2.13l0.99,1.59l-0.05,0.82l-1.34,-0.28l-0.47,0.48l0.7,3.06l2.62,1.99l2.99,1.65Z", name: "India" }, TZ: { path: "M495.56,296.42l2.8,-3.12l-0.02,-0.81l-0.64,-1.3l0.68,-0.52l0.14,-1.47l-0.76,-1.25l0.31,-0.11l2.26,0.03l-0.51,2.76l0.76,1.3l0.5,0.12l1.05,-0.53l1.19,-0.12l0.61,0.24l1.43,-0.62l0.1,-0.67l-0.71,-0.62l1.57,-1.7l8.65,4.86l0.32,1.53l3.34,2.33l-1.05,2.8l0.13,1.61l1.63,1.12l-0.6,1.76l-0.01,2.33l1.89,4.03l0.57,0.43l-1.46,1.08l-2.61,0.94l-1.43,-0.04l-1.06,0.77l-2.29,0.36l-2.87,-0.68l-0.83,0.07l-0.63,-0.75l-0.31,-2.78l-1.32,-1.35l-3.25,-0.77l-3.96,-1.58l-1.18,-2.41l-0.32,-1.75l-1.76,-1.49l0.42,-1.05l-0.44,-0.89l0.08,-0.96l-0.46,-0.58l0.06,-0.56Z", name: "Tanzania" }, AZ: { path: "M539.29,175.73l1.33,0.32l1.94,-1.8l2.3,3.34l1.43,0.43l-1.26,0.15l-0.35,0.32l-0.8,3.14l-0.99,0.96l0.05,1.11l-1.26,-1.13l0.7,-1.18l-0.04,-0.47l-0.74,-0.86l-1.48,0.15l-2.34,1.71l-0.03,-1.27l-2.03,-1.35l0.47,-0.62l-0.08,-0.56l-1.03,-0.79l0.29,-0.43l-0.14,-0.58l-1.13,-0.86l1.89,0.68l1.69,0.06l0.37,-0.87l-0.81,-1.37l0.42,0.06l1.63,1.72ZM533.78,180.57l0.61,0.46l0.69,-0.0l0.59,1.15l-0.68,-0.15l-1.21,-1.45Z", name: "Azerbaijan" }, IE: { path: "M405.08,135.42l0.35,2.06l-1.75,2.78l-4.22,1.88l-2.84,-0.4l1.73,-3.0l-1.18,-3.53l4.6,-3.74l0.32,1.15l-0.49,1.74l0.4,0.51l1.47,-0.04l1.6,0.6Z", name: "Ireland" }, ID: { path: "M756.47,287.89l0.69,4.01l2.79,1.78l0.51,-0.1l2.04,-2.59l2.71,-1.43l2.05,-0.0l3.9,1.73l2.46,0.45l0.08,15.12l-1.75,-1.54l-2.54,-0.51l-0.88,0.71l-2.32,0.06l0.69,-1.33l1.45,-0.64l0.23,-0.46l-0.65,-2.74l-1.24,-2.21l-5.04,-2.29l-2.09,-0.23l-3.68,-2.27l-0.55,0.13l-0.65,1.07l-0.52,0.12l-0.55,-1.89l-1.21,-0.78l1.84,-0.62l1.72,0.05l0.39,-0.52l-0.21,-0.66l-0.38,-0.28l-3.45,-0.0l-1.13,-1.48l-2.1,-0.43l-0.52,-0.6l2.69,-0.48l1.28,-0.78l3.66,0.94l0.3,0.71ZM757.91,300.34l-0.62,0.82l-0.1,-0.8l0.59,-1.12l0.13,1.1ZM747.38,292.98l0.34,0.72l-1.22,-0.57l-4.68,-0.1l0.27,-0.62l2.78,-0.09l2.52,0.67ZM741.05,285.25l-0.67,-2.88l0.64,-2.01l0.41,0.86l1.21,0.18l0.16,0.7l-0.1,1.68l-0.84,-0.16l-0.46,0.3l-0.34,1.34ZM739.05,293.5l-0.5,0.44l-1.34,-0.36l-0.17,-0.37l1.73,-0.08l0.27,0.36ZM721.45,284.51l-0.19,1.97l2.24,2.23l0.54,0.02l1.27,-1.07l2.75,-0.5l-0.9,1.21l-2.11,0.93l-0.16,0.6l2.22,3.01l-0.3,1.07l1.36,1.74l-2.26,0.85l-0.28,-0.31l0.12,-1.19l-1.64,-1.34l0.17,-2.23l-0.56,-0.39l-1.67,0.76l-0.23,0.39l0.3,6.17l-1.1,0.25l-0.69,-0.47l0.64,-2.21l-0.39,-2.42l-0.39,-0.34l-0.8,-0.01l-0.58,-1.29l0.98,-1.6l0.35,-1.96l1.32,-3.87ZM728.59,296.27l0.38,0.49l-0.02,1.28l-0.88,0.49l-0.53,-0.47l1.04,-1.79ZM729.04,286.98l0.27,-0.05l-0.02,0.13l-0.24,-0.08ZM721.68,284.05l0.16,-0.32l1.89,-1.65l1.83,0.68l3.16,0.35l2.94,-0.1l2.39,-1.66l-1.73,2.13l-1.66,0.43l-2.41,-0.48l-4.17,0.13l-2.39,0.51ZM730.55,310.47l1.11,-1.93l2.03,-0.82l0.08,0.62l-1.45,1.67l-1.77,0.46ZM728.12,305.88l-0.1,0.38l-3.46,0.66l-2.91,-0.27l-0.0,-0.25l1.54,-0.41l1.66,0.73l1.67,-0.19l1.61,-0.65ZM722.9,310.24l-0.64,0.03l-2.26,-1.2l1.11,-0.24l1.78,1.41ZM716.26,305.77l0.88,0.51l1.28,-0.17l0.2,0.35l-4.65,0.73l0.39,-0.67l1.15,-0.02l0.75,-0.73ZM711.66,293.84l-0.38,-0.16l-2.54,1.01l-1.12,-1.44l-1.69,-0.13l-1.16,-0.75l-3.04,0.77l-1.1,-1.15l-3.31,-0.11l-0.35,-3.05l-1.35,-0.95l-1.11,-1.98l-0.33,-2.06l0.27,-2.14l0.9,-1.01l0.37,1.15l2.09,1.49l1.53,-0.48l1.82,0.08l1.38,-1.19l1.0,-0.18l2.28,0.67l2.26,-0.53l1.52,-3.64l1.01,-0.99l0.78,-2.57l4.1,0.3l-1.11,1.77l0.02,0.46l1.7,2.2l-0.23,1.39l2.07,1.71l-2.33,0.42l-0.88,1.9l0.1,2.05l-2.4,1.9l-0.06,2.45l-0.7,2.79ZM692.58,302.03l0.35,0.26l4.8,0.25l0.78,-0.97l4.17,1.09l1.13,1.68l3.69,0.45l2.13,1.04l-1.8,0.6l-2.77,-0.99l-4.8,-0.12l-5.24,-1.41l-1.84,-0.25l-1.11,0.3l-4.26,-0.97l-0.7,-1.14l-1.59,-0.13l1.18,-1.65l2.74,0.13l2.87,1.13l0.26,0.68ZM685.53,299.17l-2.22,0.04l-2.06,-2.03l-3.15,-2.01l-2.93,-3.51l-3.11,-5.33l-2.2,-2.12l-1.64,-4.06l-2.32,-1.69l-1.27,-2.07l-1.96,-1.5l-2.51,-2.65l-0.11,-0.66l4.81,0.53l2.15,2.38l3.31,2.74l2.35,2.66l2.7,0.17l1.95,1.59l1.54,2.17l1.59,0.95l-0.84,1.71l0.15,0.52l1.44,0.87l0.79,0.1l0.4,1.58l0.87,1.4l1.96,0.39l1.0,1.31l-0.6,3.01l-0.09,3.5Z", name: "Indonesia" }, UA: { path: "M492.5,162.44l1.28,-2.49l1.82,0.19l0.66,-0.23l0.09,-0.71l-0.25,-0.75l-0.79,-0.72l-0.33,-1.21l-0.86,-0.62l-0.02,-1.19l-1.13,-0.86l-1.15,-0.19l-2.04,-1.0l-1.66,0.32l-0.66,0.47l-0.92,-0.0l-0.84,0.78l-2.48,0.7l-1.18,-0.71l-3.07,-0.36l-0.89,0.43l-0.24,-0.55l-1.11,-0.7l0.35,-0.93l1.26,-1.02l-0.54,-1.23l2.04,-2.43l1.4,-0.62l0.25,-1.19l-1.04,-2.39l0.83,-0.13l1.28,-0.84l1.8,-0.07l2.47,0.26l2.86,0.81l1.88,0.06l0.86,0.44l1.04,-0.41l0.77,0.66l2.18,-0.15l0.92,0.3l0.52,-0.34l0.15,-1.53l0.56,-0.54l2.85,-0.05l0.84,-0.72l3.04,-0.18l1.23,1.46l-0.48,0.77l0.21,1.03l0.36,0.32l1.8,0.14l0.93,2.08l3.18,1.15l1.94,-0.45l1.67,1.49l1.4,-0.03l3.35,0.96l0.02,0.54l-0.96,1.59l0.47,1.97l-0.26,0.7l-2.36,0.28l-1.29,0.89l-0.23,1.38l-1.83,0.27l-1.58,0.97l-2.41,0.21l-2.16,1.17l-0.21,0.38l0.34,2.26l1.23,0.75l2.13,-0.08l-0.14,0.31l-2.65,0.53l-3.23,1.69l-0.87,-0.39l0.42,-1.1l-0.25,-0.52l-2.21,-0.73l2.35,-1.06l0.12,-0.65l-0.93,-0.82l-3.62,-0.74l-0.13,-0.89l-0.46,-0.34l-2.61,0.59l-0.91,1.69l-1.71,2.04l-0.86,-0.4l-1.62,0.27Z", name: "Ukraine" }, QA: { path: "M549.33,221.64l-0.76,-0.23l-0.14,-1.64l0.84,-1.29l0.47,0.52l0.04,1.34l-0.45,1.3Z", name: "Qatar" }, MZ: { path: "M508.58,318.75l-0.34,-2.57l0.51,-2.05l3.55,0.63l2.5,-0.38l1.02,-0.76l1.49,0.01l2.74,-0.98l1.66,-1.2l0.5,9.24l0.41,1.23l-0.68,1.67l-0.93,1.71l-1.5,1.5l-5.16,2.28l-2.78,2.73l-1.02,0.53l-1.71,1.8l-0.98,0.57l-0.35,2.41l1.16,1.94l0.49,2.17l0.43,0.31l-0.06,2.06l-0.39,1.17l0.5,0.72l-0.25,0.73l-0.92,0.83l-5.12,2.39l-1.22,1.36l0.21,1.13l0.58,0.39l-0.11,0.72l-1.22,-0.01l-0.73,-2.97l0.42,-3.09l-1.78,-5.37l2.49,-2.81l0.69,-1.89l0.44,-0.43l0.28,-1.53l-0.39,-0.93l0.59,-3.65l-0.01,-3.26l-1.49,-1.16l-1.2,-0.22l-1.74,-1.17l-1.92,0.01l-0.29,-2.08l7.06,-1.96l1.28,1.09l0.89,-0.1l0.67,0.44l0.1,0.73l-0.51,1.29l0.19,1.81l1.75,1.83l0.65,-0.13l0.71,-1.65l1.17,-0.86l-0.26,-3.47l-1.05,-1.85l-1.04,-0.94Z", name: "Mozambique" } }, height: 440.70631074413296, width: 900, projection: { type: "mill", centralMeridian: 11.5 } });

  // assets/scripts/components/map-01.js
  var map01 = () => {
    const mapSelectorOne = document.querySelectorAll("#mapOne");
    if (mapSelectorOne.length) {
      const mapOne = new index({
        selector: "#mapOne",
        map: "world",
        zoomButtons: false,
        regionStyle: {
          initial: {
            fontFamily: "Outfit",
            fill: "#D9D9D9"
          },
          hover: {
            fillOpacity: 1,
            fill: "#465fff"
          }
        },
        markers: [
          {
            name: "Egypt",
            coords: [26.8206, 30.8025]
          },
          {
            name: "United Kingdom",
            coords: [55.3781, 3.436]
          },
          {
            name: "United States",
            coords: [37.0902, -95.7129]
          }
        ],
        markerStyle: {
          initial: {
            strokeWidth: 1,
            fill: "#465fff",
            fillOpacity: 1,
            r: 4
          },
          hover: {
            fill: "#465fff",
            fillOpacity: 1
          },
          selected: {},
          selectedHover: {}
        },
        onRegionTooltipShow: function(tooltip, code) {
          if (code === "EG") {
            tooltip.selector.innerHTML = tooltip.text() + " <b>(Hello Russia)</b>";
          }
        }
      });
    }
  };
  var map_01_default = map01;

  // node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var i;
  var t;
  var r;
  var o;
  var f;
  var e;
  var c = {};
  var s = [];
  var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h(n2, l3) {
    for (var u3 in l3) n2[u3] = l3[u3];
    return n2;
  }
  function v(n2) {
    var l3 = n2.parentNode;
    l3 && l3.removeChild(n2);
  }
  function y(l3, u3, i3) {
    var t3, r3, o2, f3 = {};
    for (o2 in u3) "key" == o2 ? t3 = u3[o2] : "ref" == o2 ? r3 = u3[o2] : f3[o2] = u3[o2];
    if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps) for (o2 in l3.defaultProps) void 0 === f3[o2] && (f3[o2] = l3.defaultProps[o2]);
    return p(l3, f3, t3, r3, null);
  }
  function p(n2, i3, t3, r3, o2) {
    var f3 = { type: n2, props: i3, key: t3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++u : o2 };
    return null == o2 && null != l.vnode && l.vnode(f3), f3;
  }
  function d() {
    return { current: null };
  }
  function _(n2) {
    return n2.children;
  }
  function k(n2, l3, u3, i3, t3) {
    var r3;
    for (r3 in u3) "children" === r3 || "key" === r3 || r3 in l3 || g(n2, r3, null, u3[r3], i3);
    for (r3 in l3) t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || g(n2, r3, l3[r3], u3[r3], i3);
  }
  function b(n2, l3, u3) {
    "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
  }
  function g(n2, l3, u3, i3, t3) {
    var r3;
    n: if ("style" === l3) if ("string" == typeof u3) n2.style.cssText = u3;
    else {
      if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3) for (l3 in i3) u3 && l3 in u3 || b(n2.style, l3, "");
      if (u3) for (l3 in u3) i3 && u3[l3] === i3[l3] || b(n2.style, l3, u3[l3]);
    }
    else if ("o" === l3[0] && "n" === l3[1]) r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u3, u3 ? i3 || n2.addEventListener(l3, r3 ? w : m, r3) : n2.removeEventListener(l3, r3 ? w : m, r3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t3) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2) try {
        n2[l3] = null == u3 ? "" : u3;
        break n;
      } catch (n3) {
      }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
  }
  function m(n2) {
    t = true;
    try {
      return this.l[n2.type + false](l.event ? l.event(n2) : n2);
    } finally {
      t = false;
    }
  }
  function w(n2) {
    t = true;
    try {
      return this.l[n2.type + true](l.event ? l.event(n2) : n2);
    } finally {
      t = false;
    }
  }
  function x(n2, l3) {
    this.props = n2, this.context = l3;
  }
  function A(n2, l3) {
    if (null == l3) return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
    for (var u3; l3 < n2.__k.length; l3++) if (null != (u3 = n2.__k[l3]) && null != u3.__e) return u3.__e;
    return "function" == typeof n2.type ? A(n2) : null;
  }
  function P(n2) {
    var l3, u3;
    if (null != (n2 = n2.__) && null != n2.__c) {
      for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++) if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
      return P(n2);
    }
  }
  function C(n2) {
    t ? setTimeout(n2) : f(n2);
  }
  function T(n2) {
    (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
  }
  function $() {
    var n2, l3, u3, i3, t3, o2, f3, e3;
    for (r.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }); n2 = r.shift(); ) n2.__d && (l3 = r.length, i3 = void 0, t3 = void 0, f3 = (o2 = (u3 = n2).__v).__e, (e3 = u3.__P) && (i3 = [], (t3 = h({}, o2)).__v = o2.__v + 1, M(e3, o2, t3, u3.__n, void 0 !== e3.ownerSVGElement, null != o2.__h ? [f3] : null, i3, null == f3 ? A(o2) : f3, o2.__h), N(i3, o2), o2.__e != f3 && P(o2)), r.length > l3 && r.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }));
    $.__r = 0;
  }
  function H(n2, l3, u3, i3, t3, r3, o2, f3, e3, a3) {
    var h3, v3, y3, d2, k3, b3, g4, m3 = i3 && i3.__k || s, w4 = m3.length;
    for (u3.__k = [], h3 = 0; h3 < l3.length; h3++) if (null != (d2 = u3.__k[h3] = null == (d2 = l3[h3]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
      if (d2.__ = u3, d2.__b = u3.__b + 1, null === (y3 = m3[h3]) || y3 && d2.key == y3.key && d2.type === y3.type) m3[h3] = void 0;
      else for (v3 = 0; v3 < w4; v3++) {
        if ((y3 = m3[v3]) && d2.key == y3.key && d2.type === y3.type) {
          m3[v3] = void 0;
          break;
        }
        y3 = null;
      }
      M(n2, d2, y3 = y3 || c, t3, r3, o2, f3, e3, a3), k3 = d2.__e, (v3 = d2.ref) && y3.ref != v3 && (g4 || (g4 = []), y3.ref && g4.push(y3.ref, null, d2), g4.push(v3, d2.__c || k3, d2)), null != k3 ? (null == b3 && (b3 = k3), "function" == typeof d2.type && d2.__k === y3.__k ? d2.__d = e3 = I(d2, e3, n2) : e3 = z(n2, d2, y3, m3, k3, e3), "function" == typeof u3.type && (u3.__d = e3)) : e3 && y3.__e == e3 && e3.parentNode != n2 && (e3 = A(y3));
    }
    for (u3.__e = b3, h3 = w4; h3--; ) null != m3[h3] && ("function" == typeof u3.type && null != m3[h3].__e && m3[h3].__e == u3.__d && (u3.__d = L(i3).nextSibling), q(m3[h3], m3[h3]));
    if (g4) for (h3 = 0; h3 < g4.length; h3++) S(g4[h3], g4[++h3], g4[++h3]);
  }
  function I(n2, l3, u3) {
    for (var i3, t3 = n2.__k, r3 = 0; t3 && r3 < t3.length; r3++) (i3 = t3[r3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? I(i3, l3, u3) : z(u3, i3, i3, t3, i3.__e, l3));
    return l3;
  }
  function j2(n2, l3) {
    return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
      j2(n3, l3);
    }) : l3.push(n2)), l3;
  }
  function z(n2, l3, u3, i3, t3, r3) {
    var o2, f3, e3;
    if (void 0 !== l3.__d) o2 = l3.__d, l3.__d = void 0;
    else if (null == u3 || t3 != r3 || null == t3.parentNode) n: if (null == r3 || r3.parentNode !== n2) n2.appendChild(t3), o2 = null;
    else {
      for (f3 = r3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1) if (f3 == t3) break n;
      n2.insertBefore(t3, r3), o2 = r3;
    }
    return void 0 !== o2 ? o2 : t3.nextSibling;
  }
  function L(n2) {
    var l3, u3, i3;
    if (null == n2.type || "string" == typeof n2.type) return n2.__e;
    if (n2.__k) {
      for (l3 = n2.__k.length - 1; l3 >= 0; l3--) if ((u3 = n2.__k[l3]) && (i3 = L(u3))) return i3;
    }
    return null;
  }
  function M(n2, u3, i3, t3, r3, o2, f3, e3, c3) {
    var s3, a3, v3, y3, p3, d2, k3, b3, g4, m3, w4, A3, P3, C3, T4, $3 = u3.type;
    if (void 0 !== u3.constructor) return null;
    null != i3.__h && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, o2 = [e3]), (s3 = l.__b) && s3(u3);
    try {
      n: if ("function" == typeof $3) {
        if (b3 = u3.props, g4 = (s3 = $3.contextType) && t3[s3.__c], m3 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? k3 = (a3 = u3.__c = i3.__c).__ = a3.__E : ("prototype" in $3 && $3.prototype.render ? u3.__c = a3 = new $3(b3, m3) : (u3.__c = a3 = new x(b3, m3), a3.constructor = $3, a3.render = B), g4 && g4.sub(a3), a3.props = b3, a3.state || (a3.state = {}), a3.context = m3, a3.__n = t3, v3 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != $3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, $3.getDerivedStateFromProps(b3, a3.__s))), y3 = a3.props, p3 = a3.state, a3.__v = u3, v3) null == $3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
        else {
          if (null == $3.getDerivedStateFromProps && b3 !== y3 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(b3, m3), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(b3, a3.__s, m3) || u3.__v === i3.__v) {
            for (u3.__v !== i3.__v && (a3.props = b3, a3.state = a3.__s, a3.__d = false), u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), w4 = 0; w4 < a3._sb.length; w4++) a3.__h.push(a3._sb[w4]);
            a3._sb = [], a3.__h.length && f3.push(a3);
            break n;
          }
          null != a3.componentWillUpdate && a3.componentWillUpdate(b3, a3.__s, m3), null != a3.componentDidUpdate && a3.__h.push(function() {
            a3.componentDidUpdate(y3, p3, d2);
          });
        }
        if (a3.context = m3, a3.props = b3, a3.__P = n2, A3 = l.__r, P3 = 0, "prototype" in $3 && $3.prototype.render) {
          for (a3.state = a3.__s, a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), C3 = 0; C3 < a3._sb.length; C3++) a3.__h.push(a3._sb[C3]);
          a3._sb = [];
        } else do {
          a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
        } while (a3.__d && ++P3 < 25);
        a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), v3 || null == a3.getSnapshotBeforeUpdate || (d2 = a3.getSnapshotBeforeUpdate(y3, p3)), T4 = null != s3 && s3.type === _ && null == s3.key ? s3.props.children : s3, H(n2, Array.isArray(T4) ? T4 : [T4], u3, i3, t3, r3, o2, f3, e3, c3), a3.base = u3.__e, u3.__h = null, a3.__h.length && f3.push(a3), k3 && (a3.__E = a3.__ = null), a3.__e = false;
      } else null == o2 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = O(i3.__e, u3, i3, t3, r3, o2, f3, c3);
      (s3 = l.diffed) && s3(u3);
    } catch (n3) {
      u3.__v = null, (c3 || null != o2) && (u3.__e = e3, u3.__h = !!c3, o2[o2.indexOf(e3)] = null), l.__e(n3, u3, i3);
    }
  }
  function N(n2, u3) {
    l.__c && l.__c(u3, n2), n2.some(function(u4) {
      try {
        n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
          n3.call(u4);
        });
      } catch (n3) {
        l.__e(n3, u4.__v);
      }
    });
  }
  function O(l3, u3, i3, t3, r3, o2, f3, e3) {
    var s3, a3, h3, y3 = i3.props, p3 = u3.props, d2 = u3.type, _3 = 0;
    if ("svg" === d2 && (r3 = true), null != o2) {
      for (; _3 < o2.length; _3++) if ((s3 = o2[_3]) && "setAttribute" in s3 == !!d2 && (d2 ? s3.localName === d2 : 3 === s3.nodeType)) {
        l3 = s3, o2[_3] = null;
        break;
      }
    }
    if (null == l3) {
      if (null === d2) return document.createTextNode(p3);
      l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p3.is && p3), o2 = null, e3 = false;
    }
    if (null === d2) y3 === p3 || e3 && l3.data === p3 || (l3.data = p3);
    else {
      if (o2 = o2 && n.call(l3.childNodes), a3 = (y3 = i3.props || c).dangerouslySetInnerHTML, h3 = p3.dangerouslySetInnerHTML, !e3) {
        if (null != o2) for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++) y3[l3.attributes[_3].name] = l3.attributes[_3].value;
        (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
      }
      if (k(l3, p3, y3, r3, e3), h3) u3.__k = [];
      else if (_3 = u3.props.children, H(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, r3 && "foreignObject" !== d2, o2, f3, o2 ? o2[0] : i3.__k && A(i3, 0), e3), null != o2) for (_3 = o2.length; _3--; ) null != o2[_3] && v(o2[_3]);
      e3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d2 && !_3 || "option" === d2 && _3 !== y3.value) && g(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && g(l3, "checked", _3, y3.checked, false));
    }
    return l3;
  }
  function S(n2, u3, i3) {
    try {
      "function" == typeof n2 ? n2(u3) : n2.current = u3;
    } catch (n3) {
      l.__e(n3, i3);
    }
  }
  function q(n2, u3, i3) {
    var t3, r3;
    if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || S(t3, null, u3)), null != (t3 = n2.__c)) {
      if (t3.componentWillUnmount) try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
      t3.base = t3.__P = null, n2.__c = void 0;
    }
    if (t3 = n2.__k) for (r3 = 0; r3 < t3.length; r3++) t3[r3] && q(t3[r3], u3, i3 || "function" != typeof n2.type);
    i3 || null == n2.__e || v(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
  }
  function B(n2, l3, u3) {
    return this.constructor(n2, u3);
  }
  function D(u3, i3, t3) {
    var r3, o2, f3;
    l.__ && l.__(u3, i3), o2 = (r3 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], M(i3, u3 = (!r3 && t3 || i3).__k = y(_, null, [u3]), o2 || c, c, void 0 !== i3.ownerSVGElement, !r3 && t3 ? [t3] : o2 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r3 && t3 ? t3 : o2 ? o2.__e : i3.firstChild, r3), N(f3, u3);
  }
  function G(n2, l3) {
    var u3 = { __c: l3 = "__cC" + e++, __: n2, Consumer: function(n3, l4) {
      return n3.children(l4);
    }, Provider: function(n3) {
      var u4, i3;
      return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
        return i3;
      }, this.shouldComponentUpdate = function(n4) {
        this.props.value !== n4.value && u4.some(function(n5) {
          n5.__e = true, T(n5);
        });
      }, this.sub = function(n4) {
        u4.push(n4);
        var l4 = n4.componentWillUnmount;
        n4.componentWillUnmount = function() {
          u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
        };
      }), n3.children;
    } };
    return u3.Provider.__ = u3.Consumer.contextType = u3;
  }
  n = s.slice, l = { __e: function(n2, l3, u3, i3) {
    for (var t3, r3, o2; l3 = l3.__; ) if ((t3 = l3.__c) && !t3.__) try {
      if ((r3 = t3.constructor) && null != r3.getDerivedStateFromError && (t3.setState(r3.getDerivedStateFromError(n2)), o2 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o2 = t3.__d), o2) return t3.__E = t3;
    } catch (l4) {
      n2 = l4;
    }
    throw n2;
  } }, u = 0, i = function(n2) {
    return null != n2 && void 0 === n2.constructor;
  }, t = false, x.prototype.setState = function(n2, l3) {
    var u3;
    u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u3), this.props)), n2 && h(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), T(this));
  }, x.prototype.forceUpdate = function(n2) {
    this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
  }, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

  // node_modules/preact/hooks/dist/hooks.module.js
  var t2;
  var r2;
  var u2;
  var i2;
  var f2 = [];
  var c2 = [];
  var e2 = l.__b;
  var a2 = l.__r;
  var v2 = l.diffed;
  var l2 = l.__c;
  var m2 = l.unmount;
  function b2() {
    for (var t3; t3 = f2.shift(); ) if (t3.__P && t3.__H) try {
      t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
    } catch (r3) {
      t3.__H.__h = [], l.__e(r3, t3.__v);
    }
  }
  l.__b = function(n2) {
    r2 = null, e2 && e2(n2);
  }, l.__r = function(n2) {
    a2 && a2(n2), t2 = 0;
    var i3 = (r2 = n2.__c).__H;
    i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
      n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
    })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
  }, l.diffed = function(t3) {
    v2 && v2(t3);
    var o2 = t3.__c;
    o2 && o2.__H && (o2.__H.__h.length && (1 !== f2.push(o2) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j3)(b2)), o2.__H.__.forEach(function(n2) {
      n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
    })), u2 = r2 = null;
  }, l.__c = function(t3, r3) {
    r3.some(function(t4) {
      try {
        t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
          return !n2.__ || w2(n2);
        });
      } catch (u3) {
        r3.some(function(n2) {
          n2.__h && (n2.__h = []);
        }), r3 = [], l.__e(u3, t4.__v);
      }
    }), l2 && l2(t3, r3);
  }, l.unmount = function(t3) {
    m2 && m2(t3);
    var r3, u3 = t3.__c;
    u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
      try {
        k2(n2);
      } catch (n3) {
        r3 = n3;
      }
    }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
  };
  var g2 = "function" == typeof requestAnimationFrame;
  function j3(n2) {
    var t3, r3 = function() {
      clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
    }, u3 = setTimeout(r3, 100);
    g2 && (t3 = requestAnimationFrame(r3));
  }
  function k2(n2) {
    var t3 = r2, u3 = n2.__c;
    "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t3;
  }
  function w2(n2) {
    var t3 = r2;
    n2.__c = n2.__(), r2 = t3;
  }

  // node_modules/preact/compat/dist/compat.module.js
  function g3(n2, t3) {
    for (var e3 in t3) n2[e3] = t3[e3];
    return n2;
  }
  function C2(n2, t3) {
    for (var e3 in n2) if ("__source" !== e3 && !(e3 in t3)) return true;
    for (var r3 in t3) if ("__source" !== r3 && n2[r3] !== t3[r3]) return true;
    return false;
  }
  function w3(n2) {
    this.props = n2;
  }
  (w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
    return C2(this.props, n2) || C2(this.state, t3);
  };
  var x3 = l.__b;
  l.__b = function(n2) {
    n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
  };
  var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  var T3 = l.__e;
  l.__e = function(n2, t3, e3, r3) {
    if (n2.then) {
      for (var u3, o2 = t3; o2 = o2.__; ) if ((u3 = o2.__c) && u3.__c) return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
    }
    T3(n2, t3, e3, r3);
  };
  var I2 = l.unmount;
  function L2(n2, t3, e3) {
    return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
      "function" == typeof n3.__c && n3.__c();
    }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
      return L2(n3, t3, e3);
    })), n2;
  }
  function U(n2, t3, e3) {
    return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
      return U(n3, t3, e3);
    }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
  }
  function D2() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F3(n2) {
    var t3 = n2.__.__c;
    return t3 && t3.__a && t3.__a(n2);
  }
  function V2() {
    this.u = null, this.o = null;
  }
  l.unmount = function(n2) {
    var t3 = n2.__c;
    t3 && t3.__R && t3.__R(), t3 && true === n2.__h && (n2.type = null), I2 && I2(n2);
  }, (D2.prototype = new x()).__c = function(n2, t3) {
    var e3 = t3.__c, r3 = this;
    null == r3.t && (r3.t = []), r3.t.push(e3);
    var u3 = F3(r3.__v), o2 = false, i3 = function() {
      o2 || (o2 = true, e3.__R = null, u3 ? u3(l3) : l3());
    };
    e3.__R = i3;
    var l3 = function() {
      if (!--r3.__u) {
        if (r3.state.__a) {
          var n3 = r3.state.__a;
          r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
        }
        var t4;
        for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); ) t4.forceUpdate();
      }
    }, c3 = true === t3.__h;
    r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
  }, D2.prototype.componentWillUnmount = function() {
    this.t = [];
  }, D2.prototype.render = function(n2, e3) {
    if (this.__b) {
      if (this.__v.__k) {
        var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
        this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
      }
      this.__b = null;
    }
    var i3 = e3.__a && y(_, null, n2.fallback);
    return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
  };
  var W = function(n2, t3, e3) {
    if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size)) for (e3 = n2.u; e3; ) {
      for (; e3.length > 3; ) e3.pop()();
      if (e3[1] < e3[0]) break;
      n2.u = e3 = e3[2];
    }
  };
  function P2(n2) {
    return this.getChildContext = function() {
      return n2.context;
    }, n2.children;
  }
  function $2(n2) {
    var e3 = this, r3 = n2.i;
    e3.componentWillUnmount = function() {
      D(null, e3.l), e3.l = null, e3.i = null;
    }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
      this.childNodes.push(n3), e3.i.appendChild(n3);
    }, insertBefore: function(n3, t3) {
      this.childNodes.push(n3), e3.i.appendChild(n3);
    }, removeChild: function(n3) {
      this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
    } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
  }
  function j4(n2, e3) {
    var r3 = y($2, { __v: n2, i: e3 });
    return r3.containerInfo = e3, r3;
  }
  (V2.prototype = new x()).__a = function(n2) {
    var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
    return r3[0]++, function(u3) {
      var o2 = function() {
        t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
      };
      e3 ? e3(o2) : o2();
    };
  }, V2.prototype.render = function(n2) {
    this.u = null, this.o = /* @__PURE__ */ new Map();
    var t3 = j2(n2.children);
    n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
    for (var e3 = t3.length; e3--; ) this.o.set(t3[e3], this.u = [1, 0, this.u]);
    return n2.children;
  }, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
    var n2 = this;
    this.o.forEach(function(t3, e3) {
      W(n2, e3, t3);
    });
  };
  var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
  var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
  var H2 = "undefined" != typeof document;
  var Z = function(n2) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
  };
  x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
    Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
      return this["UNSAFE_" + t3];
    }, set: function(n2) {
      Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
    } });
  });
  var G2 = l.event;
  function J() {
  }
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  l.event = function(n2) {
    return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
  };
  var X;
  var nn = { configurable: true, get: function() {
    return this.class;
  } };
  var tn = l.vnode;
  l.vnode = function(n2) {
    var t3 = n2.type, e3 = n2.props, u3 = e3;
    if ("string" == typeof t3) {
      var o2 = -1 === t3.indexOf("-");
      for (var i3 in u3 = {}, e3) {
        var l3 = e3[i3];
        H2 && "children" === i3 && "noscript" === t3 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
      }
      "select" == t3 && u3.multiple && Array.isArray(u3.value) && (u3.value = j2(e3.children).forEach(function(n3) {
        n3.props.selected = -1 != u3.value.indexOf(n3.props.value);
      })), "select" == t3 && null != u3.defaultValue && (u3.value = j2(e3.children).forEach(function(n3) {
        n3.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n3.props.value) : u3.defaultValue == n3.props.value;
      })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
    }
    n2.$$typeof = z2, tn && tn(n2);
  };
  var en = l.__r;
  l.__r = function(n2) {
    en && en(n2), X = n2.__c;
  };

  // node_modules/@fullcalendar/core/internal-common.js
  var styleTexts = [];
  var styleEls = /* @__PURE__ */ new Map();
  function injectStyles(styleText) {
    styleTexts.push(styleText);
    styleEls.forEach((styleEl) => {
      appendStylesTo(styleEl, styleText);
    });
  }
  function ensureElHasStyles(el) {
    if (el.isConnected && // sometimes true if SSR system simulates DOM
    el.getRootNode) {
      registerStylesRoot(el.getRootNode());
    }
  }
  function registerStylesRoot(rootNode) {
    let styleEl = styleEls.get(rootNode);
    if (!styleEl || !styleEl.isConnected) {
      styleEl = rootNode.querySelector("style[data-fullcalendar]");
      if (!styleEl) {
        styleEl = document.createElement("style");
        styleEl.setAttribute("data-fullcalendar", "");
        const nonce = getNonceValue();
        if (nonce) {
          styleEl.nonce = nonce;
        }
        const parentEl = rootNode === document ? document.head : rootNode;
        const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
        parentEl.insertBefore(styleEl, insertBefore);
      }
      styleEls.set(rootNode, styleEl);
      hydrateStylesRoot(styleEl);
    }
  }
  function hydrateStylesRoot(styleEl) {
    for (const styleText of styleTexts) {
      appendStylesTo(styleEl, styleText);
    }
  }
  function appendStylesTo(styleEl, styleText) {
    const { sheet } = styleEl;
    const ruleCnt = sheet.cssRules.length;
    styleText.split("}").forEach((styleStr, i3) => {
      styleStr = styleStr.trim();
      if (styleStr) {
        sheet.insertRule(styleStr + "}", ruleCnt + i3);
      }
    });
  }
  var queriedNonceValue;
  function getNonceValue() {
    if (queriedNonceValue === void 0) {
      queriedNonceValue = queryNonceValue();
    }
    return queriedNonceValue;
  }
  function queryNonceValue() {
    const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
    if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
      return metaWithNonce.getAttribute("content");
    }
    const elWithNonce = document.querySelector("script[nonce]");
    if (elWithNonce) {
      return elWithNonce.nonce || "";
    }
    return "";
  }
  if (typeof document !== "undefined") {
    registerStylesRoot(document);
  }
  var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
  injectStyles(css_248z);
  var DelayedRunner = class {
    constructor(drainedOption) {
      this.drainedOption = drainedOption;
      this.isRunning = false;
      this.isDirty = false;
      this.pauseDepths = {};
      this.timeoutId = 0;
    }
    request(delay) {
      this.isDirty = true;
      if (!this.isPaused()) {
        this.clearTimeout();
        if (delay == null) {
          this.tryDrain();
        } else {
          this.timeoutId = setTimeout(
            // NOT OPTIMAL! TODO: look at debounce
            this.tryDrain.bind(this),
            delay
          );
        }
      }
    }
    pause(scope2 = "") {
      let { pauseDepths } = this;
      pauseDepths[scope2] = (pauseDepths[scope2] || 0) + 1;
      this.clearTimeout();
    }
    resume(scope2 = "", force) {
      let { pauseDepths } = this;
      if (scope2 in pauseDepths) {
        if (force) {
          delete pauseDepths[scope2];
        } else {
          pauseDepths[scope2] -= 1;
          let depth = pauseDepths[scope2];
          if (depth <= 0) {
            delete pauseDepths[scope2];
          }
        }
        this.tryDrain();
      }
    }
    isPaused() {
      return Object.keys(this.pauseDepths).length;
    }
    tryDrain() {
      if (!this.isRunning && !this.isPaused()) {
        this.isRunning = true;
        while (this.isDirty) {
          this.isDirty = false;
          this.drained();
        }
        this.isRunning = false;
      }
    }
    clear() {
      this.clearTimeout();
      this.isDirty = false;
      this.pauseDepths = {};
    }
    clearTimeout() {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = 0;
      }
    }
    drained() {
      if (this.drainedOption) {
        this.drainedOption();
      }
    }
  };
  function removeElement3(el) {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  function elementClosest(el, selector) {
    if (el.closest) {
      return el.closest(selector);
    }
    if (!document.documentElement.contains(el)) {
      return null;
    }
    do {
      if (elementMatches(el, selector)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
  }
  function elementMatches(el, selector) {
    let method = el.matches || el.matchesSelector || el.msMatchesSelector;
    return method.call(el, selector);
  }
  function findElements(container, selector) {
    let containers = container instanceof HTMLElement ? [container] : container;
    let allMatches = [];
    for (let i3 = 0; i3 < containers.length; i3 += 1) {
      let matches = containers[i3].querySelectorAll(selector);
      for (let j5 = 0; j5 < matches.length; j5 += 1) {
        allMatches.push(matches[j5]);
      }
    }
    return allMatches;
  }
  var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
  function applyStyle(el, props) {
    for (let propName in props) {
      applyStyleProp(el, propName, props[propName]);
    }
  }
  function applyStyleProp(el, name, val) {
    if (val == null) {
      el.style[name] = "";
    } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
      el.style[name] = `${val}px`;
    } else {
      el.style[name] = val;
    }
  }
  function getEventTargetViaRoot(ev) {
    var _a, _b;
    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
  }
  var guid$1 = 0;
  function getUniqueDomId() {
    guid$1 += 1;
    return "fc-dom-" + guid$1;
  }
  function preventDefault(ev) {
    ev.preventDefault();
  }
  function buildDelegationHandler(selector, handler4) {
    return (ev) => {
      let matchedChild = elementClosest(ev.target, selector);
      if (matchedChild) {
        handler4.call(matchedChild, ev, matchedChild);
      }
    };
  }
  function listenBySelector(container, eventType, selector, handler4) {
    let attachedHandler = buildDelegationHandler(selector, handler4);
    container.addEventListener(eventType, attachedHandler);
    return () => {
      container.removeEventListener(eventType, attachedHandler);
    };
  }
  function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
    let currentMatchedChild;
    return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
      if (matchedChild !== currentMatchedChild) {
        currentMatchedChild = matchedChild;
        onMouseEnter(mouseOverEv, matchedChild);
        let realOnMouseLeave = (mouseLeaveEv) => {
          currentMatchedChild = null;
          onMouseLeave(mouseLeaveEv, matchedChild);
          matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
        };
        matchedChild.addEventListener("mouseleave", realOnMouseLeave);
      }
    });
  }
  var transitionEventNames = [
    "webkitTransitionEnd",
    "otransitionend",
    "oTransitionEnd",
    "msTransitionEnd",
    "transitionend"
  ];
  function whenTransitionDone(el, callback) {
    let realCallback = (ev) => {
      callback(ev);
      transitionEventNames.forEach((eventName) => {
        el.removeEventListener(eventName, realCallback);
      });
    };
    transitionEventNames.forEach((eventName) => {
      el.addEventListener(eventName, realCallback);
    });
  }
  function createAriaClickAttrs(handler4) {
    return Object.assign({ onClick: handler4 }, createAriaKeyboardAttrs(handler4));
  }
  function createAriaKeyboardAttrs(handler4) {
    return {
      tabIndex: 0,
      onKeyDown(ev) {
        if (ev.key === "Enter" || ev.key === " ") {
          handler4(ev);
          ev.preventDefault();
        }
      }
    };
  }
  var guidNumber = 0;
  function guid() {
    guidNumber += 1;
    return String(guidNumber);
  }
  function disableCursor() {
    document.body.classList.add("fc-not-allowed");
  }
  function enableCursor() {
    document.body.classList.remove("fc-not-allowed");
  }
  function preventSelection(el) {
    el.style.userSelect = "none";
    el.style.webkitUserSelect = "none";
    el.addEventListener("selectstart", preventDefault);
  }
  function allowSelection(el) {
    el.style.userSelect = "";
    el.style.webkitUserSelect = "";
    el.removeEventListener("selectstart", preventDefault);
  }
  function preventContextMenu(el) {
    el.addEventListener("contextmenu", preventDefault);
  }
  function allowContextMenu(el) {
    el.removeEventListener("contextmenu", preventDefault);
  }
  function parseFieldSpecs(input) {
    let specs = [];
    let tokens = [];
    let i3;
    let token;
    if (typeof input === "string") {
      tokens = input.split(/\s*,\s*/);
    } else if (typeof input === "function") {
      tokens = [input];
    } else if (Array.isArray(input)) {
      tokens = input;
    }
    for (i3 = 0; i3 < tokens.length; i3 += 1) {
      token = tokens[i3];
      if (typeof token === "string") {
        specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
      } else if (typeof token === "function") {
        specs.push({ func: token });
      }
    }
    return specs;
  }
  function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
    let i3;
    let cmp;
    for (i3 = 0; i3 < fieldSpecs.length; i3 += 1) {
      cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
      if (cmp) {
        return cmp;
      }
    }
    return 0;
  }
  function compareByFieldSpec(obj0, obj1, fieldSpec) {
    if (fieldSpec.func) {
      return fieldSpec.func(obj0, obj1);
    }
    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
  }
  function flexibleCompare(a3, b3) {
    if (!a3 && !b3) {
      return 0;
    }
    if (b3 == null) {
      return -1;
    }
    if (a3 == null) {
      return 1;
    }
    if (typeof a3 === "string" || typeof b3 === "string") {
      return String(a3).localeCompare(String(b3));
    }
    return a3 - b3;
  }
  function padStart(val, len) {
    let s3 = String(val);
    return "000".substr(0, len - s3.length) + s3;
  }
  function formatWithOrdinals(formatter, args, fallbackText) {
    if (typeof formatter === "function") {
      return formatter(...args);
    }
    if (typeof formatter === "string") {
      return args.reduce((str, arg, index6) => str.replace("$" + index6, arg || ""), formatter);
    }
    return fallbackText;
  }
  function compareNumbers(a3, b3) {
    return a3 - b3;
  }
  function isInt(n2) {
    return n2 % 1 === 0;
  }
  function computeSmallestCellWidth(cellEl) {
    let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
    let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
    if (!allWidthEl) {
      throw new Error("needs fc-scrollgrid-shrink-frame className");
    }
    if (!contentWidthEl) {
      throw new Error("needs fc-scrollgrid-shrink-cushion className");
    }
    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
    contentWidthEl.getBoundingClientRect().width;
  }
  var INTERNAL_UNITS = ["years", "months", "days", "milliseconds"];
  var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
  function createDuration(input, unit) {
    if (typeof input === "string") {
      return parseString(input);
    }
    if (typeof input === "object" && input) {
      return parseObject(input);
    }
    if (typeof input === "number") {
      return parseObject({ [unit || "milliseconds"]: input });
    }
    return null;
  }
  function parseString(s3) {
    let m3 = PARSE_RE.exec(s3);
    if (m3) {
      let sign = m3[1] ? -1 : 1;
      return {
        years: 0,
        months: 0,
        days: sign * (m3[2] ? parseInt(m3[2], 10) : 0),
        milliseconds: sign * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1e3 + // hours
        (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1e3 + // minutes
        (m3[5] ? parseInt(m3[5], 10) : 0) * 1e3 + // seconds
        (m3[6] ? parseInt(m3[6], 10) : 0))
      };
    }
    return null;
  }
  function parseObject(obj) {
    let duration2 = {
      years: obj.years || obj.year || 0,
      months: obj.months || obj.month || 0,
      days: obj.days || obj.day || 0,
      milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
      (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
      (obj.seconds || obj.second || 0) * 1e3 + // seconds
      (obj.milliseconds || obj.millisecond || obj.ms || 0)
      // ms
    };
    let weeks = obj.weeks || obj.week;
    if (weeks) {
      duration2.days += weeks * 7;
      duration2.specifiedWeeks = true;
    }
    return duration2;
  }
  function durationsEqual(d0, d1) {
    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
  }
  function addDurations(d0, d1) {
    return {
      years: d0.years + d1.years,
      months: d0.months + d1.months,
      days: d0.days + d1.days,
      milliseconds: d0.milliseconds + d1.milliseconds
    };
  }
  function subtractDurations(d1, d0) {
    return {
      years: d1.years - d0.years,
      months: d1.months - d0.months,
      days: d1.days - d0.days,
      milliseconds: d1.milliseconds - d0.milliseconds
    };
  }
  function multiplyDuration(d2, n2) {
    return {
      years: d2.years * n2,
      months: d2.months * n2,
      days: d2.days * n2,
      milliseconds: d2.milliseconds * n2
    };
  }
  function asRoughYears(dur) {
    return asRoughDays(dur) / 365;
  }
  function asRoughMonths(dur) {
    return asRoughDays(dur) / 30;
  }
  function asRoughDays(dur) {
    return asRoughMs(dur) / 864e5;
  }
  function asRoughMs(dur) {
    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
  }
  function wholeDivideDurations(numerator, denominator) {
    let res = null;
    for (let i3 = 0; i3 < INTERNAL_UNITS.length; i3 += 1) {
      let unit = INTERNAL_UNITS[i3];
      if (denominator[unit]) {
        let localRes = numerator[unit] / denominator[unit];
        if (!isInt(localRes) || res !== null && res !== localRes) {
          return null;
        }
        res = localRes;
      } else if (numerator[unit]) {
        return null;
      }
    }
    return res;
  }
  function greatestDurationDenominator(dur) {
    let ms = dur.milliseconds;
    if (ms) {
      if (ms % 1e3 !== 0) {
        return { unit: "millisecond", value: ms };
      }
      if (ms % (1e3 * 60) !== 0) {
        return { unit: "second", value: ms / 1e3 };
      }
      if (ms % (1e3 * 60 * 60) !== 0) {
        return { unit: "minute", value: ms / (1e3 * 60) };
      }
      if (ms) {
        return { unit: "hour", value: ms / (1e3 * 60 * 60) };
      }
    }
    if (dur.days) {
      if (dur.specifiedWeeks && dur.days % 7 === 0) {
        return { unit: "week", value: dur.days / 7 };
      }
      return { unit: "day", value: dur.days };
    }
    if (dur.months) {
      return { unit: "month", value: dur.months };
    }
    if (dur.years) {
      return { unit: "year", value: dur.years };
    }
    return { unit: "millisecond", value: 0 };
  }
  function isArraysEqual(a0, a1, equalityFunc) {
    if (a0 === a1) {
      return true;
    }
    let len = a0.length;
    let i3;
    if (len !== a1.length) {
      return false;
    }
    for (i3 = 0; i3 < len; i3 += 1) {
      if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
        return false;
      }
    }
    return true;
  }
  var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
  function addWeeks(m3, n2) {
    let a3 = dateToUtcArray(m3);
    a3[2] += n2 * 7;
    return arrayToUtcDate(a3);
  }
  function addDays(m3, n2) {
    let a3 = dateToUtcArray(m3);
    a3[2] += n2;
    return arrayToUtcDate(a3);
  }
  function addMs(m3, n2) {
    let a3 = dateToUtcArray(m3);
    a3[6] += n2;
    return arrayToUtcDate(a3);
  }
  function diffWeeks(m0, m1) {
    return diffDays(m0, m1) / 7;
  }
  function diffDays(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
  }
  function diffHours(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
  }
  function diffMinutes(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
  }
  function diffSeconds(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / 1e3;
  }
  function diffDayAndTime(m0, m1) {
    let m0day = startOfDay(m0);
    let m1day = startOfDay(m1);
    return {
      years: 0,
      months: 0,
      days: Math.round(diffDays(m0day, m1day)),
      milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
    };
  }
  function diffWholeWeeks(m0, m1) {
    let d2 = diffWholeDays(m0, m1);
    if (d2 !== null && d2 % 7 === 0) {
      return d2 / 7;
    }
    return null;
  }
  function diffWholeDays(m0, m1) {
    if (timeAsMs(m0) === timeAsMs(m1)) {
      return Math.round(diffDays(m0, m1));
    }
    return null;
  }
  function startOfDay(m3) {
    return arrayToUtcDate([
      m3.getUTCFullYear(),
      m3.getUTCMonth(),
      m3.getUTCDate()
    ]);
  }
  function startOfHour(m3) {
    return arrayToUtcDate([
      m3.getUTCFullYear(),
      m3.getUTCMonth(),
      m3.getUTCDate(),
      m3.getUTCHours()
    ]);
  }
  function startOfMinute(m3) {
    return arrayToUtcDate([
      m3.getUTCFullYear(),
      m3.getUTCMonth(),
      m3.getUTCDate(),
      m3.getUTCHours(),
      m3.getUTCMinutes()
    ]);
  }
  function startOfSecond(m3) {
    return arrayToUtcDate([
      m3.getUTCFullYear(),
      m3.getUTCMonth(),
      m3.getUTCDate(),
      m3.getUTCHours(),
      m3.getUTCMinutes(),
      m3.getUTCSeconds()
    ]);
  }
  function weekOfYear(marker, dow, doy) {
    let y3 = marker.getUTCFullYear();
    let w4 = weekOfGivenYear(marker, y3, dow, doy);
    if (w4 < 1) {
      return weekOfGivenYear(marker, y3 - 1, dow, doy);
    }
    let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
    if (nextW >= 1) {
      return Math.min(w4, nextW);
    }
    return w4;
  }
  function weekOfGivenYear(marker, year2, dow, doy) {
    let firstWeekStart = arrayToUtcDate([year2, 0, 1 + firstWeekOffset(year2, dow, doy)]);
    let dayStart = startOfDay(marker);
    let days = Math.round(diffDays(firstWeekStart, dayStart));
    return Math.floor(days / 7) + 1;
  }
  function firstWeekOffset(year2, dow, doy) {
    let fwd = 7 + dow - doy;
    let fwdlw = (7 + arrayToUtcDate([year2, 0, fwd]).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dateToLocalArray(date) {
    return [
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      date.getHours(),
      date.getMinutes(),
      date.getSeconds(),
      date.getMilliseconds()
    ];
  }
  function arrayToLocalDate(a3) {
    return new Date(
      a3[0],
      a3[1] || 0,
      a3[2] == null ? 1 : a3[2],
      // day of month
      a3[3] || 0,
      a3[4] || 0,
      a3[5] || 0
    );
  }
  function dateToUtcArray(date) {
    return [
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds(),
      date.getUTCMilliseconds()
    ];
  }
  function arrayToUtcDate(a3) {
    if (a3.length === 1) {
      a3 = a3.concat([0]);
    }
    return new Date(Date.UTC(...a3));
  }
  function isValidDate(m3) {
    return !isNaN(m3.valueOf());
  }
  function timeAsMs(m3) {
    return m3.getUTCHours() * 1e3 * 60 * 60 + m3.getUTCMinutes() * 1e3 * 60 + m3.getUTCSeconds() * 1e3 + m3.getUTCMilliseconds();
  }
  function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
    let s3 = marker.toISOString();
    s3 = s3.replace(".000", "");
    if (stripZeroTime) {
      s3 = s3.replace("T00:00:00Z", "");
    }
    if (s3.length > 10) {
      if (timeZoneOffset == null) {
        s3 = s3.replace("Z", "");
      } else if (timeZoneOffset !== 0) {
        s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
      }
    }
    return s3;
  }
  function formatDayString(marker) {
    return marker.toISOString().replace(/T.*$/, "");
  }
  function formatIsoMonthStr(marker) {
    return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
  }
  function formatIsoTimeString(marker) {
    return padStart(marker.getUTCHours(), 2) + ":" + padStart(marker.getUTCMinutes(), 2) + ":" + padStart(marker.getUTCSeconds(), 2);
  }
  function formatTimeZoneOffset(minutes, doIso = false) {
    let sign = minutes < 0 ? "-" : "+";
    let abs = Math.abs(minutes);
    let hours = Math.floor(abs / 60);
    let mins = Math.round(abs % 60);
    if (doIso) {
      return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;
    }
    return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
  }
  function memoize(workerFunc, resEquality, teardownFunc) {
    let currentArgs;
    let currentRes;
    return function(...newArgs) {
      if (!currentArgs) {
        currentRes = workerFunc.apply(this, newArgs);
      } else if (!isArraysEqual(currentArgs, newArgs)) {
        if (teardownFunc) {
          teardownFunc(currentRes);
        }
        let res = workerFunc.apply(this, newArgs);
        if (!resEquality || !resEquality(res, currentRes)) {
          currentRes = res;
        }
      }
      currentArgs = newArgs;
      return currentRes;
    };
  }
  function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
    let currentArg;
    let currentRes;
    return (newArg) => {
      if (!currentArg) {
        currentRes = workerFunc.call(this, newArg);
      } else if (!isPropsEqual(currentArg, newArg)) {
        if (teardownFunc) {
          teardownFunc(currentRes);
        }
        let res = workerFunc.call(this, newArg);
        if (!resEquality || !resEquality(res, currentRes)) {
          currentRes = res;
        }
      }
      currentArg = newArg;
      return currentRes;
    };
  }
  var EXTENDED_SETTINGS_AND_SEVERITIES = {
    week: 3,
    separator: 9,
    omitZeroMinute: 9,
    meridiem: 9,
    omitCommas: 9
  };
  var STANDARD_DATE_PROP_SEVERITIES = {
    timeZoneName: 7,
    era: 6,
    year: 5,
    month: 4,
    day: 2,
    weekday: 2,
    hour: 1,
    minute: 1,
    second: 1
  };
  var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
  var COMMA_RE = /,/g;
  var MULTI_SPACE_RE = /\s+/g;
  var LTR_RE = /\u200e/g;
  var UTC_RE = /UTC|GMT/;
  var NativeFormatter = class {
    constructor(formatSettings) {
      let standardDateProps = {};
      let extendedSettings = {};
      let smallestUnitNum = 9;
      for (let name in formatSettings) {
        if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
          extendedSettings[name] = formatSettings[name];
          const severity = EXTENDED_SETTINGS_AND_SEVERITIES[name];
          if (severity < 9) {
            smallestUnitNum = Math.min(EXTENDED_SETTINGS_AND_SEVERITIES[name], smallestUnitNum);
          }
        } else {
          standardDateProps[name] = formatSettings[name];
          if (name in STANDARD_DATE_PROP_SEVERITIES) {
            smallestUnitNum = Math.min(STANDARD_DATE_PROP_SEVERITIES[name], smallestUnitNum);
          }
        }
      }
      this.standardDateProps = standardDateProps;
      this.extendedSettings = extendedSettings;
      this.smallestUnitNum = smallestUnitNum;
      this.buildFormattingFunc = memoize(buildFormattingFunc);
    }
    format(date, context) {
      return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
    }
    formatRange(start2, end, context, betterDefaultSeparator) {
      let { standardDateProps, extendedSettings } = this;
      let diffSeverity = computeMarkerDiffSeverity(start2.marker, end.marker, context.calendarSystem);
      if (!diffSeverity) {
        return this.format(start2, context);
      }
      let biggestUnitForPartial = diffSeverity;
      if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
      (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
        biggestUnitForPartial = 1;
      }
      let full0 = this.format(start2, context);
      let full1 = this.format(end, context);
      if (full0 === full1) {
        return full0;
      }
      let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
      let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
      let partial0 = partialFormattingFunc(start2);
      let partial1 = partialFormattingFunc(end);
      let insertion = findCommonInsertion(full0, partial0, full1, partial1);
      let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
      if (insertion) {
        return insertion.before + partial0 + separator + partial1 + insertion.after;
      }
      return full0 + separator + full1;
    }
    getSmallestUnit() {
      switch (this.smallestUnitNum) {
        case 7:
        case 6:
        case 5:
          return "year";
        case 4:
          return "month";
        case 3:
          return "week";
        case 2:
          return "day";
        default:
          return "time";
      }
    }
  };
  function buildFormattingFunc(standardDateProps, extendedSettings, context) {
    let standardDatePropCnt = Object.keys(standardDateProps).length;
    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
      return (date) => formatTimeZoneOffset(date.timeZoneOffset);
    }
    if (standardDatePropCnt === 0 && extendedSettings.week) {
      return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
    }
    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
  }
  function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
    standardDateProps = Object.assign({}, standardDateProps);
    extendedSettings = Object.assign({}, extendedSettings);
    sanitizeSettings(standardDateProps, extendedSettings);
    standardDateProps.timeZone = "UTC";
    let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
    let zeroFormat;
    if (extendedSettings.omitZeroMinute) {
      let zeroProps = Object.assign({}, standardDateProps);
      delete zeroProps.minute;
      zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
    }
    return (date) => {
      let { marker } = date;
      let format;
      if (zeroFormat && !marker.getUTCMinutes()) {
        format = zeroFormat;
      } else {
        format = normalFormat;
      }
      let s3 = format.format(marker);
      return postProcess(s3, date, standardDateProps, extendedSettings, context);
    };
  }
  function sanitizeSettings(standardDateProps, extendedSettings) {
    if (standardDateProps.timeZoneName) {
      if (!standardDateProps.hour) {
        standardDateProps.hour = "2-digit";
      }
      if (!standardDateProps.minute) {
        standardDateProps.minute = "2-digit";
      }
    }
    if (standardDateProps.timeZoneName === "long") {
      standardDateProps.timeZoneName = "short";
    }
    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
      delete extendedSettings.omitZeroMinute;
    }
  }
  function postProcess(s3, date, standardDateProps, extendedSettings, context) {
    s3 = s3.replace(LTR_RE, "");
    if (standardDateProps.timeZoneName === "short") {
      s3 = injectTzoStr(s3, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
        // important to normalize for IE, which does "GMT"
        formatTimeZoneOffset(date.timeZoneOffset)
      ));
    }
    if (extendedSettings.omitCommas) {
      s3 = s3.replace(COMMA_RE, "").trim();
    }
    if (extendedSettings.omitZeroMinute) {
      s3 = s3.replace(":00", "");
    }
    if (extendedSettings.meridiem === false) {
      s3 = s3.replace(MERIDIEM_RE, "").trim();
    } else if (extendedSettings.meridiem === "narrow") {
      s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
    } else if (extendedSettings.meridiem === "short") {
      s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
    } else if (extendedSettings.meridiem === "lowercase") {
      s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
    }
    s3 = s3.replace(MULTI_SPACE_RE, " ");
    s3 = s3.trim();
    return s3;
  }
  function injectTzoStr(s3, tzoStr) {
    let replaced = false;
    s3 = s3.replace(UTC_RE, () => {
      replaced = true;
      return tzoStr;
    });
    if (!replaced) {
      s3 += ` ${tzoStr}`;
    }
    return s3;
  }
  function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
    let parts = [];
    if (display === "long") {
      parts.push(weekTextLong);
    } else if (display === "short" || display === "narrow") {
      parts.push(weekText);
    }
    if (display === "long" || display === "short") {
      parts.push(" ");
    }
    parts.push(locale.simpleNumberFormat.format(num));
    if (locale.options.direction === "rtl") {
      parts.reverse();
    }
    return parts.join("");
  }
  function computeMarkerDiffSeverity(d0, d1, ca) {
    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
      return 5;
    }
    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
      return 4;
    }
    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
      return 2;
    }
    if (timeAsMs(d0) !== timeAsMs(d1)) {
      return 1;
    }
    return 0;
  }
  function computePartialFormattingOptions(options, biggestUnit) {
    let partialOptions = {};
    for (let name in options) {
      if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
      STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
        partialOptions[name] = options[name];
      }
    }
    return partialOptions;
  }
  function findCommonInsertion(full0, partial0, full1, partial1) {
    let i0 = 0;
    while (i0 < full0.length) {
      let found0 = full0.indexOf(partial0, i0);
      if (found0 === -1) {
        break;
      }
      let before0 = full0.substr(0, found0);
      i0 = found0 + partial0.length;
      let after0 = full0.substr(i0);
      let i1 = 0;
      while (i1 < full1.length) {
        let found1 = full1.indexOf(partial1, i1);
        if (found1 === -1) {
          break;
        }
        let before1 = full1.substr(0, found1);
        i1 = found1 + partial1.length;
        let after1 = full1.substr(i1);
        if (before0 === before1 && after0 === after1) {
          return {
            before: before0,
            after: after0
          };
        }
      }
    }
    return null;
  }
  function expandZonedMarker(dateInfo, calendarSystem) {
    let a3 = calendarSystem.markerToArray(dateInfo.marker);
    return {
      marker: dateInfo.marker,
      timeZoneOffset: dateInfo.timeZoneOffset,
      array: a3,
      year: a3[0],
      month: a3[1],
      day: a3[2],
      hour: a3[3],
      minute: a3[4],
      second: a3[5],
      millisecond: a3[6]
    };
  }
  function createVerboseFormattingArg(start2, end, context, betterDefaultSeparator) {
    let startInfo = expandZonedMarker(start2, context.calendarSystem);
    let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
    return {
      date: startInfo,
      start: startInfo,
      end: endInfo,
      timeZone: context.timeZone,
      localeCodes: context.locale.codes,
      defaultSeparator: betterDefaultSeparator || context.defaultSeparator
    };
  }
  var CmdFormatter = class {
    constructor(cmdStr) {
      this.cmdStr = cmdStr;
    }
    format(date, context, betterDefaultSeparator) {
      return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
    }
    formatRange(start2, end, context, betterDefaultSeparator) {
      return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start2, end, context, betterDefaultSeparator));
    }
  };
  var FuncFormatter = class {
    constructor(func) {
      this.func = func;
    }
    format(date, context, betterDefaultSeparator) {
      return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
    }
    formatRange(start2, end, context, betterDefaultSeparator) {
      return this.func(createVerboseFormattingArg(start2, end, context, betterDefaultSeparator));
    }
  };
  function createFormatter(input) {
    if (typeof input === "object" && input) {
      return new NativeFormatter(input);
    }
    if (typeof input === "string") {
      return new CmdFormatter(input);
    }
    if (typeof input === "function") {
      return new FuncFormatter(input);
    }
    return null;
  }
  var BASE_OPTION_REFINERS = {
    navLinkDayClick: identity,
    navLinkWeekClick: identity,
    duration: createDuration,
    bootstrapFontAwesome: identity,
    buttonIcons: identity,
    customButtons: identity,
    defaultAllDayEventDuration: createDuration,
    defaultTimedEventDuration: createDuration,
    nextDayThreshold: createDuration,
    scrollTime: createDuration,
    scrollTimeReset: Boolean,
    slotMinTime: createDuration,
    slotMaxTime: createDuration,
    dayPopoverFormat: createFormatter,
    slotDuration: createDuration,
    snapDuration: createDuration,
    headerToolbar: identity,
    footerToolbar: identity,
    defaultRangeSeparator: String,
    titleRangeSeparator: String,
    forceEventDuration: Boolean,
    dayHeaders: Boolean,
    dayHeaderFormat: createFormatter,
    dayHeaderClassNames: identity,
    dayHeaderContent: identity,
    dayHeaderDidMount: identity,
    dayHeaderWillUnmount: identity,
    dayCellClassNames: identity,
    dayCellContent: identity,
    dayCellDidMount: identity,
    dayCellWillUnmount: identity,
    initialView: String,
    aspectRatio: Number,
    weekends: Boolean,
    weekNumberCalculation: identity,
    weekNumbers: Boolean,
    weekNumberClassNames: identity,
    weekNumberContent: identity,
    weekNumberDidMount: identity,
    weekNumberWillUnmount: identity,
    editable: Boolean,
    viewClassNames: identity,
    viewDidMount: identity,
    viewWillUnmount: identity,
    nowIndicator: Boolean,
    nowIndicatorSnap: identity,
    nowIndicatorClassNames: identity,
    nowIndicatorContent: identity,
    nowIndicatorDidMount: identity,
    nowIndicatorWillUnmount: identity,
    showNonCurrentDates: Boolean,
    lazyFetching: Boolean,
    startParam: String,
    endParam: String,
    timeZoneParam: String,
    timeZone: String,
    locales: identity,
    locale: identity,
    themeSystem: String,
    dragRevertDuration: Number,
    dragScroll: Boolean,
    allDayMaintainDuration: Boolean,
    unselectAuto: Boolean,
    dropAccept: identity,
    eventOrder: parseFieldSpecs,
    eventOrderStrict: Boolean,
    handleWindowResize: Boolean,
    windowResizeDelay: Number,
    longPressDelay: Number,
    eventDragMinDistance: Number,
    expandRows: Boolean,
    height: identity,
    contentHeight: identity,
    direction: String,
    weekNumberFormat: createFormatter,
    eventResizableFromStart: Boolean,
    displayEventTime: Boolean,
    displayEventEnd: Boolean,
    weekText: String,
    weekTextLong: String,
    progressiveEventRendering: Boolean,
    businessHours: identity,
    initialDate: identity,
    now: identity,
    eventDataTransform: identity,
    stickyHeaderDates: identity,
    stickyFooterScrollbar: identity,
    viewHeight: identity,
    defaultAllDay: Boolean,
    eventSourceFailure: identity,
    eventSourceSuccess: identity,
    eventDisplay: String,
    eventStartEditable: Boolean,
    eventDurationEditable: Boolean,
    eventOverlap: identity,
    eventConstraint: identity,
    eventAllow: identity,
    eventBackgroundColor: String,
    eventBorderColor: String,
    eventTextColor: String,
    eventColor: String,
    eventClassNames: identity,
    eventContent: identity,
    eventDidMount: identity,
    eventWillUnmount: identity,
    selectConstraint: identity,
    selectOverlap: identity,
    selectAllow: identity,
    droppable: Boolean,
    unselectCancel: String,
    slotLabelFormat: identity,
    slotLaneClassNames: identity,
    slotLaneContent: identity,
    slotLaneDidMount: identity,
    slotLaneWillUnmount: identity,
    slotLabelClassNames: identity,
    slotLabelContent: identity,
    slotLabelDidMount: identity,
    slotLabelWillUnmount: identity,
    dayMaxEvents: identity,
    dayMaxEventRows: identity,
    dayMinWidth: Number,
    slotLabelInterval: createDuration,
    allDayText: String,
    allDayClassNames: identity,
    allDayContent: identity,
    allDayDidMount: identity,
    allDayWillUnmount: identity,
    slotMinWidth: Number,
    navLinks: Boolean,
    eventTimeFormat: createFormatter,
    rerenderDelay: Number,
    moreLinkText: identity,
    moreLinkHint: identity,
    selectMinDistance: Number,
    selectable: Boolean,
    selectLongPressDelay: Number,
    eventLongPressDelay: Number,
    selectMirror: Boolean,
    eventMaxStack: Number,
    eventMinHeight: Number,
    eventMinWidth: Number,
    eventShortHeight: Number,
    slotEventOverlap: Boolean,
    plugins: identity,
    firstDay: Number,
    dayCount: Number,
    dateAlignment: String,
    dateIncrement: createDuration,
    hiddenDays: identity,
    fixedWeekCount: Boolean,
    validRange: identity,
    visibleRange: identity,
    titleFormat: identity,
    eventInteractive: Boolean,
    // only used by list-view, but languages define the value, so we need it in base options
    noEventsText: String,
    viewHint: identity,
    navLinkHint: identity,
    closeHint: String,
    timeHint: String,
    eventHint: String,
    moreLinkClick: identity,
    moreLinkClassNames: identity,
    moreLinkContent: identity,
    moreLinkDidMount: identity,
    moreLinkWillUnmount: identity,
    monthStartFormat: createFormatter,
    // for connectors
    // (can't be part of plugin system b/c must be provided at runtime)
    handleCustomRendering: identity,
    customRenderingMetaMap: identity,
    customRenderingReplaces: Boolean
  };
  var BASE_OPTION_DEFAULTS = {
    eventDisplay: "auto",
    defaultRangeSeparator: " - ",
    titleRangeSeparator: " \u2013 ",
    defaultTimedEventDuration: "01:00:00",
    defaultAllDayEventDuration: { day: 1 },
    forceEventDuration: false,
    nextDayThreshold: "00:00:00",
    dayHeaders: true,
    initialView: "",
    aspectRatio: 1.35,
    headerToolbar: {
      start: "title",
      center: "",
      end: "today prev,next"
    },
    weekends: true,
    weekNumbers: false,
    weekNumberCalculation: "local",
    editable: false,
    nowIndicator: false,
    scrollTime: "06:00:00",
    scrollTimeReset: true,
    slotMinTime: "00:00:00",
    slotMaxTime: "24:00:00",
    showNonCurrentDates: true,
    lazyFetching: true,
    startParam: "start",
    endParam: "end",
    timeZoneParam: "timeZone",
    timeZone: "local",
    locales: [],
    locale: "",
    themeSystem: "standard",
    dragRevertDuration: 500,
    dragScroll: true,
    allDayMaintainDuration: false,
    unselectAuto: true,
    dropAccept: "*",
    eventOrder: "start,-duration,allDay,title",
    dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1e3,
    eventDragMinDistance: 5,
    expandRows: false,
    navLinks: false,
    selectable: false,
    eventMinHeight: 15,
    eventMinWidth: 30,
    eventShortHeight: 30,
    monthStartFormat: { month: "long", day: "numeric" },
    nowIndicatorSnap: "auto"
  };
  var CALENDAR_LISTENER_REFINERS = {
    datesSet: identity,
    eventsSet: identity,
    eventAdd: identity,
    eventChange: identity,
    eventRemove: identity,
    windowResize: identity,
    eventClick: identity,
    eventMouseEnter: identity,
    eventMouseLeave: identity,
    select: identity,
    unselect: identity,
    loading: identity,
    // internal
    _unmount: identity,
    _beforeprint: identity,
    _afterprint: identity,
    _noEventDrop: identity,
    _noEventResize: identity,
    _resize: identity,
    _scrollRequest: identity
  };
  var CALENDAR_OPTION_REFINERS = {
    buttonText: identity,
    buttonHints: identity,
    views: identity,
    plugins: identity,
    initialEvents: identity,
    events: identity,
    eventSources: identity
  };
  var COMPLEX_OPTION_COMPARATORS = {
    headerToolbar: isMaybeObjectsEqual,
    footerToolbar: isMaybeObjectsEqual,
    buttonText: isMaybeObjectsEqual,
    buttonHints: isMaybeObjectsEqual,
    buttonIcons: isMaybeObjectsEqual,
    dateIncrement: isMaybeObjectsEqual,
    plugins: isMaybeArraysEqual,
    events: isMaybeArraysEqual,
    eventSources: isMaybeArraysEqual,
    ["resources"]: isMaybeArraysEqual
  };
  function isMaybeObjectsEqual(a3, b3) {
    if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
      return isPropsEqual(a3, b3);
    }
    return a3 === b3;
  }
  function isMaybeArraysEqual(a3, b3) {
    if (Array.isArray(a3) && Array.isArray(b3)) {
      return isArraysEqual(a3, b3);
    }
    return a3 === b3;
  }
  var VIEW_OPTION_REFINERS = {
    type: String,
    component: identity,
    buttonText: String,
    buttonTextKey: String,
    dateProfileGeneratorClass: identity,
    usesMinMaxTime: Boolean,
    classNames: identity,
    content: identity,
    didMount: identity,
    willUnmount: identity
  };
  function mergeRawOptions(optionSets) {
    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
  }
  function refineProps(input, refiners) {
    let refined = {};
    let extra = {};
    for (let propName in refiners) {
      if (propName in input) {
        refined[propName] = refiners[propName](input[propName]);
      }
    }
    for (let propName in input) {
      if (!(propName in refiners)) {
        extra[propName] = input[propName];
      }
    }
    return { refined, extra };
  }
  function identity(raw2) {
    return raw2;
  }
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  function mergeProps(propObjs, complexPropsMap) {
    let dest = {};
    if (complexPropsMap) {
      for (let name in complexPropsMap) {
        if (complexPropsMap[name] === isMaybeObjectsEqual) {
          let complexObjs = [];
          for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
            let val = propObjs[i3][name];
            if (typeof val === "object" && val) {
              complexObjs.unshift(val);
            } else if (val !== void 0) {
              dest[name] = val;
              break;
            }
          }
          if (complexObjs.length) {
            dest[name] = mergeProps(complexObjs);
          }
        }
      }
    }
    for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
      let props = propObjs[i3];
      for (let name in props) {
        if (!(name in dest)) {
          dest[name] = props[name];
        }
      }
    }
    return dest;
  }
  function filterHash(hash, func) {
    let filtered = {};
    for (let key in hash) {
      if (func(hash[key], key)) {
        filtered[key] = hash[key];
      }
    }
    return filtered;
  }
  function mapHash(hash, func) {
    let newHash = {};
    for (let key in hash) {
      newHash[key] = func(hash[key], key);
    }
    return newHash;
  }
  function arrayToHash(a3) {
    let hash = {};
    for (let item of a3) {
      hash[item] = true;
    }
    return hash;
  }
  function hashValuesToArray(obj) {
    let a3 = [];
    for (let key in obj) {
      a3.push(obj[key]);
    }
    return a3;
  }
  function isPropsEqual(obj0, obj1) {
    if (obj0 === obj1) {
      return true;
    }
    for (let key in obj0) {
      if (hasOwnProperty2.call(obj0, key)) {
        if (!(key in obj1)) {
          return false;
        }
      }
    }
    for (let key in obj1) {
      if (hasOwnProperty2.call(obj1, key)) {
        if (obj0[key] !== obj1[key]) {
          return false;
        }
      }
    }
    return true;
  }
  var HANDLER_RE = /^on[A-Z]/;
  function isNonHandlerPropsEqual(obj0, obj1) {
    const keys = getUnequalProps(obj0, obj1);
    for (let key of keys) {
      if (!HANDLER_RE.test(key)) {
        return false;
      }
    }
    return true;
  }
  function getUnequalProps(obj0, obj1) {
    let keys = [];
    for (let key in obj0) {
      if (hasOwnProperty2.call(obj0, key)) {
        if (!(key in obj1)) {
          keys.push(key);
        }
      }
    }
    for (let key in obj1) {
      if (hasOwnProperty2.call(obj1, key)) {
        if (obj0[key] !== obj1[key]) {
          keys.push(key);
        }
      }
    }
    return keys;
  }
  function compareObjs(oldProps, newProps, equalityFuncs = {}) {
    if (oldProps === newProps) {
      return true;
    }
    for (let key in newProps) {
      if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;
      else {
        return false;
      }
    }
    for (let key in oldProps) {
      if (!(key in newProps)) {
        return false;
      }
    }
    return true;
  }
  function isObjValsEqual(val0, val1, comparator) {
    if (val0 === val1 || comparator === true) {
      return true;
    }
    if (comparator) {
      return comparator(val0, val1);
    }
    return false;
  }
  function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
    let res = [];
    if (endIndex == null) {
      endIndex = Object.keys(hash).length;
    }
    for (let i3 = startIndex; i3 < endIndex; i3 += step) {
      let val = hash[i3];
      if (val !== void 0) {
        res.push(val);
      }
    }
    return res;
  }
  var calendarSystemClassMap = {};
  function registerCalendarSystem(name, theClass) {
    calendarSystemClassMap[name] = theClass;
  }
  function createCalendarSystem(name) {
    return new calendarSystemClassMap[name]();
  }
  var GregorianCalendarSystem = class {
    getMarkerYear(d2) {
      return d2.getUTCFullYear();
    }
    getMarkerMonth(d2) {
      return d2.getUTCMonth();
    }
    getMarkerDay(d2) {
      return d2.getUTCDate();
    }
    arrayToMarker(arr) {
      return arrayToUtcDate(arr);
    }
    markerToArray(marker) {
      return dateToUtcArray(marker);
    }
  };
  registerCalendarSystem("gregory", GregorianCalendarSystem);
  var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
  function parse(str) {
    let m3 = ISO_RE.exec(str);
    if (m3) {
      let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1e3 : 0));
      if (isValidDate(marker)) {
        let timeZoneOffset = null;
        if (m3[13]) {
          timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
        }
        return {
          marker,
          isTimeUnspecified: !m3[6],
          timeZoneOffset
        };
      }
    }
    return null;
  }
  var DateEnv = class {
    constructor(settings) {
      let timeZone = this.timeZone = settings.timeZone;
      let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
      if (settings.namedTimeZoneImpl && isNamedTimeZone) {
        this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
      }
      this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
      this.calendarSystem = createCalendarSystem(settings.calendarSystem);
      this.locale = settings.locale;
      this.weekDow = settings.locale.week.dow;
      this.weekDoy = settings.locale.week.doy;
      if (settings.weekNumberCalculation === "ISO") {
        this.weekDow = 1;
        this.weekDoy = 4;
      }
      if (typeof settings.firstDay === "number") {
        this.weekDow = settings.firstDay;
      }
      if (typeof settings.weekNumberCalculation === "function") {
        this.weekNumberFunc = settings.weekNumberCalculation;
      }
      this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
      this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
      this.cmdFormatter = settings.cmdFormatter;
      this.defaultSeparator = settings.defaultSeparator;
    }
    // Creating / Parsing
    createMarker(input) {
      let meta = this.createMarkerMeta(input);
      if (meta === null) {
        return null;
      }
      return meta.marker;
    }
    createNowMarker() {
      if (this.canComputeOffset) {
        return this.timestampToMarker((/* @__PURE__ */ new Date()).valueOf());
      }
      return arrayToUtcDate(dateToLocalArray(/* @__PURE__ */ new Date()));
    }
    createMarkerMeta(input) {
      if (typeof input === "string") {
        return this.parse(input);
      }
      let marker = null;
      if (typeof input === "number") {
        marker = this.timestampToMarker(input);
      } else if (input instanceof Date) {
        input = input.valueOf();
        if (!isNaN(input)) {
          marker = this.timestampToMarker(input);
        }
      } else if (Array.isArray(input)) {
        marker = arrayToUtcDate(input);
      }
      if (marker === null || !isValidDate(marker)) {
        return null;
      }
      return { marker, isTimeUnspecified: false, forcedTzo: null };
    }
    parse(s3) {
      let parts = parse(s3);
      if (parts === null) {
        return null;
      }
      let { marker } = parts;
      let forcedTzo = null;
      if (parts.timeZoneOffset !== null) {
        if (this.canComputeOffset) {
          marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
        } else {
          forcedTzo = parts.timeZoneOffset;
        }
      }
      return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
    }
    // Accessors
    getYear(marker) {
      return this.calendarSystem.getMarkerYear(marker);
    }
    getMonth(marker) {
      return this.calendarSystem.getMarkerMonth(marker);
    }
    getDay(marker) {
      return this.calendarSystem.getMarkerDay(marker);
    }
    // Adding / Subtracting
    add(marker, dur) {
      let a3 = this.calendarSystem.markerToArray(marker);
      a3[0] += dur.years;
      a3[1] += dur.months;
      a3[2] += dur.days;
      a3[6] += dur.milliseconds;
      return this.calendarSystem.arrayToMarker(a3);
    }
    subtract(marker, dur) {
      let a3 = this.calendarSystem.markerToArray(marker);
      a3[0] -= dur.years;
      a3[1] -= dur.months;
      a3[2] -= dur.days;
      a3[6] -= dur.milliseconds;
      return this.calendarSystem.arrayToMarker(a3);
    }
    addYears(marker, n2) {
      let a3 = this.calendarSystem.markerToArray(marker);
      a3[0] += n2;
      return this.calendarSystem.arrayToMarker(a3);
    }
    addMonths(marker, n2) {
      let a3 = this.calendarSystem.markerToArray(marker);
      a3[1] += n2;
      return this.calendarSystem.arrayToMarker(a3);
    }
    // Diffing Whole Units
    diffWholeYears(m0, m1) {
      let { calendarSystem } = this;
      if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
        return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
      }
      return null;
    }
    diffWholeMonths(m0, m1) {
      let { calendarSystem } = this;
      if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
        return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
      }
      return null;
    }
    // Range / Duration
    greatestWholeUnit(m0, m1) {
      let n2 = this.diffWholeYears(m0, m1);
      if (n2 !== null) {
        return { unit: "year", value: n2 };
      }
      n2 = this.diffWholeMonths(m0, m1);
      if (n2 !== null) {
        return { unit: "month", value: n2 };
      }
      n2 = diffWholeWeeks(m0, m1);
      if (n2 !== null) {
        return { unit: "week", value: n2 };
      }
      n2 = diffWholeDays(m0, m1);
      if (n2 !== null) {
        return { unit: "day", value: n2 };
      }
      n2 = diffHours(m0, m1);
      if (isInt(n2)) {
        return { unit: "hour", value: n2 };
      }
      n2 = diffMinutes(m0, m1);
      if (isInt(n2)) {
        return { unit: "minute", value: n2 };
      }
      n2 = diffSeconds(m0, m1);
      if (isInt(n2)) {
        return { unit: "second", value: n2 };
      }
      return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
    }
    countDurationsBetween(m0, m1, d2) {
      let diff;
      if (d2.years) {
        diff = this.diffWholeYears(m0, m1);
        if (diff !== null) {
          return diff / asRoughYears(d2);
        }
      }
      if (d2.months) {
        diff = this.diffWholeMonths(m0, m1);
        if (diff !== null) {
          return diff / asRoughMonths(d2);
        }
      }
      if (d2.days) {
        diff = diffWholeDays(m0, m1);
        if (diff !== null) {
          return diff / asRoughDays(d2);
        }
      }
      return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
    }
    // Start-Of
    // these DON'T return zoned-dates. only UTC start-of dates
    startOf(m3, unit) {
      if (unit === "year") {
        return this.startOfYear(m3);
      }
      if (unit === "month") {
        return this.startOfMonth(m3);
      }
      if (unit === "week") {
        return this.startOfWeek(m3);
      }
      if (unit === "day") {
        return startOfDay(m3);
      }
      if (unit === "hour") {
        return startOfHour(m3);
      }
      if (unit === "minute") {
        return startOfMinute(m3);
      }
      if (unit === "second") {
        return startOfSecond(m3);
      }
      return null;
    }
    startOfYear(m3) {
      return this.calendarSystem.arrayToMarker([
        this.calendarSystem.getMarkerYear(m3)
      ]);
    }
    startOfMonth(m3) {
      return this.calendarSystem.arrayToMarker([
        this.calendarSystem.getMarkerYear(m3),
        this.calendarSystem.getMarkerMonth(m3)
      ]);
    }
    startOfWeek(m3) {
      return this.calendarSystem.arrayToMarker([
        this.calendarSystem.getMarkerYear(m3),
        this.calendarSystem.getMarkerMonth(m3),
        m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
      ]);
    }
    // Week Number
    computeWeekNumber(marker) {
      if (this.weekNumberFunc) {
        return this.weekNumberFunc(this.toDate(marker));
      }
      return weekOfYear(marker, this.weekDow, this.weekDoy);
    }
    // TODO: choke on timeZoneName: long
    format(marker, formatter, dateOptions = {}) {
      return formatter.format({
        marker,
        timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
      }, this);
    }
    formatRange(start2, end, formatter, dateOptions = {}) {
      if (dateOptions.isEndExclusive) {
        end = addMs(end, -1);
      }
      return formatter.formatRange({
        marker: start2,
        timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start2)
      }, {
        marker: end,
        timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
      }, this, dateOptions.defaultSeparator);
    }
    /*
    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
    might as well use buildIsoString or some other util directly
    */
    formatIso(marker, extraOptions = {}) {
      let timeZoneOffset = null;
      if (!extraOptions.omitTimeZoneOffset) {
        if (extraOptions.forcedTzo != null) {
          timeZoneOffset = extraOptions.forcedTzo;
        } else {
          timeZoneOffset = this.offsetForMarker(marker);
        }
      }
      return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
    }
    // TimeZone
    timestampToMarker(ms) {
      if (this.timeZone === "local") {
        return arrayToUtcDate(dateToLocalArray(new Date(ms)));
      }
      if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
        return new Date(ms);
      }
      return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
    }
    offsetForMarker(m3) {
      if (this.timeZone === "local") {
        return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
      }
      if (this.timeZone === "UTC") {
        return 0;
      }
      if (this.namedTimeZoneImpl) {
        return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
      }
      return null;
    }
    // Conversion
    toDate(m3, forcedTzo) {
      if (this.timeZone === "local") {
        return arrayToLocalDate(dateToUtcArray(m3));
      }
      if (this.timeZone === "UTC") {
        return new Date(m3.valueOf());
      }
      if (!this.namedTimeZoneImpl) {
        return new Date(m3.valueOf() - (forcedTzo || 0));
      }
      return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1e3 * 60);
    }
  };
  var Theme = class {
    constructor(calendarOptions) {
      if (this.iconOverrideOption) {
        this.setIconOverride(calendarOptions[this.iconOverrideOption]);
      }
    }
    setIconOverride(iconOverrideHash) {
      let iconClassesCopy;
      let buttonName;
      if (typeof iconOverrideHash === "object" && iconOverrideHash) {
        iconClassesCopy = Object.assign({}, this.iconClasses);
        for (buttonName in iconOverrideHash) {
          iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
        }
        this.iconClasses = iconClassesCopy;
      } else if (iconOverrideHash === false) {
        this.iconClasses = {};
      }
    }
    applyIconOverridePrefix(className) {
      let prefix2 = this.iconOverridePrefix;
      if (prefix2 && className.indexOf(prefix2) !== 0) {
        className = prefix2 + className;
      }
      return className;
    }
    getClass(key) {
      return this.classes[key] || "";
    }
    getIconClass(buttonName, isRtl) {
      let className;
      if (isRtl && this.rtlIconClasses) {
        className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
      } else {
        className = this.iconClasses[buttonName];
      }
      if (className) {
        return `${this.baseIconClass} ${className}`;
      }
      return "";
    }
    getCustomButtonIconClass(customButtonProps) {
      let className;
      if (this.iconOverrideCustomButtonOption) {
        className = customButtonProps[this.iconOverrideCustomButtonOption];
        if (className) {
          return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
        }
      }
      return "";
    }
  };
  Theme.prototype.classes = {};
  Theme.prototype.iconClasses = {};
  Theme.prototype.baseIconClass = "";
  Theme.prototype.iconOverridePrefix = "";
  function flushSync(runBeforeFlush) {
    runBeforeFlush();
    let oldDebounceRendering = l.debounceRendering;
    let callbackQ = [];
    function execCallbackSync(callback) {
      callbackQ.push(callback);
    }
    l.debounceRendering = execCallbackSync;
    D(y(FakeComponent, {}), document.createElement("div"));
    while (callbackQ.length) {
      callbackQ.shift()();
    }
    l.debounceRendering = oldDebounceRendering;
  }
  var FakeComponent = class extends x {
    render() {
      return y("div", {});
    }
    componentDidMount() {
      this.setState({});
    }
  };
  function createContext(defaultValue) {
    let ContextType = G(defaultValue);
    let origProvider = ContextType.Provider;
    ContextType.Provider = function() {
      let isNew = !this.getChildContext;
      let children = origProvider.apply(this, arguments);
      if (isNew) {
        let subs = [];
        this.shouldComponentUpdate = (_props) => {
          if (this.props.value !== _props.value) {
            subs.forEach((c3) => {
              c3.context = _props.value;
              c3.forceUpdate();
            });
          }
        };
        this.sub = (c3) => {
          subs.push(c3);
          let old = c3.componentWillUnmount;
          c3.componentWillUnmount = () => {
            subs.splice(subs.indexOf(c3), 1);
            old && old.call(c3);
          };
        };
      }
      return children;
    };
    return ContextType;
  }
  var ScrollResponder = class {
    constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
      this.execFunc = execFunc;
      this.emitter = emitter;
      this.scrollTime = scrollTime;
      this.scrollTimeReset = scrollTimeReset;
      this.handleScrollRequest = (request) => {
        this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
        this.drain();
      };
      emitter.on("_scrollRequest", this.handleScrollRequest);
      this.fireInitialScroll();
    }
    detach() {
      this.emitter.off("_scrollRequest", this.handleScrollRequest);
    }
    update(isDatesNew) {
      if (isDatesNew && this.scrollTimeReset) {
        this.fireInitialScroll();
      } else {
        this.drain();
      }
    }
    fireInitialScroll() {
      this.handleScrollRequest({
        time: this.scrollTime
      });
    }
    drain() {
      if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
        this.queuedRequest = null;
      }
    }
  };
  var ViewContextType = createContext({});
  function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, nowManager, theme, pluginHooks, dispatch2, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
    return {
      dateEnv,
      nowManager,
      options: viewOptions,
      pluginHooks,
      emitter,
      dispatch: dispatch2,
      getCurrentData,
      calendarApi,
      viewSpec,
      viewApi,
      dateProfileGenerator,
      theme,
      isRtl: viewOptions.direction === "rtl",
      addResizeHandler(handler4) {
        emitter.on("_resize", handler4);
      },
      removeResizeHandler(handler4) {
        emitter.off("_resize", handler4);
      },
      createScrollResponder(execFunc) {
        return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
      },
      registerInteractiveComponent,
      unregisterInteractiveComponent
    };
  }
  var PureComponent = class extends x {
    // debug: boolean
    shouldComponentUpdate(nextProps, nextState) {
      const shouldUpdate = !compareObjs(
        this.props,
        nextProps,
        this.propEquality
        /*, this.debug */
      ) || !compareObjs(
        this.state,
        nextState,
        this.stateEquality
        /*, this.debug */
      );
      return shouldUpdate;
    }
    // HACK for freakin' React StrictMode
    safeSetState(newState) {
      if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
        this.setState(newState);
      }
    }
  };
  PureComponent.addPropsEquality = addPropsEquality;
  PureComponent.addStateEquality = addStateEquality;
  PureComponent.contextType = ViewContextType;
  PureComponent.prototype.propEquality = {};
  PureComponent.prototype.stateEquality = {};
  var BaseComponent2 = class extends PureComponent {
  };
  BaseComponent2.contextType = ViewContextType;
  function addPropsEquality(propEquality) {
    let hash = Object.create(this.prototype.propEquality);
    Object.assign(hash, propEquality);
    this.prototype.propEquality = hash;
  }
  function addStateEquality(stateEquality) {
    let hash = Object.create(this.prototype.stateEquality);
    Object.assign(hash, stateEquality);
    this.prototype.stateEquality = hash;
  }
  function setRef(ref, current) {
    if (typeof ref === "function") {
      ref(current);
    } else if (ref) {
      ref.current = current;
    }
  }
  var ContentInjector = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.id = guid();
      this.queuedDomNodes = [];
      this.currentDomNodes = [];
      this.handleEl = (el) => {
        const { options } = this.context;
        const { generatorName } = this.props;
        if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
          this.updateElRef(el);
        }
      };
      this.updateElRef = (el) => {
        if (this.props.elRef) {
          setRef(this.props.elRef, el);
        }
      };
    }
    render() {
      const { props, context } = this;
      const { options } = context;
      const { customGenerator, defaultGenerator, renderProps } = props;
      const attrs = buildElAttrs(props, [], this.handleEl);
      let useDefault = false;
      let innerContent;
      let queuedDomNodes = [];
      let currentGeneratorMeta;
      if (customGenerator != null) {
        const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
        if (customGeneratorRes === true) {
          useDefault = true;
        } else {
          const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
          if (isObject2 && "html" in customGeneratorRes) {
            attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
          } else if (isObject2 && "domNodes" in customGeneratorRes) {
            queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
          } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
            innerContent = customGeneratorRes;
          } else {
            currentGeneratorMeta = customGeneratorRes;
          }
        }
      } else {
        useDefault = !hasCustomRenderingHandler(props.generatorName, options);
      }
      if (useDefault && defaultGenerator) {
        innerContent = defaultGenerator(renderProps);
      }
      this.queuedDomNodes = queuedDomNodes;
      this.currentGeneratorMeta = currentGeneratorMeta;
      return y(props.elTag, attrs, innerContent);
    }
    componentDidMount() {
      this.applyQueueudDomNodes();
      this.triggerCustomRendering(true);
    }
    componentDidUpdate() {
      this.applyQueueudDomNodes();
      this.triggerCustomRendering(true);
    }
    componentWillUnmount() {
      this.triggerCustomRendering(false);
    }
    triggerCustomRendering(isActive) {
      var _a;
      const { props, context } = this;
      const { handleCustomRendering, customRenderingMetaMap } = context.options;
      if (handleCustomRendering) {
        const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
        if (generatorMeta) {
          handleCustomRendering(Object.assign(Object.assign({
            id: this.id,
            isActive,
            containerEl: this.base,
            reportNewContainerEl: this.updateElRef,
            // front-end framework tells us about new container els
            generatorMeta
          }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
        }
      }
    }
    applyQueueudDomNodes() {
      const { queuedDomNodes, currentDomNodes } = this;
      const el = this.base;
      if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
        currentDomNodes.forEach(removeElement3);
        for (let newNode of queuedDomNodes) {
          el.appendChild(newNode);
        }
        this.currentDomNodes = queuedDomNodes;
      }
    }
  };
  ContentInjector.addPropsEquality({
    elClasses: isArraysEqual,
    elStyle: isPropsEqual,
    elAttrs: isNonHandlerPropsEqual,
    renderProps: isPropsEqual
  });
  function hasCustomRenderingHandler(generatorName, options) {
    var _a;
    return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
  }
  function buildElAttrs(props, extraClassNames, elRef) {
    const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
    if (props.elClasses || extraClassNames) {
      attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
    }
    if (props.elStyle) {
      attrs.style = props.elStyle;
    }
    return attrs;
  }
  function isTruthy(val) {
    return Boolean(val);
  }
  var RenderId = createContext(0);
  var ContentContainer = class extends x {
    constructor() {
      super(...arguments);
      this.InnerContent = InnerContentInjector.bind(void 0, this);
      this.handleEl = (el) => {
        this.el = el;
        if (this.props.elRef) {
          setRef(this.props.elRef, el);
          if (el && this.didMountMisfire) {
            this.componentDidMount();
          }
        }
      };
    }
    render() {
      const { props } = this;
      const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
      if (props.children) {
        const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
        const children = props.children(this.InnerContent, props.renderProps, elAttrs);
        if (props.elTag) {
          return y(props.elTag, elAttrs, children);
        } else {
          return children;
        }
      } else {
        return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
      }
    }
    componentDidMount() {
      var _a, _b;
      if (this.el) {
        (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
      } else {
        this.didMountMisfire = true;
      }
    }
    componentWillUnmount() {
      var _a, _b;
      (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    }
  };
  ContentContainer.contextType = RenderId;
  function InnerContentInjector(containerComponent, props) {
    const parentProps = containerComponent.props;
    return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
  }
  function generateClassNames(classNameGenerator, renderProps) {
    const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
    return typeof classNames === "string" ? [classNames] : classNames;
  }
  var ViewContainer = class extends BaseComponent2 {
    render() {
      let { props, context } = this;
      let { options } = context;
      let renderProps = { view: context.viewApi };
      return y(ContentContainer, { elRef: props.elRef, elTag: props.elTag || "div", elAttrs: props.elAttrs, elClasses: [
        ...buildViewClassNames(props.viewSpec),
        ...props.elClasses || []
      ], elStyle: props.elStyle, renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }, () => props.children);
    }
  };
  function buildViewClassNames(viewSpec) {
    return [
      `fc-${viewSpec.type}-view`,
      "fc-view"
    ];
  }
  function parseRange(input, dateEnv) {
    let start2 = null;
    let end = null;
    if (input.start) {
      start2 = dateEnv.createMarker(input.start);
    }
    if (input.end) {
      end = dateEnv.createMarker(input.end);
    }
    if (!start2 && !end) {
      return null;
    }
    if (start2 && end && end < start2) {
      return null;
    }
    return { start: start2, end };
  }
  function invertRanges(ranges, constraintRange) {
    let invertedRanges = [];
    let { start: start2 } = constraintRange;
    let i3;
    let dateRange;
    ranges.sort(compareRanges);
    for (i3 = 0; i3 < ranges.length; i3 += 1) {
      dateRange = ranges[i3];
      if (dateRange.start > start2) {
        invertedRanges.push({ start: start2, end: dateRange.start });
      }
      if (dateRange.end > start2) {
        start2 = dateRange.end;
      }
    }
    if (start2 < constraintRange.end) {
      invertedRanges.push({ start: start2, end: constraintRange.end });
    }
    return invertedRanges;
  }
  function compareRanges(range0, range1) {
    return range0.start.valueOf() - range1.start.valueOf();
  }
  function intersectRanges(range0, range1) {
    let { start: start2, end } = range0;
    let newRange = null;
    if (range1.start !== null) {
      if (start2 === null) {
        start2 = range1.start;
      } else {
        start2 = new Date(Math.max(start2.valueOf(), range1.start.valueOf()));
      }
    }
    if (range1.end != null) {
      if (end === null) {
        end = range1.end;
      } else {
        end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
      }
    }
    if (start2 === null || end === null || start2 < end) {
      newRange = { start: start2, end };
    }
    return newRange;
  }
  function rangesEqual(range0, range1) {
    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
  }
  function rangesIntersect(range0, range1) {
    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
  }
  function rangeContainsRange(outerRange, innerRange) {
    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
  }
  function rangeContainsMarker(range, date) {
    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
  }
  function constrainMarkerToRange(date, range) {
    if (range.start != null && date < range.start) {
      return range.start;
    }
    if (range.end != null && date >= range.end) {
      return new Date(range.end.valueOf() - 1);
    }
    return date;
  }
  function computeAlignedDayRange(timedRange) {
    let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
    let start2 = startOfDay(timedRange.start);
    let end = addDays(start2, dayCnt);
    return { start: start2, end };
  }
  function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
    let startDay = null;
    let endDay = null;
    if (timedRange.end) {
      endDay = startOfDay(timedRange.end);
      let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
      if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
        endDay = addDays(endDay, 1);
      }
    }
    if (timedRange.start) {
      startDay = startOfDay(timedRange.start);
      if (endDay && endDay <= startDay) {
        endDay = addDays(startDay, 1);
      }
    }
    return { start: startDay, end: endDay };
  }
  function isMultiDayRange(range) {
    let visibleRange = computeVisibleDayRange(range);
    return diffDays(visibleRange.start, visibleRange.end) > 1;
  }
  function diffDates(date0, date1, dateEnv, largeUnit) {
    if (largeUnit === "year") {
      return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
    }
    if (largeUnit === "month") {
      return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
    }
    return diffDayAndTime(date0, date1);
  }
  var DateProfileGenerator = class {
    constructor(props) {
      this.props = props;
      this.initHiddenDays();
    }
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds a structure with info about what the dates/ranges will be for the "prev" view.
    buildPrev(currentDateProfile, currentDate, forceToValid) {
      let { dateEnv } = this.props;
      let prevDate = dateEnv.subtract(
        dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
        // important for start-of-month
        currentDateProfile.dateIncrement
      );
      return this.build(prevDate, -1, forceToValid);
    }
    // Builds a structure with info about what the dates/ranges will be for the "next" view.
    buildNext(currentDateProfile, currentDate, forceToValid) {
      let { dateEnv } = this.props;
      let nextDate = dateEnv.add(
        dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
        // important for start-of-month
        currentDateProfile.dateIncrement
      );
      return this.build(nextDate, 1, forceToValid);
    }
    // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).
    build(currentDate, direction, forceToValid = true) {
      let { props } = this;
      let validRange;
      let currentInfo;
      let isRangeAllDay;
      let renderRange;
      let activeRange;
      let isValid;
      validRange = this.buildValidRange();
      validRange = this.trimHiddenDays(validRange);
      if (forceToValid) {
        currentDate = constrainMarkerToRange(currentDate, validRange);
      }
      currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
      isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
      renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
      renderRange = this.trimHiddenDays(renderRange);
      activeRange = renderRange;
      if (!props.showNonCurrentDates) {
        activeRange = intersectRanges(activeRange, currentInfo.range);
      }
      activeRange = this.adjustActiveRange(activeRange);
      activeRange = intersectRanges(activeRange, validRange);
      isValid = rangesIntersect(currentInfo.range, validRange);
      if (!rangeContainsMarker(renderRange, currentDate)) {
        currentDate = renderRange.start;
      }
      return {
        currentDate,
        // constraint for where prev/next operations can go and where events can be dragged/resized to.
        // an object with optional start and end properties.
        validRange,
        // range the view is formally responsible for.
        // for example, a month view might have 1st-31st, excluding padded dates
        currentRange: currentInfo.range,
        // name of largest unit being displayed, like "month" or "week"
        currentRangeUnit: currentInfo.unit,
        isRangeAllDay,
        // dates that display events and accept drag-n-drop
        // will be `null` if no dates accept events
        activeRange,
        // date range with a rendered skeleton
        // includes not-active days that need some sort of DOM
        renderRange,
        // Duration object that denotes the first visible time of any given day
        slotMinTime: props.slotMinTime,
        // Duration object that denotes the exclusive visible end time of any given day
        slotMaxTime: props.slotMaxTime,
        isValid,
        // how far the current date will move for a prev/next operation
        dateIncrement: this.buildDateIncrement(currentInfo.duration)
        // pass a fallback (might be null) ^
      };
    }
    // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.
    buildValidRange() {
      let input = this.props.validRangeInput;
      let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.props.dateEnv.toDate(this.props.nowManager.getDateMarker())) : input;
      return this.refineRange(simpleInput) || { start: null, end: null };
    }
    // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.
    buildCurrentRangeInfo(date, direction) {
      let { props } = this;
      let duration2 = null;
      let unit = null;
      let range = null;
      let dayCount;
      if (props.duration) {
        duration2 = props.duration;
        unit = props.durationUnit;
        range = this.buildRangeFromDuration(date, direction, duration2, unit);
      } else if (dayCount = this.props.dayCount) {
        unit = "day";
        range = this.buildRangeFromDayCount(date, direction, dayCount);
      } else if (range = this.buildCustomVisibleRange(date)) {
        unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
      } else {
        duration2 = this.getFallbackDuration();
        unit = greatestDurationDenominator(duration2).unit;
        range = this.buildRangeFromDuration(date, direction, duration2, unit);
      }
      return { duration: duration2, unit, range };
    }
    getFallbackDuration() {
      return createDuration({ day: 1 });
    }
    // Returns a new activeRange to have time values (un-ambiguate)
    // slotMinTime or slotMaxTime causes the range to expand.
    adjustActiveRange(range) {
      let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
      let { start: start2, end } = range;
      if (usesMinMaxTime) {
        if (asRoughDays(slotMinTime) < 0) {
          start2 = startOfDay(start2);
          start2 = dateEnv.add(start2, slotMinTime);
        }
        if (asRoughDays(slotMaxTime) > 1) {
          end = startOfDay(end);
          end = addDays(end, -1);
          end = dateEnv.add(end, slotMaxTime);
        }
      }
      return { start: start2, end };
    }
    // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed greatestDurationDenominator unit of duration.
    buildRangeFromDuration(date, direction, duration2, unit) {
      let { dateEnv, dateAlignment } = this.props;
      let start2;
      let end;
      let res;
      if (!dateAlignment) {
        let { dateIncrement } = this.props;
        if (dateIncrement) {
          if (asRoughMs(dateIncrement) < asRoughMs(duration2)) {
            dateAlignment = greatestDurationDenominator(dateIncrement).unit;
          } else {
            dateAlignment = unit;
          }
        } else {
          dateAlignment = unit;
        }
      }
      if (asRoughDays(duration2) <= 1) {
        if (this.isHiddenDay(start2)) {
          start2 = this.skipHiddenDays(start2, direction);
          start2 = startOfDay(start2);
        }
      }
      function computeRes() {
        start2 = dateEnv.startOf(date, dateAlignment);
        end = dateEnv.add(start2, duration2);
        res = { start: start2, end };
      }
      computeRes();
      if (!this.trimHiddenDays(res)) {
        date = this.skipHiddenDays(date, direction);
        computeRes();
      }
      return res;
    }
    // Builds the "current" range when a dayCount is specified.
    buildRangeFromDayCount(date, direction, dayCount) {
      let { dateEnv, dateAlignment } = this.props;
      let runningCount = 0;
      let start2 = date;
      let end;
      if (dateAlignment) {
        start2 = dateEnv.startOf(start2, dateAlignment);
      }
      start2 = startOfDay(start2);
      start2 = this.skipHiddenDays(start2, direction);
      end = start2;
      do {
        end = addDays(end, 1);
        if (!this.isHiddenDay(end)) {
          runningCount += 1;
        }
      } while (runningCount < dayCount);
      return { start: start2, end };
    }
    // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentRange and activeRange at the same time.
    buildCustomVisibleRange(date) {
      let { props } = this;
      let input = props.visibleRangeInput;
      let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
      let range = this.refineRange(simpleInput);
      if (range && (range.start == null || range.end == null)) {
        return null;
      }
      return range;
    }
    // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.
    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
      return currentRange;
    }
    // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.
    buildDateIncrement(fallback) {
      let { dateIncrement } = this.props;
      let customAlignment;
      if (dateIncrement) {
        return dateIncrement;
      }
      if (customAlignment = this.props.dateAlignment) {
        return createDuration(1, customAlignment);
      }
      if (fallback) {
        return fallback;
      }
      return createDuration({ days: 1 });
    }
    refineRange(rangeInput) {
      if (rangeInput) {
        let range = parseRange(rangeInput, this.props.dateEnv);
        if (range) {
          range = computeVisibleDayRange(range);
        }
        return range;
      }
      return null;
    }
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/
    // Initializes internal variables related to calculating hidden days-of-week
    initHiddenDays() {
      let hiddenDays = this.props.hiddenDays || [];
      let isHiddenDayHash = [];
      let dayCnt = 0;
      let i3;
      if (this.props.weekends === false) {
        hiddenDays.push(0, 6);
      }
      for (i3 = 0; i3 < 7; i3 += 1) {
        if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
          dayCnt += 1;
        }
      }
      if (!dayCnt) {
        throw new Error("invalid hiddenDays");
      }
      this.isHiddenDayHash = isHiddenDayHash;
    }
    // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null
    trimHiddenDays(range) {
      let { start: start2, end } = range;
      if (start2) {
        start2 = this.skipHiddenDays(start2);
      }
      if (end) {
        end = this.skipHiddenDays(end, -1, true);
      }
      if (start2 == null || end == null || start2 < end) {
        return { start: start2, end };
      }
      return null;
    }
    // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Date (used for UTC)
    isHiddenDay(day) {
      if (day instanceof Date) {
        day = day.getUTCDay();
      }
      return this.isHiddenDayHash[day];
    }
    // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)
    skipHiddenDays(date, inc = 1, isExclusive = false) {
      while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
        date = addDays(date, inc);
      }
      return date;
    }
  };
  function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
    return {
      instanceId: guid(),
      defId,
      range,
      forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
      forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
    };
  }
  function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
    for (let i3 = 0; i3 < recurringTypes.length; i3 += 1) {
      let parsed = recurringTypes[i3].parse(refined, dateEnv);
      if (parsed) {
        let { allDay } = refined;
        if (allDay == null) {
          allDay = defaultAllDay;
          if (allDay == null) {
            allDay = parsed.allDayGuess;
            if (allDay == null) {
              allDay = false;
            }
          }
        }
        return {
          allDay,
          duration: parsed.duration,
          typeData: parsed.typeData,
          typeId: i3
        };
      }
    }
    return null;
  }
  function expandRecurring(eventStore, framingRange, context) {
    let { dateEnv, pluginHooks, options } = context;
    let { defs, instances } = eventStore;
    instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.recurringDef) {
        let { duration: duration2 } = def.recurringDef;
        if (!duration2) {
          duration2 = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
        }
        let starts = expandRecurringRanges(def, duration2, framingRange, dateEnv, pluginHooks.recurringTypes);
        for (let start2 of starts) {
          let instance = createEventInstance(defId, {
            start: start2,
            end: dateEnv.add(start2, duration2)
          });
          instances[instance.instanceId] = instance;
        }
      }
    }
    return { defs, instances };
  }
  function expandRecurringRanges(eventDef, duration2, framingRange, dateEnv, recurringTypes) {
    let typeDef = recurringTypes[eventDef.recurringDef.typeId];
    let markers = typeDef.expand(eventDef.recurringDef.typeData, {
      start: dateEnv.subtract(framingRange.start, duration2),
      end: framingRange.end
    }, dateEnv);
    if (eventDef.allDay) {
      markers = markers.map(startOfDay);
    }
    return markers;
  }
  var EVENT_NON_DATE_REFINERS = {
    id: String,
    groupId: String,
    title: String,
    url: String,
    interactive: Boolean
  };
  var EVENT_DATE_REFINERS = {
    start: identity,
    end: identity,
    date: identity,
    allDay: Boolean
  };
  var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
  function parseEvent3(raw2, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
    let { refined, extra } = refineEventDef(raw2, context, refiners);
    let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
    let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
    if (recurringRes) {
      let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
      def.recurringDef = {
        typeId: recurringRes.typeId,
        typeData: recurringRes.typeData,
        duration: recurringRes.duration
      };
      return { def, instance: null };
    }
    let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
    if (singleRes) {
      let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
      let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
      if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
        instance.instanceId = instanceIdMap[def.publicId];
      }
      return { def, instance };
    }
    return null;
  }
  function refineEventDef(raw2, context, refiners = buildEventRefiners(context)) {
    return refineProps(raw2, refiners);
  }
  function buildEventRefiners(context) {
    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
  }
  function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
    let def = {
      title: refined.title || "",
      groupId: refined.groupId || "",
      publicId: refined.id || "",
      url: refined.url || "",
      recurringDef: null,
      defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
      sourceId,
      allDay,
      hasEnd,
      interactive: refined.interactive,
      ui: createEventUi(refined, context),
      extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
    };
    for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
      Object.assign(def, memberAdder(refined));
    }
    Object.freeze(def.ui.classNames);
    Object.freeze(def.extendedProps);
    return def;
  }
  function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
    let { allDay } = refined;
    let startMeta;
    let startMarker = null;
    let hasEnd = false;
    let endMeta;
    let endMarker = null;
    let startInput = refined.start != null ? refined.start : refined.date;
    startMeta = context.dateEnv.createMarkerMeta(startInput);
    if (startMeta) {
      startMarker = startMeta.marker;
    } else if (!allowOpenRange) {
      return null;
    }
    if (refined.end != null) {
      endMeta = context.dateEnv.createMarkerMeta(refined.end);
    }
    if (allDay == null) {
      if (defaultAllDay != null) {
        allDay = defaultAllDay;
      } else {
        allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
      }
    }
    if (allDay && startMarker) {
      startMarker = startOfDay(startMarker);
    }
    if (endMeta) {
      endMarker = endMeta.marker;
      if (allDay) {
        endMarker = startOfDay(endMarker);
      }
      if (startMarker && endMarker <= startMarker) {
        endMarker = null;
      }
    }
    if (endMarker) {
      hasEnd = true;
    } else if (!allowOpenRange) {
      hasEnd = context.options.forceEventDuration || false;
      endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
    }
    return {
      allDay,
      hasEnd,
      range: { start: startMarker, end: endMarker },
      forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
      forcedEndTzo: endMeta ? endMeta.forcedTzo : null
    };
  }
  function computeIsDefaultAllDay(eventSource, context) {
    let res = null;
    if (eventSource) {
      res = eventSource.defaultAllDay;
    }
    if (res == null) {
      res = context.options.defaultAllDay;
    }
    return res;
  }
  function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
    let eventStore = createEmptyEventStore();
    let eventRefiners = buildEventRefiners(context);
    for (let rawEvent of rawEvents) {
      let tuple = parseEvent3(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
      if (tuple) {
        eventTupleToStore(tuple, eventStore);
      }
    }
    return eventStore;
  }
  function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
    eventStore.defs[tuple.def.defId] = tuple.def;
    if (tuple.instance) {
      eventStore.instances[tuple.instance.instanceId] = tuple.instance;
    }
    return eventStore;
  }
  function getRelevantEvents(eventStore, instanceId) {
    let instance = eventStore.instances[instanceId];
    if (instance) {
      let def = eventStore.defs[instance.defId];
      let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
      newStore.defs[def.defId] = def;
      newStore.instances[instance.instanceId] = instance;
      return newStore;
    }
    return createEmptyEventStore();
  }
  function isEventDefsGrouped(def0, def1) {
    return Boolean(def0.groupId && def0.groupId === def1.groupId);
  }
  function createEmptyEventStore() {
    return { defs: {}, instances: {} };
  }
  function mergeEventStores(store0, store1) {
    return {
      defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
      instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
    };
  }
  function filterEventStoreDefs(eventStore, filterFunc) {
    let defs = filterHash(eventStore.defs, filterFunc);
    let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
    return { defs, instances };
  }
  function excludeSubEventStore(master, sub) {
    let { defs, instances } = master;
    let filteredDefs = {};
    let filteredInstances = {};
    for (let defId in defs) {
      if (!sub.defs[defId]) {
        filteredDefs[defId] = defs[defId];
      }
    }
    for (let instanceId in instances) {
      if (!sub.instances[instanceId] && // not explicitly excluded
      filteredDefs[instances[instanceId].defId]) {
        filteredInstances[instanceId] = instances[instanceId];
      }
    }
    return {
      defs: filteredDefs,
      instances: filteredInstances
    };
  }
  function normalizeConstraint(input, context) {
    if (Array.isArray(input)) {
      return parseEvents(input, null, context, true);
    }
    if (typeof input === "object" && input) {
      return parseEvents([input], null, context, true);
    }
    if (input != null) {
      return String(input);
    }
    return null;
  }
  function parseClassNames(raw2) {
    if (Array.isArray(raw2)) {
      return raw2;
    }
    if (typeof raw2 === "string") {
      return raw2.split(/\s+/);
    }
    return [];
  }
  var EVENT_UI_REFINERS = {
    display: String,
    editable: Boolean,
    startEditable: Boolean,
    durationEditable: Boolean,
    constraint: identity,
    overlap: identity,
    allow: identity,
    className: parseClassNames,
    classNames: parseClassNames,
    color: String,
    backgroundColor: String,
    borderColor: String,
    textColor: String
  };
  var EMPTY_EVENT_UI = {
    display: null,
    startEditable: null,
    durationEditable: null,
    constraints: [],
    overlap: null,
    allows: [],
    backgroundColor: "",
    borderColor: "",
    textColor: "",
    classNames: []
  };
  function createEventUi(refined, context) {
    let constraint = normalizeConstraint(refined.constraint, context);
    return {
      display: refined.display || null,
      startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
      durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
      constraints: constraint != null ? [constraint] : [],
      overlap: refined.overlap != null ? refined.overlap : null,
      allows: refined.allow != null ? [refined.allow] : [],
      backgroundColor: refined.backgroundColor || refined.color || "",
      borderColor: refined.borderColor || refined.color || "",
      textColor: refined.textColor || "",
      classNames: (refined.className || []).concat(refined.classNames || [])
      // join singular and plural
    };
  }
  function combineEventUis(uis) {
    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
  }
  function combineTwoEventUis(item0, item1) {
    return {
      display: item1.display != null ? item1.display : item0.display,
      startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
      durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
      constraints: item0.constraints.concat(item1.constraints),
      overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
      allows: item0.allows.concat(item1.allows),
      backgroundColor: item1.backgroundColor || item0.backgroundColor,
      borderColor: item1.borderColor || item0.borderColor,
      textColor: item1.textColor || item0.textColor,
      classNames: item0.classNames.concat(item1.classNames)
    };
  }
  var EVENT_SOURCE_REFINERS = {
    id: String,
    defaultAllDay: Boolean,
    url: String,
    format: String,
    events: identity,
    eventDataTransform: identity,
    // for any network-related sources
    success: identity,
    failure: identity
  };
  function parseEventSource(raw2, context, refiners = buildEventSourceRefiners(context)) {
    let rawObj;
    if (typeof raw2 === "string") {
      rawObj = { url: raw2 };
    } else if (typeof raw2 === "function" || Array.isArray(raw2)) {
      rawObj = { events: raw2 };
    } else if (typeof raw2 === "object" && raw2) {
      rawObj = raw2;
    }
    if (rawObj) {
      let { refined, extra } = refineProps(rawObj, refiners);
      let metaRes = buildEventSourceMeta(refined, context);
      if (metaRes) {
        return {
          _raw: raw2,
          isFetching: false,
          latestFetchId: "",
          fetchRange: null,
          defaultAllDay: refined.defaultAllDay,
          eventDataTransform: refined.eventDataTransform,
          success: refined.success,
          failure: refined.failure,
          publicId: refined.id || "",
          sourceId: guid(),
          sourceDefId: metaRes.sourceDefId,
          meta: metaRes.meta,
          ui: createEventUi(refined, context),
          extendedProps: extra
        };
      }
    }
    return null;
  }
  function buildEventSourceRefiners(context) {
    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
  }
  function buildEventSourceMeta(raw2, context) {
    let defs = context.pluginHooks.eventSourceDefs;
    for (let i3 = defs.length - 1; i3 >= 0; i3 -= 1) {
      let def = defs[i3];
      let meta = def.parseMeta(raw2);
      if (meta) {
        return { sourceDefId: i3, meta };
      }
    }
    return null;
  }
  function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
    switch (action.type) {
      case "RECEIVE_EVENTS":
        return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
      case "RESET_RAW_EVENTS":
        return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
      case "ADD_EVENTS":
        return addEvent(
          eventStore,
          action.eventStore,
          // new ones
          dateProfile ? dateProfile.activeRange : null,
          context
        );
      case "RESET_EVENTS":
        return action.eventStore;
      case "MERGE_EVENTS":
        return mergeEventStores(eventStore, action.eventStore);
      case "PREV":
      // TODO: how do we track all actions that affect dateProfile :(
      case "NEXT":
      case "CHANGE_DATE":
      case "CHANGE_VIEW_TYPE":
        if (dateProfile) {
          return expandRecurring(eventStore, dateProfile.activeRange, context);
        }
        return eventStore;
      case "REMOVE_EVENTS":
        return excludeSubEventStore(eventStore, action.eventStore);
      case "REMOVE_EVENT_SOURCE":
        return excludeEventsBySourceId(eventStore, action.sourceId);
      case "REMOVE_ALL_EVENT_SOURCES":
        return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
      case "REMOVE_ALL_EVENTS":
        return createEmptyEventStore();
      default:
        return eventStore;
    }
  }
  function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
    if (eventSource && // not already removed
    fetchId === eventSource.latestFetchId) {
      let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
      if (fetchRange) {
        subset = expandRecurring(subset, fetchRange, context);
      }
      return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
    }
    return eventStore;
  }
  function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
    const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
    let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
    return expandRecurring(newEventStore, activeRange, context);
  }
  function transformRawEvents(rawEvents, eventSource, context) {
    let calEachTransform = context.options.eventDataTransform;
    let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
    if (sourceEachTransform) {
      rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
    }
    if (calEachTransform) {
      rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
    }
    return rawEvents;
  }
  function transformEachRawEvent(rawEvents, func) {
    let refinedEvents;
    if (!func) {
      refinedEvents = rawEvents;
    } else {
      refinedEvents = [];
      for (let rawEvent of rawEvents) {
        let refinedEvent = func(rawEvent);
        if (refinedEvent) {
          refinedEvents.push(refinedEvent);
        } else if (refinedEvent == null) {
          refinedEvents.push(rawEvent);
        }
      }
    }
    return refinedEvents;
  }
  function addEvent(eventStore, subset, expandRange, context) {
    if (expandRange) {
      subset = expandRecurring(subset, expandRange, context);
    }
    return mergeEventStores(eventStore, subset);
  }
  function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
    let { defs } = eventStore;
    let instances = mapHash(eventStore.instances, (instance) => {
      let def = defs[instance.defId];
      if (def.allDay) {
        return instance;
      }
      return Object.assign(Object.assign({}, instance), { range: {
        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
      }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
    });
    return { defs, instances };
  }
  function excludeEventsBySourceId(eventStore, sourceId) {
    return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
  }
  function excludeInstances(eventStore, removals) {
    return {
      defs: eventStore.defs,
      instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
    };
  }
  function buildPublicIdMaps(eventStore) {
    const { defs, instances } = eventStore;
    const defIdMap = {};
    const instanceIdMap = {};
    for (let defId in defs) {
      const def = defs[defId];
      const { publicId } = def;
      if (publicId) {
        defIdMap[publicId] = defId;
      }
    }
    for (let instanceId in instances) {
      const instance = instances[instanceId];
      const def = defs[instance.defId];
      const { publicId } = def;
      if (publicId) {
        instanceIdMap[publicId] = instanceId;
      }
    }
    return { defIdMap, instanceIdMap };
  }
  var Emitter = class {
    constructor() {
      this.handlers = {};
      this.thisContext = null;
    }
    setThisContext(thisContext) {
      this.thisContext = thisContext;
    }
    setOptions(options) {
      this.options = options;
    }
    on(type, handler4) {
      addToHash(this.handlers, type, handler4);
    }
    off(type, handler4) {
      removeFromHash(this.handlers, type, handler4);
    }
    trigger(type, ...args) {
      let attachedHandlers = this.handlers[type] || [];
      let optionHandler = this.options && this.options[type];
      let handlers = [].concat(optionHandler || [], attachedHandlers);
      for (let handler4 of handlers) {
        handler4.apply(this.thisContext, args);
      }
    }
    hasHandlers(type) {
      return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
    }
  };
  function addToHash(hash, type, handler4) {
    (hash[type] || (hash[type] = [])).push(handler4);
  }
  function removeFromHash(hash, type, handler4) {
    if (handler4) {
      if (hash[type]) {
        hash[type] = hash[type].filter((func) => func !== handler4);
      }
    } else {
      delete hash[type];
    }
  }
  var DEF_DEFAULTS = {
    startTime: "09:00",
    endTime: "17:00",
    daysOfWeek: [1, 2, 3, 4, 5],
    display: "inverse-background",
    classNames: "fc-non-business",
    groupId: "_businessHours"
    // so multiple defs get grouped
  };
  function parseBusinessHours(input, context) {
    return parseEvents(refineInputs(input), null, context);
  }
  function refineInputs(input) {
    let rawDefs;
    if (input === true) {
      rawDefs = [{}];
    } else if (Array.isArray(input)) {
      rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
    } else if (typeof input === "object" && input) {
      rawDefs = [input];
    } else {
      rawDefs = [];
    }
    rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
    return rawDefs;
  }
  function triggerDateSelect(selection, pev, context) {
    context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
  }
  function triggerDateUnselect(pev, context) {
    context.emitter.trigger("unselect", {
      jsEvent: pev ? pev.origEvent : null,
      view: context.viewApi || context.calendarApi.view
    });
  }
  function buildDateSpanApiWithContext(dateSpan, context) {
    let props = {};
    for (let transform of context.pluginHooks.dateSpanTransforms) {
      Object.assign(props, transform(dateSpan, context));
    }
    Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
    return props;
  }
  function getDefaultEventEnd(allDay, marker, context) {
    let { dateEnv, options } = context;
    let end = marker;
    if (allDay) {
      end = startOfDay(end);
      end = dateEnv.add(end, options.defaultAllDayEventDuration);
    } else {
      end = dateEnv.add(end, options.defaultTimedEventDuration);
    }
    return end;
  }
  function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
    let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
    let dest = createEmptyEventStore();
    for (let defId in eventStore.defs) {
      let def = eventStore.defs[defId];
      dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
    }
    for (let instanceId in eventStore.instances) {
      let instance = eventStore.instances[instanceId];
      let def = dest.defs[instance.defId];
      dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
    }
    return dest;
  }
  function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
    let standardProps = mutation.standardProps || {};
    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
      standardProps.hasEnd = true;
    }
    let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
    if (mutation.extendedProps) {
      copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
    }
    for (let applier of context.pluginHooks.eventDefMutationAppliers) {
      applier(copy, mutation, context);
    }
    if (!copy.hasEnd && context.options.forceEventDuration) {
      copy.hasEnd = true;
    }
    return copy;
  }
  function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
    let { dateEnv } = context;
    let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
    let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
    let copy = Object.assign({}, eventInstance);
    if (forceAllDay) {
      copy.range = computeAlignedDayRange(copy.range);
    }
    if (mutation.datesDelta && eventConfig.startEditable) {
      copy.range = {
        start: dateEnv.add(copy.range.start, mutation.datesDelta),
        end: dateEnv.add(copy.range.end, mutation.datesDelta)
      };
    }
    if (mutation.startDelta && eventConfig.durationEditable) {
      copy.range = {
        start: dateEnv.add(copy.range.start, mutation.startDelta),
        end: copy.range.end
      };
    }
    if (mutation.endDelta && eventConfig.durationEditable) {
      copy.range = {
        start: copy.range.start,
        end: dateEnv.add(copy.range.end, mutation.endDelta)
      };
    }
    if (clearEnd) {
      copy.range = {
        start: copy.range.start,
        end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
      };
    }
    if (eventDef.allDay) {
      copy.range = {
        start: startOfDay(copy.range.start),
        end: startOfDay(copy.range.end)
      };
    }
    if (copy.range.end < copy.range.start) {
      copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
    }
    return copy;
  }
  var EventSourceImpl = class {
    constructor(context, internalEventSource) {
      this.context = context;
      this.internalEventSource = internalEventSource;
    }
    remove() {
      this.context.dispatch({
        type: "REMOVE_EVENT_SOURCE",
        sourceId: this.internalEventSource.sourceId
      });
    }
    refetch() {
      this.context.dispatch({
        type: "FETCH_EVENT_SOURCES",
        sourceIds: [this.internalEventSource.sourceId],
        isRefetch: true
      });
    }
    get id() {
      return this.internalEventSource.publicId;
    }
    get url() {
      return this.internalEventSource.meta.url;
    }
    get format() {
      return this.internalEventSource.meta.format;
    }
  };
  var EventImpl = class _EventImpl {
    // instance will be null if expressing a recurring event that has no current instances,
    // OR if trying to validate an incoming external event that has no dates assigned
    constructor(context, def, instance) {
      this._context = context;
      this._def = def;
      this._instance = instance || null;
    }
    /*
    TODO: make event struct more responsible for this
    */
    setProp(name, val) {
      if (name in EVENT_DATE_REFINERS) {
        console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
      } else if (name === "id") {
        val = EVENT_NON_DATE_REFINERS[name](val);
        this.mutate({
          standardProps: { publicId: val }
          // hardcoded internal name
        });
      } else if (name in EVENT_NON_DATE_REFINERS) {
        val = EVENT_NON_DATE_REFINERS[name](val);
        this.mutate({
          standardProps: { [name]: val }
        });
      } else if (name in EVENT_UI_REFINERS) {
        let ui = EVENT_UI_REFINERS[name](val);
        if (name === "color") {
          ui = { backgroundColor: val, borderColor: val };
        } else if (name === "editable") {
          ui = { startEditable: val, durationEditable: val };
        } else {
          ui = { [name]: val };
        }
        this.mutate({
          standardProps: { ui }
        });
      } else {
        console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
      }
    }
    setExtendedProp(name, val) {
      this.mutate({
        extendedProps: { [name]: val }
      });
    }
    setStart(startInput, options = {}) {
      let { dateEnv } = this._context;
      let start2 = dateEnv.createMarker(startInput);
      if (start2 && this._instance) {
        let instanceRange = this._instance.range;
        let startDelta = diffDates(instanceRange.start, start2, dateEnv, options.granularity);
        if (options.maintainDuration) {
          this.mutate({ datesDelta: startDelta });
        } else {
          this.mutate({ startDelta });
        }
      }
    }
    setEnd(endInput, options = {}) {
      let { dateEnv } = this._context;
      let end;
      if (endInput != null) {
        end = dateEnv.createMarker(endInput);
        if (!end) {
          return;
        }
      }
      if (this._instance) {
        if (end) {
          let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
          this.mutate({ endDelta });
        } else {
          this.mutate({ standardProps: { hasEnd: false } });
        }
      }
    }
    setDates(startInput, endInput, options = {}) {
      let { dateEnv } = this._context;
      let standardProps = { allDay: options.allDay };
      let start2 = dateEnv.createMarker(startInput);
      let end;
      if (!start2) {
        return;
      }
      if (endInput != null) {
        end = dateEnv.createMarker(endInput);
        if (!end) {
          return;
        }
      }
      if (this._instance) {
        let instanceRange = this._instance.range;
        if (options.allDay === true) {
          instanceRange = computeAlignedDayRange(instanceRange);
        }
        let startDelta = diffDates(instanceRange.start, start2, dateEnv, options.granularity);
        if (end) {
          let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
          if (durationsEqual(startDelta, endDelta)) {
            this.mutate({ datesDelta: startDelta, standardProps });
          } else {
            this.mutate({ startDelta, endDelta, standardProps });
          }
        } else {
          standardProps.hasEnd = false;
          this.mutate({ datesDelta: startDelta, standardProps });
        }
      }
    }
    moveStart(deltaInput) {
      let delta = createDuration(deltaInput);
      if (delta) {
        this.mutate({ startDelta: delta });
      }
    }
    moveEnd(deltaInput) {
      let delta = createDuration(deltaInput);
      if (delta) {
        this.mutate({ endDelta: delta });
      }
    }
    moveDates(deltaInput) {
      let delta = createDuration(deltaInput);
      if (delta) {
        this.mutate({ datesDelta: delta });
      }
    }
    setAllDay(allDay, options = {}) {
      let standardProps = { allDay };
      let { maintainDuration } = options;
      if (maintainDuration == null) {
        maintainDuration = this._context.options.allDayMaintainDuration;
      }
      if (this._def.allDay !== allDay) {
        standardProps.hasEnd = maintainDuration;
      }
      this.mutate({ standardProps });
    }
    formatRange(formatInput) {
      let { dateEnv } = this._context;
      let instance = this._instance;
      let formatter = createFormatter(formatInput);
      if (this._def.hasEnd) {
        return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
          forcedStartTzo: instance.forcedStartTzo,
          forcedEndTzo: instance.forcedEndTzo
        });
      }
      return dateEnv.format(instance.range.start, formatter, {
        forcedTzo: instance.forcedStartTzo
      });
    }
    mutate(mutation) {
      let instance = this._instance;
      if (instance) {
        let def = this._def;
        let context = this._context;
        let { eventStore } = context.getCurrentData();
        let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
        let eventConfigBase = {
          "": {
            display: "",
            startEditable: true,
            durationEditable: true,
            constraints: [],
            overlap: null,
            allows: [],
            backgroundColor: "",
            borderColor: "",
            textColor: "",
            classNames: []
          }
        };
        relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
        let oldEvent = new _EventImpl(context, def, instance);
        this._def = relevantEvents.defs[def.defId];
        this._instance = relevantEvents.instances[instance.instanceId];
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: relevantEvents
        });
        context.emitter.trigger("eventChange", {
          oldEvent,
          event: this,
          relatedEvents: buildEventApis(relevantEvents, context, instance),
          revert() {
            context.dispatch({
              type: "RESET_EVENTS",
              eventStore
              // the ORIGINAL store
            });
          }
        });
      }
    }
    remove() {
      let context = this._context;
      let asStore = eventApiToStore(this);
      context.dispatch({
        type: "REMOVE_EVENTS",
        eventStore: asStore
      });
      context.emitter.trigger("eventRemove", {
        event: this,
        relatedEvents: [],
        revert() {
          context.dispatch({
            type: "MERGE_EVENTS",
            eventStore: asStore
          });
        }
      });
    }
    get source() {
      let { sourceId } = this._def;
      if (sourceId) {
        return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
      }
      return null;
    }
    get start() {
      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
    }
    get end() {
      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
    }
    get startStr() {
      let instance = this._instance;
      if (instance) {
        return this._context.dateEnv.formatIso(instance.range.start, {
          omitTime: this._def.allDay,
          forcedTzo: instance.forcedStartTzo
        });
      }
      return "";
    }
    get endStr() {
      let instance = this._instance;
      if (instance && this._def.hasEnd) {
        return this._context.dateEnv.formatIso(instance.range.end, {
          omitTime: this._def.allDay,
          forcedTzo: instance.forcedEndTzo
        });
      }
      return "";
    }
    // computable props that all access the def
    // TODO: find a TypeScript-compatible way to do this at scale
    get id() {
      return this._def.publicId;
    }
    get groupId() {
      return this._def.groupId;
    }
    get allDay() {
      return this._def.allDay;
    }
    get title() {
      return this._def.title;
    }
    get url() {
      return this._def.url;
    }
    get display() {
      return this._def.ui.display || "auto";
    }
    // bad. just normalize the type earlier
    get startEditable() {
      return this._def.ui.startEditable;
    }
    get durationEditable() {
      return this._def.ui.durationEditable;
    }
    get constraint() {
      return this._def.ui.constraints[0] || null;
    }
    get overlap() {
      return this._def.ui.overlap;
    }
    get allow() {
      return this._def.ui.allows[0] || null;
    }
    get backgroundColor() {
      return this._def.ui.backgroundColor;
    }
    get borderColor() {
      return this._def.ui.borderColor;
    }
    get textColor() {
      return this._def.ui.textColor;
    }
    // NOTE: user can't modify these because Object.freeze was called in event-def parsing
    get classNames() {
      return this._def.ui.classNames;
    }
    get extendedProps() {
      return this._def.extendedProps;
    }
    toPlainObject(settings = {}) {
      let def = this._def;
      let { ui } = def;
      let { startStr, endStr } = this;
      let res = {
        allDay: def.allDay
      };
      if (def.title) {
        res.title = def.title;
      }
      if (startStr) {
        res.start = startStr;
      }
      if (endStr) {
        res.end = endStr;
      }
      if (def.publicId) {
        res.id = def.publicId;
      }
      if (def.groupId) {
        res.groupId = def.groupId;
      }
      if (def.url) {
        res.url = def.url;
      }
      if (ui.display && ui.display !== "auto") {
        res.display = ui.display;
      }
      if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
        res.color = ui.backgroundColor;
      } else {
        if (ui.backgroundColor) {
          res.backgroundColor = ui.backgroundColor;
        }
        if (ui.borderColor) {
          res.borderColor = ui.borderColor;
        }
      }
      if (ui.textColor) {
        res.textColor = ui.textColor;
      }
      if (ui.classNames.length) {
        res.classNames = ui.classNames;
      }
      if (Object.keys(def.extendedProps).length) {
        if (settings.collapseExtendedProps) {
          Object.assign(res, def.extendedProps);
        } else {
          res.extendedProps = def.extendedProps;
        }
      }
      return res;
    }
    toJSON() {
      return this.toPlainObject();
    }
  };
  function eventApiToStore(eventApi) {
    let def = eventApi._def;
    let instance = eventApi._instance;
    return {
      defs: { [def.defId]: def },
      instances: instance ? { [instance.instanceId]: instance } : {}
    };
  }
  function buildEventApis(eventStore, context, excludeInstance) {
    let { defs, instances } = eventStore;
    let eventApis = [];
    let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
    for (let id in instances) {
      let instance = instances[id];
      let def = defs[instance.defId];
      if (instance.instanceId !== excludeInstanceId) {
        eventApis.push(new EventImpl(context, def, instance));
      }
    }
    return eventApis;
  }
  function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
    let inverseBgByGroupId = {};
    let inverseBgByDefId = {};
    let defByGroupId = {};
    let bgRanges = [];
    let fgRanges = [];
    let eventUis = compileEventUis(eventStore.defs, eventUiBases);
    for (let defId in eventStore.defs) {
      let def = eventStore.defs[defId];
      let ui = eventUis[def.defId];
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId] = [];
          if (!defByGroupId[def.groupId]) {
            defByGroupId[def.groupId] = def;
          }
        } else {
          inverseBgByDefId[defId] = [];
        }
      }
    }
    for (let instanceId in eventStore.instances) {
      let instance = eventStore.instances[instanceId];
      let def = eventStore.defs[instance.defId];
      let ui = eventUis[def.defId];
      let origRange = instance.range;
      let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
      let slicedRange = intersectRanges(normalRange, framingRange);
      if (slicedRange) {
        if (ui.display === "inverse-background") {
          if (def.groupId) {
            inverseBgByGroupId[def.groupId].push(slicedRange);
          } else {
            inverseBgByDefId[instance.defId].push(slicedRange);
          }
        } else if (ui.display !== "none") {
          (ui.display === "background" ? bgRanges : fgRanges).push({
            def,
            ui,
            instance,
            range: slicedRange,
            isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
            isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
          });
        }
      }
    }
    for (let groupId in inverseBgByGroupId) {
      let ranges = inverseBgByGroupId[groupId];
      let invertedRanges = invertRanges(ranges, framingRange);
      for (let invertedRange of invertedRanges) {
        let def = defByGroupId[groupId];
        let ui = eventUis[def.defId];
        bgRanges.push({
          def,
          ui,
          instance: null,
          range: invertedRange,
          isStart: false,
          isEnd: false
        });
      }
    }
    for (let defId in inverseBgByDefId) {
      let ranges = inverseBgByDefId[defId];
      let invertedRanges = invertRanges(ranges, framingRange);
      for (let invertedRange of invertedRanges) {
        bgRanges.push({
          def: eventStore.defs[defId],
          ui: eventUis[defId],
          instance: null,
          range: invertedRange,
          isStart: false,
          isEnd: false
        });
      }
    }
    return { bg: bgRanges, fg: fgRanges };
  }
  function hasBgRendering(def) {
    return def.ui.display === "background" || def.ui.display === "inverse-background";
  }
  function setElSeg(el, seg) {
    el.fcSeg = seg;
  }
  function getElSeg(el) {
    return el.fcSeg || el.parentNode.fcSeg || // for the harness
    null;
  }
  function compileEventUis(eventDefs, eventUiBases) {
    return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
  }
  function compileEventUi(eventDef, eventUiBases) {
    let uis = [];
    if (eventUiBases[""]) {
      uis.push(eventUiBases[""]);
    }
    if (eventUiBases[eventDef.defId]) {
      uis.push(eventUiBases[eventDef.defId]);
    }
    uis.push(eventDef.ui);
    return combineEventUis(uis);
  }
  function sortEventSegs(segs, eventOrderSpecs) {
    let objs = segs.map(buildSegCompareObj);
    objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
    return objs.map((c3) => c3._seg);
  }
  function buildSegCompareObj(seg) {
    let { eventRange } = seg;
    let eventDef = eventRange.def;
    let range = eventRange.instance ? eventRange.instance.range : eventRange.range;
    let start2 = range.start ? range.start.valueOf() : 0;
    let end = range.end ? range.end.valueOf() : 0;
    return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
      id: eventDef.publicId,
      start: start2,
      end,
      duration: end - start2,
      allDay: Number(eventDef.allDay),
      _seg: seg
    });
  }
  function computeSegDraggable(seg, context) {
    let { pluginHooks } = context;
    let transformers = pluginHooks.isDraggableTransformers;
    let { def, ui } = seg.eventRange;
    let val = ui.startEditable;
    for (let transformer of transformers) {
      val = transformer(val, def, ui, context);
    }
    return val;
  }
  function computeSegStartResizable(seg, context) {
    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
  }
  function computeSegEndResizable(seg, context) {
    return seg.isEnd && seg.eventRange.ui.durationEditable;
  }
  function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
    let { dateEnv, options } = context;
    let { displayEventTime, displayEventEnd } = options;
    let eventDef = seg.eventRange.def;
    let eventInstance = seg.eventRange.instance;
    if (displayEventTime == null) {
      displayEventTime = defaultDisplayEventTime !== false;
    }
    if (displayEventEnd == null) {
      displayEventEnd = defaultDisplayEventEnd !== false;
    }
    let wholeEventStart = eventInstance.range.start;
    let wholeEventEnd = eventInstance.range.end;
    let segStart = startOverride || seg.start || seg.eventRange.range.start;
    let segEnd = endOverride || seg.end || seg.eventRange.range.end;
    let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
    let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
      segStart = isStartDay ? wholeEventStart : segStart;
      segEnd = isEndDay ? wholeEventEnd : segEnd;
      if (displayEventEnd && eventDef.hasEnd) {
        return dateEnv.formatRange(segStart, segEnd, timeFormat, {
          forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
          forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
        });
      }
      return dateEnv.format(segStart, timeFormat, {
        forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
        // nooooo, same
      });
    }
    return "";
  }
  function getSegMeta(seg, todayRange, nowDate) {
    let segRange = seg.eventRange.range;
    return {
      isPast: segRange.end <= (nowDate || todayRange.start),
      isFuture: segRange.start >= (nowDate || todayRange.end),
      isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
    };
  }
  function getEventClassNames(props) {
    let classNames = ["fc-event"];
    if (props.isMirror) {
      classNames.push("fc-event-mirror");
    }
    if (props.isDraggable) {
      classNames.push("fc-event-draggable");
    }
    if (props.isStartResizable || props.isEndResizable) {
      classNames.push("fc-event-resizable");
    }
    if (props.isDragging) {
      classNames.push("fc-event-dragging");
    }
    if (props.isResizing) {
      classNames.push("fc-event-resizing");
    }
    if (props.isSelected) {
      classNames.push("fc-event-selected");
    }
    if (props.isStart) {
      classNames.push("fc-event-start");
    }
    if (props.isEnd) {
      classNames.push("fc-event-end");
    }
    if (props.isPast) {
      classNames.push("fc-event-past");
    }
    if (props.isToday) {
      classNames.push("fc-event-today");
    }
    if (props.isFuture) {
      classNames.push("fc-event-future");
    }
    return classNames;
  }
  function buildEventRangeKey(eventRange) {
    return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
  }
  function getSegAnchorAttrs(seg, context) {
    let { def, instance } = seg.eventRange;
    let { url } = def;
    if (url) {
      return { href: url };
    }
    let { emitter, options } = context;
    let { eventInteractive } = options;
    if (eventInteractive == null) {
      eventInteractive = def.interactive;
      if (eventInteractive == null) {
        eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
      }
    }
    if (eventInteractive) {
      return createAriaKeyboardAttrs((ev) => {
        emitter.trigger("eventClick", {
          el: ev.target,
          event: new EventImpl(context, def, instance),
          jsEvent: ev,
          view: context.viewApi
        });
      });
    }
    return {};
  }
  var STANDARD_PROPS = {
    start: identity,
    end: identity,
    allDay: Boolean
  };
  function parseDateSpan(raw2, dateEnv, defaultDuration) {
    let span = parseOpenDateSpan(raw2, dateEnv);
    let { range } = span;
    if (!range.start) {
      return null;
    }
    if (!range.end) {
      if (defaultDuration == null) {
        return null;
      }
      range.end = dateEnv.add(range.start, defaultDuration);
    }
    return span;
  }
  function parseOpenDateSpan(raw2, dateEnv) {
    let { refined: standardProps, extra } = refineProps(raw2, STANDARD_PROPS);
    let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
    let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
    let { allDay } = standardProps;
    if (allDay == null) {
      allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
    }
    return Object.assign({ range: {
      start: startMeta ? startMeta.marker : null,
      end: endMeta ? endMeta.marker : null
    }, allDay }, extra);
  }
  function isDateSpansEqual(span0, span1) {
    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
  }
  function isSpanPropsEqual(span0, span1) {
    for (let propName in span1) {
      if (propName !== "range" && propName !== "allDay") {
        if (span0[propName] !== span1[propName]) {
          return false;
        }
      }
    }
    for (let propName in span0) {
      if (!(propName in span1)) {
        return false;
      }
    }
    return true;
  }
  function buildDateSpanApi(span, dateEnv) {
    return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
  }
  function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
    return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
  }
  function buildRangeApi(range, dateEnv, omitTime) {
    return {
      start: dateEnv.toDate(range.start),
      end: dateEnv.toDate(range.end),
      startStr: dateEnv.formatIso(range.start, { omitTime }),
      endStr: dateEnv.formatIso(range.end, { omitTime })
    };
  }
  function fabricateEventRange(dateSpan, eventUiBases, context) {
    let res = refineEventDef({ editable: false }, context);
    let def = parseEventDef(
      res.refined,
      res.extra,
      "",
      // sourceId
      dateSpan.allDay,
      true,
      // hasEnd
      context
    );
    return {
      def,
      ui: compileEventUi(def, eventUiBases),
      instance: createEventInstance(def.defId, dateSpan.range),
      range: dateSpan.range,
      isStart: true,
      isEnd: true
    };
  }
  function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
    let isResolved = false;
    let wrappedSuccess = function(res2) {
      if (!isResolved) {
        isResolved = true;
        normalizedSuccessCallback(res2);
      }
    };
    let wrappedFailure = function(error2) {
      if (!isResolved) {
        isResolved = true;
        normalizedFailureCallback(error2);
      }
    };
    let res = func(wrappedSuccess, wrappedFailure);
    if (res && typeof res.then === "function") {
      res.then(wrappedSuccess, wrappedFailure);
    }
  }
  var JsonRequestError = class extends Error {
    constructor(message, response) {
      super(message);
      this.response = response;
    }
  };
  function requestJson(method, url, params) {
    method = method.toUpperCase();
    const fetchOptions = {
      method
    };
    if (method === "GET") {
      url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
    } else {
      fetchOptions.body = new URLSearchParams(params);
      fetchOptions.headers = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
    }
    return fetch(url, fetchOptions).then((fetchRes) => {
      if (fetchRes.ok) {
        return fetchRes.json().then((parsedResponse) => {
          return [parsedResponse, fetchRes];
        }, () => {
          throw new JsonRequestError("Failure parsing JSON", fetchRes);
        });
      } else {
        throw new JsonRequestError("Request failed", fetchRes);
      }
    });
  }
  var canVGrowWithinCell;
  function getCanVGrowWithinCell() {
    if (canVGrowWithinCell == null) {
      canVGrowWithinCell = computeCanVGrowWithinCell();
    }
    return canVGrowWithinCell;
  }
  function computeCanVGrowWithinCell() {
    if (typeof document === "undefined") {
      return true;
    }
    let el = document.createElement("div");
    el.style.position = "absolute";
    el.style.top = "0px";
    el.style.left = "0px";
    el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
    el.querySelector("table").style.height = "100px";
    el.querySelector("div").style.height = "100%";
    document.body.appendChild(el);
    let div = el.querySelector("div");
    let possible = div.offsetHeight > 0;
    document.body.removeChild(el);
    return possible;
  }
  var CalendarRoot = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.state = {
        forPrint: false
      };
      this.handleBeforePrint = () => {
        flushSync(() => {
          this.setState({ forPrint: true });
        });
      };
      this.handleAfterPrint = () => {
        flushSync(() => {
          this.setState({ forPrint: false });
        });
      };
    }
    render() {
      let { props } = this;
      let { options } = props;
      let { forPrint } = this.state;
      let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
      let height = !isHeightAuto && options.height != null ? options.height : "";
      let classNames = [
        "fc",
        forPrint ? "fc-media-print" : "fc-media-screen",
        `fc-direction-${options.direction}`,
        props.theme.getClass("root")
      ];
      if (!getCanVGrowWithinCell()) {
        classNames.push("fc-liquid-hack");
      }
      return props.children(classNames, height, isHeightAuto, forPrint);
    }
    componentDidMount() {
      let { emitter } = this.props;
      emitter.on("_beforeprint", this.handleBeforePrint);
      emitter.on("_afterprint", this.handleAfterPrint);
    }
    componentWillUnmount() {
      let { emitter } = this.props;
      emitter.off("_beforeprint", this.handleBeforePrint);
      emitter.off("_afterprint", this.handleAfterPrint);
    }
  };
  var Interaction = class {
    constructor(settings) {
      this.component = settings.component;
      this.isHitComboAllowed = settings.isHitComboAllowed || null;
    }
    destroy() {
    }
  };
  function parseInteractionSettings(component, input) {
    return {
      component,
      el: input.el,
      useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
      isHitComboAllowed: input.isHitComboAllowed || null
    };
  }
  function interactionSettingsToStore(settings) {
    return {
      [settings.component.uid]: settings
    };
  }
  var interactionSettingsStore = {};
  var NowTimer = class extends x {
    constructor(props, context) {
      super(props, context);
      this.handleRefresh = () => {
        let timing = this.computeTiming();
        if (timing.state.nowDate.valueOf() !== this.state.nowDate.valueOf()) {
          this.setState(timing.state);
        }
        this.clearTimeout();
        this.setTimeout(timing.waitMs);
      };
      this.handleVisibilityChange = () => {
        if (!document.hidden) {
          this.handleRefresh();
        }
      };
      this.state = this.computeTiming().state;
    }
    render() {
      let { props, state } = this;
      return props.children(state.nowDate, state.todayRange);
    }
    componentDidMount() {
      this.setTimeout();
      this.context.nowManager.addResetListener(this.handleRefresh);
      document.addEventListener("visibilitychange", this.handleVisibilityChange);
    }
    componentDidUpdate(prevProps) {
      if (prevProps.unit !== this.props.unit) {
        this.clearTimeout();
        this.setTimeout();
      }
    }
    componentWillUnmount() {
      this.clearTimeout();
      this.context.nowManager.removeResetListener(this.handleRefresh);
      document.removeEventListener("visibilitychange", this.handleVisibilityChange);
    }
    computeTiming() {
      let { props, context } = this;
      let unroundedNow = context.nowManager.getDateMarker();
      let { nowIndicatorSnap } = context.options;
      if (nowIndicatorSnap === "auto") {
        nowIndicatorSnap = // large unit?
        /year|month|week|day/.test(props.unit) || // if slotDuration 30 mins for example, would NOT appear to snap (legacy behavior)
        (props.unitValue || 1) === 1;
      }
      let nowDate;
      let waitMs;
      if (nowIndicatorSnap) {
        nowDate = context.dateEnv.startOf(unroundedNow, props.unit);
        let nextUnitStart = context.dateEnv.add(nowDate, createDuration(1, props.unit));
        waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
      } else {
        nowDate = unroundedNow;
        waitMs = 1e3 * 60;
      }
      waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
      return {
        state: { nowDate, todayRange: buildDayRange(nowDate) },
        waitMs
      };
    }
    setTimeout(waitMs = this.computeTiming().waitMs) {
      this.timeoutId = setTimeout(() => {
        const timing = this.computeTiming();
        this.setState(timing.state, () => {
          this.setTimeout(timing.waitMs);
        });
      }, waitMs);
    }
    clearTimeout() {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
      }
    }
  };
  NowTimer.contextType = ViewContextType;
  function buildDayRange(date) {
    let start2 = startOfDay(date);
    let end = addDays(start2, 1);
    return { start: start2, end };
  }
  var CalendarImpl = class {
    getCurrentData() {
      return this.currentDataManager.getCurrentData();
    }
    dispatch(action) {
      this.currentDataManager.dispatch(action);
    }
    get view() {
      return this.getCurrentData().viewApi;
    }
    batchRendering(callback) {
      callback();
    }
    updateSize() {
      this.trigger("_resize", true);
    }
    // Options
    // -----------------------------------------------------------------------------------------------------------------
    setOption(name, val) {
      this.dispatch({
        type: "SET_OPTION",
        optionName: name,
        rawOptionValue: val
      });
    }
    getOption(name) {
      return this.currentDataManager.currentCalendarOptionsInput[name];
    }
    getAvailableLocaleCodes() {
      return Object.keys(this.getCurrentData().availableRawLocales);
    }
    // Trigger
    // -----------------------------------------------------------------------------------------------------------------
    on(handlerName, handler4) {
      let { currentDataManager } = this;
      if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
        currentDataManager.emitter.on(handlerName, handler4);
      } else {
        console.warn(`Unknown listener name '${handlerName}'`);
      }
    }
    off(handlerName, handler4) {
      this.currentDataManager.emitter.off(handlerName, handler4);
    }
    // not meant for public use
    trigger(handlerName, ...args) {
      this.currentDataManager.emitter.trigger(handlerName, ...args);
    }
    // View
    // -----------------------------------------------------------------------------------------------------------------
    changeView(viewType, dateOrRange) {
      this.batchRendering(() => {
        this.unselect();
        if (dateOrRange) {
          if (dateOrRange.start && dateOrRange.end) {
            this.dispatch({
              type: "CHANGE_VIEW_TYPE",
              viewType
            });
            this.dispatch({
              type: "SET_OPTION",
              optionName: "visibleRange",
              rawOptionValue: dateOrRange
            });
          } else {
            let { dateEnv } = this.getCurrentData();
            this.dispatch({
              type: "CHANGE_VIEW_TYPE",
              viewType,
              dateMarker: dateEnv.createMarker(dateOrRange)
            });
          }
        } else {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
        }
      });
    }
    // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    // needs to change
    zoomTo(dateMarker, viewType) {
      let state = this.getCurrentData();
      let spec;
      viewType = viewType || "day";
      spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
      this.unselect();
      if (spec) {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType: spec.type,
          dateMarker
        });
      } else {
        this.dispatch({
          type: "CHANGE_DATE",
          dateMarker
        });
      }
    }
    // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.
    getUnitViewSpec(unit) {
      let { viewSpecs, toolbarConfig } = this.getCurrentData();
      let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
      let i3;
      let spec;
      for (let viewType in viewSpecs) {
        viewTypes.push(viewType);
      }
      for (i3 = 0; i3 < viewTypes.length; i3 += 1) {
        spec = viewSpecs[viewTypes[i3]];
        if (spec) {
          if (spec.singleUnit === unit) {
            return spec;
          }
        }
      }
      return null;
    }
    // Current Date
    // -----------------------------------------------------------------------------------------------------------------
    prev() {
      this.unselect();
      this.dispatch({ type: "PREV" });
    }
    next() {
      this.unselect();
      this.dispatch({ type: "NEXT" });
    }
    prevYear() {
      let state = this.getCurrentData();
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.addYears(state.currentDate, -1)
      });
    }
    nextYear() {
      let state = this.getCurrentData();
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.addYears(state.currentDate, 1)
      });
    }
    today() {
      let state = this.getCurrentData();
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.nowManager.getDateMarker()
      });
    }
    gotoDate(zonedDateInput) {
      let state = this.getCurrentData();
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.createMarker(zonedDateInput)
      });
    }
    incrementDate(deltaInput) {
      let state = this.getCurrentData();
      let delta = createDuration(deltaInput);
      if (delta) {
        this.unselect();
        this.dispatch({
          type: "CHANGE_DATE",
          dateMarker: state.dateEnv.add(state.currentDate, delta)
        });
      }
    }
    getDate() {
      let state = this.getCurrentData();
      return state.dateEnv.toDate(state.currentDate);
    }
    // Date Formatting Utils
    // -----------------------------------------------------------------------------------------------------------------
    formatDate(d2, formatter) {
      let { dateEnv } = this.getCurrentData();
      return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
    }
    // `settings` is for formatter AND isEndExclusive
    formatRange(d0, d1, settings) {
      let { dateEnv } = this.getCurrentData();
      return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
    }
    formatIso(d2, omitTime) {
      let { dateEnv } = this.getCurrentData();
      return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
    }
    // Date Selection / Event Selection / DayClick
    // -----------------------------------------------------------------------------------------------------------------
    select(dateOrObj, endDate) {
      let selectionInput;
      if (endDate == null) {
        if (dateOrObj.start != null) {
          selectionInput = dateOrObj;
        } else {
          selectionInput = {
            start: dateOrObj,
            end: null
          };
        }
      } else {
        selectionInput = {
          start: dateOrObj,
          end: endDate
        };
      }
      let state = this.getCurrentData();
      let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
      if (selection) {
        this.dispatch({ type: "SELECT_DATES", selection });
        triggerDateSelect(selection, null, state);
      }
    }
    unselect(pev) {
      let state = this.getCurrentData();
      if (state.dateSelection) {
        this.dispatch({ type: "UNSELECT_DATES" });
        triggerDateUnselect(pev, state);
      }
    }
    // Public Events API
    // -----------------------------------------------------------------------------------------------------------------
    addEvent(eventInput, sourceInput) {
      if (eventInput instanceof EventImpl) {
        let def = eventInput._def;
        let instance = eventInput._instance;
        let currentData = this.getCurrentData();
        if (!currentData.eventStore.defs[def.defId]) {
          this.dispatch({
            type: "ADD_EVENTS",
            eventStore: eventTupleToStore({ def, instance })
            // TODO: better util for two args?
          });
          this.triggerEventAdd(eventInput);
        }
        return eventInput;
      }
      let state = this.getCurrentData();
      let eventSource;
      if (sourceInput instanceof EventSourceImpl) {
        eventSource = sourceInput.internalEventSource;
      } else if (typeof sourceInput === "boolean") {
        if (sourceInput) {
          [eventSource] = hashValuesToArray(state.eventSources);
        }
      } else if (sourceInput != null) {
        let sourceApi = this.getEventSourceById(sourceInput);
        if (!sourceApi) {
          console.warn(`Could not find an event source with ID "${sourceInput}"`);
          return null;
        }
        eventSource = sourceApi.internalEventSource;
      }
      let tuple = parseEvent3(eventInput, eventSource, state, false);
      if (tuple) {
        let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore(tuple)
        });
        this.triggerEventAdd(newEventApi);
        return newEventApi;
      }
      return null;
    }
    triggerEventAdd(eventApi) {
      let { emitter } = this.getCurrentData();
      emitter.trigger("eventAdd", {
        event: eventApi,
        relatedEvents: [],
        revert: () => {
          this.dispatch({
            type: "REMOVE_EVENTS",
            eventStore: eventApiToStore(eventApi)
          });
        }
      });
    }
    // TODO: optimize
    getEventById(id) {
      let state = this.getCurrentData();
      let { defs, instances } = state.eventStore;
      id = String(id);
      for (let defId in defs) {
        let def = defs[defId];
        if (def.publicId === id) {
          if (def.recurringDef) {
            return new EventImpl(state, def, null);
          }
          for (let instanceId in instances) {
            let instance = instances[instanceId];
            if (instance.defId === def.defId) {
              return new EventImpl(state, def, instance);
            }
          }
        }
      }
      return null;
    }
    getEvents() {
      let currentData = this.getCurrentData();
      return buildEventApis(currentData.eventStore, currentData);
    }
    removeAllEvents() {
      this.dispatch({ type: "REMOVE_ALL_EVENTS" });
    }
    // Public Event Sources API
    // -----------------------------------------------------------------------------------------------------------------
    getEventSources() {
      let state = this.getCurrentData();
      let sourceHash = state.eventSources;
      let sourceApis = [];
      for (let internalId in sourceHash) {
        sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
      }
      return sourceApis;
    }
    getEventSourceById(id) {
      let state = this.getCurrentData();
      let sourceHash = state.eventSources;
      id = String(id);
      for (let sourceId in sourceHash) {
        if (sourceHash[sourceId].publicId === id) {
          return new EventSourceImpl(state, sourceHash[sourceId]);
        }
      }
      return null;
    }
    addEventSource(sourceInput) {
      let state = this.getCurrentData();
      if (sourceInput instanceof EventSourceImpl) {
        if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
          this.dispatch({
            type: "ADD_EVENT_SOURCES",
            sources: [sourceInput.internalEventSource]
          });
        }
        return sourceInput;
      }
      let eventSource = parseEventSource(sourceInput, state);
      if (eventSource) {
        this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
        return new EventSourceImpl(state, eventSource);
      }
      return null;
    }
    removeAllEventSources() {
      this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
    }
    refetchEvents() {
      this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
    }
    // Scroll
    // -----------------------------------------------------------------------------------------------------------------
    scrollToTime(timeInput) {
      let time = createDuration(timeInput);
      if (time) {
        this.trigger("_scrollRequest", { time });
      }
    }
  };
  function pointInsideRect(point, rect) {
    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
  }
  function intersectRects(rect1, rect2) {
    let res = {
      left: Math.max(rect1.left, rect2.left),
      right: Math.min(rect1.right, rect2.right),
      top: Math.max(rect1.top, rect2.top),
      bottom: Math.min(rect1.bottom, rect2.bottom)
    };
    if (res.left < res.right && res.top < res.bottom) {
      return res;
    }
    return false;
  }
  function constrainPoint(point, rect) {
    return {
      left: Math.min(Math.max(point.left, rect.left), rect.right),
      top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
  }
  function getRectCenter(rect) {
    return {
      left: (rect.left + rect.right) / 2,
      top: (rect.top + rect.bottom) / 2
    };
  }
  function diffPoints(point1, point2) {
    return {
      left: point1.left - point2.left,
      top: point1.top - point2.top
    };
  }
  var EMPTY_EVENT_STORE = createEmptyEventStore();
  var Splitter = class {
    constructor() {
      this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
      this.splitDateSelection = memoize(this._splitDateSpan);
      this.splitEventStore = memoize(this._splitEventStore);
      this.splitIndividualUi = memoize(this._splitIndividualUi);
      this.splitEventDrag = memoize(this._splitInteraction);
      this.splitEventResize = memoize(this._splitInteraction);
      this.eventUiBuilders = {};
    }
    splitProps(props) {
      let keyInfos = this.getKeyInfo(props);
      let defKeys = this.getKeysForEventDefs(props.eventStore);
      let dateSelections = this.splitDateSelection(props.dateSelection);
      let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys);
      let eventStores = this.splitEventStore(props.eventStore, defKeys);
      let eventDrags = this.splitEventDrag(props.eventDrag);
      let eventResizes = this.splitEventResize(props.eventResize);
      let splitProps = {};
      this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));
      for (let key in keyInfos) {
        let keyInfo = keyInfos[key];
        let eventStore = eventStores[key] || EMPTY_EVENT_STORE;
        let buildEventUi = this.eventUiBuilders[key];
        splitProps[key] = {
          businessHours: keyInfo.businessHours || props.businessHours,
          dateSelection: dateSelections[key] || null,
          eventStore,
          eventUiBases: buildEventUi(props.eventUiBases[""], keyInfo.ui, individualUi[key]),
          eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : "",
          eventDrag: eventDrags[key] || null,
          eventResize: eventResizes[key] || null
        };
      }
      return splitProps;
    }
    _splitDateSpan(dateSpan) {
      let dateSpans = {};
      if (dateSpan) {
        let keys = this.getKeysForDateSpan(dateSpan);
        for (let key of keys) {
          dateSpans[key] = dateSpan;
        }
      }
      return dateSpans;
    }
    _getKeysForEventDefs(eventStore) {
      return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));
    }
    _splitEventStore(eventStore, defKeys) {
      let { defs, instances } = eventStore;
      let splitStores = {};
      for (let defId in defs) {
        for (let key of defKeys[defId]) {
          if (!splitStores[key]) {
            splitStores[key] = createEmptyEventStore();
          }
          splitStores[key].defs[defId] = defs[defId];
        }
      }
      for (let instanceId in instances) {
        let instance = instances[instanceId];
        for (let key of defKeys[instance.defId]) {
          if (splitStores[key]) {
            splitStores[key].instances[instanceId] = instance;
          }
        }
      }
      return splitStores;
    }
    _splitIndividualUi(eventUiBases, defKeys) {
      let splitHashes = {};
      for (let defId in eventUiBases) {
        if (defId) {
          for (let key of defKeys[defId]) {
            if (!splitHashes[key]) {
              splitHashes[key] = {};
            }
            splitHashes[key][defId] = eventUiBases[defId];
          }
        }
      }
      return splitHashes;
    }
    _splitInteraction(interaction) {
      let splitStates = {};
      if (interaction) {
        let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
        let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
        let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
        let populate = (key) => {
          if (!splitStates[key]) {
            splitStates[key] = {
              affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,
              mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,
              isEvent: interaction.isEvent
            };
          }
        };
        for (let key in affectedStores) {
          populate(key);
        }
        for (let key in mutatedStores) {
          populate(key);
        }
      }
      return splitStates;
    }
  };
  function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
    let baseParts = [];
    if (allUi) {
      baseParts.push(allUi);
    }
    if (eventUiForKey) {
      baseParts.push(eventUiForKey);
    }
    let stuff = {
      "": combineEventUis(baseParts)
    };
    if (individualUi) {
      Object.assign(stuff, individualUi);
    }
    return stuff;
  }
  function getDateMeta(date, todayRange, nowDate, dateProfile) {
    return {
      dow: date.getUTCDay(),
      isDisabled: Boolean(dateProfile && (!dateProfile.activeRange || !rangeContainsMarker(dateProfile.activeRange, date))),
      isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
      isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
      isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
      isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
    };
  }
  function getDayClassNames(meta, theme) {
    let classNames = [
      "fc-day",
      `fc-day-${DAY_IDS[meta.dow]}`
    ];
    if (meta.isDisabled) {
      classNames.push("fc-day-disabled");
    } else {
      if (meta.isToday) {
        classNames.push("fc-day-today");
        classNames.push(theme.getClass("today"));
      }
      if (meta.isPast) {
        classNames.push("fc-day-past");
      }
      if (meta.isFuture) {
        classNames.push("fc-day-future");
      }
      if (meta.isOther) {
        classNames.push("fc-day-other");
      }
    }
    return classNames;
  }
  var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
  var WEEK_FORMAT = createFormatter({ week: "long" });
  function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
    const { dateEnv, options, calendarApi } = context;
    let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
    if (options.navLinks) {
      let zonedDate = dateEnv.toDate(dateMarker);
      const handleInteraction = (ev) => {
        let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
        if (typeof customAction === "function") {
          customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
        } else {
          if (typeof customAction === "string") {
            viewType = customAction;
          }
          calendarApi.zoomTo(dateMarker, viewType);
        }
      };
      return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
    }
    return { "aria-label": dateStr };
  }
  var _isRtlScrollbarOnLeft = null;
  function getIsRtlScrollbarOnLeft() {
    if (_isRtlScrollbarOnLeft === null) {
      _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
    }
    return _isRtlScrollbarOnLeft;
  }
  function computeIsRtlScrollbarOnLeft() {
    let outerEl = document.createElement("div");
    applyStyle(outerEl, {
      position: "absolute",
      top: -1e3,
      left: 0,
      border: 0,
      padding: 0,
      overflow: "scroll",
      direction: "rtl"
    });
    outerEl.innerHTML = "<div></div>";
    document.body.appendChild(outerEl);
    let innerEl = outerEl.firstChild;
    let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
    removeElement3(outerEl);
    return res;
  }
  var _scrollbarWidths;
  function getScrollbarWidths() {
    if (!_scrollbarWidths) {
      _scrollbarWidths = computeScrollbarWidths();
    }
    return _scrollbarWidths;
  }
  function computeScrollbarWidths() {
    let el = document.createElement("div");
    el.style.overflow = "scroll";
    el.style.position = "absolute";
    el.style.top = "-9999px";
    el.style.left = "-9999px";
    document.body.appendChild(el);
    let res = computeScrollbarWidthsForEl(el);
    document.body.removeChild(el);
    return res;
  }
  function computeScrollbarWidthsForEl(el) {
    return {
      x: el.offsetHeight - el.clientHeight,
      y: el.offsetWidth - el.clientWidth
    };
  }
  function computeEdges(el, getPadding = false) {
    let computedStyle = window.getComputedStyle(el);
    let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
    let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
    let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
    let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
    let badScrollbarWidths = computeScrollbarWidthsForEl(el);
    let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
    let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
    let res = {
      borderLeft,
      borderRight,
      borderTop,
      borderBottom,
      scrollbarBottom,
      scrollbarLeft: 0,
      scrollbarRight: 0
    };
    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
      res.scrollbarLeft = scrollbarLeftRight;
    } else {
      res.scrollbarRight = scrollbarLeftRight;
    }
    if (getPadding) {
      res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
      res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
      res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
      res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
    }
    return res;
  }
  function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
    let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
    let edges = computeEdges(el, goWithinPadding);
    let res = {
      left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
      right: outerRect.right - edges.borderRight - edges.scrollbarRight,
      top: outerRect.top + edges.borderTop,
      bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
    };
    if (goWithinPadding) {
      res.left += edges.paddingLeft;
      res.right -= edges.paddingRight;
      res.top += edges.paddingTop;
      res.bottom -= edges.paddingBottom;
    }
    return res;
  }
  function computeRect(el) {
    let rect = el.getBoundingClientRect();
    return {
      left: rect.left + window.scrollX,
      top: rect.top + window.scrollY,
      right: rect.right + window.scrollX,
      bottom: rect.bottom + window.scrollY
    };
  }
  function computeClippedClientRect(el) {
    let clippingParents = getClippingParents(el);
    let rect = el.getBoundingClientRect();
    for (let clippingParent of clippingParents) {
      let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
      if (intersection) {
        rect = intersection;
      } else {
        return null;
      }
    }
    return rect;
  }
  function getClippingParents(el) {
    let parents = [];
    while (el instanceof HTMLElement) {
      let computedStyle = window.getComputedStyle(el);
      if (computedStyle.position === "fixed") {
        break;
      }
      if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
        parents.push(el);
      }
      el = el.parentNode;
    }
    return parents;
  }
  var PositionCache = class {
    constructor(originEl, els, isHorizontal, isVertical) {
      this.els = els;
      let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
      if (isHorizontal) {
        this.buildElHorizontals(originClientRect.left);
      }
      if (isVertical) {
        this.buildElVerticals(originClientRect.top);
      }
    }
    // Populates the left/right internal coordinate arrays
    buildElHorizontals(originClientLeft) {
      let lefts = [];
      let rights = [];
      for (let el of this.els) {
        let rect = el.getBoundingClientRect();
        lefts.push(rect.left - originClientLeft);
        rights.push(rect.right - originClientLeft);
      }
      this.lefts = lefts;
      this.rights = rights;
    }
    // Populates the top/bottom internal coordinate arrays
    buildElVerticals(originClientTop) {
      let tops = [];
      let bottoms = [];
      for (let el of this.els) {
        let rect = el.getBoundingClientRect();
        tops.push(rect.top - originClientTop);
        bottoms.push(rect.bottom - originClientTop);
      }
      this.tops = tops;
      this.bottoms = bottoms;
    }
    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.
    leftToIndex(leftPosition) {
      let { lefts, rights } = this;
      let len = lefts.length;
      let i3;
      for (i3 = 0; i3 < len; i3 += 1) {
        if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
          return i3;
        }
      }
      return void 0;
    }
    // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.
    topToIndex(topPosition) {
      let { tops, bottoms } = this;
      let len = tops.length;
      let i3;
      for (i3 = 0; i3 < len; i3 += 1) {
        if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
          return i3;
        }
      }
      return void 0;
    }
    // Gets the width of the element at the given index
    getWidth(leftIndex) {
      return this.rights[leftIndex] - this.lefts[leftIndex];
    }
    // Gets the height of the element at the given index
    getHeight(topIndex) {
      return this.bottoms[topIndex] - this.tops[topIndex];
    }
    similarTo(otherCache) {
      return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
    }
  };
  function similarNumArrays(a3, b3) {
    const len = a3.length;
    if (len !== b3.length) {
      return false;
    }
    for (let i3 = 0; i3 < len; i3++) {
      if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
        return false;
      }
    }
    return true;
  }
  var ScrollController = class {
    getMaxScrollTop() {
      return this.getScrollHeight() - this.getClientHeight();
    }
    getMaxScrollLeft() {
      return this.getScrollWidth() - this.getClientWidth();
    }
    canScrollVertically() {
      return this.getMaxScrollTop() > 0;
    }
    canScrollHorizontally() {
      return this.getMaxScrollLeft() > 0;
    }
    canScrollUp() {
      return this.getScrollTop() > 0;
    }
    canScrollDown() {
      return this.getScrollTop() < this.getMaxScrollTop();
    }
    canScrollLeft() {
      return this.getScrollLeft() > 0;
    }
    canScrollRight() {
      return this.getScrollLeft() < this.getMaxScrollLeft();
    }
  };
  var ElementScrollController = class extends ScrollController {
    constructor(el) {
      super();
      this.el = el;
    }
    getScrollTop() {
      return this.el.scrollTop;
    }
    getScrollLeft() {
      return this.el.scrollLeft;
    }
    setScrollTop(top) {
      this.el.scrollTop = top;
    }
    setScrollLeft(left) {
      this.el.scrollLeft = left;
    }
    getScrollWidth() {
      return this.el.scrollWidth;
    }
    getScrollHeight() {
      return this.el.scrollHeight;
    }
    getClientHeight() {
      return this.el.clientHeight;
    }
    getClientWidth() {
      return this.el.clientWidth;
    }
  };
  var WindowScrollController = class extends ScrollController {
    getScrollTop() {
      return window.scrollY;
    }
    getScrollLeft() {
      return window.scrollX;
    }
    setScrollTop(n2) {
      window.scroll(window.scrollX, n2);
    }
    setScrollLeft(n2) {
      window.scroll(n2, window.scrollY);
    }
    getScrollWidth() {
      return document.documentElement.scrollWidth;
    }
    getScrollHeight() {
      return document.documentElement.scrollHeight;
    }
    getClientHeight() {
      return document.documentElement.clientHeight;
    }
    getClientWidth() {
      return document.documentElement.clientWidth;
    }
  };
  var DateComponent = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.uid = guid();
    }
    // Hit System
    // -----------------------------------------------------------------------------------------------------------------
    prepareHits() {
    }
    queryHit(positionLeft, positionTop, elWidth, elHeight) {
      return null;
    }
    // Pointer Interaction Utils
    // -----------------------------------------------------------------------------------------------------------------
    isValidSegDownEl(el) {
      return !this.props.eventDrag && // HACK
      !this.props.eventResize && // HACK
      !elementClosest(el, ".fc-event-mirror");
    }
    isValidDateDownEl(el) {
      return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
      !elementClosest(el, "a[data-navlink]") && // a clickable nav link
      !elementClosest(el, ".fc-popover");
    }
  };
  var SegHierarchy = class {
    constructor(getEntryThickness = (entry) => {
      return entry.thickness || 1;
    }) {
      this.getEntryThickness = getEntryThickness;
      this.strictOrder = false;
      this.allowReslicing = false;
      this.maxCoord = -1;
      this.maxStackCnt = -1;
      this.levelCoords = [];
      this.entriesByLevel = [];
      this.stackCnts = {};
    }
    addSegs(inputs) {
      let hiddenEntries = [];
      for (let input of inputs) {
        this.insertEntry(input, hiddenEntries);
      }
      return hiddenEntries;
    }
    insertEntry(entry, hiddenEntries) {
      let insertion = this.findInsertion(entry);
      if (this.isInsertionValid(insertion, entry)) {
        this.insertEntryAt(entry, insertion);
      } else {
        this.handleInvalidInsertion(insertion, entry, hiddenEntries);
      }
    }
    isInsertionValid(insertion, entry) {
      return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
    }
    handleInvalidInsertion(insertion, entry, hiddenEntries) {
      if (this.allowReslicing && insertion.touchingEntry) {
        const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
        hiddenEntries.push(hiddenEntry);
        this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
      } else {
        hiddenEntries.push(entry);
      }
    }
    /*
    Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
    */
    splitEntry(entry, barrier, hiddenEntries) {
      let entrySpan = entry.span;
      let barrierSpan = barrier.span;
      if (entrySpan.start < barrierSpan.start) {
        this.insertEntry({
          index: entry.index,
          thickness: entry.thickness,
          span: { start: entrySpan.start, end: barrierSpan.start }
        }, hiddenEntries);
      }
      if (entrySpan.end > barrierSpan.end) {
        this.insertEntry({
          index: entry.index,
          thickness: entry.thickness,
          span: { start: barrierSpan.end, end: entrySpan.end }
        }, hiddenEntries);
      }
    }
    insertEntryAt(entry, insertion) {
      let { entriesByLevel, levelCoords } = this;
      if (insertion.lateral === -1) {
        insertAt(levelCoords, insertion.level, insertion.levelCoord);
        insertAt(entriesByLevel, insertion.level, [entry]);
      } else {
        insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
      }
      this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
    }
    /*
    does not care about limits
    */
    findInsertion(newEntry) {
      let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
      let levelCnt = levelCoords.length;
      let candidateCoord = 0;
      let touchingLevel = -1;
      let touchingLateral = -1;
      let touchingEntry = null;
      let stackCnt = 0;
      for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
        const trackingCoord = levelCoords[trackingLevel];
        if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
          break;
        }
        let trackingEntries = entriesByLevel[trackingLevel];
        let trackingEntry;
        let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
        let lateralIndex = searchRes[0] + searchRes[1];
        while (
          // loop through entries that horizontally intersect
          (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
          trackingEntry.span.start < newEntry.span.end
        ) {
          let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
          if (trackingEntryBottom > candidateCoord) {
            candidateCoord = trackingEntryBottom;
            touchingEntry = trackingEntry;
            touchingLevel = trackingLevel;
            touchingLateral = lateralIndex;
          }
          if (trackingEntryBottom === candidateCoord) {
            stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
          }
          lateralIndex += 1;
        }
      }
      let destLevel = 0;
      if (touchingEntry) {
        destLevel = touchingLevel + 1;
        while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
          destLevel += 1;
        }
      }
      let destLateral = -1;
      if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
        destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
      }
      return {
        touchingLevel,
        touchingLateral,
        touchingEntry,
        stackCnt,
        levelCoord: candidateCoord,
        level: destLevel,
        lateral: destLateral
      };
    }
    // sorted by levelCoord (lowest to highest)
    toRects() {
      let { entriesByLevel, levelCoords } = this;
      let levelCnt = entriesByLevel.length;
      let rects = [];
      for (let level = 0; level < levelCnt; level += 1) {
        let entries = entriesByLevel[level];
        let levelCoord = levelCoords[level];
        for (let entry of entries) {
          rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
        }
      }
      return rects;
    }
  };
  function getEntrySpanEnd(entry) {
    return entry.span.end;
  }
  function buildEntryKey(entry) {
    return entry.index + ":" + entry.span.start;
  }
  function groupIntersectingEntries(entries) {
    let merges = [];
    for (let entry of entries) {
      let filteredMerges = [];
      let hungryMerge = {
        span: entry.span,
        entries: [entry]
      };
      for (let merge3 of merges) {
        if (intersectSpans(merge3.span, hungryMerge.span)) {
          hungryMerge = {
            entries: merge3.entries.concat(hungryMerge.entries),
            span: joinSpans(merge3.span, hungryMerge.span)
          };
        } else {
          filteredMerges.push(merge3);
        }
      }
      filteredMerges.push(hungryMerge);
      merges = filteredMerges;
    }
    return merges;
  }
  function joinSpans(span0, span1) {
    return {
      start: Math.min(span0.start, span1.start),
      end: Math.max(span0.end, span1.end)
    };
  }
  function intersectSpans(span0, span1) {
    let start2 = Math.max(span0.start, span1.start);
    let end = Math.min(span0.end, span1.end);
    if (start2 < end) {
      return { start: start2, end };
    }
    return null;
  }
  function insertAt(arr, index6, item) {
    arr.splice(index6, 0, item);
  }
  function binarySearch(a3, searchVal, getItemVal) {
    let startIndex = 0;
    let endIndex = a3.length;
    if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
      return [0, 0];
    }
    if (searchVal > getItemVal(a3[endIndex - 1])) {
      return [endIndex, 0];
    }
    while (startIndex < endIndex) {
      let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
      let middleVal = getItemVal(a3[middleIndex]);
      if (searchVal < middleVal) {
        endIndex = middleIndex;
      } else if (searchVal > middleVal) {
        startIndex = middleIndex + 1;
      } else {
        return [middleIndex, 1];
      }
    }
    return [startIndex, 0];
  }
  var ElementDragging = class {
    constructor(el, selector) {
      this.emitter = new Emitter();
    }
    destroy() {
    }
    setMirrorIsVisible(bool) {
    }
    setMirrorNeedsRevert(bool) {
    }
    setAutoScrollEnabled(bool) {
    }
  };
  var config = {};
  function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
    if (!datesRepDistinctDays || dayCnt > 10) {
      return createFormatter({ weekday: "short" });
    }
    if (dayCnt > 1) {
      return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
    }
    return createFormatter({ weekday: "long" });
  }
  var CLASS_NAME = "fc-col-header-cell";
  function renderInner$1(renderProps) {
    return renderProps.text;
  }
  var TableDateCell = class extends BaseComponent2 {
    render() {
      let { dateEnv, options, theme, viewApi } = this.context;
      let { props } = this;
      let { date, dateProfile } = props;
      let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
      let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
      let text = dateEnv.format(date, props.dayHeaderFormat);
      let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
      let publicDate = dateEnv.toDate(date);
      if (dateEnv.namedTimeZoneImpl) {
        publicDate = addMs(publicDate, 36e5);
      }
      let renderProps = Object.assign(Object.assign(Object.assign({ date: publicDate, view: viewApi }, props.extraRenderProps), { text }), dayMeta);
      return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ] })));
    }
  };
  var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
  var TableDowCell = class extends BaseComponent2 {
    render() {
      let { props } = this;
      let { dateEnv, theme, viewApi, options } = this.context;
      let date = addDays(/* @__PURE__ */ new Date(2592e5), props.dow);
      let dateMeta = {
        dow: props.dow,
        isDisabled: false,
        isFuture: false,
        isPast: false,
        isToday: false,
        isOther: false
      };
      let text = dateEnv.format(date, props.dayHeaderFormat);
      let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
        // TODO: make this public?
        date
      }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
      return y(ContentContainer, { elTag: "th", elClasses: [
        CLASS_NAME,
        ...getDayClassNames(dateMeta, theme),
        ...props.extraClassNames || []
      ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-scrollgrid-sync-inner" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-col-header-cell-cushion",
          props.isSticky && "fc-sticky"
        ], elAttrs: {
          "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
        } })
      ));
    }
  };
  var DayHeader = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
    }
    render() {
      let { context } = this;
      let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
      let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
      return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
        "tr",
        { role: "row" },
        renderIntro && renderIntro("day"),
        dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
      ));
    }
  };
  function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
  }
  var DaySeriesModel = class {
    constructor(range, dateProfileGenerator) {
      let date = range.start;
      let { end } = range;
      let indices = [];
      let dates = [];
      let dayIndex = -1;
      while (date < end) {
        if (dateProfileGenerator.isHiddenDay(date)) {
          indices.push(dayIndex + 0.5);
        } else {
          dayIndex += 1;
          indices.push(dayIndex);
          dates.push(date);
        }
        date = addDays(date, 1);
      }
      this.dates = dates;
      this.indices = indices;
      this.cnt = dates.length;
    }
    sliceRange(range) {
      let firstIndex = this.getDateDayIndex(range.start);
      let lastIndex = this.getDateDayIndex(addDays(range.end, -1));
      let clippedFirstIndex = Math.max(0, firstIndex);
      let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
      clippedFirstIndex = Math.ceil(clippedFirstIndex);
      clippedLastIndex = Math.floor(clippedLastIndex);
      if (clippedFirstIndex <= clippedLastIndex) {
        return {
          firstIndex: clippedFirstIndex,
          lastIndex: clippedLastIndex,
          isStart: firstIndex === clippedFirstIndex,
          isEnd: lastIndex === clippedLastIndex
        };
      }
      return null;
    }
    // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
    getDateDayIndex(date) {
      let { indices } = this;
      let dayOffset = Math.floor(diffDays(this.dates[0], date));
      if (dayOffset < 0) {
        return indices[0] - 1;
      }
      if (dayOffset >= indices.length) {
        return indices[indices.length - 1] + 1;
      }
      return indices[dayOffset];
    }
  };
  var DayTableModel = class {
    constructor(daySeries, breakOnWeeks) {
      let { dates } = daySeries;
      let daysPerRow;
      let firstDay;
      let rowCnt;
      if (breakOnWeeks) {
        firstDay = dates[0].getUTCDay();
        for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
          if (dates[daysPerRow].getUTCDay() === firstDay) {
            break;
          }
        }
        rowCnt = Math.ceil(dates.length / daysPerRow);
      } else {
        rowCnt = 1;
        daysPerRow = dates.length;
      }
      this.rowCnt = rowCnt;
      this.colCnt = daysPerRow;
      this.daySeries = daySeries;
      this.cells = this.buildCells();
      this.headerDates = this.buildHeaderDates();
    }
    buildCells() {
      let rows = [];
      for (let row = 0; row < this.rowCnt; row += 1) {
        let cells = [];
        for (let col = 0; col < this.colCnt; col += 1) {
          cells.push(this.buildCell(row, col));
        }
        rows.push(cells);
      }
      return rows;
    }
    buildCell(row, col) {
      let date = this.daySeries.dates[row * this.colCnt + col];
      return {
        key: date.toISOString(),
        date
      };
    }
    buildHeaderDates() {
      let dates = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        dates.push(this.cells[0][col].date);
      }
      return dates;
    }
    sliceRange(range) {
      let { colCnt } = this;
      let seriesSeg = this.daySeries.sliceRange(range);
      let segs = [];
      if (seriesSeg) {
        let { firstIndex, lastIndex } = seriesSeg;
        let index6 = firstIndex;
        while (index6 <= lastIndex) {
          let row = Math.floor(index6 / colCnt);
          let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
          segs.push({
            row,
            firstCol: index6 % colCnt,
            lastCol: (nextIndex - 1) % colCnt,
            isStart: seriesSeg.isStart && index6 === firstIndex,
            isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
          });
          index6 = nextIndex;
        }
      }
      return segs;
    }
  };
  var Slicer = class {
    constructor() {
      this.sliceBusinessHours = memoize(this._sliceBusinessHours);
      this.sliceDateSelection = memoize(this._sliceDateSpan);
      this.sliceEventStore = memoize(this._sliceEventStore);
      this.sliceEventDrag = memoize(this._sliceInteraction);
      this.sliceEventResize = memoize(this._sliceInteraction);
      this.forceDayIfListItem = false;
    }
    sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
      let { eventUiBases } = props;
      let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
      return {
        dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
        businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
        fgEventSegs: eventSegs.fg,
        bgEventSegs: eventSegs.bg,
        eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
        eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
        eventSelection: props.eventSelection
      };
    }
    sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
      return this._sliceDateSpan(
        { range: { start: date, end: addMs(date, 1) }, allDay: false },
        // add 1 ms, protect against null range
        dateProfile,
        nextDayThreshold,
        {},
        context,
        ...extraArgs
      );
    }
    _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
      if (!businessHours) {
        return [];
      }
      return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
    }
    _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
      if (eventStore) {
        let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
        return {
          bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
          fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
        };
      }
      return { bg: [], fg: [] };
    }
    _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
      if (!interaction) {
        return null;
      }
      let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
        affectedInstances: interaction.affectedEvents.instances,
        isEvent: interaction.isEvent
      };
    }
    _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
      if (!dateSpan) {
        return [];
      }
      let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
      let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
      if (activeDateSpanRange) {
        dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
        let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
        let segs = this.sliceRange(dateSpan.range, ...extraArgs);
        for (let seg of segs) {
          seg.eventRange = eventRange;
        }
        return segs;
      }
      return [];
    }
    /*
    "complete" seg means it has component and eventRange
    */
    sliceEventRanges(eventRanges, extraArgs) {
      let segs = [];
      for (let eventRange of eventRanges) {
        segs.push(...this.sliceEventRange(eventRange, extraArgs));
      }
      return segs;
    }
    /*
    "complete" seg means it has component and eventRange
    */
    sliceEventRange(eventRange, extraArgs) {
      let dateRange = eventRange.range;
      if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
        dateRange = {
          start: dateRange.start,
          end: addDays(dateRange.start, 1)
        };
      }
      let segs = this.sliceRange(dateRange, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
        seg.isStart = eventRange.isStart && seg.isStart;
        seg.isEnd = eventRange.isEnd && seg.isEnd;
      }
      return segs;
    }
  };
  function computeActiveRange(dateProfile, isComponentAllDay) {
    let range = dateProfile.activeRange;
    if (isComponentAllDay) {
      return range;
    }
    return {
      start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
      end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)
      // 864e5 = ms in a day
    };
  }
  function isInteractionValid(interaction, dateProfile, context) {
    let { instances } = interaction.mutatedEvents;
    for (let instanceId in instances) {
      if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
        return false;
      }
    }
    return isNewPropsValid({ eventDrag: interaction }, context);
  }
  function isDateSelectionValid(dateSelection, dateProfile, context) {
    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
      return false;
    }
    return isNewPropsValid({ dateSelection }, context);
  }
  function isNewPropsValid(newProps, context) {
    let calendarState = context.getCurrentData();
    let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
  }
  function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
      return false;
    }
    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
      return false;
    }
    return true;
  }
  function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
    let currentState = context.getCurrentData();
    let interaction = state.eventDrag;
    let subjectEventStore = interaction.mutatedEvents;
    let subjectDefs = subjectEventStore.defs;
    let subjectInstances = subjectEventStore.instances;
    let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
    if (filterConfig) {
      subjectConfigs = mapHash(subjectConfigs, filterConfig);
    }
    let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
    let otherDefs = otherEventStore.defs;
    let otherInstances = otherEventStore.instances;
    let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
    for (let subjectInstanceId in subjectInstances) {
      let subjectInstance = subjectInstances[subjectInstanceId];
      let subjectRange = subjectInstance.range;
      let subjectConfig = subjectConfigs[subjectInstance.defId];
      let subjectDef = subjectDefs[subjectInstance.defId];
      if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
        return false;
      }
      let { eventOverlap } = context.options;
      let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
      for (let otherInstanceId in otherInstances) {
        let otherInstance = otherInstances[otherInstanceId];
        if (rangesIntersect(subjectRange, otherInstance.range)) {
          let otherOverlap = otherConfigs[otherInstance.defId].overlap;
          if (otherOverlap === false && interaction.isEvent) {
            return false;
          }
          if (subjectConfig.overlap === false) {
            return false;
          }
          if (eventOverlapFunc && !eventOverlapFunc(
            new EventImpl(context, otherDefs[otherInstance.defId], otherInstance),
            // still event
            new EventImpl(context, subjectDef, subjectInstance)
          )) {
            return false;
          }
        }
      }
      let calendarEventStore = currentState.eventStore;
      for (let subjectAllow of subjectConfig.allows) {
        let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
        let origDef = calendarEventStore.defs[subjectDef.defId];
        let origInstance = calendarEventStore.instances[subjectInstanceId];
        let eventApi;
        if (origDef) {
          eventApi = new EventImpl(context, origDef, origInstance);
        } else {
          eventApi = new EventImpl(context, subjectDef);
        }
        if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
          return false;
        }
      }
    }
    return true;
  }
  function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
    let relevantEventStore = state.eventStore;
    let relevantDefs = relevantEventStore.defs;
    let relevantInstances = relevantEventStore.instances;
    let selection = state.dateSelection;
    let selectionRange = selection.range;
    let { selectionConfig } = context.getCurrentData();
    if (filterConfig) {
      selectionConfig = filterConfig(selectionConfig);
    }
    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
      return false;
    }
    let { selectOverlap } = context.options;
    let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
    for (let relevantInstanceId in relevantInstances) {
      let relevantInstance = relevantInstances[relevantInstanceId];
      if (rangesIntersect(selectionRange, relevantInstance.range)) {
        if (selectionConfig.overlap === false) {
          return false;
        }
        if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
          return false;
        }
      }
    }
    for (let selectionAllow of selectionConfig.allows) {
      let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
      if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
        return false;
      }
    }
    return true;
  }
  function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
    for (let constraint of constraints) {
      if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
        return false;
      }
    }
    return true;
  }
  function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
    if (constraint === "businessHours") {
      return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
    }
    if (typeof constraint === "string") {
      return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
    }
    if (typeof constraint === "object" && constraint) {
      return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
    }
    return [];
  }
  function eventStoreToRanges(eventStore) {
    let { instances } = eventStore;
    let ranges = [];
    for (let instanceId in instances) {
      ranges.push(instances[instanceId].range);
    }
    return ranges;
  }
  function anyRangesContainRange(outerRanges, innerRange) {
    for (let outerRange of outerRanges) {
      if (rangeContainsRange(outerRange, innerRange)) {
        return true;
      }
    }
    return false;
  }
  var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
  var Scroller = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.handleEl = (el) => {
        this.el = el;
        setRef(this.props.elRef, el);
      };
    }
    render() {
      let { props } = this;
      let { liquid, liquidIsAbsolute } = props;
      let isAbsolute = liquid && liquidIsAbsolute;
      let className = ["fc-scroller"];
      if (liquid) {
        if (liquidIsAbsolute) {
          className.push("fc-scroller-liquid-absolute");
        } else {
          className.push("fc-scroller-liquid");
        }
      }
      return y("div", { ref: this.handleEl, className: className.join(" "), style: {
        overflowX: props.overflowX,
        overflowY: props.overflowY,
        left: isAbsolute && -(props.overcomeLeft || 0) || "",
        right: isAbsolute && -(props.overcomeRight || 0) || "",
        bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
        marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
        maxHeight: props.maxHeight || ""
      } }, props.children);
    }
    needsXScrolling() {
      if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
        return false;
      }
      let { el } = this;
      let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
      let { children } = el;
      for (let i3 = 0; i3 < children.length; i3 += 1) {
        let childEl = children[i3];
        if (childEl.getBoundingClientRect().width > realClientWidth) {
          return true;
        }
      }
      return false;
    }
    needsYScrolling() {
      if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
        return false;
      }
      let { el } = this;
      let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
      let { children } = el;
      for (let i3 = 0; i3 < children.length; i3 += 1) {
        let childEl = children[i3];
        if (childEl.getBoundingClientRect().height > realClientHeight) {
          return true;
        }
      }
      return false;
    }
    getXScrollbarWidth() {
      if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
        return 0;
      }
      return this.el.offsetHeight - this.el.clientHeight;
    }
    getYScrollbarWidth() {
      if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
        return 0;
      }
      return this.el.offsetWidth - this.el.clientWidth;
    }
  };
  var RefMap = class {
    constructor(masterCallback) {
      this.masterCallback = masterCallback;
      this.currentMap = {};
      this.depths = {};
      this.callbackMap = {};
      this.handleValue = (val, key) => {
        let { depths, currentMap } = this;
        let removed = false;
        let added = false;
        if (val !== null) {
          removed = key in currentMap;
          currentMap[key] = val;
          depths[key] = (depths[key] || 0) + 1;
          added = true;
        } else {
          depths[key] -= 1;
          if (!depths[key]) {
            delete currentMap[key];
            delete this.callbackMap[key];
            removed = true;
          }
        }
        if (this.masterCallback) {
          if (removed) {
            this.masterCallback(null, String(key));
          }
          if (added) {
            this.masterCallback(val, String(key));
          }
        }
      };
    }
    createRef(key) {
      let refCallback = this.callbackMap[key];
      if (!refCallback) {
        refCallback = this.callbackMap[key] = (val) => {
          this.handleValue(val, String(key));
        };
      }
      return refCallback;
    }
    // TODO: check callers that don't care about order. should use getAll instead
    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
    collect(startIndex, endIndex, step) {
      return collectFromHash(this.currentMap, startIndex, endIndex, step);
    }
    getAll() {
      return hashValuesToArray(this.currentMap);
    }
  };
  function computeShrinkWidth(chunkEls) {
    let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
    let largestWidth = 0;
    for (let shrinkCell of shrinkCells) {
      largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
    }
    return Math.ceil(largestWidth);
  }
  function getSectionHasLiquidHeight(props, sectionConfig) {
    return props.liquid && sectionConfig.liquid;
  }
  function getAllowYScrolling(props, sectionConfig) {
    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
    getSectionHasLiquidHeight(props, sectionConfig);
  }
  function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
    let { expandRows } = arg;
    let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
      role: "presentation",
      className: [
        chunkConfig.tableClassName,
        sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
      ].join(" "),
      style: {
        minWidth: arg.tableMinWidth,
        width: arg.clientWidth,
        height: expandRows ? arg.clientHeight : ""
        // css `height` on a <table> serves as a min-height
      }
    }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
      role: "presentation"
    }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
    return content;
  }
  function isColPropsEqual(cols0, cols1) {
    return isArraysEqual(cols0, cols1, isPropsEqual);
  }
  function renderMicroColGroup(cols, shrinkWidth) {
    let colNodes = [];
    for (let colProps of cols) {
      let span = colProps.span || 1;
      for (let i3 = 0; i3 < span; i3 += 1) {
        colNodes.push(y("col", { style: {
          width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
          minWidth: colProps.minWidth || ""
        } }));
      }
    }
    return y("colgroup", {}, ...colNodes);
  }
  function sanitizeShrinkWidth(shrinkWidth) {
    return shrinkWidth == null ? 4 : shrinkWidth;
  }
  function hasShrinkWidth(cols) {
    for (let col of cols) {
      if (col.width === "shrink") {
        return true;
      }
    }
    return false;
  }
  function getScrollGridClassNames(liquid, context) {
    let classNames = [
      "fc-scrollgrid",
      context.theme.getClass("table")
    ];
    if (liquid) {
      classNames.push("fc-scrollgrid-liquid");
    }
    return classNames;
  }
  function getSectionClassNames(sectionConfig, wholeTableVGrow) {
    let classNames = [
      "fc-scrollgrid-section",
      `fc-scrollgrid-section-${sectionConfig.type}`,
      sectionConfig.className
      // used?
    ];
    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
      classNames.push("fc-scrollgrid-section-liquid");
    }
    if (sectionConfig.isSticky) {
      classNames.push("fc-scrollgrid-section-sticky");
    }
    return classNames;
  }
  function renderScrollShim(arg) {
    return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
      width: arg.clientWidth,
      minWidth: arg.tableMinWidth
    } });
  }
  function getStickyHeaderDates(options) {
    let { stickyHeaderDates } = options;
    if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
      stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
    }
    return stickyHeaderDates;
  }
  function getStickyFooterScrollbar(options) {
    let { stickyFooterScrollbar } = options;
    if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
      stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
    }
    return stickyFooterScrollbar;
  }
  var SimpleScrollGrid = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.processCols = memoize((a3) => a3, isColPropsEqual);
      this.renderMicroColGroup = memoize(renderMicroColGroup);
      this.scrollerRefs = new RefMap();
      this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
      this.state = {
        shrinkWidth: null,
        forceYScrollbars: false,
        scrollerClientWidths: {},
        scrollerClientHeights: {}
      };
      this.handleSizing = () => {
        this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
      };
    }
    render() {
      let { props, state, context } = this;
      let sectionConfigs = props.sections || [];
      let cols = this.processCols(props.cols);
      let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
      let classNames = getScrollGridClassNames(props.liquid, context);
      if (props.collapsibleWidth) {
        classNames.push("fc-scrollgrid-collapsible");
      }
      let configCnt = sectionConfigs.length;
      let configI = 0;
      let currentConfig;
      let headSectionNodes = [];
      let bodySectionNodes = [];
      let footSectionNodes = [];
      while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
        headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
        configI += 1;
      }
      while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
        bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
        configI += 1;
      }
      while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
        footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
        configI += 1;
      }
      let isBuggy = !getCanVGrowWithinCell();
      const roleAttrs = { role: "rowgroup" };
      return y("table", {
        role: "grid",
        className: classNames.join(" "),
        style: { height: props.height }
      }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
    }
    renderSection(sectionConfig, microColGroupNode, isHeader) {
      if ("outerContent" in sectionConfig) {
        return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
      }
      return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
    }
    renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
      if ("outerContent" in chunkConfig) {
        return chunkConfig.outerContent;
      }
      let { props } = this;
      let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
      let needsYScrolling = getAllowYScrolling(props, sectionConfig);
      let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
      let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
      let sectionKey = sectionConfig.key;
      let content = renderChunkContent(sectionConfig, chunkConfig, {
        tableColGroupNode: microColGroupNode,
        tableMinWidth: "",
        clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
        clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
        expandRows: sectionConfig.expandRows,
        syncRowHeights: false,
        rowSyncHeights: [],
        reportRowHeightChange: () => {
        }
      }, isHeader);
      return y(isHeader ? "th" : "td", {
        ref: chunkConfig.elRef,
        role: "presentation"
      }, y(
        "div",
        { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
        y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
      ));
    }
    _handleScrollerEl(scrollerEl, key) {
      let section = getSectionByKey(this.props.sections, key);
      if (section) {
        setRef(section.chunk.scrollerElRef, scrollerEl);
      }
    }
    componentDidMount() {
      this.handleSizing();
      this.context.addResizeHandler(this.handleSizing);
    }
    componentDidUpdate() {
      this.handleSizing();
    }
    componentWillUnmount() {
      this.context.removeResizeHandler(this.handleSizing);
    }
    computeShrinkWidth() {
      return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
    }
    computeScrollerDims() {
      let scrollbarWidth = getScrollbarWidths();
      let { scrollerRefs, scrollerElRefs } = this;
      let forceYScrollbars = false;
      let scrollerClientWidths = {};
      let scrollerClientHeights = {};
      for (let sectionKey in scrollerRefs.currentMap) {
        let scroller = scrollerRefs.currentMap[sectionKey];
        if (scroller && scroller.needsYScrolling()) {
          forceYScrollbars = true;
          break;
        }
      }
      for (let section of this.props.sections) {
        let sectionKey = section.key;
        let scrollerEl = scrollerElRefs.currentMap[sectionKey];
        if (scrollerEl) {
          let harnessEl = scrollerEl.parentNode;
          scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
          scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
        }
      }
      return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
    }
  };
  SimpleScrollGrid.addStateEquality({
    scrollerClientWidths: isPropsEqual,
    scrollerClientHeights: isPropsEqual
  });
  function getSectionByKey(sections, key) {
    for (let section of sections) {
      if (section.key === key) {
        return section;
      }
    }
    return null;
  }
  var EventContainer = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.buildPublicEvent = memoize((context, eventDef, eventInstance) => new EventImpl(context, eventDef, eventInstance));
      this.handleEl = (el) => {
        this.el = el;
        setRef(this.props.elRef, el);
        if (el) {
          setElSeg(el, this.props.seg);
        }
      };
    }
    render() {
      const { props, context } = this;
      const { options } = context;
      const { seg } = props;
      const { eventRange } = seg;
      const { ui } = eventRange;
      const renderProps = {
        event: this.buildPublicEvent(context, eventRange.def, eventRange.instance),
        view: context.viewApi,
        timeText: props.timeText,
        textColor: ui.textColor,
        backgroundColor: ui.backgroundColor,
        borderColor: ui.borderColor,
        isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
        isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
        isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
        isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
        isStart: Boolean(seg.isStart),
        isEnd: Boolean(seg.isEnd),
        isPast: Boolean(props.isPast),
        isFuture: Boolean(props.isFuture),
        isToday: Boolean(props.isToday),
        isSelected: Boolean(props.isSelected),
        isDragging: Boolean(props.isDragging),
        isResizing: Boolean(props.isResizing)
      };
      return y(ContentContainer, { elRef: this.handleEl, elTag: props.elTag, elAttrs: props.elAttrs, elClasses: [
        ...getEventClassNames(renderProps),
        ...seg.eventRange.ui.classNames,
        ...props.elClasses || []
      ], elStyle: props.elStyle, renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }, props.children);
    }
    componentDidUpdate(prevProps) {
      if (this.el && this.props.seg !== prevProps.seg) {
        setElSeg(this.el, this.props.seg);
      }
    }
  };
  var StandardEvent = class extends BaseComponent2 {
    render() {
      let { props, context } = this;
      let { options } = context;
      let { seg } = props;
      let { ui } = seg.eventRange;
      let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
      let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
      return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
        borderColor: ui.borderColor,
        backgroundColor: ui.backgroundColor
      }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
        _,
        null,
        y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
        Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
        Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
      ));
    }
  };
  StandardEvent.addPropsEquality({
    seg: isPropsEqual
  });
  function renderInnerContent$1(innerProps) {
    return y(
      "div",
      { className: "fc-event-main-frame" },
      innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
      y(
        "div",
        { className: "fc-event-title-container" },
        y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
      )
    );
  }
  var NowIndicatorContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
    let { options } = context;
    let renderProps = {
      isAxis: props.isAxis,
      date: context.dateEnv.toDate(props.date),
      view: context.viewApi
    };
    return y(ContentContainer, { elRef: props.elRef, elTag: props.elTag || "div", elAttrs: props.elAttrs, elClasses: props.elClasses, elStyle: props.elStyle, renderProps, generatorName: "nowIndicatorContent", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount }, props.children);
  });
  var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
  var DayCellContainer = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.refineRenderProps = memoizeObjArg(refineRenderProps);
    }
    render() {
      let { props, context } = this;
      let { options } = context;
      let renderProps = this.refineRenderProps({
        date: props.date,
        dateProfile: props.dateProfile,
        todayRange: props.todayRange,
        isMonthStart: props.isMonthStart || false,
        showDayNumber: props.showDayNumber,
        extraRenderProps: props.extraRenderProps,
        viewApi: context.viewApi,
        dateEnv: context.dateEnv,
        monthStartFormat: options.monthStartFormat
      });
      return y(ContentContainer, { elRef: props.elRef, elTag: props.elTag, elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), elClasses: [
        ...getDayClassNames(renderProps, context.theme),
        ...props.elClasses || []
      ], elStyle: props.elStyle, renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
        // don't use custom classNames if disabled
        renderProps.isDisabled ? void 0 : options.dayCellClassNames
      ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }, props.children);
    }
  };
  function hasCustomDayCellContent(options) {
    return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
  }
  function refineRenderProps(raw2) {
    let { date, dateEnv, dateProfile, isMonthStart } = raw2;
    let dayMeta = getDateMeta(date, raw2.todayRange, null, dateProfile);
    let dayNumberText = raw2.showDayNumber ? dateEnv.format(date, isMonthStart ? raw2.monthStartFormat : DAY_NUM_FORMAT) : "";
    return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw2.viewApi }, dayMeta), {
      isMonthStart,
      dayNumberText
    }), raw2.extraRenderProps);
  }
  var BgEvent = class extends BaseComponent2 {
    render() {
      let { props } = this;
      let { seg } = props;
      return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
    }
  };
  function renderInnerContent(props) {
    let { title } = props.event;
    return title && y("div", { className: "fc-event-title" }, props.event.title);
  }
  function renderFill(fillType) {
    return y("div", { className: `fc-${fillType}` });
  }
  var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
    let { dateEnv, options } = context;
    let { date } = props;
    let format = options.weekNumberFormat || props.defaultFormat;
    let num = dateEnv.computeWeekNumber(date);
    let text = dateEnv.format(date, format);
    let renderProps = { num, text, date };
    return y(
      ContentContainer,
      { elRef: props.elRef, elTag: props.elTag, elAttrs: props.elAttrs, elClasses: props.elClasses, elStyle: props.elStyle, renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount },
      props.children
    );
  });
  function renderInner(innerProps) {
    return innerProps.text;
  }
  var PADDING_FROM_VIEWPORT = 10;
  var Popover = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.state = {
        titleId: getUniqueDomId()
      };
      this.handleRootEl = (el) => {
        this.rootEl = el;
        if (this.props.elRef) {
          setRef(this.props.elRef, el);
        }
      };
      this.handleDocumentMouseDown = (ev) => {
        const target = getEventTargetViaRoot(ev);
        if (!this.rootEl.contains(target)) {
          this.handleCloseClick();
        }
      };
      this.handleDocumentKeyDown = (ev) => {
        if (ev.key === "Escape") {
          this.handleCloseClick();
        }
      };
      this.handleCloseClick = () => {
        let { onClose } = this.props;
        if (onClose) {
          onClose();
        }
      };
    }
    render() {
      let { theme, options } = this.context;
      let { props, state } = this;
      let classNames = [
        "fc-popover",
        theme.getClass("popover")
      ].concat(props.extraClassNames || []);
      return j4(y(
        "div",
        Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
        y(
          "div",
          { className: "fc-popover-header " + theme.getClass("popoverHeader") },
          y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
          y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
        ),
        y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
      ), props.parentEl);
    }
    componentDidMount() {
      document.addEventListener("mousedown", this.handleDocumentMouseDown);
      document.addEventListener("keydown", this.handleDocumentKeyDown);
      this.updateSize();
    }
    componentWillUnmount() {
      document.removeEventListener("mousedown", this.handleDocumentMouseDown);
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
    }
    updateSize() {
      let { isRtl } = this.context;
      let { alignmentEl, alignGridTop } = this.props;
      let { rootEl } = this;
      let alignmentRect = computeClippedClientRect(alignmentEl);
      if (alignmentRect) {
        let popoverDims = rootEl.getBoundingClientRect();
        let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
        let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
        popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
        popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
        popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
        let origin = rootEl.offsetParent.getBoundingClientRect();
        applyStyle(rootEl, {
          top: popoverTop - origin.top,
          left: popoverLeft - origin.left
        });
      }
    }
  };
  var MorePopover = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.handleRootEl = (rootEl) => {
        this.rootEl = rootEl;
        if (rootEl) {
          this.context.registerInteractiveComponent(this, {
            el: rootEl,
            useEventCenter: false
          });
        } else {
          this.context.unregisterInteractiveComponent(this);
        }
      };
    }
    render() {
      let { options, dateEnv } = this.context;
      let { props } = this;
      let { startDate, todayRange, dateProfile } = props;
      let title = dateEnv.format(startDate, options.dayPopoverFormat);
      return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
        Popover,
        { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
        hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
        props.children
      ));
    }
    queryHit(positionLeft, positionTop, elWidth, elHeight) {
      let { rootEl, props } = this;
      if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
        return {
          dateProfile: props.dateProfile,
          dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
            start: props.startDate,
            end: props.endDate
          } }, props.extraDateSpan),
          dayEl: rootEl,
          rect: {
            left: 0,
            top: 0,
            right: elWidth,
            bottom: elHeight
          },
          layer: 1
          // important when comparing with hits from other components
        };
      }
      return null;
    }
  };
  var MoreLinkContainer = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.state = {
        isPopoverOpen: false,
        popoverId: getUniqueDomId()
      };
      this.handleLinkEl = (linkEl) => {
        this.linkEl = linkEl;
        if (this.props.elRef) {
          setRef(this.props.elRef, linkEl);
        }
      };
      this.handleClick = (ev) => {
        let { props, context } = this;
        let { moreLinkClick } = context.options;
        let date = computeRange(props).start;
        function buildPublicSeg(seg) {
          let { def, instance, range } = seg.eventRange;
          return {
            event: new EventImpl(context, def, instance),
            start: context.dateEnv.toDate(range.start),
            end: context.dateEnv.toDate(range.end),
            isStart: seg.isStart,
            isEnd: seg.isEnd
          };
        }
        if (typeof moreLinkClick === "function") {
          moreLinkClick = moreLinkClick({
            date,
            allDay: Boolean(props.allDayDate),
            allSegs: props.allSegs.map(buildPublicSeg),
            hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
            jsEvent: ev,
            view: context.viewApi
          });
        }
        if (!moreLinkClick || moreLinkClick === "popover") {
          this.setState({ isPopoverOpen: true });
        } else if (typeof moreLinkClick === "string") {
          context.calendarApi.zoomTo(date, moreLinkClick);
        }
      };
      this.handlePopoverClose = () => {
        this.setState({ isPopoverOpen: false });
      };
    }
    render() {
      let { props, state } = this;
      return y(ViewContextType.Consumer, null, (context) => {
        let { viewApi, options, calendarApi } = context;
        let { moreLinkText } = options;
        let { moreCnt } = props;
        let range = computeRange(props);
        let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
        let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
        let renderProps = {
          num: moreCnt,
          shortText: `+${moreCnt}`,
          text,
          view: viewApi
        };
        return y(
          _,
          null,
          Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
            ...props.elClasses || [],
            "fc-more-link"
          ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
          state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
        );
      });
    }
    componentDidMount() {
      this.updateParentEl();
    }
    componentDidUpdate() {
      this.updateParentEl();
    }
    updateParentEl() {
      if (this.linkEl) {
        this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
      }
    }
  };
  function renderMoreLinkInner(props) {
    return props.text;
  }
  function computeRange(props) {
    if (props.allDayDate) {
      return {
        start: props.allDayDate,
        end: addDays(props.allDayDate, 1)
      };
    }
    let { hiddenSegs } = props;
    return {
      start: computeEarliestSegStart(hiddenSegs),
      end: computeLatestSegEnd(hiddenSegs)
    };
  }
  function computeEarliestSegStart(segs) {
    return segs.reduce(pickEarliestStart).eventRange.range.start;
  }
  function pickEarliestStart(seg0, seg1) {
    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
  }
  function computeLatestSegEnd(segs) {
    return segs.reduce(pickLatestEnd).eventRange.range.end;
  }
  function pickLatestEnd(seg0, seg1) {
    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
  }

  // node_modules/@fullcalendar/core/index.js
  var globalLocales = [];
  var MINIMAL_RAW_EN_LOCALE = {
    code: "en",
    week: {
      dow: 0,
      doy: 4
      // 4 days need to be within the year to be considered the first week
    },
    direction: "ltr",
    buttonText: {
      prev: "prev",
      next: "next",
      prevYear: "prev year",
      nextYear: "next year",
      year: "year",
      today: "today",
      month: "month",
      week: "week",
      day: "day",
      list: "list"
    },
    weekText: "W",
    weekTextLong: "Week",
    closeHint: "Close",
    timeHint: "Time",
    eventHint: "Event",
    allDayText: "all-day",
    moreLinkText: "more",
    noEventsText: "No events to display"
  };
  var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
    // Includes things we don't want other locales to inherit,
    // things that derive from other translatable strings.
    buttonHints: {
      prev: "Previous $0",
      next: "Next $0",
      today(buttonText, unit) {
        return unit === "day" ? "Today" : `This ${buttonText}`;
      }
    },
    viewHint: "$0 view",
    navLinkHint: "Go to $0",
    moreLinkHint(eventCnt) {
      return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
    }
  });
  function organizeRawLocales(explicitRawLocales) {
    let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
    let allRawLocales = globalLocales.concat(explicitRawLocales);
    let rawLocaleMap = {
      en: RAW_EN_LOCALE
    };
    for (let rawLocale of allRawLocales) {
      rawLocaleMap[rawLocale.code] = rawLocale;
    }
    return {
      map: rawLocaleMap,
      defaultCode
    };
  }
  function buildLocale(inputSingular, available) {
    if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
      return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
    }
    return queryLocale(inputSingular, available);
  }
  function queryLocale(codeArg, available) {
    let codes = [].concat(codeArg || []);
    let raw2 = queryRawLocale(codes, available) || RAW_EN_LOCALE;
    return parseLocale(codeArg, codes, raw2);
  }
  function queryRawLocale(codes, available) {
    for (let i3 = 0; i3 < codes.length; i3 += 1) {
      let parts = codes[i3].toLocaleLowerCase().split("-");
      for (let j5 = parts.length; j5 > 0; j5 -= 1) {
        let simpleId = parts.slice(0, j5).join("-");
        if (available[simpleId]) {
          return available[simpleId];
        }
      }
    }
    return null;
  }
  function parseLocale(codeArg, codes, raw2) {
    let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw2], ["buttonText"]);
    delete merged.code;
    let { week } = merged;
    delete merged.week;
    return {
      codeArg,
      codes,
      week,
      simpleNumberFormat: new Intl.NumberFormat(codeArg),
      options: merged
    };
  }
  function createPlugin(input) {
    return {
      id: guid(),
      name: input.name,
      premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : void 0,
      deps: input.deps || [],
      reducers: input.reducers || [],
      isLoadingFuncs: input.isLoadingFuncs || [],
      contextInit: [].concat(input.contextInit || []),
      eventRefiners: input.eventRefiners || {},
      eventDefMemberAdders: input.eventDefMemberAdders || [],
      eventSourceRefiners: input.eventSourceRefiners || {},
      isDraggableTransformers: input.isDraggableTransformers || [],
      eventDragMutationMassagers: input.eventDragMutationMassagers || [],
      eventDefMutationAppliers: input.eventDefMutationAppliers || [],
      dateSelectionTransformers: input.dateSelectionTransformers || [],
      datePointTransforms: input.datePointTransforms || [],
      dateSpanTransforms: input.dateSpanTransforms || [],
      views: input.views || {},
      viewPropsTransformers: input.viewPropsTransformers || [],
      isPropsValid: input.isPropsValid || null,
      externalDefTransforms: input.externalDefTransforms || [],
      viewContainerAppends: input.viewContainerAppends || [],
      eventDropTransformers: input.eventDropTransformers || [],
      componentInteractions: input.componentInteractions || [],
      calendarInteractions: input.calendarInteractions || [],
      themeClasses: input.themeClasses || {},
      eventSourceDefs: input.eventSourceDefs || [],
      cmdFormatter: input.cmdFormatter,
      recurringTypes: input.recurringTypes || [],
      namedTimeZonedImpl: input.namedTimeZonedImpl,
      initialView: input.initialView || "",
      elementDraggingImpl: input.elementDraggingImpl,
      optionChangeHandlers: input.optionChangeHandlers || {},
      scrollGridImpl: input.scrollGridImpl || null,
      listenerRefiners: input.listenerRefiners || {},
      optionRefiners: input.optionRefiners || {},
      propSetHandlers: input.propSetHandlers || {}
    };
  }
  function buildPluginHooks(pluginDefs, globalDefs) {
    let currentPluginIds = {};
    let hooks = {
      premiumReleaseDate: void 0,
      reducers: [],
      isLoadingFuncs: [],
      contextInit: [],
      eventRefiners: {},
      eventDefMemberAdders: [],
      eventSourceRefiners: {},
      isDraggableTransformers: [],
      eventDragMutationMassagers: [],
      eventDefMutationAppliers: [],
      dateSelectionTransformers: [],
      datePointTransforms: [],
      dateSpanTransforms: [],
      views: {},
      viewPropsTransformers: [],
      isPropsValid: null,
      externalDefTransforms: [],
      viewContainerAppends: [],
      eventDropTransformers: [],
      componentInteractions: [],
      calendarInteractions: [],
      themeClasses: {},
      eventSourceDefs: [],
      cmdFormatter: null,
      recurringTypes: [],
      namedTimeZonedImpl: null,
      initialView: "",
      elementDraggingImpl: null,
      optionChangeHandlers: {},
      scrollGridImpl: null,
      listenerRefiners: {},
      optionRefiners: {},
      propSetHandlers: {}
    };
    function addDefs(defs) {
      for (let def of defs) {
        const pluginName = def.name;
        const currentId = currentPluginIds[pluginName];
        if (currentId === void 0) {
          currentPluginIds[pluginName] = def.id;
          addDefs(def.deps);
          hooks = combineHooks(hooks, def);
        } else if (currentId !== def.id) {
          console.warn(`Duplicate plugin '${pluginName}'`);
        }
      }
    }
    if (pluginDefs) {
      addDefs(pluginDefs);
    }
    addDefs(globalDefs);
    return hooks;
  }
  function buildBuildPluginHooks() {
    let currentOverrideDefs = [];
    let currentGlobalDefs = [];
    let currentHooks;
    return (overrideDefs, globalDefs) => {
      if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
        currentHooks = buildPluginHooks(overrideDefs, globalDefs);
      }
      currentOverrideDefs = overrideDefs;
      currentGlobalDefs = globalDefs;
      return currentHooks;
    };
  }
  function combineHooks(hooks0, hooks1) {
    return {
      premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
      reducers: hooks0.reducers.concat(hooks1.reducers),
      isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
      contextInit: hooks0.contextInit.concat(hooks1.contextInit),
      eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
      eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
      eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
      isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
      eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
      eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
      dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
      datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
      dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
      views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
      viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
      isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
      externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
      viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
      eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
      calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
      componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
      themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
      eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
      cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
      recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
      namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
      initialView: hooks0.initialView || hooks1.initialView,
      elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
      optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
      scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
      listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
      optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
      propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
    };
  }
  function compareOptionalDates(date0, date1) {
    if (date0 === void 0) {
      return date1;
    }
    if (date1 === void 0) {
      return date0;
    }
    return new Date(Math.max(date0.valueOf(), date1.valueOf()));
  }
  var StandardTheme = class extends Theme {
  };
  StandardTheme.prototype.classes = {
    root: "fc-theme-standard",
    tableCellShaded: "fc-cell-shaded",
    buttonGroup: "fc-button-group",
    button: "fc-button fc-button-primary",
    buttonActive: "fc-button-active"
  };
  StandardTheme.prototype.baseIconClass = "fc-icon";
  StandardTheme.prototype.iconClasses = {
    close: "fc-icon-x",
    prev: "fc-icon-chevron-left",
    next: "fc-icon-chevron-right",
    prevYear: "fc-icon-chevrons-left",
    nextYear: "fc-icon-chevrons-right"
  };
  StandardTheme.prototype.rtlIconClasses = {
    prev: "fc-icon-chevron-right",
    next: "fc-icon-chevron-left",
    prevYear: "fc-icon-chevrons-right",
    nextYear: "fc-icon-chevrons-left"
  };
  StandardTheme.prototype.iconOverrideOption = "buttonIcons";
  StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
  StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
  function compileViewDefs(defaultConfigs, overrideConfigs) {
    let hash = {};
    let viewType;
    for (viewType in defaultConfigs) {
      ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    }
    for (viewType in overrideConfigs) {
      ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    }
    return hash;
  }
  function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
    if (hash[viewType]) {
      return hash[viewType];
    }
    let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    if (viewDef) {
      hash[viewType] = viewDef;
    }
    return viewDef;
  }
  function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
    let defaultConfig = defaultConfigs[viewType];
    let overrideConfig = overrideConfigs[viewType];
    let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
    let theComponent = queryProp("component");
    let superType = queryProp("superType");
    let superDef = null;
    if (superType) {
      if (superType === viewType) {
        throw new Error("Can't have a custom view type that references itself");
      }
      superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
    }
    if (!theComponent && superDef) {
      theComponent = superDef.component;
    }
    if (!theComponent) {
      return null;
    }
    return {
      type: viewType,
      component: theComponent,
      defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
      overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
    };
  }
  function parseViewConfigs(inputs) {
    return mapHash(inputs, parseViewConfig);
  }
  function parseViewConfig(input) {
    let rawOptions = typeof input === "function" ? { component: input } : input;
    let { component } = rawOptions;
    if (rawOptions.content) {
      component = createViewHookComponent(rawOptions);
    } else if (component && !(component.prototype instanceof BaseComponent2)) {
      component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
    }
    return {
      superType: rawOptions.type,
      component,
      rawOptions
      // includes type and component too :(
    };
  }
  function createViewHookComponent(options) {
    return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
  }
  function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
    let defaultConfigs = parseViewConfigs(defaultInputs);
    let overrideConfigs = parseViewConfigs(optionOverrides.views);
    let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
    return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
  }
  function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
    let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
    let duration2 = null;
    let durationUnit = "";
    let singleUnit = "";
    let singleUnitOverrides = {};
    if (durationInput) {
      duration2 = createDurationCached(durationInput);
      if (duration2) {
        let denom = greatestDurationDenominator(duration2);
        durationUnit = denom.unit;
        if (denom.value === 1) {
          singleUnit = durationUnit;
          singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
        }
      }
    }
    let queryButtonText = (optionsSubset) => {
      let buttonTextMap = optionsSubset.buttonText || {};
      let buttonTextKey = viewDef.defaults.buttonTextKey;
      if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
        return buttonTextMap[buttonTextKey];
      }
      if (buttonTextMap[viewDef.type] != null) {
        return buttonTextMap[viewDef.type];
      }
      if (buttonTextMap[singleUnit] != null) {
        return buttonTextMap[singleUnit];
      }
      return null;
    };
    let queryButtonTitle = (optionsSubset) => {
      let buttonHints = optionsSubset.buttonHints || {};
      let buttonKey = viewDef.defaults.buttonTextKey;
      if (buttonKey != null && buttonHints[buttonKey] != null) {
        return buttonHints[buttonKey];
      }
      if (buttonHints[viewDef.type] != null) {
        return buttonHints[viewDef.type];
      }
      if (buttonHints[singleUnit] != null) {
        return buttonHints[singleUnit];
      }
      return null;
    };
    return {
      type: viewDef.type,
      component: viewDef.component,
      duration: duration2,
      durationUnit,
      singleUnit,
      optionDefaults: viewDef.defaults,
      optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
      buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
      viewDef.overrides.buttonText,
      buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
      // not DRY
      buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
      buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
      // will eventually fall back to buttonText
    };
  }
  var durationInputMap = {};
  function createDurationCached(durationInput) {
    let json = JSON.stringify(durationInput);
    let res = durationInputMap[json];
    if (res === void 0) {
      res = createDuration(durationInput);
      durationInputMap[json] = res;
    }
    return res;
  }
  function reduceViewType(viewType, action) {
    switch (action.type) {
      case "CHANGE_VIEW_TYPE":
        viewType = action.viewType;
    }
    return viewType;
  }
  function reduceCurrentDate(currentDate, action) {
    switch (action.type) {
      case "CHANGE_DATE":
        return action.dateMarker;
      default:
        return currentDate;
    }
  }
  function getInitialDate(options, dateEnv, nowManager) {
    let initialDateInput = options.initialDate;
    if (initialDateInput != null) {
      return dateEnv.createMarker(initialDateInput);
    }
    return nowManager.getDateMarker();
  }
  function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
    switch (action.type) {
      case "SET_OPTION":
        return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
      default:
        return dynamicOptionOverrides;
    }
  }
  function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
    let dp;
    switch (action.type) {
      case "CHANGE_VIEW_TYPE":
        return dateProfileGenerator.build(action.dateMarker || currentDate);
      case "CHANGE_DATE":
        return dateProfileGenerator.build(action.dateMarker);
      case "PREV":
        dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
        if (dp.isValid) {
          return dp;
        }
        break;
      case "NEXT":
        dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
        if (dp.isValid) {
          return dp;
        }
        break;
    }
    return currentDateProfile;
  }
  function initEventSources(calendarOptions, dateProfile, context) {
    let activeRange = dateProfile ? dateProfile.activeRange : null;
    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
  }
  function reduceEventSources(eventSources, action, dateProfile, context) {
    let activeRange = dateProfile ? dateProfile.activeRange : null;
    switch (action.type) {
      case "ADD_EVENT_SOURCES":
        return addSources(eventSources, action.sources, activeRange, context);
      case "REMOVE_EVENT_SOURCE":
        return removeSource(eventSources, action.sourceId);
      case "PREV":
      // TODO: how do we track all actions that affect dateProfile :(
      case "NEXT":
      case "CHANGE_DATE":
      case "CHANGE_VIEW_TYPE":
        if (dateProfile) {
          return fetchDirtySources(eventSources, activeRange, context);
        }
        return eventSources;
      case "FETCH_EVENT_SOURCES":
        return fetchSourcesByIds(eventSources, action.sourceIds ? (
          // why no type?
          arrayToHash(action.sourceIds)
        ) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
      case "RECEIVE_EVENTS":
      case "RECEIVE_EVENT_ERROR":
        return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
      case "REMOVE_ALL_EVENT_SOURCES":
        return {};
      default:
        return eventSources;
    }
  }
  function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
    let activeRange = dateProfile ? dateProfile.activeRange : null;
    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
  }
  function computeEventSourcesLoading(eventSources) {
    for (let sourceId in eventSources) {
      if (eventSources[sourceId].isFetching) {
        return true;
      }
    }
    return false;
  }
  function addSources(eventSourceHash, sources, fetchRange, context) {
    let hash = {};
    for (let source of sources) {
      hash[source.sourceId] = source;
    }
    if (fetchRange) {
      hash = fetchDirtySources(hash, fetchRange, context);
    }
    return Object.assign(Object.assign({}, eventSourceHash), hash);
  }
  function removeSource(eventSourceHash, sourceId) {
    return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
  }
  function fetchDirtySources(sourceHash, fetchRange, context) {
    return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
  }
  function isSourceDirty(eventSource, fetchRange, context) {
    if (!doesSourceNeedRange(eventSource, context)) {
      return !eventSource.latestFetchId;
    }
    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
  }
  function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
    let nextSources = {};
    for (let sourceId in prevSources) {
      let source = prevSources[sourceId];
      if (sourceIdHash[sourceId]) {
        nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
      } else {
        nextSources[sourceId] = source;
      }
    }
    return nextSources;
  }
  function fetchSource(eventSource, fetchRange, isRefetch, context) {
    let { options, calendarApi } = context;
    let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
    let fetchId = guid();
    sourceDef.fetch({
      eventSource,
      range: fetchRange,
      isRefetch,
      context
    }, (res) => {
      let { rawEvents } = res;
      if (options.eventSourceSuccess) {
        rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
      }
      if (eventSource.success) {
        rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
      }
      context.dispatch({
        type: "RECEIVE_EVENTS",
        sourceId: eventSource.sourceId,
        fetchId,
        fetchRange,
        rawEvents
      });
    }, (error2) => {
      let errorHandled = false;
      if (options.eventSourceFailure) {
        options.eventSourceFailure.call(calendarApi, error2);
        errorHandled = true;
      }
      if (eventSource.failure) {
        eventSource.failure(error2);
        errorHandled = true;
      }
      if (!errorHandled) {
        console.warn(error2.message, error2);
      }
      context.dispatch({
        type: "RECEIVE_EVENT_ERROR",
        sourceId: eventSource.sourceId,
        fetchId,
        fetchRange,
        error: error2
      });
    });
    return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
  }
  function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
    let eventSource = sourceHash[sourceId];
    if (eventSource && // not already removed
    fetchId === eventSource.latestFetchId) {
      return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
    }
    return sourceHash;
  }
  function excludeStaticSources(eventSources, context) {
    return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
  }
  function parseInitialSources(rawOptions, context) {
    let refiners = buildEventSourceRefiners(context);
    let rawSources = [].concat(rawOptions.eventSources || []);
    let sources = [];
    if (rawOptions.initialEvents) {
      rawSources.unshift(rawOptions.initialEvents);
    }
    if (rawOptions.events) {
      rawSources.unshift(rawOptions.events);
    }
    for (let rawSource of rawSources) {
      let source = parseEventSource(rawSource, context, refiners);
      if (source) {
        sources.push(source);
      }
    }
    return sources;
  }
  function doesSourceNeedRange(eventSource, context) {
    let defs = context.pluginHooks.eventSourceDefs;
    return !defs[eventSource.sourceDefId].ignoreRange;
  }
  function reduceDateSelection(currentSelection, action) {
    switch (action.type) {
      case "UNSELECT_DATES":
        return null;
      case "SELECT_DATES":
        return action.selection;
      default:
        return currentSelection;
    }
  }
  function reduceSelectedEvent(currentInstanceId, action) {
    switch (action.type) {
      case "UNSELECT_EVENT":
        return "";
      case "SELECT_EVENT":
        return action.eventInstanceId;
      default:
        return currentInstanceId;
    }
  }
  function reduceEventDrag(currentDrag, action) {
    let newDrag;
    switch (action.type) {
      case "UNSET_EVENT_DRAG":
        return null;
      case "SET_EVENT_DRAG":
        newDrag = action.state;
        return {
          affectedEvents: newDrag.affectedEvents,
          mutatedEvents: newDrag.mutatedEvents,
          isEvent: newDrag.isEvent
        };
      default:
        return currentDrag;
    }
  }
  function reduceEventResize(currentResize, action) {
    let newResize;
    switch (action.type) {
      case "UNSET_EVENT_RESIZE":
        return null;
      case "SET_EVENT_RESIZE":
        newResize = action.state;
        return {
          affectedEvents: newResize.affectedEvents,
          mutatedEvents: newResize.mutatedEvents,
          isEvent: newResize.isEvent
        };
      default:
        return currentResize;
    }
  }
  function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
    let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
    let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
    return { header, footer };
  }
  function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
    let sectionWidgets = {};
    let viewsWithButtons = [];
    let hasTitle = false;
    for (let sectionName in sectionStrHash) {
      let sectionStr = sectionStrHash[sectionName];
      let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
      sectionWidgets[sectionName] = sectionRes.widgets;
      viewsWithButtons.push(...sectionRes.viewsWithButtons);
      hasTitle = hasTitle || sectionRes.hasTitle;
    }
    return { sectionWidgets, viewsWithButtons, hasTitle };
  }
  function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
    let isRtl = calendarOptions.direction === "rtl";
    let calendarCustomButtons = calendarOptions.customButtons || {};
    let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
    let calendarButtonText = calendarOptions.buttonText || {};
    let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
    let calendarButtonHints = calendarOptions.buttonHints || {};
    let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
    let viewsWithButtons = [];
    let hasTitle = false;
    let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
      if (buttonName === "title") {
        hasTitle = true;
        return { buttonName };
      }
      let customButtonProps;
      let viewSpec;
      let buttonClick;
      let buttonIcon;
      let buttonText;
      let buttonHint;
      if (customButtonProps = calendarCustomButtons[buttonName]) {
        buttonClick = (ev) => {
          if (customButtonProps.click) {
            customButtonProps.click.call(ev.target, ev, ev.target);
          }
        };
        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
        buttonHint = customButtonProps.hint || customButtonProps.text;
      } else if (viewSpec = viewSpecs[buttonName]) {
        viewsWithButtons.push(buttonName);
        buttonClick = () => {
          calendarApi.changeView(buttonName);
        };
        (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
        let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
        buttonHint = formatWithOrdinals(
          viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
          [textFallback, buttonName],
          // view-name = buttonName
          textFallback
        );
      } else if (calendarApi[buttonName]) {
        buttonClick = () => {
          calendarApi[buttonName]();
        };
        (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
        if (buttonName === "prevYear" || buttonName === "nextYear") {
          let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
          buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
            calendarButtonText.year || "year",
            "year"
          ], calendarButtonText[buttonName]);
        } else {
          buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
            calendarButtonText[navUnit] || navUnit,
            navUnit
          ], calendarButtonText[buttonName]);
        }
      }
      return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
    }));
    return { widgets, viewsWithButtons, hasTitle };
  }
  var ViewImpl = class {
    constructor(type, getCurrentData, dateEnv) {
      this.type = type;
      this.getCurrentData = getCurrentData;
      this.dateEnv = dateEnv;
    }
    get calendar() {
      return this.getCurrentData().calendarApi;
    }
    get title() {
      return this.getCurrentData().viewTitle;
    }
    get activeStart() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
    }
    get activeEnd() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
    }
    get currentStart() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
    }
    get currentEnd() {
      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
    }
    getOption(name) {
      return this.getCurrentData().options[name];
    }
  };
  var eventSourceDef$2 = {
    ignoreRange: true,
    parseMeta(refined) {
      if (Array.isArray(refined.events)) {
        return refined.events;
      }
      return null;
    },
    fetch(arg, successCallback) {
      successCallback({
        rawEvents: arg.eventSource.meta
      });
    }
  };
  var arrayEventSourcePlugin = createPlugin({
    name: "array-event-source",
    eventSourceDefs: [eventSourceDef$2]
  });
  var eventSourceDef$1 = {
    parseMeta(refined) {
      if (typeof refined.events === "function") {
        return refined.events;
      }
      return null;
    },
    fetch(arg, successCallback, errorCallback) {
      const { dateEnv } = arg.context;
      const func = arg.eventSource.meta;
      unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
    }
  };
  var funcEventSourcePlugin = createPlugin({
    name: "func-event-source",
    eventSourceDefs: [eventSourceDef$1]
  });
  var JSON_FEED_EVENT_SOURCE_REFINERS = {
    method: String,
    extraParams: identity,
    startParam: String,
    endParam: String,
    timeZoneParam: String
  };
  var eventSourceDef = {
    parseMeta(refined) {
      if (refined.url && (refined.format === "json" || !refined.format)) {
        return {
          url: refined.url,
          format: "json",
          method: (refined.method || "GET").toUpperCase(),
          extraParams: refined.extraParams,
          startParam: refined.startParam,
          endParam: refined.endParam,
          timeZoneParam: refined.timeZoneParam
        };
      }
      return null;
    },
    fetch(arg, successCallback, errorCallback) {
      const { meta } = arg.eventSource;
      const requestParams = buildRequestParams(meta, arg.range, arg.context);
      requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
        successCallback({ rawEvents, response });
      }, errorCallback);
    }
  };
  var jsonFeedEventSourcePlugin = createPlugin({
    name: "json-event-source",
    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
    eventSourceDefs: [eventSourceDef]
  });
  function buildRequestParams(meta, range, context) {
    let { dateEnv, options } = context;
    let startParam;
    let endParam;
    let timeZoneParam;
    let customRequestParams;
    let params = {};
    startParam = meta.startParam;
    if (startParam == null) {
      startParam = options.startParam;
    }
    endParam = meta.endParam;
    if (endParam == null) {
      endParam = options.endParam;
    }
    timeZoneParam = meta.timeZoneParam;
    if (timeZoneParam == null) {
      timeZoneParam = options.timeZoneParam;
    }
    if (typeof meta.extraParams === "function") {
      customRequestParams = meta.extraParams();
    } else {
      customRequestParams = meta.extraParams || {};
    }
    Object.assign(params, customRequestParams);
    params[startParam] = dateEnv.formatIso(range.start);
    params[endParam] = dateEnv.formatIso(range.end);
    if (dateEnv.timeZone !== "local") {
      params[timeZoneParam] = dateEnv.timeZone;
    }
    return params;
  }
  var SIMPLE_RECURRING_REFINERS = {
    daysOfWeek: identity,
    startTime: createDuration,
    endTime: createDuration,
    duration: createDuration,
    startRecur: identity,
    endRecur: identity
  };
  var recurring = {
    parse(refined, dateEnv) {
      if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
        let recurringData = {
          daysOfWeek: refined.daysOfWeek || null,
          startTime: refined.startTime || null,
          endTime: refined.endTime || null,
          startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
          endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,
          dateEnv
        };
        let duration2;
        if (refined.duration) {
          duration2 = refined.duration;
        }
        if (!duration2 && refined.startTime && refined.endTime) {
          duration2 = subtractDurations(refined.endTime, refined.startTime);
        }
        return {
          allDayGuess: Boolean(!refined.startTime && !refined.endTime),
          duration: duration2,
          typeData: recurringData
          // doesn't need endTime anymore but oh well
        };
      }
      return null;
    },
    expand(typeData, framingRange, dateEnv) {
      let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
      if (clippedFramingRange) {
        return expandRanges(typeData.daysOfWeek, typeData.startTime, typeData.dateEnv, dateEnv, clippedFramingRange);
      }
      return [];
    }
  };
  var simpleRecurringEventsPlugin = createPlugin({
    name: "simple-recurring-event",
    recurringTypes: [recurring],
    eventRefiners: SIMPLE_RECURRING_REFINERS
  });
  function expandRanges(daysOfWeek, startTime, eventDateEnv, calendarDateEnv, framingRange) {
    let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
    let dayMarker = startOfDay(framingRange.start);
    let endMarker = framingRange.end;
    let instanceStarts = [];
    if (startTime) {
      if (startTime.milliseconds < 0) {
        endMarker = addDays(endMarker, 1);
      } else if (startTime.milliseconds >= 1e3 * 60 * 60 * 24) {
        dayMarker = addDays(dayMarker, -1);
      }
    }
    while (dayMarker < endMarker) {
      let instanceStart;
      if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
        if (startTime) {
          instanceStart = calendarDateEnv.add(dayMarker, startTime);
        } else {
          instanceStart = dayMarker;
        }
        instanceStarts.push(calendarDateEnv.createMarker(eventDateEnv.toDate(instanceStart)));
      }
      dayMarker = addDays(dayMarker, 1);
    }
    return instanceStarts;
  }
  var changeHandlerPlugin = createPlugin({
    name: "change-handler",
    optionChangeHandlers: {
      events(events, context) {
        handleEventSources([events], context);
      },
      eventSources: handleEventSources
    }
  });
  function handleEventSources(inputs, context) {
    let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
    if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
      context.dispatch({
        type: "RESET_RAW_EVENTS",
        sourceId: unfoundSources[0].sourceId,
        rawEvents: inputs[0]
      });
      return;
    }
    let newInputs = [];
    for (let input of inputs) {
      let inputFound = false;
      for (let i3 = 0; i3 < unfoundSources.length; i3 += 1) {
        if (unfoundSources[i3]._raw === input) {
          unfoundSources.splice(i3, 1);
          inputFound = true;
          break;
        }
      }
      if (!inputFound) {
        newInputs.push(input);
      }
    }
    for (let unfoundSource of unfoundSources) {
      context.dispatch({
        type: "REMOVE_EVENT_SOURCE",
        sourceId: unfoundSource.sourceId
      });
    }
    for (let newInput of newInputs) {
      context.calendarApi.addEventSource(newInput);
    }
  }
  function handleDateProfile(dateProfile, context) {
    context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
  }
  function handleEventStore(eventStore, context) {
    let { emitter } = context;
    if (emitter.hasHandlers("eventsSet")) {
      emitter.trigger("eventsSet", buildEventApis(eventStore, context));
    }
  }
  var globalPlugins = [
    arrayEventSourcePlugin,
    funcEventSourcePlugin,
    jsonFeedEventSourcePlugin,
    simpleRecurringEventsPlugin,
    changeHandlerPlugin,
    createPlugin({
      name: "misc",
      isLoadingFuncs: [
        (state) => computeEventSourcesLoading(state.eventSources)
      ],
      propSetHandlers: {
        dateProfile: handleDateProfile,
        eventStore: handleEventStore
      }
    })
  ];
  var TaskRunner = class {
    constructor(runTaskOption, drainedOption) {
      this.runTaskOption = runTaskOption;
      this.drainedOption = drainedOption;
      this.queue = [];
      this.delayedRunner = new DelayedRunner(this.drain.bind(this));
    }
    request(task, delay) {
      this.queue.push(task);
      this.delayedRunner.request(delay);
    }
    pause(scope2) {
      this.delayedRunner.pause(scope2);
    }
    resume(scope2, force) {
      this.delayedRunner.resume(scope2, force);
    }
    drain() {
      let { queue: queue2 } = this;
      while (queue2.length) {
        let completedTasks = [];
        let task;
        while (task = queue2.shift()) {
          this.runTask(task);
          completedTasks.push(task);
        }
        this.drained(completedTasks);
      }
    }
    runTask(task) {
      if (this.runTaskOption) {
        this.runTaskOption(task);
      }
    }
    drained(completedTasks) {
      if (this.drainedOption) {
        this.drainedOption(completedTasks);
      }
    }
  };
  function buildTitle(dateProfile, viewOptions, dateEnv) {
    let range;
    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
      range = dateProfile.currentRange;
    } else {
      range = dateProfile.activeRange;
    }
    return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
      isEndExclusive: dateProfile.isRangeAllDay,
      defaultSeparator: viewOptions.titleRangeSeparator
    });
  }
  function buildTitleFormat(dateProfile) {
    let { currentRangeUnit } = dateProfile;
    if (currentRangeUnit === "year") {
      return { year: "numeric" };
    }
    if (currentRangeUnit === "month") {
      return { year: "numeric", month: "long" };
    }
    let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
    if (days !== null && days > 1) {
      return { year: "numeric", month: "short", day: "numeric" };
    }
    return { year: "numeric", month: "long", day: "numeric" };
  }
  var CalendarNowManager = class {
    constructor() {
      this.resetListeners = /* @__PURE__ */ new Set();
    }
    handleInput(dateEnv, nowInput) {
      const oldDateEnv = this.dateEnv;
      if (dateEnv !== oldDateEnv) {
        if (typeof nowInput === "function") {
          this.nowFn = nowInput;
        } else if (!oldDateEnv) {
          this.nowAnchorDate = dateEnv.toDate(nowInput ? dateEnv.createMarker(nowInput) : dateEnv.createNowMarker());
          this.nowAnchorQueried = Date.now();
        }
        this.dateEnv = dateEnv;
        if (oldDateEnv) {
          for (const resetListener of this.resetListeners.values()) {
            resetListener();
          }
        }
      }
    }
    getDateMarker() {
      return this.nowAnchorDate ? this.dateEnv.timestampToMarker(this.nowAnchorDate.valueOf() + (Date.now() - this.nowAnchorQueried)) : this.dateEnv.createMarker(this.nowFn());
    }
    addResetListener(handler4) {
      this.resetListeners.add(handler4);
    }
    removeResetListener(handler4) {
      this.resetListeners.delete(handler4);
    }
  };
  var CalendarDataManager = class {
    constructor(props) {
      this.computeCurrentViewData = memoize(this._computeCurrentViewData);
      this.organizeRawLocales = memoize(organizeRawLocales);
      this.buildLocale = memoize(buildLocale);
      this.buildPluginHooks = buildBuildPluginHooks();
      this.buildDateEnv = memoize(buildDateEnv$1);
      this.buildTheme = memoize(buildTheme);
      this.parseToolbars = memoize(parseToolbars);
      this.buildViewSpecs = memoize(buildViewSpecs);
      this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
      this.buildViewApi = memoize(buildViewApi);
      this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
      this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
      this.buildEventUiBases = memoize(buildEventUiBases);
      this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
      this.buildTitle = memoize(buildTitle);
      this.nowManager = new CalendarNowManager();
      this.emitter = new Emitter();
      this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
      this.currentCalendarOptionsInput = {};
      this.currentCalendarOptionsRefined = {};
      this.currentViewOptionsInput = {};
      this.currentViewOptionsRefined = {};
      this.currentCalendarOptionsRefiners = {};
      this.optionsForRefining = [];
      this.optionsForHandling = [];
      this.getCurrentData = () => this.data;
      this.dispatch = (action) => {
        this.actionRunner.request(action);
      };
      this.props = props;
      this.actionRunner.pause();
      this.nowManager = new CalendarNowManager();
      let dynamicOptionOverrides = {};
      let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
      let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
      let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
      props.calendarApi.currentDataManager = this;
      this.emitter.setThisContext(props.calendarApi);
      this.emitter.setOptions(currentViewData.options);
      let calendarContext = {
        nowManager: this.nowManager,
        dateEnv: optionsData.dateEnv,
        options: optionsData.calendarOptions,
        pluginHooks: optionsData.pluginHooks,
        calendarApi: props.calendarApi,
        dispatch: this.dispatch,
        emitter: this.emitter,
        getCurrentData: this.getCurrentData
      };
      let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv, this.nowManager);
      let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
      if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
        currentDate = dateProfile.currentRange.start;
      }
      for (let callback of optionsData.pluginHooks.contextInit) {
        callback(calendarContext);
      }
      let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
      let initialState = {
        dynamicOptionOverrides,
        currentViewType,
        currentDate,
        dateProfile,
        businessHours: this.parseContextBusinessHours(calendarContext),
        eventSources,
        eventUiBases: {},
        eventStore: createEmptyEventStore(),
        renderableEventStore: createEmptyEventStore(),
        dateSelection: null,
        eventSelection: "",
        eventDrag: null,
        eventResize: null,
        selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
      };
      let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
      for (let reducer of optionsData.pluginHooks.reducers) {
        Object.assign(initialState, reducer(null, null, contextAndState));
      }
      if (computeIsLoading(initialState, calendarContext)) {
        this.emitter.trigger("loading", true);
      }
      this.state = initialState;
      this.updateData();
      this.actionRunner.resume();
    }
    resetOptions(optionOverrides, changedOptionNames) {
      let { props } = this;
      if (changedOptionNames === void 0) {
        props.optionOverrides = optionOverrides;
      } else {
        props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
        this.optionsForRefining.push(...changedOptionNames);
      }
      if (changedOptionNames === void 0 || changedOptionNames.length) {
        this.actionRunner.request({
          type: "NOTHING"
        });
      }
    }
    _handleAction(action) {
      let { props, state, emitter } = this;
      let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
      let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
      let currentViewType = reduceViewType(state.currentViewType, action);
      let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
      props.calendarApi.currentDataManager = this;
      emitter.setThisContext(props.calendarApi);
      emitter.setOptions(currentViewData.options);
      let calendarContext = {
        nowManager: this.nowManager,
        dateEnv: optionsData.dateEnv,
        options: optionsData.calendarOptions,
        pluginHooks: optionsData.pluginHooks,
        calendarApi: props.calendarApi,
        dispatch: this.dispatch,
        emitter,
        getCurrentData: this.getCurrentData
      };
      let { currentDate, dateProfile } = state;
      if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
        dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
      }
      currentDate = reduceCurrentDate(currentDate, action);
      dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
      if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
      action.type === "NEXT" || // "
      !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
        currentDate = dateProfile.currentRange.start;
      }
      let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
      let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
      let isEventsLoading = computeEventSourcesLoading(eventSources);
      let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
        // try from previous state
        eventStore
      );
      let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
      let eventUiBySource = this.buildEventUiBySource(eventSources);
      let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
      let newState = {
        dynamicOptionOverrides,
        currentViewType,
        currentDate,
        dateProfile,
        eventSources,
        eventStore,
        renderableEventStore,
        selectionConfig,
        eventUiBases,
        businessHours: this.parseContextBusinessHours(calendarContext),
        dateSelection: reduceDateSelection(state.dateSelection, action),
        eventSelection: reduceSelectedEvent(state.eventSelection, action),
        eventDrag: reduceEventDrag(state.eventDrag, action),
        eventResize: reduceEventResize(state.eventResize, action)
      };
      let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
      for (let reducer of optionsData.pluginHooks.reducers) {
        Object.assign(newState, reducer(state, action, contextAndState));
      }
      let wasLoading = computeIsLoading(state, calendarContext);
      let isLoading = computeIsLoading(newState, calendarContext);
      if (!wasLoading && isLoading) {
        emitter.trigger("loading", true);
      } else if (wasLoading && !isLoading) {
        emitter.trigger("loading", false);
      }
      this.state = newState;
      if (props.onAction) {
        props.onAction(action);
      }
    }
    updateData() {
      let { props, state } = this;
      let oldData = this.data;
      let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
      let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
      let data2 = this.data = Object.assign(Object.assign(Object.assign({ nowManager: this.nowManager, viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
      let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
      let oldCalendarOptions = oldData && oldData.calendarOptions;
      let newCalendarOptions = optionsData.calendarOptions;
      if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
        if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
          state.eventSources = data2.eventSources = reduceEventSourcesNewTimeZone(data2.eventSources, state.dateProfile, data2);
          state.eventStore = data2.eventStore = rezoneEventStoreDates(data2.eventStore, oldData.dateEnv, data2.dateEnv);
          state.renderableEventStore = data2.renderableEventStore = rezoneEventStoreDates(data2.renderableEventStore, oldData.dateEnv, data2.dateEnv);
        }
        for (let optionName in changeHandlers) {
          if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
            changeHandlers[optionName](newCalendarOptions[optionName], data2);
          }
        }
      }
      this.optionsForHandling = [];
      if (props.onData) {
        props.onData(data2);
      }
    }
    computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
      if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
        return this.stableCalendarOptionsData;
      }
      let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
      warnUnknownOptions(extra);
      let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
      let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
      let theme = this.buildTheme(refinedOptions, pluginHooks);
      let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
      return this.stableCalendarOptionsData = {
        calendarOptions: refinedOptions,
        pluginHooks,
        dateEnv,
        viewSpecs,
        theme,
        toolbarConfig,
        localeDefaults,
        availableRawLocales: availableLocaleData.map
      };
    }
    // always called from behind a memoizer
    processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
      let { locales, locale } = mergeRawOptions([
        BASE_OPTION_DEFAULTS,
        optionOverrides,
        dynamicOptionOverrides
      ]);
      let availableLocaleData = this.organizeRawLocales(locales);
      let availableRawLocales = availableLocaleData.map;
      let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
      let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
      let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
      let extra = {};
      let raw2 = mergeRawOptions([
        BASE_OPTION_DEFAULTS,
        localeDefaults,
        optionOverrides,
        dynamicOptionOverrides
      ]);
      let refined = {};
      let currentRaw = this.currentCalendarOptionsInput;
      let currentRefined = this.currentCalendarOptionsRefined;
      let anyChanges = false;
      for (let optionName in raw2) {
        if (this.optionsForRefining.indexOf(optionName) === -1 && (raw2[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw2[optionName]))) {
          refined[optionName] = currentRefined[optionName];
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw2[optionName]);
          anyChanges = true;
        } else {
          extra[optionName] = currentRaw[optionName];
        }
      }
      if (anyChanges) {
        this.currentCalendarOptionsInput = raw2;
        this.currentCalendarOptionsRefined = refined;
        this.stableOptionOverrides = optionOverrides;
        this.stableDynamicOptionOverrides = dynamicOptionOverrides;
      }
      this.optionsForHandling.push(...this.optionsForRefining);
      this.optionsForRefining = [];
      return {
        rawOptions: this.currentCalendarOptionsInput,
        refinedOptions: this.currentCalendarOptionsRefined,
        pluginHooks,
        availableLocaleData,
        localeDefaults,
        extra
      };
    }
    _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
      let viewSpec = optionsData.viewSpecs[viewType];
      if (!viewSpec) {
        throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
      }
      let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
      warnUnknownOptions(extra);
      this.nowManager.handleInput(optionsData.dateEnv, refinedOptions.now);
      let dateProfileGenerator = this.buildDateProfileGenerator({
        dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
        nowManager: this.nowManager,
        duration: viewSpec.duration,
        durationUnit: viewSpec.durationUnit,
        usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
        dateEnv: optionsData.dateEnv,
        calendarApi: this.props.calendarApi,
        slotMinTime: refinedOptions.slotMinTime,
        slotMaxTime: refinedOptions.slotMaxTime,
        showNonCurrentDates: refinedOptions.showNonCurrentDates,
        dayCount: refinedOptions.dayCount,
        dateAlignment: refinedOptions.dateAlignment,
        dateIncrement: refinedOptions.dateIncrement,
        hiddenDays: refinedOptions.hiddenDays,
        weekends: refinedOptions.weekends,
        validRangeInput: refinedOptions.validRange,
        visibleRangeInput: refinedOptions.visibleRange,
        fixedWeekCount: refinedOptions.fixedWeekCount
      });
      let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
      return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
    }
    processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
      let raw2 = mergeRawOptions([
        BASE_OPTION_DEFAULTS,
        viewSpec.optionDefaults,
        localeDefaults,
        optionOverrides,
        viewSpec.optionOverrides,
        dynamicOptionOverrides
      ]);
      let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
      let refined = {};
      let currentRaw = this.currentViewOptionsInput;
      let currentRefined = this.currentViewOptionsRefined;
      let anyChanges = false;
      let extra = {};
      for (let optionName in raw2) {
        if (raw2[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw2[optionName], currentRaw[optionName])) {
          refined[optionName] = currentRefined[optionName];
        } else {
          if (raw2[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw2[optionName], this.currentCalendarOptionsInput[optionName])) {
            if (optionName in this.currentCalendarOptionsRefined) {
              refined[optionName] = this.currentCalendarOptionsRefined[optionName];
            }
          } else if (refiners[optionName]) {
            refined[optionName] = refiners[optionName](raw2[optionName]);
          } else {
            extra[optionName] = raw2[optionName];
          }
          anyChanges = true;
        }
      }
      if (anyChanges) {
        this.currentViewOptionsInput = raw2;
        this.currentViewOptionsRefined = refined;
      }
      return {
        rawOptions: this.currentViewOptionsInput,
        refinedOptions: this.currentViewOptionsRefined,
        extra
      };
    }
  };
  function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
    let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
    return new DateEnv({
      calendarSystem: "gregory",
      timeZone,
      namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
      locale,
      weekNumberCalculation,
      firstDay,
      weekText,
      cmdFormatter: pluginHooks.cmdFormatter,
      defaultSeparator
    });
  }
  function buildTheme(options, pluginHooks) {
    let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
    return new ThemeClass(options);
  }
  function buildDateProfileGenerator(props) {
    let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
    return new DateProfileGeneratorClass(props);
  }
  function buildViewApi(type, getCurrentData, dateEnv) {
    return new ViewImpl(type, getCurrentData, dateEnv);
  }
  function buildEventUiBySource(eventSources) {
    return mapHash(eventSources, (eventSource) => eventSource.ui);
  }
  function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
    let eventUiBases = { "": eventUiSingleBase };
    for (let defId in eventDefs) {
      let def = eventDefs[defId];
      if (def.sourceId && eventUiBySource[def.sourceId]) {
        eventUiBases[defId] = eventUiBySource[def.sourceId];
      }
    }
    return eventUiBases;
  }
  function buildViewUiProps(calendarContext) {
    let { options } = calendarContext;
    return {
      eventUiSingleBase: createEventUi({
        display: options.eventDisplay,
        editable: options.editable,
        startEditable: options.eventStartEditable,
        durationEditable: options.eventDurationEditable,
        constraint: options.eventConstraint,
        overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
        allow: options.eventAllow,
        backgroundColor: options.eventBackgroundColor,
        borderColor: options.eventBorderColor,
        textColor: options.eventTextColor,
        color: options.eventColor
        // classNames: options.eventClassNames // render hook will handle this
      }, calendarContext),
      selectionConfig: createEventUi({
        constraint: options.selectConstraint,
        overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
        allow: options.selectAllow
      }, calendarContext)
    };
  }
  function computeIsLoading(state, context) {
    for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
      if (isLoadingFunc(state)) {
        return true;
      }
    }
    return false;
  }
  function parseContextBusinessHours(calendarContext) {
    return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
  }
  function warnUnknownOptions(options, viewName) {
    for (let optionName in options) {
      console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
    }
  }
  var ToolbarSection = class extends BaseComponent2 {
    render() {
      let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
      return y("div", { className: "fc-toolbar-chunk" }, ...children);
    }
    renderWidgetGroup(widgetGroup) {
      let { props } = this;
      let { theme } = this.context;
      let children = [];
      let isOnlyButtons = true;
      for (let widget of widgetGroup) {
        let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
        if (buttonName === "title") {
          isOnlyButtons = false;
          children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
        } else {
          let isPressed = buttonName === props.activeButton;
          let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
          let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
          if (isPressed) {
            buttonClasses.push(theme.getClass("buttonActive"));
          }
          children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
        }
      }
      if (children.length > 1) {
        let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
        return y("div", { className: groupClassName }, ...children);
      }
      return children[0];
    }
  };
  var Toolbar = class extends BaseComponent2 {
    render() {
      let { model, extraClassName } = this.props;
      let forceLtr = false;
      let startContent;
      let endContent;
      let sectionWidgets = model.sectionWidgets;
      let centerContent = sectionWidgets.center;
      if (sectionWidgets.left) {
        forceLtr = true;
        startContent = sectionWidgets.left;
      } else {
        startContent = sectionWidgets.start;
      }
      if (sectionWidgets.right) {
        forceLtr = true;
        endContent = sectionWidgets.right;
      } else {
        endContent = sectionWidgets.end;
      }
      let classNames = [
        extraClassName || "",
        "fc-toolbar",
        forceLtr ? "fc-toolbar-ltr" : ""
      ];
      return y(
        "div",
        { className: classNames.join(" ") },
        this.renderSection("start", startContent || []),
        this.renderSection("center", centerContent || []),
        this.renderSection("end", endContent || [])
      );
    }
    renderSection(key, widgetGroups) {
      let { props } = this;
      return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
    }
  };
  var ViewHarness = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.state = {
        availableWidth: null
      };
      this.handleEl = (el) => {
        this.el = el;
        setRef(this.props.elRef, el);
        this.updateAvailableWidth();
      };
      this.handleResize = () => {
        this.updateAvailableWidth();
      };
    }
    render() {
      let { props, state } = this;
      let { aspectRatio } = props;
      let classNames = [
        "fc-view-harness",
        aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
        // let the view do the height
      ];
      let height = "";
      let paddingBottom = "";
      if (aspectRatio) {
        if (state.availableWidth !== null) {
          height = state.availableWidth / aspectRatio;
        } else {
          paddingBottom = `${1 / aspectRatio * 100}%`;
        }
      } else {
        height = props.height || "";
      }
      return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
    }
    componentDidMount() {
      this.context.addResizeHandler(this.handleResize);
    }
    componentWillUnmount() {
      this.context.removeResizeHandler(this.handleResize);
    }
    updateAvailableWidth() {
      if (this.el && // needed. but why?
      this.props.aspectRatio) {
        this.setState({ availableWidth: this.el.offsetWidth });
      }
    }
  };
  var EventClicking = class extends Interaction {
    constructor(settings) {
      super(settings);
      this.handleSegClick = (ev, segEl) => {
        let { component } = this;
        let { context } = component;
        let seg = getElSeg(segEl);
        if (seg && // might be the <div> surrounding the more link
        component.isValidSegDownEl(ev.target)) {
          let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
          let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
          context.emitter.trigger("eventClick", {
            el: segEl,
            event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
            jsEvent: ev,
            view: context.viewApi
          });
          if (url && !ev.defaultPrevented) {
            window.location.href = url;
          }
        }
      };
      this.destroy = listenBySelector(
        settings.el,
        "click",
        ".fc-event",
        // on both fg and bg events
        this.handleSegClick
      );
    }
  };
  var EventHovering = class extends Interaction {
    constructor(settings) {
      super(settings);
      this.handleEventElRemove = (el) => {
        if (el === this.currentSegEl) {
          this.handleSegLeave(null, this.currentSegEl);
        }
      };
      this.handleSegEnter = (ev, segEl) => {
        if (getElSeg(segEl)) {
          this.currentSegEl = segEl;
          this.triggerEvent("eventMouseEnter", ev, segEl);
        }
      };
      this.handleSegLeave = (ev, segEl) => {
        if (this.currentSegEl) {
          this.currentSegEl = null;
          this.triggerEvent("eventMouseLeave", ev, segEl);
        }
      };
      this.removeHoverListeners = listenToHoverBySelector(
        settings.el,
        ".fc-event",
        // on both fg and bg events
        this.handleSegEnter,
        this.handleSegLeave
      );
    }
    destroy() {
      this.removeHoverListeners();
    }
    triggerEvent(publicEvName, ev, segEl) {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (!ev || component.isValidSegDownEl(ev.target)) {
        context.emitter.trigger(publicEvName, {
          el: segEl,
          event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
      }
    }
  };
  var CalendarContent = class extends PureComponent {
    constructor() {
      super(...arguments);
      this.buildViewContext = memoize(buildViewContext);
      this.buildViewPropTransformers = memoize(buildViewPropTransformers);
      this.buildToolbarProps = memoize(buildToolbarProps);
      this.headerRef = d();
      this.footerRef = d();
      this.interactionsStore = {};
      this.state = {
        viewLabelId: getUniqueDomId()
      };
      this.registerInteractiveComponent = (component, settingsInput) => {
        let settings = parseInteractionSettings(component, settingsInput);
        let DEFAULT_INTERACTIONS = [
          EventClicking,
          EventHovering
        ];
        let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
        let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
        this.interactionsStore[component.uid] = interactions;
        interactionSettingsStore[component.uid] = settings;
      };
      this.unregisterInteractiveComponent = (component) => {
        let listeners = this.interactionsStore[component.uid];
        if (listeners) {
          for (let listener of listeners) {
            listener.destroy();
          }
          delete this.interactionsStore[component.uid];
        }
        delete interactionSettingsStore[component.uid];
      };
      this.resizeRunner = new DelayedRunner(() => {
        this.props.emitter.trigger("_resize", true);
        this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
      });
      this.handleWindowResize = (ev) => {
        let { options } = this.props;
        if (options.handleWindowResize && ev.target === window) {
          this.resizeRunner.request(options.windowResizeDelay);
        }
      };
    }
    /*
    renders INSIDE of an outer div
    */
    render() {
      let { props } = this;
      let { toolbarConfig, options } = props;
      let viewVGrow = false;
      let viewHeight = "";
      let viewAspectRatio;
      if (props.isHeightAuto || props.forPrint) {
        viewHeight = "";
      } else if (options.height != null) {
        viewVGrow = true;
      } else if (options.contentHeight != null) {
        viewHeight = options.contentHeight;
      } else {
        viewAspectRatio = Math.max(options.aspectRatio, 0.5);
      }
      let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.nowManager, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
      let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
      return y(
        ViewContextType.Provider,
        { value: viewContext },
        y(NowTimer, { unit: "day" }, (nowDate) => {
          let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, nowDate, props.viewTitle);
          return y(
            _,
            null,
            toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
            y(
              ViewHarness,
              { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
              this.renderView(props),
              this.buildAppendContent()
            ),
            toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
          );
        })
      );
    }
    componentDidMount() {
      let { props } = this;
      this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
      window.addEventListener("resize", this.handleWindowResize);
      let { propSetHandlers } = props.pluginHooks;
      for (let propName in propSetHandlers) {
        propSetHandlers[propName](props[propName], props);
      }
    }
    componentDidUpdate(prevProps) {
      let { props } = this;
      let { propSetHandlers } = props.pluginHooks;
      for (let propName in propSetHandlers) {
        if (props[propName] !== prevProps[propName]) {
          propSetHandlers[propName](props[propName], props);
        }
      }
    }
    componentWillUnmount() {
      window.removeEventListener("resize", this.handleWindowResize);
      this.resizeRunner.clear();
      for (let interaction of this.calendarInteractions) {
        interaction.destroy();
      }
      this.props.emitter.trigger("_unmount");
    }
    buildAppendContent() {
      let { props } = this;
      let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
      return y(_, {}, ...children);
    }
    renderView(props) {
      let { pluginHooks } = props;
      let { viewSpec } = props;
      let viewProps = {
        dateProfile: props.dateProfile,
        businessHours: props.businessHours,
        eventStore: props.renderableEventStore,
        eventUiBases: props.eventUiBases,
        dateSelection: props.dateSelection,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        isHeightAuto: props.isHeightAuto,
        forPrint: props.forPrint
      };
      let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
      for (let transformer of transformers) {
        Object.assign(viewProps, transformer.transform(viewProps, props));
      }
      let ViewComponent = viewSpec.component;
      return y(ViewComponent, Object.assign({}, viewProps));
    }
  };
  function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
    let todayInfo = dateProfileGenerator.build(now, void 0, false);
    let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
    let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
    return {
      title,
      activeButton: viewSpec.type,
      navUnit: viewSpec.singleUnit,
      isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
      isPrevEnabled: prevInfo.isValid,
      isNextEnabled: nextInfo.isValid
    };
  }
  function buildViewPropTransformers(theClasses) {
    return theClasses.map((TheClass) => new TheClass());
  }
  var Calendar = class extends CalendarImpl {
    constructor(el, optionOverrides = {}) {
      super();
      this.isRendering = false;
      this.isRendered = false;
      this.currentClassNames = [];
      this.customContentRenderId = 0;
      this.handleAction = (action) => {
        switch (action.type) {
          case "SET_EVENT_DRAG":
          case "SET_EVENT_RESIZE":
            this.renderRunner.tryDrain();
        }
      };
      this.handleData = (data2) => {
        this.currentData = data2;
        this.renderRunner.request(data2.calendarOptions.rerenderDelay);
      };
      this.handleRenderRequest = () => {
        if (this.isRendering) {
          this.isRendered = true;
          let { currentData } = this;
          flushSync(() => {
            D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
              this.setClassNames(classNames);
              this.setHeight(height);
              return y(
                RenderId.Provider,
                { value: this.customContentRenderId },
                y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
              );
            }), this.el);
          });
        } else if (this.isRendered) {
          this.isRendered = false;
          D(null, this.el);
          this.setClassNames([]);
          this.setHeight("");
        }
      };
      ensureElHasStyles(el);
      this.el = el;
      this.renderRunner = new DelayedRunner(this.handleRenderRequest);
      new CalendarDataManager({
        optionOverrides,
        calendarApi: this,
        onAction: this.handleAction,
        onData: this.handleData
      });
    }
    render() {
      let wasRendering = this.isRendering;
      if (!wasRendering) {
        this.isRendering = true;
      } else {
        this.customContentRenderId += 1;
      }
      this.renderRunner.request();
      if (wasRendering) {
        this.updateSize();
      }
    }
    destroy() {
      if (this.isRendering) {
        this.isRendering = false;
        this.renderRunner.request();
      }
    }
    updateSize() {
      flushSync(() => {
        super.updateSize();
      });
    }
    batchRendering(func) {
      this.renderRunner.pause("batchRendering");
      func();
      this.renderRunner.resume("batchRendering");
    }
    pauseRendering() {
      this.renderRunner.pause("pauseRendering");
    }
    resumeRendering() {
      this.renderRunner.resume("pauseRendering", true);
    }
    resetOptions(optionOverrides, changedOptionNames) {
      this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
    }
    setClassNames(classNames) {
      if (!isArraysEqual(classNames, this.currentClassNames)) {
        let { classList } = this.el;
        for (let className of this.currentClassNames) {
          classList.remove(className);
        }
        for (let className of classNames) {
          classList.add(className);
        }
        this.currentClassNames = classNames;
      }
    }
    setHeight(height) {
      applyStyleProp(this.el, "height", height);
    }
  };

  // node_modules/@fullcalendar/daygrid/internal.js
  var TableView = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.headerElRef = d();
    }
    renderSimpleLayout(headerRowContent, bodyContent) {
      let { props, context } = this;
      let sections = [];
      let stickyHeaderDates = getStickyHeaderDates(context.options);
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          chunk: {
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        });
      }
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        chunk: { content: bodyContent }
      });
      return y(
        ViewContainer,
        { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
        y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
      );
    }
    renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
      let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
      if (!ScrollGrid) {
        throw new Error("No ScrollGrid implementation");
      }
      let { props, context } = this;
      let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
      let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
      let sections = [];
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          chunks: [{
            key: "main",
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }]
        });
      }
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        chunks: [{
          key: "main",
          content: bodyContent
        }]
      });
      if (stickyFooterScrollbar) {
        sections.push({
          type: "footer",
          key: "footer",
          isSticky: true,
          chunks: [{
            key: "main",
            content: renderScrollShim
          }]
        });
      }
      return y(
        ViewContainer,
        { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
        y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
      );
    }
  };
  function splitSegsByRow(segs, rowCnt) {
    let byRow = [];
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = [];
    }
    for (let seg of segs) {
      byRow[seg.row].push(seg);
    }
    return byRow;
  }
  function splitSegsByFirstCol(segs, colCnt) {
    let byCol = [];
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byCol[i3] = [];
    }
    for (let seg of segs) {
      byCol[seg.firstCol].push(seg);
    }
    return byCol;
  }
  function splitInteractionByRow(ui, rowCnt) {
    let byRow = [];
    if (!ui) {
      for (let i3 = 0; i3 < rowCnt; i3 += 1) {
        byRow[i3] = null;
      }
    } else {
      for (let i3 = 0; i3 < rowCnt; i3 += 1) {
        byRow[i3] = {
          affectedInstances: ui.affectedInstances,
          isEvent: ui.isEvent,
          segs: []
        };
      }
      for (let seg of ui.segs) {
        byRow[seg.row].segs.push(seg);
      }
    }
    return byRow;
  }
  var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
    hour: "numeric",
    minute: "2-digit",
    omitZeroMinute: true,
    meridiem: "narrow"
  });
  function hasListItemDisplay(seg) {
    let { display } = seg.eventRange.ui;
    return display === "list-item" || display === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
    seg.isStart && // "
    seg.isEnd;
  }
  var TableBlockEvent = class extends BaseComponent2 {
    render() {
      let { props } = this;
      return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
    }
  };
  var TableListItemEvent = class extends BaseComponent2 {
    render() {
      let { props, context } = this;
      let { options } = context;
      let { seg } = props;
      let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
      let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
      return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
    }
  };
  function renderInnerContent2(renderProps) {
    return y(
      _,
      null,
      y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
      renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
      y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
    );
  }
  var TableCellMoreLink = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.compileSegs = memoize(compileSegs);
    }
    render() {
      let { props } = this;
      let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
      return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
        let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
        return y(_, null, allSegs.map((seg) => {
          let instanceId = seg.eventRange.instance.instanceId;
          return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
            visibility: isForcedInvisible[instanceId] ? "hidden" : ""
          } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
        }));
      } });
    }
  };
  function compileSegs(singlePlacements) {
    let allSegs = [];
    let invisibleSegs = [];
    for (let placement of singlePlacements) {
      allSegs.push(placement.seg);
      if (!placement.isVisible) {
        invisibleSegs.push(placement.seg);
      }
    }
    return { allSegs, invisibleSegs };
  }
  var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
  var TableCell = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.rootElRef = d();
      this.state = {
        dayNumberId: getUniqueDomId()
      };
      this.handleRootEl = (el) => {
        setRef(this.rootElRef, el);
        setRef(this.props.elRef, el);
      };
    }
    render() {
      let { context, props, state, rootElRef } = this;
      let { options, dateEnv } = context;
      let { date, dateProfile } = props;
      const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
      return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
        "fc-daygrid-day",
        ...props.extraClassNames || []
      ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
        "div",
        { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
        props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
        !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
          "div",
          { className: "fc-daygrid-day-top" },
          y(InnerContent, { elTag: "a", elClasses: [
            "fc-daygrid-day-number",
            isMonthStart && "fc-daygrid-month-start"
          ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })
        ) : props.showDayNumber ? (
          // for creating correct amount of space (see issue #7162)
          y(
            "div",
            { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
            y("a", { className: "fc-daygrid-day-number" }, "\xA0")
          )
        ) : void 0,
        y(
          "div",
          { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
          props.fgContent,
          y(
            "div",
            { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
            y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
          )
        ),
        y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
      ));
    }
  };
  function renderTopInner(props) {
    return props.dayNumberText || y(_, null, "\xA0");
  }
  function shouldDisplayMonthStart(date, currentRange, dateEnv) {
    const { start: currentStart, end: currentEnd } = currentRange;
    const currentEndIncl = addMs(currentEnd, -1);
    const currentFirstYear = dateEnv.getYear(currentStart);
    const currentFirstMonth = dateEnv.getMonth(currentStart);
    const currentLastYear = dateEnv.getYear(currentEndIncl);
    const currentLastMonth = dateEnv.getMonth(currentEndIncl);
    return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
      // first date in current view?
      date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
      dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
    );
  }
  function generateSegKey(seg) {
    return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
  }
  function generateSegUid(seg) {
    return generateSegKey(seg) + ":" + seg.lastCol;
  }
  function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
    let hierarchy = new DayGridSegHierarchy((segEntry) => {
      let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
      return segHeights[segUid] || 1;
    });
    hierarchy.allowReslicing = true;
    hierarchy.strictOrder = strictOrder;
    if (dayMaxEvents === true || dayMaxEventRows === true) {
      hierarchy.maxCoord = maxContentHeight;
      hierarchy.hiddenConsumes = true;
    } else if (typeof dayMaxEvents === "number") {
      hierarchy.maxStackCnt = dayMaxEvents;
    } else if (typeof dayMaxEventRows === "number") {
      hierarchy.maxStackCnt = dayMaxEventRows;
      hierarchy.hiddenConsumes = true;
    }
    let segInputs = [];
    let unknownHeightSegs = [];
    for (let i3 = 0; i3 < segs.length; i3 += 1) {
      let seg = segs[i3];
      let segUid = generateSegUid(seg);
      let eventHeight = segHeights[segUid];
      if (eventHeight != null) {
        segInputs.push({
          index: i3,
          span: {
            start: seg.firstCol,
            end: seg.lastCol + 1
          }
        });
      } else {
        unknownHeightSegs.push(seg);
      }
    }
    let hiddenEntries = hierarchy.addSegs(segInputs);
    let segRects = hierarchy.toRects();
    let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
    let moreCnts = [];
    let moreMarginTops = [];
    for (let seg of unknownHeightSegs) {
      multiColPlacements[seg.firstCol].push({
        seg,
        isVisible: false,
        isAbsolute: true,
        absoluteTop: 0,
        marginTop: 0
      });
      for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
        singleColPlacements[col].push({
          seg: resliceSeg(seg, col, col + 1, cells),
          isVisible: false,
          isAbsolute: false,
          absoluteTop: 0,
          marginTop: 0
        });
      }
    }
    for (let col = 0; col < cells.length; col += 1) {
      moreCnts.push(0);
    }
    for (let hiddenEntry of hiddenEntries) {
      let seg = segs[hiddenEntry.index];
      let hiddenSpan = hiddenEntry.span;
      multiColPlacements[hiddenSpan.start].push({
        seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
        isVisible: false,
        isAbsolute: true,
        absoluteTop: 0,
        marginTop: 0
      });
      for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
        moreCnts[col] += 1;
        singleColPlacements[col].push({
          seg: resliceSeg(seg, col, col + 1, cells),
          isVisible: false,
          isAbsolute: false,
          absoluteTop: 0,
          marginTop: 0
        });
      }
    }
    for (let col = 0; col < cells.length; col += 1) {
      moreMarginTops.push(leftoverMargins[col]);
    }
    return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
  }
  function placeRects(allRects, segs, cells) {
    let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
    let singleColPlacements = [];
    let multiColPlacements = [];
    let leftoverMargins = [];
    for (let col = 0; col < cells.length; col += 1) {
      let rects = rectsByEachCol[col];
      let singlePlacements = [];
      let currentHeight = 0;
      let currentMarginTop = 0;
      for (let rect of rects) {
        let seg = segs[rect.index];
        singlePlacements.push({
          seg: resliceSeg(seg, col, col + 1, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: rect.levelCoord - currentHeight
        });
        currentHeight = rect.levelCoord + rect.thickness;
      }
      let multiPlacements = [];
      currentHeight = 0;
      currentMarginTop = 0;
      for (let rect of rects) {
        let seg = segs[rect.index];
        let isAbsolute = rect.span.end - rect.span.start > 1;
        let isFirstCol = rect.span.start === col;
        currentMarginTop += rect.levelCoord - currentHeight;
        currentHeight = rect.levelCoord + rect.thickness;
        if (isAbsolute) {
          currentMarginTop += rect.thickness;
          if (isFirstCol) {
            multiPlacements.push({
              seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
              isVisible: true,
              isAbsolute: true,
              absoluteTop: rect.levelCoord,
              marginTop: 0
            });
          }
        } else if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: false,
            absoluteTop: rect.levelCoord,
            marginTop: currentMarginTop
            // claim the margin
          });
          currentMarginTop = 0;
        }
      }
      singleColPlacements.push(singlePlacements);
      multiColPlacements.push(multiPlacements);
      leftoverMargins.push(currentMarginTop);
    }
    return { singleColPlacements, multiColPlacements, leftoverMargins };
  }
  function groupRectsByEachCol(rects, colCnt) {
    let rectsByEachCol = [];
    for (let col = 0; col < colCnt; col += 1) {
      rectsByEachCol.push([]);
    }
    for (let rect of rects) {
      for (let col = rect.span.start; col < rect.span.end; col += 1) {
        rectsByEachCol[col].push(rect);
      }
    }
    return rectsByEachCol;
  }
  function resliceSeg(seg, spanStart, spanEnd, cells) {
    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
      return seg;
    }
    let eventRange = seg.eventRange;
    let origRange = eventRange.range;
    let slicedRange = intersectRanges(origRange, {
      start: cells[spanStart].date,
      end: addDays(cells[spanEnd - 1].date, 1)
    });
    return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
      def: eventRange.def,
      ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
      instance: eventRange.instance,
      range: slicedRange
    }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
  }
  var DayGridSegHierarchy = class extends SegHierarchy {
    constructor() {
      super(...arguments);
      this.hiddenConsumes = false;
      this.forceHidden = {};
    }
    addSegs(segInputs) {
      const hiddenSegs = super.addSegs(segInputs);
      const { entriesByLevel } = this;
      const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
      for (let level = 0; level < entriesByLevel.length; level += 1) {
        entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
      }
      return hiddenSegs;
    }
    handleInvalidInsertion(insertion, entry, hiddenEntries) {
      const { entriesByLevel, forceHidden } = this;
      const { touchingEntry, touchingLevel, touchingLateral } = insertion;
      if (this.hiddenConsumes && touchingEntry) {
        const touchingEntryId = buildEntryKey(touchingEntry);
        if (!forceHidden[touchingEntryId]) {
          if (this.allowReslicing) {
            const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
            const hiddenEntryId = buildEntryKey(hiddenEntry);
            forceHidden[hiddenEntryId] = true;
            entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
            hiddenEntries.push(hiddenEntry);
            this.splitEntry(touchingEntry, entry, hiddenEntries);
          } else {
            forceHidden[touchingEntryId] = true;
            hiddenEntries.push(touchingEntry);
          }
        }
      }
      super.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  };
  var TableRow = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.cellElRefs = new RefMap();
      this.frameElRefs = new RefMap();
      this.fgElRefs = new RefMap();
      this.segHarnessRefs = new RefMap();
      this.rootElRef = d();
      this.state = {
        framePositions: null,
        maxContentHeight: null,
        segHeights: {}
      };
      this.handleResize = (isForced) => {
        if (isForced) {
          this.updateSizing(true);
        }
      };
    }
    render() {
      let { props, state, context } = this;
      let { options } = context;
      let colCnt = props.cells.length;
      let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
      let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
      let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
      let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
      let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
      let isForcedInvisible = (
        // TODO: messy way to compute this
        props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
      );
      return y(
        "tr",
        { ref: this.rootElRef, role: "row" },
        props.renderIntro && props.renderIntro(),
        props.cells.map((cell, col) => {
          let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
          let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
          return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
            // Fragment scopes the keys
            y(
              _,
              null,
              y(_, null, normalFgNodes),
              y(_, null, mirrorFgNodes)
            )
          ), bgContent: (
            // Fragment scopes the keys
            y(
              _,
              null,
              this.renderFillSegs(highlightSegsByCol[col], "highlight"),
              this.renderFillSegs(businessHoursByCol[col], "non-business"),
              this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
            )
          ), minHeight: props.cellMinHeight });
        })
      );
    }
    componentDidMount() {
      this.updateSizing(true);
      this.context.addResizeHandler(this.handleResize);
    }
    componentDidUpdate(prevProps, prevState) {
      let currentProps = this.props;
      this.updateSizing(!isPropsEqual(prevProps, currentProps));
    }
    componentWillUnmount() {
      this.context.removeResizeHandler(this.handleResize);
    }
    getHighlightSegs() {
      let { props } = this;
      if (props.eventDrag && props.eventDrag.segs.length) {
        return props.eventDrag.segs;
      }
      if (props.eventResize && props.eventResize.segs.length) {
        return props.eventResize.segs;
      }
      return props.dateSelectionSegs;
    }
    getMirrorSegs() {
      let { props } = this;
      if (props.eventResize && props.eventResize.segs.length) {
        return props.eventResize.segs;
      }
      return [];
    }
    renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
      let { context } = this;
      let { eventSelection } = this.props;
      let { framePositions } = this.state;
      let defaultDisplayEventEnd = this.props.cells.length === 1;
      let isMirror = isDragging || isResizing || isDateSelecting;
      let nodes = [];
      if (framePositions) {
        for (let placement of segPlacements) {
          let { seg } = placement;
          let { instanceId } = seg.eventRange.instance;
          let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
          let isAbsolute = placement.isAbsolute;
          let left = "";
          let right = "";
          if (isAbsolute) {
            if (context.isRtl) {
              right = 0;
              left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
            } else {
              left = 0;
              right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
            }
          }
          nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
            visibility: isVisible ? "" : "hidden",
            marginTop: isAbsolute ? "" : placement.marginTop,
            top: isAbsolute ? placement.absoluteTop : "",
            left,
            right
          } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
        }
      }
      return nodes;
    }
    renderFillSegs(segs, fillType) {
      let { isRtl } = this.context;
      let { todayRange } = this.props;
      let { framePositions } = this.state;
      let nodes = [];
      if (framePositions) {
        for (let seg of segs) {
          let leftRightCss = isRtl ? {
            right: 0,
            left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
          } : {
            left: 0,
            right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
          };
          nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
        }
      }
      return y(_, {}, ...nodes);
    }
    updateSizing(isExternalSizingChange) {
      let { props, state, frameElRefs } = this;
      if (!props.forPrint && props.clientWidth !== null) {
        if (isExternalSizingChange) {
          let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
          if (frameEls.length) {
            let originEl = this.rootElRef.current;
            let newPositionCache = new PositionCache(
              originEl,
              frameEls,
              true,
              // isHorizontal
              false
            );
            if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
              this.setState({
                framePositions: new PositionCache(
                  originEl,
                  frameEls,
                  true,
                  // isHorizontal
                  false
                )
              });
            }
          }
        }
        const oldSegHeights = this.state.segHeights;
        const newSegHeights = this.querySegHeights();
        const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
        this.safeSetState({
          // HACK to prevent oscillations of events being shown/hidden from max-event-rows
          // Essentially, once you compute an element's height, never null-out.
          // TODO: always display all events, as visibility:hidden?
          segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
          maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
        });
      }
    }
    querySegHeights() {
      let segElMap = this.segHarnessRefs.currentMap;
      let segHeights = {};
      for (let segUid in segElMap) {
        let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
        segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
      }
      return segHeights;
    }
    computeMaxContentHeight() {
      let firstKey = this.props.cells[0].key;
      let cellEl = this.cellElRefs.currentMap[firstKey];
      let fcContainerEl = this.fgElRefs.currentMap[firstKey];
      return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
    }
    getCellEls() {
      let elMap = this.cellElRefs.currentMap;
      return this.props.cells.map((cell) => elMap[cell.key]);
    }
  };
  TableRow.addStateEquality({
    segHeights: isPropsEqual
  });
  function buildMirrorPlacements(mirrorSegs, colPlacements) {
    if (!mirrorSegs.length) {
      return [];
    }
    let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
    return mirrorSegs.map((seg) => ({
      seg,
      isVisible: true,
      isAbsolute: true,
      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
      marginTop: 0
    }));
  }
  function buildAbsoluteTopHash(colPlacements) {
    let topsByInstanceId = {};
    for (let placements of colPlacements) {
      for (let placement of placements) {
        topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
      }
    }
    return topsByInstanceId;
  }
  var TableRows = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.splitBusinessHourSegs = memoize(splitSegsByRow);
      this.splitBgEventSegs = memoize(splitAllDaySegsByRow);
      this.splitFgEventSegs = memoize(splitSegsByRow);
      this.splitDateSelectionSegs = memoize(splitSegsByRow);
      this.splitEventDrag = memoize(splitInteractionByRow);
      this.splitEventResize = memoize(splitInteractionByRow);
      this.rowRefs = new RefMap();
    }
    render() {
      let { props, context } = this;
      let rowCnt = props.cells.length;
      let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
      let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
      let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
      let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
      let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
      let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
      let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
      return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
        ref: this.rowRefs.createRef(row),
        key: cells.length ? cells[0].date.toISOString() : row,
        showDayNumbers: rowCnt > 1,
        showWeekNumbers: props.showWeekNumbers,
        todayRange,
        dateProfile: props.dateProfile,
        cells,
        renderIntro: props.renderRowIntro,
        businessHourSegs: businessHourSegsByRow[row],
        eventSelection: props.eventSelection,
        bgEventSegs: bgEventSegsByRow[row],
        fgEventSegs: fgEventSegsByRow[row],
        dateSelectionSegs: dateSelectionSegsByRow[row],
        eventDrag: eventDragByRow[row],
        eventResize: eventResizeByRow[row],
        dayMaxEvents: props.dayMaxEvents,
        dayMaxEventRows: props.dayMaxEventRows,
        clientWidth: props.clientWidth,
        clientHeight: props.clientHeight,
        cellMinHeight,
        forPrint: props.forPrint
      }))));
    }
    componentDidMount() {
      this.registerInteractiveComponent();
    }
    componentDidUpdate() {
      this.registerInteractiveComponent();
    }
    registerInteractiveComponent() {
      if (!this.rootEl) {
        const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
        const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
        if (rootEl) {
          this.rootEl = rootEl;
          this.context.registerInteractiveComponent(this, {
            el: rootEl,
            isHitComboAllowed: this.props.isHitComboAllowed
          });
        }
      }
    }
    componentWillUnmount() {
      if (this.rootEl) {
        this.context.unregisterInteractiveComponent(this);
        this.rootEl = null;
      }
    }
    // Hit System
    // ----------------------------------------------------------------------------------------------------
    prepareHits() {
      this.rowPositions = new PositionCache(
        this.rootEl,
        this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
        // first cell el in each row. TODO: not optimal
        false,
        true
      );
      this.colPositions = new PositionCache(
        this.rootEl,
        this.rowRefs.currentMap[0].getCellEls(),
        // cell els in first row
        true,
        // horizontal
        false
      );
    }
    queryHit(positionLeft, positionTop) {
      let { colPositions, rowPositions } = this;
      let col = colPositions.leftToIndex(positionLeft);
      let row = rowPositions.topToIndex(positionTop);
      if (row != null && col != null) {
        let cell = this.props.cells[row][col];
        return {
          dateProfile: this.props.dateProfile,
          dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
          dayEl: this.getCellEl(row, col),
          rect: {
            left: colPositions.lefts[col],
            right: colPositions.rights[col],
            top: rowPositions.tops[row],
            bottom: rowPositions.bottoms[row]
          },
          layer: 0
        };
      }
      return null;
    }
    getCellEl(row, col) {
      return this.rowRefs.currentMap[row].getCellEls()[col];
    }
    getCellRange(row, col) {
      let start2 = this.props.cells[row][col].date;
      let end = addDays(start2, 1);
      return { start: start2, end };
    }
  };
  function splitAllDaySegsByRow(segs, rowCnt) {
    return splitSegsByRow(segs.filter(isSegAllDay), rowCnt);
  }
  function isSegAllDay(seg) {
    return seg.eventRange.def.allDay;
  }
  var Table = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.elRef = d();
      this.needsScrollReset = false;
    }
    render() {
      let { props } = this;
      let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
      let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
      if (limitViaBalanced && !expandRows) {
        limitViaBalanced = false;
        dayMaxEventRows = null;
        dayMaxEvents = null;
      }
      let classNames = [
        "fc-daygrid-body",
        limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
        expandRows ? "" : "fc-daygrid-body-natural"
        // will height of one row depend on the others?
      ];
      return y(
        "div",
        { ref: this.elRef, className: classNames.join(" "), style: {
          // these props are important to give this wrapper correct dimensions for interactions
          // TODO: if we set it here, can we avoid giving to inner tables?
          width: props.clientWidth,
          minWidth: props.tableMinWidth
        } },
        y(
          "table",
          { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
            width: props.clientWidth,
            minWidth: props.tableMinWidth,
            height: expandRows ? props.clientHeight : ""
          } },
          props.colGroupNode,
          y(
            "tbody",
            { role: "presentation" },
            y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
          )
        )
      );
    }
    componentDidMount() {
      this.requestScrollReset();
    }
    componentDidUpdate(prevProps) {
      if (prevProps.dateProfile !== this.props.dateProfile) {
        this.requestScrollReset();
      } else {
        this.flushScrollReset();
      }
    }
    requestScrollReset() {
      this.needsScrollReset = true;
      this.flushScrollReset();
    }
    flushScrollReset() {
      if (this.needsScrollReset && this.props.clientWidth) {
        const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
        if (subjectEl) {
          const originEl = subjectEl.closest(".fc-daygrid-body");
          const scrollEl = originEl.closest(".fc-scroller");
          const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
          scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
        }
        this.needsScrollReset = false;
      }
    }
  };
  function getScrollSubjectEl(containerEl, dateProfile) {
    let el;
    if (dateProfile.currentRangeUnit.match(/year|month/)) {
      el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
    }
    if (!el) {
      el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
    }
    return el;
  }
  var DayTableSlicer = class extends Slicer {
    constructor() {
      super(...arguments);
      this.forceDayIfListItem = true;
    }
    sliceRange(dateRange, dayTableModel) {
      return dayTableModel.sliceRange(dateRange);
    }
  };
  var DayTable = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.slicer = new DayTableSlicer();
      this.tableRef = d();
    }
    render() {
      let { props, context } = this;
      return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
    }
  };
  var DayTableView = class extends TableView {
    constructor() {
      super(...arguments);
      this.buildDayTableModel = memoize(buildDayTableModel);
      this.headerRef = d();
      this.tableRef = d();
    }
    render() {
      let { options, dateProfileGenerator } = this.context;
      let { props } = this;
      let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
      let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
      let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
      return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
    }
  };
  function buildDayTableModel(dateProfile, dateProfileGenerator) {
    let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
    return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
  }
  var TableDateProfileGenerator = class extends DateProfileGenerator {
    // Computes the date range that will be rendered
    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
      let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
      let { props } = this;
      return buildDayTableRenderRange({
        currentRange: renderRange,
        snapToWeek: /^(year|month)$/.test(currentRangeUnit),
        fixedWeekCount: props.fixedWeekCount,
        dateEnv: props.dateEnv
      });
    }
  };
  function buildDayTableRenderRange(props) {
    let { dateEnv, currentRange } = props;
    let { start: start2, end } = currentRange;
    let endOfWeek;
    if (props.snapToWeek) {
      start2 = dateEnv.startOfWeek(start2);
      endOfWeek = dateEnv.startOfWeek(end);
      if (endOfWeek.valueOf() !== end.valueOf()) {
        end = addWeeks(endOfWeek, 1);
      }
    }
    if (props.fixedWeekCount) {
      let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
      let rowCnt = Math.ceil(
        // could be partial weeks due to hiddenDays
        diffWeeks(lastMonthRenderStart, end)
      );
      end = addWeeks(end, 6 - rowCnt);
    }
    return { start: start2, end };
  }
  var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
  injectStyles(css_248z2);

  // node_modules/@fullcalendar/daygrid/index.js
  var index2 = createPlugin({
    name: "@fullcalendar/daygrid",
    initialView: "dayGridMonth",
    views: {
      dayGrid: {
        component: DayTableView,
        dateProfileGeneratorClass: TableDateProfileGenerator
      },
      dayGridDay: {
        type: "dayGrid",
        duration: { days: 1 }
      },
      dayGridWeek: {
        type: "dayGrid",
        duration: { weeks: 1 }
      },
      dayGridMonth: {
        type: "dayGrid",
        duration: { months: 1 },
        fixedWeekCount: true
      },
      dayGridYear: {
        type: "dayGrid",
        duration: { years: 1 }
      }
    }
  });

  // node_modules/@fullcalendar/list/internal.js
  var ListViewHeaderRow = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.state = {
        textId: getUniqueDomId()
      };
    }
    render() {
      let { theme, dateEnv, options, viewApi } = this.context;
      let { cellId, dayDate, todayRange } = this.props;
      let { textId } = this.state;
      let dayMeta = getDateMeta(dayDate, todayRange);
      let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : "";
      let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : "";
      let renderProps = Object.assign({
        date: dateEnv.toDate(dayDate),
        view: viewApi,
        textId,
        text,
        sideText,
        navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),
        sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, "day", false)
      }, dayMeta);
      return y(ContentContainer, { elTag: "tr", elClasses: [
        "fc-list-day",
        ...getDayClassNames(dayMeta, theme)
      ], elAttrs: {
        "data-date": formatDayString(dayDate)
      }, renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInnerContent3, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => (
        // TODO: force-hide top border based on :first-child
        y(
          "th",
          { scope: "colgroup", colSpan: 3, id: cellId, "aria-labelledby": textId },
          y(InnerContent, { elTag: "div", elClasses: [
            "fc-list-day-cushion",
            theme.getClass("tableCellShaded")
          ] })
        )
      ));
    }
  };
  function renderInnerContent3(props) {
    return y(
      _,
      null,
      props.text && y("a", Object.assign({ id: props.textId, className: "fc-list-day-text" }, props.navLinkAttrs), props.text),
      props.sideText && /* not keyboard tabbable */
      y("a", Object.assign({ "aria-hidden": true, className: "fc-list-day-side-text" }, props.sideNavLinkAttrs), props.sideText)
    );
  }
  var DEFAULT_TIME_FORMAT = createFormatter({
    hour: "numeric",
    minute: "2-digit",
    meridiem: "short"
  });
  var ListViewEventRow = class extends BaseComponent2 {
    render() {
      let { props, context } = this;
      let { options } = context;
      let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;
      let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT;
      return y(EventContainer, Object.assign({}, props, { elTag: "tr", elClasses: [
        "fc-list-event",
        seg.eventRange.def.url && "fc-event-forced-url"
      ], defaultGenerator: () => renderEventInnerContent(seg, context), seg, timeText: "", disableDragging: true, disableResizing: true }), (InnerContent, eventContentArg) => y(
        _,
        null,
        buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId),
        y(
          "td",
          { "aria-hidden": true, className: "fc-list-event-graphic" },
          y("span", { className: "fc-list-event-dot", style: {
            borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor
          } })
        ),
        y(InnerContent, { elTag: "td", elClasses: ["fc-list-event-title"], elAttrs: { headers: `${eventHeaderId} ${dateHeaderId}` } })
      ));
    }
  };
  function renderEventInnerContent(seg, context) {
    let interactiveAttrs = getSegAnchorAttrs(seg, context);
    return y("a", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);
  }
  function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
    let { options } = context;
    if (options.displayEventTime !== false) {
      let eventDef = seg.eventRange.def;
      let eventInstance = seg.eventRange.instance;
      let doAllDay = false;
      let timeText;
      if (eventDef.allDay) {
        doAllDay = true;
      } else if (isMultiDayRange(seg.eventRange.range)) {
        if (seg.isStart) {
          timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
        } else if (seg.isEnd) {
          timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
        } else {
          doAllDay = true;
        }
      } else {
        timeText = buildSegTimeText(seg, timeFormat, context);
      }
      if (doAllDay) {
        let renderProps = {
          text: context.options.allDayText,
          view: context.viewApi
        };
        return y(ContentContainer, { elTag: "td", elClasses: ["fc-list-event-time"], elAttrs: {
          headers: `${timeHeaderId} ${dateHeaderId}`
        }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount });
      }
      return y("td", { className: "fc-list-event-time" }, timeText);
    }
    return null;
  }
  function renderAllDayInner(renderProps) {
    return renderProps.text;
  }
  var ListView = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.computeDateVars = memoize(computeDateVars);
      this.eventStoreToSegs = memoize(this._eventStoreToSegs);
      this.state = {
        timeHeaderId: getUniqueDomId(),
        eventHeaderId: getUniqueDomId(),
        dateHeaderIdRoot: getUniqueDomId()
      };
      this.setRootEl = (rootEl) => {
        if (rootEl) {
          this.context.registerInteractiveComponent(this, {
            el: rootEl
          });
        } else {
          this.context.unregisterInteractiveComponent(this);
        }
      };
    }
    render() {
      let { props, context } = this;
      let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);
      let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
      return y(
        ViewContainer,
        { elRef: this.setRootEl, elClasses: [
          "fc-list",
          context.theme.getClass("table"),
          context.options.stickyHeaderDates !== false ? "fc-list-sticky" : ""
        ], viewSpec: context.viewSpec },
        y(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? "visible" : "hidden", overflowY: props.isHeightAuto ? "visible" : "auto" }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage())
      );
    }
    renderEmptyMessage() {
      let { options, viewApi } = this.context;
      let renderProps = {
        text: options.noEventsText,
        view: viewApi
      };
      return y(ContentContainer, { elTag: "div", elClasses: ["fc-list-empty"], renderProps, generatorName: "noEventsContent", customGenerator: options.noEventsContent, defaultGenerator: renderNoEventsInner, classNameGenerator: options.noEventsClassNames, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-list-empty-cushion"] }));
    }
    renderSegList(allSegs, dayDates) {
      let { theme, options } = this.context;
      let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;
      let segsByDay = groupSegsByDay(allSegs);
      return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
        let innerNodes = [];
        for (let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
          let daySegs = segsByDay[dayIndex];
          if (daySegs) {
            let dayStr = formatDayString(dayDates[dayIndex]);
            let dateHeaderId = dateHeaderIdRoot + "-" + dayStr;
            innerNodes.push(y(ListViewHeaderRow, { key: dayStr, cellId: dateHeaderId, dayDate: dayDates[dayIndex], todayRange }));
            daySegs = sortEventSegs(daySegs, options.eventOrder);
            for (let seg of daySegs) {
              innerNodes.push(y(ListViewEventRow, Object.assign({ key: dayStr + ":" + seg.eventRange.instance.instanceId, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, timeHeaderId, eventHeaderId, dateHeaderId }, getSegMeta(seg, todayRange, nowDate))));
            }
          }
        }
        return y(
          "table",
          { className: "fc-list-table " + theme.getClass("table") },
          y(
            "thead",
            null,
            y(
              "tr",
              null,
              y("th", { scope: "col", id: timeHeaderId }, options.timeHint),
              y("th", { scope: "col", "aria-hidden": true }),
              y("th", { scope: "col", id: eventHeaderId }, options.eventHint)
            )
          ),
          y("tbody", null, innerNodes)
        );
      });
    }
    _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {
      return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
    }
    eventRangesToSegs(eventRanges, dayRanges) {
      let segs = [];
      for (let eventRange of eventRanges) {
        segs.push(...this.eventRangeToSegs(eventRange, dayRanges));
      }
      return segs;
    }
    eventRangeToSegs(eventRange, dayRanges) {
      let { dateEnv } = this.context;
      let { nextDayThreshold } = this.context.options;
      let range = eventRange.range;
      let allDay = eventRange.def.allDay;
      let dayIndex;
      let segRange;
      let seg;
      let segs = [];
      for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
        segRange = intersectRanges(range, dayRanges[dayIndex]);
        if (segRange) {
          seg = {
            component: this,
            eventRange,
            start: segRange.start,
            end: segRange.end,
            isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),
            isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),
            dayIndex
          };
          segs.push(seg);
          if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
            seg.end = range.end;
            seg.isEnd = true;
            break;
          }
        }
      }
      return segs;
    }
  };
  function renderNoEventsInner(renderProps) {
    return renderProps.text;
  }
  function computeDateVars(dateProfile) {
    let dayStart = startOfDay(dateProfile.renderRange.start);
    let viewEnd = dateProfile.renderRange.end;
    let dayDates = [];
    let dayRanges = [];
    while (dayStart < viewEnd) {
      dayDates.push(dayStart);
      dayRanges.push({
        start: dayStart,
        end: addDays(dayStart, 1)
      });
      dayStart = addDays(dayStart, 1);
    }
    return { dayDates, dayRanges };
  }
  function groupSegsByDay(segs) {
    let segsByDay = [];
    let i3;
    let seg;
    for (i3 = 0; i3 < segs.length; i3 += 1) {
      seg = segs[i3];
      (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
    }
    return segsByDay;
  }
  var css_248z3 = ':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}';
  injectStyles(css_248z3);

  // node_modules/@fullcalendar/list/index.js
  var OPTION_REFINERS = {
    listDayFormat: createFalsableFormatter,
    listDaySideFormat: createFalsableFormatter,
    noEventsClassNames: identity,
    noEventsContent: identity,
    noEventsDidMount: identity,
    noEventsWillUnmount: identity
    // noEventsText is defined in base options
  };
  function createFalsableFormatter(input) {
    return input === false ? null : createFormatter(input);
  }
  var index3 = createPlugin({
    name: "@fullcalendar/list",
    optionRefiners: OPTION_REFINERS,
    views: {
      list: {
        component: ListView,
        buttonTextKey: "list",
        listDayFormat: { month: "long", day: "numeric", year: "numeric" }
        // like "January 1, 2016"
      },
      listDay: {
        type: "list",
        duration: { days: 1 },
        listDayFormat: { weekday: "long" }
        // day-of-week is all we need. full date is probably in headerToolbar
      },
      listWeek: {
        type: "list",
        duration: { weeks: 1 },
        listDayFormat: { weekday: "long" },
        listDaySideFormat: { month: "long", day: "numeric", year: "numeric" }
      },
      listMonth: {
        type: "list",
        duration: { month: 1 },
        listDaySideFormat: { weekday: "long" }
        // day-of-week is nice-to-have
      },
      listYear: {
        type: "list",
        duration: { year: 1 },
        listDaySideFormat: { weekday: "long" }
        // day-of-week is nice-to-have
      }
    }
  });

  // node_modules/@fullcalendar/timegrid/internal.js
  var AllDaySplitter = class extends Splitter {
    getKeyInfo() {
      return {
        allDay: {},
        timed: {}
      };
    }
    getKeysForDateSpan(dateSpan) {
      if (dateSpan.allDay) {
        return ["allDay"];
      }
      return ["timed"];
    }
    getKeysForEventDef(eventDef) {
      if (!eventDef.allDay) {
        return ["timed"];
      }
      if (hasBgRendering(eventDef)) {
        return ["timed", "allDay"];
      }
      return ["allDay"];
    }
  };
  var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
    hour: "numeric",
    minute: "2-digit",
    omitZeroMinute: true,
    meridiem: "short"
  });
  function TimeColsAxisCell(props) {
    let classNames = [
      "fc-timegrid-slot",
      "fc-timegrid-slot-label",
      props.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"
    ];
    return y(ViewContextType.Consumer, null, (context) => {
      if (!props.isLabeled) {
        return y("td", { className: classNames.join(" "), "data-time": props.isoTimeStr });
      }
      let { dateEnv, options, viewApi } = context;
      let labelFormat = (
        // TODO: fully pre-parse
        options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat)
      );
      let renderProps = {
        level: 0,
        time: props.time,
        date: dateEnv.toDate(props.date),
        view: viewApi,
        text: dateEnv.format(props.date, labelFormat)
      };
      return y(ContentContainer, { elTag: "td", elClasses: classNames, elAttrs: {
        "data-time": props.isoTimeStr
      }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent4, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
        y(InnerContent, { elTag: "div", elClasses: [
          "fc-timegrid-slot-label-cushion",
          "fc-scrollgrid-shrink-cushion"
        ] })
      ));
    });
  }
  function renderInnerContent4(props) {
    return props.text;
  }
  var TimeBodyAxis = class extends BaseComponent2 {
    render() {
      return this.props.slatMetas.map((slatMeta) => y(
        "tr",
        { key: slatMeta.key },
        y(TimeColsAxisCell, Object.assign({}, slatMeta))
      ));
    }
  };
  var DEFAULT_WEEK_NUM_FORMAT2 = createFormatter({ week: "short" });
  var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
  var TimeColsView = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.allDaySplitter = new AllDaySplitter();
      this.headerElRef = d();
      this.rootElRef = d();
      this.scrollerElRef = d();
      this.state = {
        slatCoords: null
      };
      this.handleScrollTopRequest = (scrollTop) => {
        let scrollerEl = this.scrollerElRef.current;
        if (scrollerEl) {
          scrollerEl.scrollTop = scrollTop;
        }
      };
      this.renderHeadAxis = (rowKey, frameHeight = "") => {
        let { options } = this.context;
        let { dateProfile } = this.props;
        let range = dateProfile.renderRange;
        let dayCnt = diffDays(range.start, range.end);
        let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range.start, "week") : {};
        if (options.weekNumbers && rowKey === "day") {
          return y(WeekNumberContainer, { elTag: "th", elClasses: [
            "fc-timegrid-axis",
            "fc-scrollgrid-shrink"
          ], elAttrs: {
            "aria-hidden": true
          }, date: range.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT2 }, (InnerContent) => y(
            "div",
            { className: [
              "fc-timegrid-axis-frame",
              "fc-scrollgrid-shrink-frame",
              "fc-timegrid-axis-frame-liquid"
            ].join(" "), style: { height: frameHeight } },
            y(InnerContent, { elTag: "a", elClasses: [
              "fc-timegrid-axis-cushion",
              "fc-scrollgrid-shrink-cushion",
              "fc-scrollgrid-sync-inner"
            ], elAttrs: navLinkAttrs })
          ));
        }
        return y(
          "th",
          { "aria-hidden": true, className: "fc-timegrid-axis" },
          y("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })
        );
      };
      this.renderTableRowAxis = (rowHeight) => {
        let { options, viewApi } = this.context;
        let renderProps = {
          text: options.allDayText,
          view: viewApi
        };
        return (
          // TODO: make reusable hook. used in list view too
          y(ContentContainer, { elTag: "td", elClasses: [
            "fc-timegrid-axis",
            "fc-scrollgrid-shrink"
          ], elAttrs: {
            "aria-hidden": true
          }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner2, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => y(
            "div",
            { className: [
              "fc-timegrid-axis-frame",
              "fc-scrollgrid-shrink-frame",
              rowHeight == null ? " fc-timegrid-axis-frame-liquid" : ""
            ].join(" "), style: { height: rowHeight } },
            y(InnerContent, { elTag: "span", elClasses: [
              "fc-timegrid-axis-cushion",
              "fc-scrollgrid-shrink-cushion",
              "fc-scrollgrid-sync-inner"
            ] })
          ))
        );
      };
      this.handleSlatCoords = (slatCoords) => {
        this.setState({ slatCoords });
      };
    }
    // rendering
    // ----------------------------------------------------------------------------------------------------
    renderSimpleLayout(headerRowContent, allDayContent, timeContent) {
      let { context, props } = this;
      let sections = [];
      let stickyHeaderDates = getStickyHeaderDates(context.options);
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          chunk: {
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        });
      }
      if (allDayContent) {
        sections.push({
          type: "body",
          key: "all-day",
          chunk: { content: allDayContent }
        });
        sections.push({
          type: "body",
          key: "all-day-divider",
          outerContent: (
            // TODO: rename to cellContent so don't need to define <tr>?
            y(
              "tr",
              { role: "presentation", className: "fc-scrollgrid-section" },
              y("td", { className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
            )
          )
        });
      }
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        expandRows: Boolean(context.options.expandRows),
        chunk: {
          scrollerElRef: this.scrollerElRef,
          content: timeContent
        }
      });
      return y(
        ViewContainer,
        { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
        y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: "shrink" }], sections })
      );
    }
    renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
      let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
      if (!ScrollGrid) {
        throw new Error("No ScrollGrid implementation");
      }
      let { context, props } = this;
      let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
      let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
      let sections = [];
      if (headerRowContent) {
        sections.push({
          type: "header",
          key: "header",
          isSticky: stickyHeaderDates,
          syncRowHeights: true,
          chunks: [
            {
              key: "axis",
              rowContent: (arg) => y("tr", { role: "presentation" }, this.renderHeadAxis("day", arg.rowSyncHeights[0]))
            },
            {
              key: "cols",
              elRef: this.headerElRef,
              tableClassName: "fc-col-header",
              rowContent: headerRowContent
            }
          ]
        });
      }
      if (allDayContent) {
        sections.push({
          type: "body",
          key: "all-day",
          syncRowHeights: true,
          chunks: [
            {
              key: "axis",
              rowContent: (contentArg) => y("tr", { role: "presentation" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))
            },
            {
              key: "cols",
              content: allDayContent
            }
          ]
        });
        sections.push({
          key: "all-day-divider",
          type: "body",
          outerContent: (
            // TODO: rename to cellContent so don't need to define <tr>?
            y(
              "tr",
              { role: "presentation", className: "fc-scrollgrid-section" },
              y("td", { colSpan: 2, className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
            )
          )
        });
      }
      let isNowIndicator = context.options.nowIndicator;
      sections.push({
        type: "body",
        key: "body",
        liquid: true,
        expandRows: Boolean(context.options.expandRows),
        chunks: [
          {
            key: "axis",
            content: (arg) => (
              // TODO: make this now-indicator arrow more DRY with TimeColsContent
              y(
                "div",
                { className: "fc-timegrid-axis-chunk" },
                y(
                  "table",
                  { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : "" } },
                  arg.tableColGroupNode,
                  y(
                    "tbody",
                    null,
                    y(TimeBodyAxis, { slatMetas })
                  )
                ),
                y(
                  "div",
                  { className: "fc-timegrid-now-indicator-container" },
                  y(NowTimer, {
                    unit: isNowIndicator ? "minute" : "day"
                    /* hacky */
                  }, (nowDate) => {
                    let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate);
                    if (typeof nowIndicatorTop === "number") {
                      return y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate });
                    }
                    return null;
                  })
                )
              )
            )
          },
          {
            key: "cols",
            scrollerElRef: this.scrollerElRef,
            content: timeContent
          }
        ]
      });
      if (stickyFooterScrollbar) {
        sections.push({
          key: "footer",
          type: "footer",
          isSticky: true,
          chunks: [
            {
              key: "axis",
              content: renderScrollShim
            },
            {
              key: "cols",
              content: renderScrollShim
            }
          ]
        });
      }
      return y(
        ViewContainer,
        { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
        y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
          { width: "shrink", cols: [{ width: "shrink" }] },
          { cols: [{ span: colCnt, minWidth: dayMinWidth }] }
        ], sections })
      );
    }
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    getAllDayMaxEventProps() {
      let { dayMaxEvents, dayMaxEventRows } = this.context.options;
      if (dayMaxEvents === true || dayMaxEventRows === true) {
        dayMaxEvents = void 0;
        dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS;
      }
      return { dayMaxEvents, dayMaxEventRows };
    }
  };
  function renderAllDayInner2(renderProps) {
    return renderProps.text;
  }
  var TimeColsSlatsCoords = class {
    constructor(positions, dateProfile, slotDuration) {
      this.positions = positions;
      this.dateProfile = dateProfile;
      this.slotDuration = slotDuration;
    }
    safeComputeTop(date) {
      let { dateProfile } = this;
      if (rangeContainsMarker(dateProfile.currentRange, date)) {
        let startOfDayDate = startOfDay(date);
        let timeMs = date.valueOf() - startOfDayDate.valueOf();
        if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
          return this.computeTimeTop(createDuration(timeMs));
        }
      }
      return null;
    }
    // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
    computeDateTop(when, startOfDayDate) {
      if (!startOfDayDate) {
        startOfDayDate = startOfDay(when);
      }
      return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
    }
    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
    // Eventually allow computation with arbirary slat dates.
    computeTimeTop(duration2) {
      let { positions, dateProfile } = this;
      let len = positions.els.length;
      let slatCoverage = (duration2.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
      let slatIndex;
      let slatRemainder;
      slatCoverage = Math.max(0, slatCoverage);
      slatCoverage = Math.min(len, slatCoverage);
      slatIndex = Math.floor(slatCoverage);
      slatIndex = Math.min(slatIndex, len - 1);
      slatRemainder = slatCoverage - slatIndex;
      return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
    }
  };
  var TimeColsSlatsBody = class extends BaseComponent2 {
    render() {
      let { props, context } = this;
      let { options } = context;
      let { slatElRefs } = props;
      return y("tbody", null, props.slatMetas.map((slatMeta, i3) => {
        let renderProps = {
          time: slatMeta.time,
          date: context.dateEnv.toDate(slatMeta.date),
          view: context.viewApi
        };
        return y(
          "tr",
          { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
          props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)),
          y(ContentContainer, { elTag: "td", elClasses: [
            "fc-timegrid-slot",
            "fc-timegrid-slot-lane",
            !slatMeta.isLabeled && "fc-timegrid-slot-minor"
          ], elAttrs: {
            "data-time": slatMeta.isoTimeStr
          }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })
        );
      }));
    }
  };
  var TimeColsSlats = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.rootElRef = d();
      this.slatElRefs = new RefMap();
    }
    render() {
      let { props, context } = this;
      return y(
        "div",
        { ref: this.rootElRef, className: "fc-timegrid-slots" },
        y(
          "table",
          { "aria-hidden": true, className: context.theme.getClass("table"), style: {
            minWidth: props.tableMinWidth,
            width: props.clientWidth,
            height: props.minHeight
          } },
          props.tableColGroupNode,
          y(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas })
        )
      );
    }
    componentDidMount() {
      this.updateSizing();
    }
    componentDidUpdate() {
      this.updateSizing();
    }
    componentWillUnmount() {
      if (this.props.onCoords) {
        this.props.onCoords(null);
      }
    }
    updateSizing() {
      let { context, props } = this;
      if (props.onCoords && props.clientWidth !== null) {
        let rootEl = this.rootElRef.current;
        if (rootEl.offsetHeight) {
          props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
        }
      }
    }
  };
  function collectSlatEls(elMap, slatMetas) {
    return slatMetas.map((slatMeta) => elMap[slatMeta.key]);
  }
  function splitSegsByCol(segs, colCnt) {
    let segsByCol = [];
    let i3;
    for (i3 = 0; i3 < colCnt; i3 += 1) {
      segsByCol.push([]);
    }
    if (segs) {
      for (i3 = 0; i3 < segs.length; i3 += 1) {
        segsByCol[segs[i3].col].push(segs[i3]);
      }
    }
    return segsByCol;
  }
  function splitInteractionByCol(ui, colCnt) {
    let byRow = [];
    if (!ui) {
      for (let i3 = 0; i3 < colCnt; i3 += 1) {
        byRow[i3] = null;
      }
    } else {
      for (let i3 = 0; i3 < colCnt; i3 += 1) {
        byRow[i3] = {
          affectedInstances: ui.affectedInstances,
          isEvent: ui.isEvent,
          segs: []
        };
      }
      for (let seg of ui.segs) {
        byRow[seg.col].segs.push(seg);
      }
    }
    return byRow;
  }
  var TimeColMoreLink = class extends BaseComponent2 {
    render() {
      let { props } = this;
      return y(MoreLinkContainer, { elClasses: ["fc-timegrid-more-link"], elStyle: {
        top: props.top,
        bottom: props.bottom
      }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner2, forceTimed: true }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"] }));
    }
  };
  function renderMoreLinkInner2(props) {
    return props.shortText;
  }
  function buildPositioning(segInputs, strictOrder, maxStackCnt) {
    let hierarchy = new SegHierarchy();
    if (strictOrder != null) {
      hierarchy.strictOrder = strictOrder;
    }
    if (maxStackCnt != null) {
      hierarchy.maxStackCnt = maxStackCnt;
    }
    let hiddenEntries = hierarchy.addSegs(segInputs);
    let hiddenGroups = groupIntersectingEntries(hiddenEntries);
    let web = buildWeb(hierarchy);
    web = stretchWeb(web, 1);
    let segRects = webToRects(web);
    return { segRects, hiddenGroups };
  }
  function buildWeb(hierarchy) {
    const { entriesByLevel } = hierarchy;
    const buildNode = cacheable((level, lateral) => level + ":" + lateral, (level, lateral) => {
      let siblingRange = findNextLevelSegs(hierarchy, level, lateral);
      let nextLevelRes = buildNodes(siblingRange, buildNode);
      let entry = entriesByLevel[level][lateral];
      return [
        Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
        entry.thickness + nextLevelRes[1]
        // the pressure builds
      ];
    });
    return buildNodes(entriesByLevel.length ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length } : null, buildNode)[0];
  }
  function buildNodes(siblingRange, buildNode) {
    if (!siblingRange) {
      return [[], 0];
    }
    let { level, lateralStart, lateralEnd } = siblingRange;
    let lateral = lateralStart;
    let pairs = [];
    while (lateral < lateralEnd) {
      pairs.push(buildNode(level, lateral));
      lateral += 1;
    }
    pairs.sort(cmpDescPressures);
    return [
      pairs.map(extractNode),
      pairs[0][1]
      // first item's pressure
    ];
  }
  function cmpDescPressures(a3, b3) {
    return b3[1] - a3[1];
  }
  function extractNode(a3) {
    return a3[0];
  }
  function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
    let { levelCoords, entriesByLevel } = hierarchy;
    let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
    let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
    let levelCnt = levelCoords.length;
    let level = subjectLevel;
    for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
      ;
    for (; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let entry;
      let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
      let lateralStart = searchIndex[0] + searchIndex[1];
      let lateralEnd = lateralStart;
      while (
        // loop through entries that horizontally intersect
        (entry = entries[lateralEnd]) && // but not past the whole seg list
        entry.span.start < subjectEntry.span.end
      ) {
        lateralEnd += 1;
      }
      if (lateralStart < lateralEnd) {
        return { level, lateralStart, lateralEnd };
      }
    }
    return null;
  }
  function stretchWeb(topLevelNodes, totalThickness) {
    const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {
      let { nextLevelNodes, thickness } = node;
      let allThickness = thickness + prevThickness;
      let thicknessFraction = thickness / allThickness;
      let endCoord;
      let newChildren = [];
      if (!nextLevelNodes.length) {
        endCoord = totalThickness;
      } else {
        for (let childNode of nextLevelNodes) {
          if (endCoord === void 0) {
            let res = stretchNode(childNode, startCoord, allThickness);
            endCoord = res[0];
            newChildren.push(res[1]);
          } else {
            let res = stretchNode(childNode, endCoord, 0);
            newChildren.push(res[1]);
          }
        }
      }
      let newThickness = (endCoord - startCoord) * thicknessFraction;
      return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
    });
    return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);
  }
  function webToRects(topLevelNodes) {
    let rects = [];
    const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {
      let rect = Object.assign(Object.assign({}, node), {
        levelCoord,
        stackDepth,
        stackForward: 0
      });
      rects.push(rect);
      return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
    });
    function processNodes(nodes, levelCoord, stackDepth) {
      let stackForward = 0;
      for (let node of nodes) {
        stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
      }
      return stackForward;
    }
    processNodes(topLevelNodes, 0, 0);
    return rects;
  }
  function cacheable(keyFunc, workFunc) {
    const cache = {};
    return (...args) => {
      let key = keyFunc(...args);
      return key in cache ? cache[key] : cache[key] = workFunc(...args);
    };
  }
  function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {
    let vcoords = [];
    if (slatCoords) {
      for (let i3 = 0; i3 < segs.length; i3 += 1) {
        let seg = segs[i3];
        let spanStart = slatCoords.computeDateTop(seg.start, colDate);
        let spanEnd = Math.max(
          spanStart + (eventMinHeight || 0),
          // :(
          slatCoords.computeDateTop(seg.end, colDate)
        );
        vcoords.push({
          start: Math.round(spanStart),
          end: Math.round(spanEnd)
          //
        });
      }
    }
    return vcoords;
  }
  function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
    let segInputs = [];
    let dumbSegs = [];
    for (let i3 = 0; i3 < segs.length; i3 += 1) {
      let vcoords = segVCoords[i3];
      if (vcoords) {
        segInputs.push({
          index: i3,
          thickness: 1,
          span: vcoords
        });
      } else {
        dumbSegs.push(segs[i3]);
      }
    }
    let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);
    let segPlacements = [];
    for (let segRect of segRects) {
      segPlacements.push({
        seg: segs[segRect.index],
        rect: segRect
      });
    }
    for (let dumbSeg of dumbSegs) {
      segPlacements.push({ seg: dumbSeg, rect: null });
    }
    return { segPlacements, hiddenGroups };
  }
  var DEFAULT_TIME_FORMAT2 = createFormatter({
    hour: "numeric",
    minute: "2-digit",
    meridiem: false
  });
  var TimeColEvent = class extends BaseComponent2 {
    render() {
      return y(StandardEvent, Object.assign({}, this.props, { elClasses: [
        "fc-timegrid-event",
        "fc-v-event",
        this.props.isShort && "fc-timegrid-event-short"
      ], defaultTimeFormat: DEFAULT_TIME_FORMAT2 }));
    }
  };
  var TimeCol = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.sortEventSegs = memoize(sortEventSegs);
    }
    // TODO: memoize event-placement?
    render() {
      let { props, context } = this;
      let { options } = context;
      let isSelectMirror = options.selectMirror;
      let mirrorSegs = (
        // yuck
        props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || []
      );
      let interactionAffectedInstances = (
        // TODO: messy way to compute this
        props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
      );
      let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);
      return y(DayCellContainer, { elTag: "td", elRef: props.elRef, elClasses: [
        "fc-timegrid-col",
        ...props.extraClassNames || []
      ], elAttrs: Object.assign({ role: "gridcell" }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => y(
        "div",
        { className: "fc-timegrid-col-frame" },
        y(
          "div",
          { className: "fc-timegrid-col-bg" },
          this.renderFillSegs(props.businessHourSegs, "non-business"),
          this.renderFillSegs(props.bgEventSegs, "bg-event"),
          this.renderFillSegs(props.dateSelectionSegs, "highlight")
        ),
        y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
        y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), "mirror")),
        y("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(props.nowIndicatorSegs)),
        hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-col-misc"] })
      ));
    }
    renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
      let { props } = this;
      if (props.forPrint) {
        return renderPlainFgSegs(sortedFgSegs, props);
      }
      return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);
    }
    renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
      let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;
      let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;
      let isMirror = isDragging || isResizing || isDateSelecting;
      let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
      let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);
      return y(
        _,
        null,
        this.renderHiddenGroups(hiddenGroups, segs),
        segPlacements.map((segPlacement) => {
          let { seg, rect } = segPlacement;
          let instanceId = seg.eventRange.instance.instanceId;
          let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
          let vStyle = computeSegVStyle(rect && rect.span);
          let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : { left: 0, right: 0 };
          let isInset = Boolean(rect) && rect.stackForward > 0;
          let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight;
          return y(
            "div",
            { className: "fc-timegrid-event-harness" + (isInset ? " fc-timegrid-event-harness-inset" : ""), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? "" : "hidden" }, vStyle), hStyle) },
            y(TimeColEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, isShort }, getSegMeta(seg, todayRange, nowDate)))
          );
        })
      );
    }
    // will already have eventMinHeight applied because segInputs already had it
    renderHiddenGroups(hiddenGroups, segs) {
      let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;
      return y(_, null, hiddenGroups.map((hiddenGroup) => {
        let positionCss = computeSegVStyle(hiddenGroup.span);
        let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
        return y(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize });
      }));
    }
    renderFillSegs(segs, fillType) {
      let { props, context } = this;
      let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight);
      let children = segVCoords.map((vcoords, i3) => {
        let seg = segs[i3];
        return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
      });
      return y(_, null, children);
    }
    renderNowIndicator(segs) {
      let { slatCoords, date } = this.props;
      if (!slatCoords) {
        return null;
      }
      return segs.map((seg, i3) => y(
        NowIndicatorContainer,
        {
          // key doesn't matter. will only ever be one
          key: i3,
          elClasses: ["fc-timegrid-now-indicator-line"],
          elStyle: {
            top: slatCoords.computeDateTop(seg.start, date)
          },
          isAxis: false,
          date
        }
      ));
    }
    computeSegHStyle(segHCoords) {
      let { isRtl, options } = this.context;
      let shouldOverlap = options.slotEventOverlap;
      let nearCoord = segHCoords.levelCoord;
      let farCoord = segHCoords.levelCoord + segHCoords.thickness;
      let left;
      let right;
      if (shouldOverlap) {
        farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
      }
      if (isRtl) {
        left = 1 - farCoord;
        right = nearCoord;
      } else {
        left = nearCoord;
        right = 1 - farCoord;
      }
      let props = {
        zIndex: segHCoords.stackDepth + 1,
        left: left * 100 + "%",
        right: right * 100 + "%"
      };
      if (shouldOverlap && !segHCoords.stackForward) {
        props[isRtl ? "marginLeft" : "marginRight"] = 10 * 2;
      }
      return props;
    }
  };
  function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {
    let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
    return y(_, null, sortedFgSegs.map((seg) => {
      let instanceId = seg.eventRange.instance.instanceId;
      return y(
        "div",
        { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? "hidden" : "" } },
        y(TimeColEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))
      );
    }));
  }
  function computeSegVStyle(segVCoords) {
    if (!segVCoords) {
      return { top: "", bottom: "" };
    }
    return {
      top: segVCoords.start,
      bottom: -segVCoords.end
    };
  }
  function compileSegsFromEntries(segEntries, allSegs) {
    return segEntries.map((segEntry) => allSegs[segEntry.index]);
  }
  var TimeColsContent = class extends BaseComponent2 {
    constructor() {
      super(...arguments);
      this.splitFgEventSegs = memoize(splitSegsByCol);
      this.splitBgEventSegs = memoize(splitSegsByCol);
      this.splitBusinessHourSegs = memoize(splitSegsByCol);
      this.splitNowIndicatorSegs = memoize(splitSegsByCol);
      this.splitDateSelectionSegs = memoize(splitSegsByCol);
      this.splitEventDrag = memoize(splitInteractionByCol);
      this.splitEventResize = memoize(splitInteractionByCol);
      this.rootElRef = d();
      this.cellElRefs = new RefMap();
    }
    render() {
      let { props, context } = this;
      let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate);
      let colCnt = props.cells.length;
      let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
      let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
      let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
      let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
      let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
      let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
      let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
      return y(
        "div",
        { className: "fc-timegrid-cols", ref: this.rootElRef },
        y(
          "table",
          { role: "presentation", style: {
            minWidth: props.tableMinWidth,
            width: props.clientWidth
          } },
          props.tableColGroupNode,
          y(
            "tbody",
            { role: "presentation" },
            y(
              "tr",
              { role: "row" },
              props.axis && y(
                "td",
                { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
                y(
                  "div",
                  { className: "fc-timegrid-col-frame" },
                  y("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === "number" && y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate }))
                )
              ),
              props.cells.map((cell, i3) => y(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i3], bgEventSegs: bgEventSegsByRow[i3], businessHourSegs: businessHourSegsByRow[i3], nowIndicatorSegs: nowIndicatorSegsByRow[i3], dateSelectionSegs: dateSelectionSegsByRow[i3], eventDrag: eventDragByRow[i3], eventResize: eventResizeByRow[i3], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))
            )
          )
        )
      );
    }
    componentDidMount() {
      this.updateCoords();
    }
    componentDidUpdate() {
      this.updateCoords();
    }
    updateCoords() {
      let { props } = this;
      if (props.onColCoords && props.clientWidth !== null) {
        props.onColCoords(new PositionCache(
          this.rootElRef.current,
          collectCellEls(this.cellElRefs.currentMap, props.cells),
          true,
          // horizontal
          false
        ));
      }
    }
  };
  function collectCellEls(elMap, cells) {
    return cells.map((cell) => elMap[cell.key]);
  }
  var TimeCols = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.processSlotOptions = memoize(processSlotOptions);
      this.state = {
        slatCoords: null
      };
      this.handleRootEl = (el) => {
        if (el) {
          this.context.registerInteractiveComponent(this, {
            el,
            isHitComboAllowed: this.props.isHitComboAllowed
          });
        } else {
          this.context.unregisterInteractiveComponent(this);
        }
      };
      this.handleScrollRequest = (request) => {
        let { onScrollTopRequest } = this.props;
        let { slatCoords } = this.state;
        if (onScrollTopRequest && slatCoords) {
          if (request.time) {
            let top = slatCoords.computeTimeTop(request.time);
            top = Math.ceil(top);
            if (top) {
              top += 1;
            }
            onScrollTopRequest(top);
          }
          return true;
        }
        return false;
      };
      this.handleColCoords = (colCoords) => {
        this.colCoords = colCoords;
      };
      this.handleSlatCoords = (slatCoords) => {
        this.setState({ slatCoords });
        if (this.props.onSlatCoords) {
          this.props.onSlatCoords(slatCoords);
        }
      };
    }
    render() {
      let { props, state } = this;
      return y(
        "div",
        { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
          // these props are important to give this wrapper correct dimensions for interactions
          // TODO: if we set it here, can we avoid giving to inner tables?
          width: props.clientWidth,
          minWidth: props.tableMinWidth
        } },
        y(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null, onCoords: this.handleSlatCoords }),
        y(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })
      );
    }
    componentDidMount() {
      this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
    }
    componentDidUpdate(prevProps) {
      this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
    }
    componentWillUnmount() {
      this.scrollResponder.detach();
    }
    queryHit(positionLeft, positionTop) {
      let { dateEnv, options } = this.context;
      let { colCoords } = this;
      let { dateProfile } = this.props;
      let { slatCoords } = this.state;
      let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);
      let colIndex = colCoords.leftToIndex(positionLeft);
      let slatIndex = slatCoords.positions.topToIndex(positionTop);
      if (colIndex != null && slatIndex != null) {
        let cell = this.props.cells[colIndex];
        let slatTop = slatCoords.positions.tops[slatIndex];
        let slatHeight = slatCoords.positions.getHeight(slatIndex);
        let partial = (positionTop - slatTop) / slatHeight;
        let localSnapIndex = Math.floor(partial * snapsPerSlot);
        let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
        let dayDate = this.props.cells[colIndex].date;
        let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
        let start2 = dateEnv.add(dayDate, time);
        let end = dateEnv.add(start2, snapDuration);
        return {
          dateProfile,
          dateSpan: Object.assign({ range: { start: start2, end }, allDay: false }, cell.extraDateSpan),
          dayEl: colCoords.els[colIndex],
          rect: {
            left: colCoords.lefts[colIndex],
            right: colCoords.rights[colIndex],
            top: slatTop,
            bottom: slatTop + slatHeight
          },
          layer: 0
        };
      }
      return null;
    }
  };
  function processSlotOptions(slotDuration, snapDurationOverride) {
    let snapDuration = snapDurationOverride || slotDuration;
    let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
    if (snapsPerSlot === null) {
      snapDuration = slotDuration;
      snapsPerSlot = 1;
    }
    return { snapDuration, snapsPerSlot };
  }
  var DayTimeColsSlicer = class extends Slicer {
    sliceRange(range, dayRanges) {
      let segs = [];
      for (let col = 0; col < dayRanges.length; col += 1) {
        let segRange = intersectRanges(range, dayRanges[col]);
        if (segRange) {
          segs.push({
            start: segRange.start,
            end: segRange.end,
            isStart: segRange.start.valueOf() === range.start.valueOf(),
            isEnd: segRange.end.valueOf() === range.end.valueOf(),
            col
          });
        }
      }
      return segs;
    }
  };
  var DayTimeCols = class extends DateComponent {
    constructor() {
      super(...arguments);
      this.buildDayRanges = memoize(buildDayRanges);
      this.slicer = new DayTimeColsSlicer();
      this.timeColsRef = d();
    }
    render() {
      let { props, context } = this;
      let { dateProfile, dayTableModel } = props;
      let { nowIndicator, nextDayThreshold } = context.options;
      let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
      return y(NowTimer, { unit: nowIndicator ? "minute" : "day" }, (nowDate, todayRange) => y(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })));
    }
  };
  function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
    let ranges = [];
    for (let date of dayTableModel.headerDates) {
      ranges.push({
        start: dateEnv.add(date, dateProfile.slotMinTime),
        end: dateEnv.add(date, dateProfile.slotMaxTime)
      });
    }
    return ranges;
  }
  var STOCK_SUB_DURATIONS = [
    { hours: 1 },
    { minutes: 30 },
    { minutes: 15 },
    { seconds: 30 },
    { seconds: 15 }
  ];
  function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
    let dayStart = /* @__PURE__ */ new Date(0);
    let slatTime = slotMinTime;
    let slatIterator = createDuration(0);
    let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
    let metas = [];
    while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
      let date = dateEnv.add(dayStart, slatTime);
      let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
      metas.push({
        date,
        time: slatTime,
        key: date.toISOString(),
        isoTimeStr: formatIsoTimeString(date),
        isLabeled
      });
      slatTime = addDurations(slatTime, slotDuration);
      slatIterator = addDurations(slatIterator, slotDuration);
    }
    return metas;
  }
  function computeLabelInterval(slotDuration) {
    let i3;
    let labelInterval;
    let slotsPerLabel;
    for (i3 = STOCK_SUB_DURATIONS.length - 1; i3 >= 0; i3 -= 1) {
      labelInterval = createDuration(STOCK_SUB_DURATIONS[i3]);
      slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
      if (slotsPerLabel !== null && slotsPerLabel > 1) {
        return labelInterval;
      }
    }
    return slotDuration;
  }
  var DayTimeColsView = class extends TimeColsView {
    constructor() {
      super(...arguments);
      this.buildTimeColsModel = memoize(buildTimeColsModel);
      this.buildSlatMetas = memoize(buildSlatMetas);
    }
    render() {
      let { options, dateEnv, dateProfileGenerator } = this.context;
      let { props } = this;
      let { dateProfile } = props;
      let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
      let splitProps = this.allDaySplitter.splitProps(props);
      let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
      let { dayMinWidth } = options;
      let hasAttachedAxis = !dayMinWidth;
      let hasDetachedAxis = dayMinWidth;
      let headerContent = options.dayHeaders && y(DayHeader, { dates: dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
      let allDayContent = options.allDaySlot !== false && ((contentArg) => y(DayTable, Object.assign({}, splitProps.allDay, { dateProfile, dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps())));
      let timeGridContent = (contentArg) => y(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel, dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest }));
      return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
    }
  };
  function buildTimeColsModel(dateProfile, dateProfileGenerator) {
    let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
    return new DayTableModel(daySeries, false);
  }
  var css_248z4 = '.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}';
  injectStyles(css_248z4);

  // node_modules/@fullcalendar/timegrid/index.js
  var OPTION_REFINERS2 = {
    allDaySlot: Boolean
  };
  var index4 = createPlugin({
    name: "@fullcalendar/timegrid",
    initialView: "timeGridWeek",
    optionRefiners: OPTION_REFINERS2,
    views: {
      timeGrid: {
        component: DayTimeColsView,
        usesMinMaxTime: true,
        allDaySlot: true,
        slotDuration: "00:30:00",
        slotEventOverlap: true
        // a bad name. confused with overlap/constraint system
      },
      timeGridDay: {
        type: "timeGrid",
        duration: { days: 1 }
      },
      timeGridWeek: {
        type: "timeGrid",
        duration: { weeks: 1 }
      }
    }
  });

  // node_modules/@fullcalendar/interaction/index.js
  config.touchMouseIgnoreWait = 500;
  var ignoreMouseDepth = 0;
  var listenerCnt = 0;
  var isWindowTouchMoveCancelled = false;
  var PointerDragging = class {
    constructor(containerEl) {
      this.subjectEl = null;
      this.selector = "";
      this.handleSelector = "";
      this.shouldIgnoreMove = false;
      this.shouldWatchScroll = true;
      this.isDragging = false;
      this.isTouchDragging = false;
      this.wasTouchScroll = false;
      this.handleMouseDown = (ev) => {
        if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
          let pev = this.createEventFromMouse(ev, true);
          this.emitter.trigger("pointerdown", pev);
          this.initScrollWatch(pev);
          if (!this.shouldIgnoreMove) {
            document.addEventListener("mousemove", this.handleMouseMove);
          }
          document.addEventListener("mouseup", this.handleMouseUp);
        }
      };
      this.handleMouseMove = (ev) => {
        let pev = this.createEventFromMouse(ev);
        this.recordCoords(pev);
        this.emitter.trigger("pointermove", pev);
      };
      this.handleMouseUp = (ev) => {
        document.removeEventListener("mousemove", this.handleMouseMove);
        document.removeEventListener("mouseup", this.handleMouseUp);
        this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
        this.cleanup();
      };
      this.handleTouchStart = (ev) => {
        if (this.tryStart(ev)) {
          this.isTouchDragging = true;
          let pev = this.createEventFromTouch(ev, true);
          this.emitter.trigger("pointerdown", pev);
          this.initScrollWatch(pev);
          let targetEl = ev.target;
          if (!this.shouldIgnoreMove) {
            targetEl.addEventListener("touchmove", this.handleTouchMove);
          }
          targetEl.addEventListener("touchend", this.handleTouchEnd);
          targetEl.addEventListener("touchcancel", this.handleTouchEnd);
          window.addEventListener("scroll", this.handleTouchScroll, true);
        }
      };
      this.handleTouchMove = (ev) => {
        let pev = this.createEventFromTouch(ev);
        this.recordCoords(pev);
        this.emitter.trigger("pointermove", pev);
      };
      this.handleTouchEnd = (ev) => {
        if (this.isDragging) {
          let targetEl = ev.target;
          targetEl.removeEventListener("touchmove", this.handleTouchMove);
          targetEl.removeEventListener("touchend", this.handleTouchEnd);
          targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
          window.removeEventListener("scroll", this.handleTouchScroll, true);
          this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
          this.cleanup();
          this.isTouchDragging = false;
          startIgnoringMouse();
        }
      };
      this.handleTouchScroll = () => {
        this.wasTouchScroll = true;
      };
      this.handleScroll = (ev) => {
        if (!this.shouldIgnoreMove) {
          let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
          let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
          this.emitter.trigger("pointermove", {
            origEvent: ev,
            isTouch: this.isTouchDragging,
            subjectEl: this.subjectEl,
            pageX,
            pageY,
            deltaX: pageX - this.origPageX,
            deltaY: pageY - this.origPageY
          });
        }
      };
      this.containerEl = containerEl;
      this.emitter = new Emitter();
      containerEl.addEventListener("mousedown", this.handleMouseDown);
      containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
      listenerCreated();
    }
    destroy() {
      this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
      this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
      listenerDestroyed();
    }
    tryStart(ev) {
      let subjectEl = this.querySubjectEl(ev);
      let downEl = ev.target;
      if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
        this.subjectEl = subjectEl;
        this.isDragging = true;
        this.wasTouchScroll = false;
        return true;
      }
      return false;
    }
    cleanup() {
      isWindowTouchMoveCancelled = false;
      this.isDragging = false;
      this.subjectEl = null;
      this.destroyScrollWatch();
    }
    querySubjectEl(ev) {
      if (this.selector) {
        return elementClosest(ev.target, this.selector);
      }
      return this.containerEl;
    }
    shouldIgnoreMouse() {
      return ignoreMouseDepth || this.isTouchDragging;
    }
    // can be called by user of this class, to cancel touch-based scrolling for the current drag
    cancelTouchScroll() {
      if (this.isDragging) {
        isWindowTouchMoveCancelled = true;
      }
    }
    // Scrolling that simulates pointermoves
    // ----------------------------------------------------------------------------------------------------
    initScrollWatch(ev) {
      if (this.shouldWatchScroll) {
        this.recordCoords(ev);
        window.addEventListener("scroll", this.handleScroll, true);
      }
    }
    recordCoords(ev) {
      if (this.shouldWatchScroll) {
        this.prevPageX = ev.pageX;
        this.prevPageY = ev.pageY;
        this.prevScrollX = window.scrollX;
        this.prevScrollY = window.scrollY;
      }
    }
    destroyScrollWatch() {
      if (this.shouldWatchScroll) {
        window.removeEventListener("scroll", this.handleScroll, true);
      }
    }
    // Event Normalization
    // ----------------------------------------------------------------------------------------------------
    createEventFromMouse(ev, isFirst) {
      let deltaX = 0;
      let deltaY = 0;
      if (isFirst) {
        this.origPageX = ev.pageX;
        this.origPageY = ev.pageY;
      } else {
        deltaX = ev.pageX - this.origPageX;
        deltaY = ev.pageY - this.origPageY;
      }
      return {
        origEvent: ev,
        isTouch: false,
        subjectEl: this.subjectEl,
        pageX: ev.pageX,
        pageY: ev.pageY,
        deltaX,
        deltaY
      };
    }
    createEventFromTouch(ev, isFirst) {
      let touches = ev.touches;
      let pageX;
      let pageY;
      let deltaX = 0;
      let deltaY = 0;
      if (touches && touches.length) {
        pageX = touches[0].pageX;
        pageY = touches[0].pageY;
      } else {
        pageX = ev.pageX;
        pageY = ev.pageY;
      }
      if (isFirst) {
        this.origPageX = pageX;
        this.origPageY = pageY;
      } else {
        deltaX = pageX - this.origPageX;
        deltaY = pageY - this.origPageY;
      }
      return {
        origEvent: ev,
        isTouch: true,
        subjectEl: this.subjectEl,
        pageX,
        pageY,
        deltaX,
        deltaY
      };
    }
  };
  function isPrimaryMouseButton(ev) {
    return ev.button === 0 && !ev.ctrlKey;
  }
  function startIgnoringMouse() {
    ignoreMouseDepth += 1;
    setTimeout(() => {
      ignoreMouseDepth -= 1;
    }, config.touchMouseIgnoreWait);
  }
  function listenerCreated() {
    listenerCnt += 1;
    if (listenerCnt === 1) {
      window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
    }
  }
  function listenerDestroyed() {
    listenerCnt -= 1;
    if (!listenerCnt) {
      window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
    }
  }
  function onWindowTouchMove(ev) {
    if (isWindowTouchMoveCancelled) {
      ev.preventDefault();
    }
  }
  var ElementMirror = class {
    constructor() {
      this.isVisible = false;
      this.sourceEl = null;
      this.mirrorEl = null;
      this.sourceElRect = null;
      this.parentNode = document.body;
      this.zIndex = 9999;
      this.revertDuration = 0;
    }
    start(sourceEl, pageX, pageY) {
      this.sourceEl = sourceEl;
      this.sourceElRect = this.sourceEl.getBoundingClientRect();
      this.origScreenX = pageX - window.scrollX;
      this.origScreenY = pageY - window.scrollY;
      this.deltaX = 0;
      this.deltaY = 0;
      this.updateElPosition();
    }
    handleMove(pageX, pageY) {
      this.deltaX = pageX - window.scrollX - this.origScreenX;
      this.deltaY = pageY - window.scrollY - this.origScreenY;
      this.updateElPosition();
    }
    // can be called before start
    setIsVisible(bool) {
      if (bool) {
        if (!this.isVisible) {
          if (this.mirrorEl) {
            this.mirrorEl.style.display = "";
          }
          this.isVisible = bool;
          this.updateElPosition();
        }
      } else if (this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "none";
        }
        this.isVisible = bool;
      }
    }
    // always async
    stop(needsRevertAnimation, callback) {
      let done = () => {
        this.cleanup();
        callback();
      };
      if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
      (this.deltaX || this.deltaY)) {
        this.doRevertAnimation(done, this.revertDuration);
      } else {
        setTimeout(done, 0);
      }
    }
    doRevertAnimation(callback, revertDuration) {
      let mirrorEl = this.mirrorEl;
      let finalSourceElRect = this.sourceEl.getBoundingClientRect();
      mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
      applyStyle(mirrorEl, {
        left: finalSourceElRect.left,
        top: finalSourceElRect.top
      });
      whenTransitionDone(mirrorEl, () => {
        mirrorEl.style.transition = "";
        callback();
      });
    }
    cleanup() {
      if (this.mirrorEl) {
        removeElement3(this.mirrorEl);
        this.mirrorEl = null;
      }
      this.sourceEl = null;
    }
    updateElPosition() {
      if (this.sourceEl && this.isVisible) {
        applyStyle(this.getMirrorEl(), {
          left: this.sourceElRect.left + this.deltaX,
          top: this.sourceElRect.top + this.deltaY
        });
      }
    }
    getMirrorEl() {
      let sourceElRect = this.sourceElRect;
      let mirrorEl = this.mirrorEl;
      if (!mirrorEl) {
        mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
        mirrorEl.style.userSelect = "none";
        mirrorEl.style.webkitUserSelect = "none";
        mirrorEl.style.pointerEvents = "none";
        mirrorEl.classList.add("fc-event-dragging");
        applyStyle(mirrorEl, {
          position: "fixed",
          zIndex: this.zIndex,
          visibility: "",
          boxSizing: "border-box",
          width: sourceElRect.right - sourceElRect.left,
          height: sourceElRect.bottom - sourceElRect.top,
          right: "auto",
          bottom: "auto",
          margin: 0
        });
        this.parentNode.appendChild(mirrorEl);
      }
      return mirrorEl;
    }
  };
  var ScrollGeomCache = class extends ScrollController {
    constructor(scrollController, doesListening) {
      super();
      this.handleScroll = () => {
        this.scrollTop = this.scrollController.getScrollTop();
        this.scrollLeft = this.scrollController.getScrollLeft();
        this.handleScrollChange();
      };
      this.scrollController = scrollController;
      this.doesListening = doesListening;
      this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
      this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
      this.scrollWidth = scrollController.getScrollWidth();
      this.scrollHeight = scrollController.getScrollHeight();
      this.clientWidth = scrollController.getClientWidth();
      this.clientHeight = scrollController.getClientHeight();
      this.clientRect = this.computeClientRect();
      if (this.doesListening) {
        this.getEventTarget().addEventListener("scroll", this.handleScroll);
      }
    }
    destroy() {
      if (this.doesListening) {
        this.getEventTarget().removeEventListener("scroll", this.handleScroll);
      }
    }
    getScrollTop() {
      return this.scrollTop;
    }
    getScrollLeft() {
      return this.scrollLeft;
    }
    setScrollTop(top) {
      this.scrollController.setScrollTop(top);
      if (!this.doesListening) {
        this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
        this.handleScrollChange();
      }
    }
    setScrollLeft(top) {
      this.scrollController.setScrollLeft(top);
      if (!this.doesListening) {
        this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
        this.handleScrollChange();
      }
    }
    getClientWidth() {
      return this.clientWidth;
    }
    getClientHeight() {
      return this.clientHeight;
    }
    getScrollWidth() {
      return this.scrollWidth;
    }
    getScrollHeight() {
      return this.scrollHeight;
    }
    handleScrollChange() {
    }
  };
  var ElementScrollGeomCache = class extends ScrollGeomCache {
    constructor(el, doesListening) {
      super(new ElementScrollController(el), doesListening);
    }
    getEventTarget() {
      return this.scrollController.el;
    }
    computeClientRect() {
      return computeInnerRect(this.scrollController.el);
    }
  };
  var WindowScrollGeomCache = class extends ScrollGeomCache {
    constructor(doesListening) {
      super(new WindowScrollController(), doesListening);
    }
    getEventTarget() {
      return window;
    }
    computeClientRect() {
      return {
        left: this.scrollLeft,
        right: this.scrollLeft + this.clientWidth,
        top: this.scrollTop,
        bottom: this.scrollTop + this.clientHeight
      };
    }
    // the window is the only scroll object that changes it's rectangle relative
    // to the document's topleft as it scrolls
    handleScrollChange() {
      this.clientRect = this.computeClientRect();
    }
  };
  var getTime = typeof performance === "function" ? performance.now : Date.now;
  var AutoScroller = class {
    constructor() {
      this.isEnabled = true;
      this.scrollQuery = [window, ".fc-scroller"];
      this.edgeThreshold = 50;
      this.maxVelocity = 300;
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.isAnimating = false;
      this.scrollCaches = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.animate = () => {
        if (this.isAnimating) {
          let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
          if (edge) {
            let now = getTime();
            this.handleSide(edge, (now - this.msSinceRequest) / 1e3);
            this.requestAnimation(now);
          } else {
            this.isAnimating = false;
          }
        }
      };
    }
    start(pageX, pageY, scrollStartEl) {
      if (this.isEnabled) {
        this.scrollCaches = this.buildCaches(scrollStartEl);
        this.pointerScreenX = null;
        this.pointerScreenY = null;
        this.everMovedUp = false;
        this.everMovedDown = false;
        this.everMovedLeft = false;
        this.everMovedRight = false;
        this.handleMove(pageX, pageY);
      }
    }
    handleMove(pageX, pageY) {
      if (this.isEnabled) {
        let pointerScreenX = pageX - window.scrollX;
        let pointerScreenY = pageY - window.scrollY;
        let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
        let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
        if (yDelta < 0) {
          this.everMovedUp = true;
        } else if (yDelta > 0) {
          this.everMovedDown = true;
        }
        if (xDelta < 0) {
          this.everMovedLeft = true;
        } else if (xDelta > 0) {
          this.everMovedRight = true;
        }
        this.pointerScreenX = pointerScreenX;
        this.pointerScreenY = pointerScreenY;
        if (!this.isAnimating) {
          this.isAnimating = true;
          this.requestAnimation(getTime());
        }
      }
    }
    stop() {
      if (this.isEnabled) {
        this.isAnimating = false;
        for (let scrollCache of this.scrollCaches) {
          scrollCache.destroy();
        }
        this.scrollCaches = null;
      }
    }
    requestAnimation(now) {
      this.msSinceRequest = now;
      requestAnimationFrame(this.animate);
    }
    handleSide(edge, seconds) {
      let { scrollCache } = edge;
      let { edgeThreshold } = this;
      let invDistance = edgeThreshold - edge.distance;
      let velocity = (
        // the closer to the edge, the faster we scroll
        invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
        this.maxVelocity * seconds
      );
      let sign = 1;
      switch (edge.name) {
        case "left":
          sign = -1;
        // falls through
        case "right":
          scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
          break;
        case "top":
          sign = -1;
        // falls through
        case "bottom":
          scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
          break;
      }
    }
    // left/top are relative to document topleft
    computeBestEdge(left, top) {
      let { edgeThreshold } = this;
      let bestSide = null;
      let scrollCaches = this.scrollCaches || [];
      for (let scrollCache of scrollCaches) {
        let rect = scrollCache.clientRect;
        let leftDist = left - rect.left;
        let rightDist = rect.right - left;
        let topDist = top - rect.top;
        let bottomDist = rect.bottom - top;
        if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
          if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
            bestSide = { scrollCache, name: "top", distance: topDist };
          }
          if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
            bestSide = { scrollCache, name: "bottom", distance: bottomDist };
          }
          if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
            bestSide = { scrollCache, name: "left", distance: leftDist };
          }
          if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
            bestSide = { scrollCache, name: "right", distance: rightDist };
          }
        }
      }
      return bestSide;
    }
    buildCaches(scrollStartEl) {
      return this.queryScrollEls(scrollStartEl).map((el) => {
        if (el === window) {
          return new WindowScrollGeomCache(false);
        }
        return new ElementScrollGeomCache(el, false);
      });
    }
    queryScrollEls(scrollStartEl) {
      let els = [];
      for (let query of this.scrollQuery) {
        if (typeof query === "object") {
          els.push(query);
        } else {
          els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
        }
      }
      return els;
    }
  };
  var FeaturefulElementDragging = class extends ElementDragging {
    constructor(containerEl, selector) {
      super(containerEl);
      this.containerEl = containerEl;
      this.delay = null;
      this.minDistance = 0;
      this.touchScrollAllowed = true;
      this.mirrorNeedsRevert = false;
      this.isInteracting = false;
      this.isDragging = false;
      this.isDelayEnded = false;
      this.isDistanceSurpassed = false;
      this.delayTimeoutId = null;
      this.onPointerDown = (ev) => {
        if (!this.isDragging) {
          this.isInteracting = true;
          this.isDelayEnded = false;
          this.isDistanceSurpassed = false;
          preventSelection(document.body);
          preventContextMenu(document.body);
          if (!ev.isTouch) {
            ev.origEvent.preventDefault();
          }
          this.emitter.trigger("pointerdown", ev);
          if (this.isInteracting && // not destroyed via pointerdown handler
          !this.pointer.shouldIgnoreMove) {
            this.mirror.setIsVisible(false);
            this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
            this.startDelay(ev);
            if (!this.minDistance) {
              this.handleDistanceSurpassed(ev);
            }
          }
        }
      };
      this.onPointerMove = (ev) => {
        if (this.isInteracting) {
          this.emitter.trigger("pointermove", ev);
          if (!this.isDistanceSurpassed) {
            let minDistance = this.minDistance;
            let distanceSq;
            let { deltaX, deltaY } = ev;
            distanceSq = deltaX * deltaX + deltaY * deltaY;
            if (distanceSq >= minDistance * minDistance) {
              this.handleDistanceSurpassed(ev);
            }
          }
          if (this.isDragging) {
            if (ev.origEvent.type !== "scroll") {
              this.mirror.handleMove(ev.pageX, ev.pageY);
              this.autoScroller.handleMove(ev.pageX, ev.pageY);
            }
            this.emitter.trigger("dragmove", ev);
          }
        }
      };
      this.onPointerUp = (ev) => {
        if (this.isInteracting) {
          this.isInteracting = false;
          allowSelection(document.body);
          allowContextMenu(document.body);
          this.emitter.trigger("pointerup", ev);
          if (this.isDragging) {
            this.autoScroller.stop();
            this.tryStopDrag(ev);
          }
          if (this.delayTimeoutId) {
            clearTimeout(this.delayTimeoutId);
            this.delayTimeoutId = null;
          }
        }
      };
      let pointer = this.pointer = new PointerDragging(containerEl);
      pointer.emitter.on("pointerdown", this.onPointerDown);
      pointer.emitter.on("pointermove", this.onPointerMove);
      pointer.emitter.on("pointerup", this.onPointerUp);
      if (selector) {
        pointer.selector = selector;
      }
      this.mirror = new ElementMirror();
      this.autoScroller = new AutoScroller();
    }
    destroy() {
      this.pointer.destroy();
      this.onPointerUp({});
    }
    startDelay(ev) {
      if (typeof this.delay === "number") {
        this.delayTimeoutId = setTimeout(() => {
          this.delayTimeoutId = null;
          this.handleDelayEnd(ev);
        }, this.delay);
      } else {
        this.handleDelayEnd(ev);
      }
    }
    handleDelayEnd(ev) {
      this.isDelayEnded = true;
      this.tryStartDrag(ev);
    }
    handleDistanceSurpassed(ev) {
      this.isDistanceSurpassed = true;
      this.tryStartDrag(ev);
    }
    tryStartDrag(ev) {
      if (this.isDelayEnded && this.isDistanceSurpassed) {
        if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
          this.isDragging = true;
          this.mirrorNeedsRevert = false;
          this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
          this.emitter.trigger("dragstart", ev);
          if (this.touchScrollAllowed === false) {
            this.pointer.cancelTouchScroll();
          }
        }
      }
    }
    tryStopDrag(ev) {
      this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
    }
    stopDrag(ev) {
      this.isDragging = false;
      this.emitter.trigger("dragend", ev);
    }
    // fill in the implementations...
    setIgnoreMove(bool) {
      this.pointer.shouldIgnoreMove = bool;
    }
    setMirrorIsVisible(bool) {
      this.mirror.setIsVisible(bool);
    }
    setMirrorNeedsRevert(bool) {
      this.mirrorNeedsRevert = bool;
    }
    setAutoScrollEnabled(bool) {
      this.autoScroller.isEnabled = bool;
    }
  };
  var OffsetTracker = class {
    constructor(el) {
      this.el = el;
      this.origRect = computeRect(el);
      this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
    }
    destroy() {
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
    }
    computeLeft() {
      let left = this.origRect.left;
      for (let scrollCache of this.scrollCaches) {
        left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
      }
      return left;
    }
    computeTop() {
      let top = this.origRect.top;
      for (let scrollCache of this.scrollCaches) {
        top += scrollCache.origScrollTop - scrollCache.getScrollTop();
      }
      return top;
    }
    isWithinClipping(pageX, pageY) {
      let point = { left: pageX, top: pageY };
      for (let scrollCache of this.scrollCaches) {
        if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
          return false;
        }
      }
      return true;
    }
  };
  function isIgnoredClipping(node) {
    let tagName = node.tagName;
    return tagName === "HTML" || tagName === "BODY";
  }
  var HitDragging = class {
    constructor(dragging, droppableStore) {
      this.useSubjectCenter = false;
      this.requireInitial = true;
      this.disablePointCheck = false;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.handlePointerDown = (ev) => {
        let { dragging: dragging2 } = this;
        this.initialHit = null;
        this.movingHit = null;
        this.finalHit = null;
        this.prepareHits();
        this.processFirstCoord(ev);
        if (this.initialHit || !this.requireInitial) {
          dragging2.setIgnoreMove(false);
          this.emitter.trigger("pointerdown", ev);
        } else {
          dragging2.setIgnoreMove(true);
        }
      };
      this.handleDragStart = (ev) => {
        this.emitter.trigger("dragstart", ev);
        this.handleMove(ev, true);
      };
      this.handleDragMove = (ev) => {
        this.emitter.trigger("dragmove", ev);
        this.handleMove(ev);
      };
      this.handlePointerUp = (ev) => {
        this.releaseHits();
        this.emitter.trigger("pointerup", ev);
      };
      this.handleDragEnd = (ev) => {
        if (this.movingHit) {
          this.emitter.trigger("hitupdate", null, true, ev);
        }
        this.finalHit = this.movingHit;
        this.movingHit = null;
        this.emitter.trigger("dragend", ev);
      };
      this.droppableStore = droppableStore;
      dragging.emitter.on("pointerdown", this.handlePointerDown);
      dragging.emitter.on("dragstart", this.handleDragStart);
      dragging.emitter.on("dragmove", this.handleDragMove);
      dragging.emitter.on("pointerup", this.handlePointerUp);
      dragging.emitter.on("dragend", this.handleDragEnd);
      this.dragging = dragging;
      this.emitter = new Emitter();
    }
    // sets initialHit
    // sets coordAdjust
    processFirstCoord(ev) {
      let origPoint = { left: ev.pageX, top: ev.pageY };
      let adjustedPoint = origPoint;
      let subjectEl = ev.subjectEl;
      let subjectRect;
      if (subjectEl instanceof HTMLElement) {
        subjectRect = computeRect(subjectEl);
        adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
      }
      let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
      if (initialHit) {
        if (this.useSubjectCenter && subjectRect) {
          let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
          if (slicedSubjectRect) {
            adjustedPoint = getRectCenter(slicedSubjectRect);
          }
        }
        this.coordAdjust = diffPoints(adjustedPoint, origPoint);
      } else {
        this.coordAdjust = { left: 0, top: 0 };
      }
    }
    handleMove(ev, forceHandle) {
      let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
      if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
        this.movingHit = hit;
        this.emitter.trigger("hitupdate", hit, false, ev);
      }
    }
    prepareHits() {
      this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
        interactionSettings.component.prepareHits();
        return new OffsetTracker(interactionSettings.el);
      });
    }
    releaseHits() {
      let { offsetTrackers } = this;
      for (let id in offsetTrackers) {
        offsetTrackers[id].destroy();
      }
      this.offsetTrackers = {};
    }
    queryHitForOffset(offsetLeft, offsetTop) {
      let { droppableStore, offsetTrackers } = this;
      let bestHit = null;
      for (let id in droppableStore) {
        let component = droppableStore[id].component;
        let offsetTracker = offsetTrackers[id];
        if (offsetTracker && // wasn't destroyed mid-drag
        offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
          let originLeft = offsetTracker.computeLeft();
          let originTop = offsetTracker.computeTop();
          let positionLeft = offsetLeft - originLeft;
          let positionTop = offsetTop - originTop;
          let { origRect } = offsetTracker;
          let width = origRect.right - origRect.left;
          let height = origRect.bottom - origRect.top;
          if (
            // must be within the element's bounds
            positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
          ) {
            let hit = component.queryHit(positionLeft, positionTop, width, height);
            if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
            rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
            // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
            // https://github.com/fullcalendar/fullcalendar/issues/5026
            (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(
              // add-back origins to get coordinate relative to top-left of window viewport
              positionLeft + originLeft - window.scrollX,
              positionTop + originTop - window.scrollY
            ))) && (!bestHit || hit.layer > bestHit.layer)) {
              hit.componentId = id;
              hit.context = component.context;
              hit.rect.left += originLeft;
              hit.rect.right += originLeft;
              hit.rect.top += originTop;
              hit.rect.bottom += originTop;
              bestHit = hit;
            }
          }
        }
      }
      return bestHit;
    }
  };
  function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) {
      return true;
    }
    if (Boolean(hit0) !== Boolean(hit1)) {
      return false;
    }
    return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
  }
  function buildDatePointApiWithContext(dateSpan, context) {
    let props = {};
    for (let transform of context.pluginHooks.datePointTransforms) {
      Object.assign(props, transform(dateSpan, context));
    }
    Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
    return props;
  }
  function buildDatePointApi(span, dateEnv) {
    return {
      date: dateEnv.toDate(span.range.start),
      dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
      allDay: span.allDay
    };
  }
  var DateClicking = class extends Interaction {
    constructor(settings) {
      super(settings);
      this.handlePointerDown = (pev) => {
        let { dragging } = this;
        let downEl = pev.origEvent.target;
        dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
      };
      this.handleDragEnd = (ev) => {
        let { component } = this;
        let { pointer } = this.dragging;
        if (!pointer.wasTouchScroll) {
          let { initialHit, finalHit } = this.hitDragging;
          if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
            let { context } = component;
            let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
            context.emitter.trigger("dateClick", arg);
          }
        }
      };
      this.dragging = new FeaturefulElementDragging(settings.el);
      this.dragging.autoScroller.isEnabled = false;
      let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
      hitDragging.emitter.on("pointerdown", this.handlePointerDown);
      hitDragging.emitter.on("dragend", this.handleDragEnd);
    }
    destroy() {
      this.dragging.destroy();
    }
  };
  var DateSelecting = class extends Interaction {
    constructor(settings) {
      super(settings);
      this.dragSelection = null;
      this.handlePointerDown = (ev) => {
        let { component: component2, dragging: dragging2 } = this;
        let { options: options2 } = component2.context;
        let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
        dragging2.setIgnoreMove(!canSelect);
        dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
      };
      this.handleDragStart = (ev) => {
        this.component.context.calendarApi.unselect(ev);
      };
      this.handleHitUpdate = (hit, isFinal) => {
        let { context } = this.component;
        let dragSelection = null;
        let isInvalid = false;
        if (hit) {
          let initialHit = this.hitDragging.initialHit;
          let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
          if (!disallowed) {
            dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
          }
          if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
            isInvalid = true;
            dragSelection = null;
          }
        }
        if (dragSelection) {
          context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
        } else if (!isFinal) {
          context.dispatch({ type: "UNSELECT_DATES" });
        }
        if (!isInvalid) {
          enableCursor();
        } else {
          disableCursor();
        }
        if (!isFinal) {
          this.dragSelection = dragSelection;
        }
      };
      this.handlePointerUp = (pev) => {
        if (this.dragSelection) {
          triggerDateSelect(this.dragSelection, pev, this.component.context);
          this.dragSelection = null;
        }
      };
      let { component } = settings;
      let { options } = component.context;
      let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
      dragging.touchScrollAllowed = false;
      dragging.minDistance = options.selectMinDistance || 0;
      dragging.autoScroller.isEnabled = options.dragScroll;
      let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
      hitDragging.emitter.on("pointerdown", this.handlePointerDown);
      hitDragging.emitter.on("dragstart", this.handleDragStart);
      hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
      hitDragging.emitter.on("pointerup", this.handlePointerUp);
    }
    destroy() {
      this.dragging.destroy();
    }
  };
  function getComponentTouchDelay$1(component) {
    let { options } = component.context;
    let delay = options.selectLongPressDelay;
    if (delay == null) {
      delay = options.longPressDelay;
    }
    return delay;
  }
  function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
    let dateSpan0 = hit0.dateSpan;
    let dateSpan1 = hit1.dateSpan;
    let ms = [
      dateSpan0.range.start,
      dateSpan0.range.end,
      dateSpan1.range.start,
      dateSpan1.range.end
    ];
    ms.sort(compareNumbers);
    let props = {};
    for (let transformer of dateSelectionTransformers) {
      let res = transformer(hit0, hit1);
      if (res === false) {
        return null;
      }
      if (res) {
        Object.assign(props, res);
      }
    }
    props.range = { start: ms[0], end: ms[3] };
    props.allDay = dateSpan0.allDay;
    return props;
  }
  var EventDragging = class _EventDragging extends Interaction {
    constructor(settings) {
      super(settings);
      this.subjectEl = null;
      this.subjectSeg = null;
      this.isDragging = false;
      this.eventRange = null;
      this.relevantEvents = null;
      this.receivingContext = null;
      this.validMutation = null;
      this.mutatedRelevantEvents = null;
      this.handlePointerDown = (ev) => {
        let origTarget = ev.origEvent.target;
        let { component: component2, dragging: dragging2 } = this;
        let { mirror } = dragging2;
        let { options: options2 } = component2.context;
        let initialContext = component2.context;
        this.subjectEl = ev.subjectEl;
        let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
        let eventRange = this.eventRange = subjectSeg.eventRange;
        let eventInstanceId = eventRange.instance.instanceId;
        this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
        dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
        dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
        ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
        if (options2.fixedMirrorParent) {
          mirror.parentNode = options2.fixedMirrorParent;
        } else {
          mirror.parentNode = elementClosest(origTarget, ".fc");
        }
        mirror.revertDuration = options2.dragRevertDuration;
        let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
        dragging2.setIgnoreMove(!isValid);
        this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
      };
      this.handleDragStart = (ev) => {
        let initialContext = this.component.context;
        let eventRange = this.eventRange;
        let eventInstanceId = eventRange.instance.instanceId;
        if (ev.isTouch) {
          if (eventInstanceId !== this.component.props.eventSelection) {
            initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
          }
        } else {
          initialContext.dispatch({ type: "UNSELECT_EVENT" });
        }
        if (this.isDragging) {
          initialContext.calendarApi.unselect(ev);
          initialContext.emitter.trigger("eventDragStart", {
            el: this.subjectEl,
            event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
            jsEvent: ev.origEvent,
            view: initialContext.viewApi
          });
        }
      };
      this.handleHitUpdate = (hit, isFinal) => {
        if (!this.isDragging) {
          return;
        }
        let relevantEvents = this.relevantEvents;
        let initialHit = this.hitDragging.initialHit;
        let initialContext = this.component.context;
        let receivingContext = null;
        let mutation = null;
        let mutatedRelevantEvents = null;
        let isInvalid = false;
        let interaction = {
          affectedEvents: relevantEvents,
          mutatedEvents: createEmptyEventStore(),
          isEvent: true
        };
        if (hit) {
          receivingContext = hit.context;
          let receivingOptions = receivingContext.options;
          if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
            mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
            if (mutation) {
              mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
              interaction.mutatedEvents = mutatedRelevantEvents;
              if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
                isInvalid = true;
                mutation = null;
                mutatedRelevantEvents = null;
                interaction.mutatedEvents = createEmptyEventStore();
              }
            }
          } else {
            receivingContext = null;
          }
        }
        this.displayDrag(receivingContext, interaction);
        if (!isInvalid) {
          enableCursor();
        } else {
          disableCursor();
        }
        if (!isFinal) {
          if (initialContext === receivingContext && // TODO: write test for this
          isHitsEqual(initialHit, hit)) {
            mutation = null;
          }
          this.dragging.setMirrorNeedsRevert(!mutation);
          this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
          this.receivingContext = receivingContext;
          this.validMutation = mutation;
          this.mutatedRelevantEvents = mutatedRelevantEvents;
        }
      };
      this.handlePointerUp = () => {
        if (!this.isDragging) {
          this.cleanup();
        }
      };
      this.handleDragEnd = (ev) => {
        if (this.isDragging) {
          let initialContext = this.component.context;
          let initialView = initialContext.viewApi;
          let { receivingContext, validMutation } = this;
          let eventDef = this.eventRange.def;
          let eventInstance = this.eventRange.instance;
          let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
          let relevantEvents = this.relevantEvents;
          let mutatedRelevantEvents = this.mutatedRelevantEvents;
          let { finalHit } = this.hitDragging;
          this.clearDrag();
          initialContext.emitter.trigger("eventDragStop", {
            el: this.subjectEl,
            event: eventApi,
            jsEvent: ev.origEvent,
            view: initialView
          });
          if (validMutation) {
            if (receivingContext === initialContext) {
              let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
              initialContext.dispatch({
                type: "MERGE_EVENTS",
                eventStore: mutatedRelevantEvents
              });
              let eventChangeArg = {
                oldEvent: eventApi,
                event: updatedEventApi,
                relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
                revert() {
                  initialContext.dispatch({
                    type: "MERGE_EVENTS",
                    eventStore: relevantEvents
                    // the pre-change data
                  });
                }
              };
              let transformed = {};
              for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
                Object.assign(transformed, transformer(validMutation, initialContext));
              }
              initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
              initialContext.emitter.trigger("eventChange", eventChangeArg);
            } else if (receivingContext) {
              let eventRemoveArg = {
                event: eventApi,
                relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
                revert() {
                  initialContext.dispatch({
                    type: "MERGE_EVENTS",
                    eventStore: relevantEvents
                  });
                }
              };
              initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
              initialContext.dispatch({
                type: "REMOVE_EVENTS",
                eventStore: relevantEvents
              });
              initialContext.emitter.trigger("eventRemove", eventRemoveArg);
              let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
              let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
              let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
              receivingContext.dispatch({
                type: "MERGE_EVENTS",
                eventStore: mutatedRelevantEvents
              });
              let eventAddArg = {
                event: addedEventApi,
                relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
                revert() {
                  receivingContext.dispatch({
                    type: "REMOVE_EVENTS",
                    eventStore: mutatedRelevantEvents
                  });
                }
              };
              receivingContext.emitter.trigger("eventAdd", eventAddArg);
              if (ev.isTouch) {
                receivingContext.dispatch({
                  type: "SELECT_EVENT",
                  eventInstanceId: eventInstance.instanceId
                });
              }
              receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
              receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
            }
          } else {
            initialContext.emitter.trigger("_noEventDrop");
          }
        }
        this.cleanup();
      };
      let { component } = this;
      let { options } = component.context;
      let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
      dragging.pointer.selector = _EventDragging.SELECTOR;
      dragging.touchScrollAllowed = false;
      dragging.autoScroller.isEnabled = options.dragScroll;
      let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
      hitDragging.useSubjectCenter = settings.useEventCenter;
      hitDragging.emitter.on("pointerdown", this.handlePointerDown);
      hitDragging.emitter.on("dragstart", this.handleDragStart);
      hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
      hitDragging.emitter.on("pointerup", this.handlePointerUp);
      hitDragging.emitter.on("dragend", this.handleDragEnd);
    }
    destroy() {
      this.dragging.destroy();
    }
    // render a drag state on the next receivingCalendar
    displayDrag(nextContext, state) {
      let initialContext = this.component.context;
      let prevContext = this.receivingContext;
      if (prevContext && prevContext !== nextContext) {
        if (prevContext === initialContext) {
          prevContext.dispatch({
            type: "SET_EVENT_DRAG",
            state: {
              affectedEvents: state.affectedEvents,
              mutatedEvents: createEmptyEventStore(),
              isEvent: true
            }
          });
        } else {
          prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
        }
      }
      if (nextContext) {
        nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
      }
    }
    clearDrag() {
      let initialCalendar = this.component.context;
      let { receivingContext } = this;
      if (receivingContext) {
        receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
      if (initialCalendar !== receivingContext) {
        initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    cleanup() {
      this.subjectSeg = null;
      this.isDragging = false;
      this.eventRange = null;
      this.relevantEvents = null;
      this.receivingContext = null;
      this.validMutation = null;
      this.mutatedRelevantEvents = null;
    }
  };
  EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
  function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
    let dateSpan0 = hit0.dateSpan;
    let dateSpan1 = hit1.dateSpan;
    let date0 = dateSpan0.range.start;
    let date1 = dateSpan1.range.start;
    let standardProps = {};
    if (dateSpan0.allDay !== dateSpan1.allDay) {
      standardProps.allDay = dateSpan1.allDay;
      standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
      if (dateSpan1.allDay) {
        date0 = startOfDay(eventInstanceStart);
      } else {
        date0 = eventInstanceStart;
      }
    }
    let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
    if (delta.milliseconds) {
      standardProps.allDay = false;
    }
    let mutation = {
      datesDelta: delta,
      standardProps
    };
    for (let massager of massagers) {
      massager(mutation, hit0, hit1);
    }
    return mutation;
  }
  function getComponentTouchDelay(component) {
    let { options } = component.context;
    let delay = options.eventLongPressDelay;
    if (delay == null) {
      delay = options.longPressDelay;
    }
    return delay;
  }
  var EventResizing = class extends Interaction {
    constructor(settings) {
      super(settings);
      this.draggingSegEl = null;
      this.draggingSeg = null;
      this.eventRange = null;
      this.relevantEvents = null;
      this.validMutation = null;
      this.mutatedRelevantEvents = null;
      this.handlePointerDown = (ev) => {
        let { component: component2 } = this;
        let segEl = this.querySegEl(ev);
        let seg = getElSeg(segEl);
        let eventRange = this.eventRange = seg.eventRange;
        this.dragging.minDistance = component2.context.options.eventDragMinDistance;
        this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
      };
      this.handleDragStart = (ev) => {
        let { context } = this.component;
        let eventRange = this.eventRange;
        this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
        let segEl = this.querySegEl(ev);
        this.draggingSegEl = segEl;
        this.draggingSeg = getElSeg(segEl);
        context.calendarApi.unselect();
        context.emitter.trigger("eventResizeStart", {
          el: segEl,
          event: new EventImpl(context, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: context.viewApi
        });
      };
      this.handleHitUpdate = (hit, isFinal, ev) => {
        let { context } = this.component;
        let relevantEvents = this.relevantEvents;
        let initialHit = this.hitDragging.initialHit;
        let eventInstance = this.eventRange.instance;
        let mutation = null;
        let mutatedRelevantEvents = null;
        let isInvalid = false;
        let interaction = {
          affectedEvents: relevantEvents,
          mutatedEvents: createEmptyEventStore(),
          isEvent: true
        };
        if (hit) {
          let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
          if (!disallowed) {
            mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
          }
        }
        if (mutation) {
          mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
          interaction.mutatedEvents = mutatedRelevantEvents;
          if (!isInteractionValid(interaction, hit.dateProfile, context)) {
            isInvalid = true;
            mutation = null;
            mutatedRelevantEvents = null;
            interaction.mutatedEvents = null;
          }
        }
        if (mutatedRelevantEvents) {
          context.dispatch({
            type: "SET_EVENT_RESIZE",
            state: interaction
          });
        } else {
          context.dispatch({ type: "UNSET_EVENT_RESIZE" });
        }
        if (!isInvalid) {
          enableCursor();
        } else {
          disableCursor();
        }
        if (!isFinal) {
          if (mutation && isHitsEqual(initialHit, hit)) {
            mutation = null;
          }
          this.validMutation = mutation;
          this.mutatedRelevantEvents = mutatedRelevantEvents;
        }
      };
      this.handleDragEnd = (ev) => {
        let { context } = this.component;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(context, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        context.emitter.trigger("eventResizeStop", {
          el: this.draggingSegEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: context.viewApi
        });
        if (this.validMutation) {
          let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
          context.dispatch({
            type: "MERGE_EVENTS",
            eventStore: mutatedRelevantEvents
          });
          let eventChangeArg = {
            oldEvent: eventApi,
            event: updatedEventApi,
            relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
            revert() {
              context.dispatch({
                type: "MERGE_EVENTS",
                eventStore: relevantEvents
                // the pre-change events
              });
            }
          };
          context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
          context.emitter.trigger("eventChange", eventChangeArg);
        } else {
          context.emitter.trigger("_noEventResize");
        }
        this.draggingSeg = null;
        this.relevantEvents = null;
        this.validMutation = null;
      };
      let { component } = settings;
      let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
      dragging.pointer.selector = ".fc-event-resizer";
      dragging.touchScrollAllowed = false;
      dragging.autoScroller.isEnabled = component.context.options.dragScroll;
      let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
      hitDragging.emitter.on("pointerdown", this.handlePointerDown);
      hitDragging.emitter.on("dragstart", this.handleDragStart);
      hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
      hitDragging.emitter.on("dragend", this.handleDragEnd);
    }
    destroy() {
      this.dragging.destroy();
    }
    querySegEl(ev) {
      return elementClosest(ev.subjectEl, ".fc-event");
    }
  };
  function computeMutation(hit0, hit1, isFromStart, instanceRange) {
    let dateEnv = hit0.context.dateEnv;
    let date0 = hit0.dateSpan.range.start;
    let date1 = hit1.dateSpan.range.start;
    let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
    if (isFromStart) {
      if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
        return { startDelta: delta };
      }
    } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
      return { endDelta: delta };
    }
    return null;
  }
  var UnselectAuto = class {
    constructor(context) {
      this.context = context;
      this.isRecentPointerDateSelect = false;
      this.matchesCancel = false;
      this.matchesEvent = false;
      this.onSelect = (selectInfo) => {
        if (selectInfo.jsEvent) {
          this.isRecentPointerDateSelect = true;
        }
      };
      this.onDocumentPointerDown = (pev) => {
        let unselectCancel = this.context.options.unselectCancel;
        let downEl = getEventTargetViaRoot(pev.origEvent);
        this.matchesCancel = !!elementClosest(downEl, unselectCancel);
        this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
      };
      this.onDocumentPointerUp = (pev) => {
        let { context: context2 } = this;
        let { documentPointer: documentPointer2 } = this;
        let calendarState = context2.getCurrentData();
        if (!documentPointer2.wasTouchScroll) {
          if (calendarState.dateSelection && // an existing date selection?
          !this.isRecentPointerDateSelect) {
            let unselectAuto = context2.options.unselectAuto;
            if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
              context2.calendarApi.unselect(pev);
            }
          }
          if (calendarState.eventSelection && // an existing event selected?
          !this.matchesEvent) {
            context2.dispatch({ type: "UNSELECT_EVENT" });
          }
        }
        this.isRecentPointerDateSelect = false;
      };
      let documentPointer = this.documentPointer = new PointerDragging(document);
      documentPointer.shouldIgnoreMove = true;
      documentPointer.shouldWatchScroll = false;
      documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
      documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
      context.emitter.on("select", this.onSelect);
    }
    destroy() {
      this.context.emitter.off("select", this.onSelect);
      this.documentPointer.destroy();
    }
  };
  var OPTION_REFINERS3 = {
    fixedMirrorParent: identity
  };
  var LISTENER_REFINERS = {
    dateClick: identity,
    eventDragStart: identity,
    eventDragStop: identity,
    eventDrop: identity,
    eventResizeStart: identity,
    eventResizeStop: identity,
    eventResize: identity,
    drop: identity,
    eventReceive: identity,
    eventLeave: identity
  };
  config.dataAttrPrefix = "";
  var index5 = createPlugin({
    name: "@fullcalendar/interaction",
    componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
    calendarInteractions: [UnselectAuto],
    elementDraggingImpl: FeaturefulElementDragging,
    optionRefiners: OPTION_REFINERS3,
    listenerRefiners: LISTENER_REFINERS
  });

  // assets/scripts/components/calendar-init.js
  document.addEventListener("DOMContentLoaded", function() {
    const calendarWrapper = document.querySelector("#calendar");
    if (calendarWrapper) {
      let resetModalFields = function() {
        getModalTitleEl.value = "";
        getModalStartDateEl.value = "";
        getModalEndDateEl.value = "";
        const getModalIfCheckedRadioBtnEl = document.querySelector(
          'input[name="event-level"]:checked'
        );
        if (getModalIfCheckedRadioBtnEl) {
          getModalIfCheckedRadioBtnEl.checked = false;
        }
      };
      const newDate = /* @__PURE__ */ new Date();
      const getDynamicMonth = () => {
        const month = newDate.getMonth() + 1;
        return month < 10 ? `0${month}` : `${month}`;
      };
      const getModalTitleEl = document.querySelector("#event-title");
      const getModalStartDateEl = document.querySelector("#event-start-date");
      const getModalEndDateEl = document.querySelector("#event-end-date");
      const getModalAddBtnEl = document.querySelector(".btn-add-event");
      const getModalUpdateBtnEl = document.querySelector(".btn-update-event");
      const calendarsEvents = {
        Danger: "danger",
        Success: "success",
        Primary: "primary",
        Warning: "warning"
      };
      const calendarEl = document.querySelector("#calendar");
      const calendarHeaderToolbar = {
        left: "prev,next addEventButton",
        center: "title",
        right: "dayGridMonth,timeGridWeek,timeGridDay"
      };
      const calendarEventsList = [
        {
          id: 1,
          title: "Event Conf.",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-01`,
          extendedProps: { calendar: "Danger" }
        },
        {
          id: 2,
          title: "Seminar #4",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-07`,
          end: `${newDate.getFullYear()}-${getDynamicMonth()}-10`,
          extendedProps: { calendar: "Success" }
        },
        {
          groupId: "999",
          id: 3,
          title: "Meeting #5",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-09T16:00:00`,
          extendedProps: { calendar: "Primary" }
        },
        {
          groupId: "999",
          id: 4,
          title: "Submission #1",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-16T16:00:00`,
          extendedProps: { calendar: "Warning" }
        },
        {
          id: 5,
          title: "Seminar #6",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-11`,
          end: `${newDate.getFullYear()}-${getDynamicMonth()}-13`,
          extendedProps: { calendar: "Danger" }
        },
        {
          id: 6,
          title: "Meeting 3",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-12T10:30:00`,
          end: `${newDate.getFullYear()}-${getDynamicMonth()}-12T12:30:00`,
          extendedProps: { calendar: "Success" }
        },
        {
          id: 7,
          title: "Meetup #",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-12T12:00:00`,
          extendedProps: { calendar: "Primary" }
        },
        {
          id: 8,
          title: "Submission",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-12T14:30:00`,
          extendedProps: { calendar: "Warning" }
        },
        {
          id: 9,
          title: "Attend event",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-13T07:00:00`,
          extendedProps: { calendar: "Success" }
        },
        {
          id: 10,
          title: "Project submission #2",
          start: `${newDate.getFullYear()}-${getDynamicMonth()}-28`,
          extendedProps: { calendar: "Primary" }
        }
      ];
      const openModal = () => {
        document.getElementById("eventModal").style.display = "flex";
      };
      const closeModal = () => {
        document.getElementById("eventModal").style.display = "none";
        resetModalFields();
      };
      window.onclick = function(event) {
        const modal = document.getElementById("eventModal");
        if (event.target === modal) {
          closeModal();
        }
      };
      const calendarSelect = (info) => {
        resetModalFields();
        getModalAddBtnEl.style.display = "flex";
        getModalUpdateBtnEl.style.display = "none";
        openModal();
        getModalStartDateEl.value = info.startStr;
        getModalEndDateEl.value = info.endStr || info.startStr;
        getModalTitleEl.value = "";
      };
      const calendarAddEvent = () => {
        const currentDate = /* @__PURE__ */ new Date();
        const dd = String(currentDate.getDate()).padStart(2, "0");
        const mm = String(currentDate.getMonth() + 1).padStart(2, "0");
        const yyyy = currentDate.getFullYear();
        const combineDate = `${yyyy}-${mm}-${dd}T00:00:00`;
        getModalAddBtnEl.style.display = "flex";
        getModalUpdateBtnEl.style.display = "none";
        openModal();
        getModalStartDateEl.value = combineDate;
      };
      const calendarEventClick = (info) => {
        const eventObj = info.event;
        if (eventObj.url) {
          window.open(eventObj.url);
          info.jsEvent.preventDefault();
        } else {
          const getModalEventId = eventObj._def.publicId;
          const getModalEventLevel = eventObj._def.extendedProps.calendar;
          const getModalCheckedRadioBtnEl = document.querySelector(
            `input[value="${getModalEventLevel}"]`
          );
          getModalTitleEl.value = eventObj.title;
          getModalStartDateEl.value = eventObj.startStr.slice(0, 10);
          getModalEndDateEl.value = eventObj.endStr ? eventObj.endStr.slice(0, 10) : "";
          if (getModalCheckedRadioBtnEl) {
            getModalCheckedRadioBtnEl.checked = true;
          }
          getModalUpdateBtnEl.dataset.fcEventPublicId = getModalEventId;
          getModalAddBtnEl.style.display = "none";
          getModalUpdateBtnEl.style.display = "block";
          openModal();
        }
      };
      const calendar = new Calendar(calendarEl, {
        plugins: [index2, index4, index3, index5],
        selectable: true,
        initialView: "dayGridMonth",
        initialDate: `${newDate.getFullYear()}-${getDynamicMonth()}-07`,
        headerToolbar: calendarHeaderToolbar,
        events: calendarEventsList,
        select: calendarSelect,
        eventClick: calendarEventClick,
        dateClick: calendarAddEvent,
        customButtons: {
          addEventButton: {
            text: "Add Event +",
            click: calendarAddEvent
          }
        },
        eventClassNames({ event: calendarEvent }) {
          const getColorValue = calendarsEvents[calendarEvent._def.extendedProps.calendar];
          return [`event-fc-color`, `fc-bg-${getColorValue}`];
        }
      });
      getModalUpdateBtnEl.addEventListener("click", () => {
        const getPublicID = getModalUpdateBtnEl.dataset.fcEventPublicId;
        const getTitleUpdatedValue = getModalTitleEl.value;
        const setModalStartDateValue = getModalStartDateEl.value;
        const setModalEndDateValue = getModalEndDateEl.value;
        const getEvent = calendar.getEventById(getPublicID);
        const getModalUpdatedCheckedRadioBtnEl = document.querySelector(
          'input[name="event-level"]:checked'
        );
        const getModalUpdatedCheckedRadioBtnValue = getModalUpdatedCheckedRadioBtnEl ? getModalUpdatedCheckedRadioBtnEl.value : "";
        getEvent.setProp("title", getTitleUpdatedValue);
        getEvent.setDates(setModalStartDateValue, setModalEndDateValue);
        getEvent.setExtendedProp("calendar", getModalUpdatedCheckedRadioBtnValue);
        closeModal();
      });
      getModalAddBtnEl.addEventListener("click", () => {
        const getModalCheckedRadioBtnEl = document.querySelector(
          'input[name="event-level"]:checked'
        );
        const getTitleValue = getModalTitleEl.value;
        const setModalStartDateValue = getModalStartDateEl.value;
        const setModalEndDateValue = getModalEndDateEl.value;
        const getModalCheckedRadioBtnValue = getModalCheckedRadioBtnEl ? getModalCheckedRadioBtnEl.value : "";
        calendar.addEvent({
          id: Date.now(),
          // Use unique ID based on timestamp
          title: getTitleValue,
          start: setModalStartDateValue,
          end: setModalEndDateValue,
          allDay: true,
          extendedProps: { calendar: getModalCheckedRadioBtnValue }
        });
        closeModal();
      });
      calendar.render();
      document.getElementById("eventModal").addEventListener("click", (event) => {
        if (event.target.classList.contains("modal-close-btn")) {
          closeModal();
        }
      });
      document.getElementById("eventModal").addEventListener("hidden.bs.modal", () => {
        resetModalFields();
      });
      document.querySelectorAll(".modal-close-btn").forEach((btn) => {
        btn.addEventListener("click", closeModal);
      });
      window.addEventListener("click", (event) => {
        if (event.target === document.getElementById("eventModal")) {
          closeModal();
        }
      });
    }
  });

  // assets/scripts/components/image-resize.js
  if (document.querySelectorAll("#pane").length) {
    let setBounds = function(element, x5, y4, w4, h3) {
      element.style.left = x5 + "px";
      element.style.top = y4 + "px";
      element.style.width = w4 + "px";
      element.style.height = h3 + "px";
    }, hintHide = function() {
      setBounds(ghostpane, b3.left, b3.top, b3.width, b3.height);
      ghostpane.style.opacity = 0;
    }, onTouchDown = function(e4) {
      onDown(e4.touches[0]);
      e4.preventDefault();
    }, onTouchMove = function(e4) {
      onMove(e4.touches[0]);
    }, onTouchEnd = function(e4) {
      if (e4.touches.length == 0) onUp(e4.changedTouches[0]);
    }, onMouseDown = function(e4) {
      onDown(e4);
      e4.preventDefault();
    }, onDown = function(e4) {
      calc(e4);
      var isResizing = onRightEdge || onBottomEdge || onTopEdge || onLeftEdge;
      clicked = {
        x: x4,
        y: y3,
        cx: e4.clientX,
        cy: e4.clientY,
        w: b3.width,
        h: b3.height,
        isResizing,
        isMoving: !isResizing && canMove(),
        onTopEdge,
        onLeftEdge,
        onRightEdge,
        onBottomEdge
      };
    }, canMove = function() {
      return x4 > 0 && x4 < b3.width && y3 > 0 && y3 < b3.height && y3 < 30;
    }, calc = function(e4) {
      b3 = pane.getBoundingClientRect();
      x4 = e4.clientX - b3.left;
      y3 = e4.clientY - b3.top;
      onTopEdge = y3 < MARGINS;
      onLeftEdge = x4 < MARGINS;
      onRightEdge = x4 >= b3.width - MARGINS;
      onBottomEdge = y3 >= b3.height - MARGINS;
      rightScreenEdge = window.innerWidth - MARGINS;
      bottomScreenEdge = window.innerHeight - MARGINS;
    }, onMove = function(ee) {
      calc(ee);
      e3 = ee;
      redraw = true;
    }, animate = function() {
      requestAnimationFrame(animate);
      if (!redraw) return;
      redraw = false;
      if (clicked && clicked.isResizing) {
        if (clicked.onRightEdge) pane.style.width = Math.max(x4, minWidth) + "px";
        if (clicked.onBottomEdge)
          pane.style.height = Math.max(y3, minHeight) + "px";
        if (clicked.onLeftEdge) {
          var currentWidth = Math.max(
            clicked.cx - e3.clientX + clicked.w,
            minWidth
          );
          if (currentWidth > minWidth) {
            pane.style.width = currentWidth + "px";
            pane.style.left = e3.clientX + "px";
          }
        }
        if (clicked.onTopEdge) {
          var currentHeight = Math.max(
            clicked.cy - e3.clientY + clicked.h,
            minHeight
          );
          if (currentHeight > minHeight) {
            pane.style.height = currentHeight + "px";
            pane.style.top = e3.clientY + "px";
          }
        }
        hintHide();
        return;
      }
      if (clicked && clicked.isMoving) {
        if (b3.top < FULLSCREEN_MARGINS || b3.left < FULLSCREEN_MARGINS || b3.right > window.innerWidth - FULLSCREEN_MARGINS || b3.bottom > window.innerHeight - FULLSCREEN_MARGINS) {
          setBounds(ghostpane, 0, 0, window.innerWidth, window.innerHeight);
          ghostpane.style.opacity = 0.2;
        } else if (b3.top < MARGINS) {
          setBounds(ghostpane, 0, 0, window.innerWidth, window.innerHeight / 2);
          ghostpane.style.opacity = 0.2;
        } else if (b3.left < MARGINS) {
          setBounds(ghostpane, 0, 0, window.innerWidth / 2, window.innerHeight);
          ghostpane.style.opacity = 0.2;
        } else if (b3.right > rightScreenEdge) {
          setBounds(
            ghostpane,
            window.innerWidth / 2,
            0,
            window.innerWidth / 2,
            window.innerHeight
          );
          ghostpane.style.opacity = 0.2;
        } else if (b3.bottom > bottomScreenEdge) {
          setBounds(
            ghostpane,
            0,
            window.innerHeight / 2,
            window.innerWidth,
            window.innerWidth / 2
          );
          ghostpane.style.opacity = 0.2;
        } else {
          hintHide();
        }
        if (preSnapped) {
          setBounds(
            pane,
            e3.clientX - preSnapped.width / 2,
            e3.clientY - Math.min(clicked.y, preSnapped.height),
            preSnapped.width,
            preSnapped.height
          );
          return;
        }
        pane.style.top = e3.clientY - clicked.y + "px";
        pane.style.left = e3.clientX - clicked.x + "px";
        return;
      }
      if (onRightEdge && onBottomEdge || onLeftEdge && onTopEdge) {
        pane.style.cursor = "nwse-resize";
      } else if (onRightEdge && onTopEdge || onBottomEdge && onLeftEdge) {
        pane.style.cursor = "nesw-resize";
      } else if (onRightEdge || onLeftEdge) {
        pane.style.cursor = "ew-resize";
      } else if (onBottomEdge || onTopEdge) {
        pane.style.cursor = "ns-resize";
      } else if (canMove()) {
        pane.style.cursor = "move";
      } else {
        pane.style.cursor = "default";
      }
    }, onUp = function(e4) {
      calc(e4);
      if (clicked && clicked.isMoving) {
        var snapped = {
          width: b3.width,
          height: b3.height
        };
        if (b3.top < FULLSCREEN_MARGINS || b3.left < FULLSCREEN_MARGINS || b3.right > window.innerWidth - FULLSCREEN_MARGINS || b3.bottom > window.innerHeight - FULLSCREEN_MARGINS) {
          setBounds(pane, 0, 0, window.innerWidth, window.innerHeight);
          preSnapped = snapped;
        } else if (b3.top < MARGINS) {
          setBounds(pane, 0, 0, window.innerWidth, window.innerHeight / 2);
          preSnapped = snapped;
        } else if (b3.left < MARGINS) {
          setBounds(pane, 0, 0, window.innerWidth / 2, window.innerHeight);
          preSnapped = snapped;
        } else if (b3.right > rightScreenEdge) {
          setBounds(
            pane,
            window.innerWidth / 2,
            0,
            window.innerWidth / 2,
            window.innerHeight
          );
          preSnapped = snapped;
        } else if (b3.bottom > bottomScreenEdge) {
          setBounds(
            pane,
            0,
            window.innerHeight / 2,
            window.innerWidth,
            window.innerWidth / 2
          );
          preSnapped = snapped;
        } else {
          preSnapped = null;
        }
        hintHide();
      }
      clicked = null;
    };
    setBounds2 = setBounds, hintHide2 = hintHide, onTouchDown2 = onTouchDown, onTouchMove2 = onTouchMove, onTouchEnd2 = onTouchEnd, onMouseDown2 = onMouseDown, onDown2 = onDown, canMove2 = canMove, calc2 = calc, onMove2 = onMove, animate2 = animate, onUp2 = onUp;
    "use strict";
    minWidth = 60;
    minHeight = 40;
    FULLSCREEN_MARGINS = -10;
    MARGINS = 4;
    clicked = null;
    redraw = false;
    pane = document.getElementById("pane");
    ghostpane = document.getElementById("ghostpane");
    pane.addEventListener("mousedown", onMouseDown);
    document.addEventListener("mousemove", onMove);
    document.addEventListener("mouseup", onUp);
    pane.addEventListener("touchstart", onTouchDown);
    document.addEventListener("touchmove", onTouchMove);
    document.addEventListener("touchend", onTouchEnd);
    animate();
  }
  var minWidth;
  var minHeight;
  var FULLSCREEN_MARGINS;
  var MARGINS;
  var clicked;
  var onRightEdge;
  var onBottomEdge;
  var onLeftEdge;
  var onTopEdge;
  var rightScreenEdge;
  var bottomScreenEdge;
  var preSnapped;
  var b3;
  var x4;
  var y3;
  var redraw;
  var pane;
  var ghostpane;
  var e3;
  var setBounds2;
  var hintHide2;
  var onTouchDown2;
  var onTouchMove2;
  var onTouchEnd2;
  var onMouseDown2;
  var onDown2;
  var canMove2;
  var calc2;
  var onMove2;
  var animate2;
  var onUp2;

  // assets/scripts/custom.js
  module_default.plugin(module_default2);
  window.Alpine = module_default;
  module_default.start();
  esm_default(".datepicker", {
    mode: "range",
    static: true,
    monthSelectorType: "static",
    dateFormat: "M j, Y",
    defaultDate: [(/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 6), /* @__PURE__ */ new Date()],
    prevArrow: '<svg class="stroke-current" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.25 6L9 12.25L15.25 18.5" stroke="" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    nextArrow: '<svg class="stroke-current" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.75 19L15 12.75L8.75 6.5" stroke="" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
    onReady: (selectedDates, dateStr, instance) => {
      instance.element.value = dateStr.replace("to", "-");
      const customClass = instance.element.getAttribute("data-class");
      instance.calendarContainer.classList.add(customClass);
    },
    onChange: (selectedDates, dateStr, instance) => {
      instance.element.value = dateStr.replace("to", "-");
    }
  });
  var dropzoneArea = document.querySelectorAll("#demo-upload");
  if (dropzoneArea.length) {
    let myDropzone = new $3ed269f2f0fb224b$export$2e2bcd8739ae039("#demo-upload", { url: "/file/post" });
  }
  document.addEventListener("DOMContentLoaded", () => {
    chart_01_default();
    chart_02_default();
    chart_03_default();
    map_01_default();
  });
  var year = document.getElementById("year");
  if (year) {
    year.textContent = (/* @__PURE__ */ new Date()).getFullYear();
  }
  document.addEventListener("DOMContentLoaded", () => {
    const copyInput = document.getElementById("copy-input");
    if (copyInput) {
      const copyButton = document.getElementById("copy-button");
      const copyText = document.getElementById("copy-text");
      const websiteInput = document.getElementById("website-input");
      copyButton.addEventListener("click", () => {
        navigator.clipboard.writeText(websiteInput.value).then(() => {
          copyText.textContent = "Copied";
          setTimeout(() => {
            copyText.textContent = "Copy";
          }, 2e3);
        });
      });
    }
  });
  document.addEventListener("DOMContentLoaded", function() {
    const searchInput = document.getElementById("search-input");
    const searchButton = document.getElementById("search-button");
    function focusSearchInput() {
      searchInput.focus();
    }
    searchButton.addEventListener("click", focusSearchInput);
    document.addEventListener("keydown", function(event) {
      if ((event.metaKey || event.ctrlKey) && event.key === "k") {
        event.preventDefault();
        focusSearchInput();
      }
    });
    document.addEventListener("keydown", function(event) {
      if (event.key === "/" && document.activeElement !== searchInput) {
        event.preventDefault();
        focusSearchInput();
      }
    });
  });
})();
/*! Bundled license information:

apexcharts/dist/apexcharts.common.js:
  (*!
   * ApexCharts v3.54.1
   * (c) 2018-2024 ApexCharts
   * Released under the MIT License.
   *)
*/
